/*******************************************************************************
 * HELIUM V, Open Source ERP software for sustained success
 * at small and medium-sized enterprises.
 * Copyright (C) 2004 - 2015 HELIUM V IT-Solutions GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of theLicense, or
 * (at your option) any later version.
 *
 * According to sec. 7 of the GNU Affero General Public License, version 3,
 * the terms of the AGPL are supplemented with the following terms:
 *
 * "HELIUM V" and "HELIUM 5" are registered trademarks of
 * HELIUM V IT-Solutions GmbH. The licensing of the program under the
 * AGPL does not imply a trademark license. Therefore any rights, title and
 * interest in our trademarks remain entirely with us. If you want to propagate
 * modified versions of the Program under the name "HELIUM V" or "HELIUM 5",
 * you may only do so if you have a written permission by HELIUM V IT-Solutions
 * GmbH (to acquire a permission please contact HELIUM V IT-Solutions
 * at trademark@heliumv.com).
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Contact: developers@heliumv.com
 ******************************************************************************/
package com.lp.server.personal.ejbfac;

import java.io.File;
import java.io.FileInputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.rmi.RemoteException;
import java.sql.Time;
import java.sql.Timestamp;
import java.text.DateFormatSymbols;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import javax.ejb.Local;
import javax.ejb.Remote;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.persistence.EntityExistsException;
import javax.persistence.EntityManager;
import javax.persistence.NoResultException;
import javax.persistence.NonUniqueResultException;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;

import org.apache.commons.lang.StringUtils;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.criterion.Expression;
import org.hibernate.criterion.Order;
import org.hibernate.criterion.Restrictions;
import org.jfree.util.Log;

import com.lp.server.angebot.ejb.Angebotauftrag;
import com.lp.server.angebot.service.AngebotDto;
import com.lp.server.angebot.service.AngebotauftragDto;
import com.lp.server.angebotstkl.ejb.Agstklarbeitsplan;
import com.lp.server.angebotstkl.ejb.Agstklmaterial;
import com.lp.server.angebotstkl.ejb.Agstklposition;
import com.lp.server.artikel.ejb.Artikel;
import com.lp.server.artikel.service.ArtikelDto;
import com.lp.server.artikel.service.ArtikelFac;
import com.lp.server.artikel.service.BelegInfos;
import com.lp.server.auftrag.ejb.Auftrag;
import com.lp.server.auftrag.ejb.Auftragposition;
import com.lp.server.auftrag.service.AuftragDto;
import com.lp.server.auftrag.service.AuftragpositionDto;
import com.lp.server.auftrag.service.AuftragzeitenDto;
import com.lp.server.auftrag.service.VerrechenbarDto;
import com.lp.server.benutzer.service.BenutzerFac;
import com.lp.server.benutzer.service.RechteFac;
import com.lp.server.bestellung.service.BSMahnungDto;
import com.lp.server.eingangsrechnung.ejb.Auftragszuordnungverrechnet;
import com.lp.server.fertigung.ejb.Losgutschlecht;
import com.lp.server.fertigung.ejb.Lossollarbeitsplan;
import com.lp.server.fertigung.ejb.Lossollmaterial;
import com.lp.server.fertigung.fastlanereader.generated.FLRLossollmaterial;
import com.lp.server.fertigung.service.FertigungFac;
import com.lp.server.fertigung.service.LosArbeitsplanZeitVergleichDto;
import com.lp.server.fertigung.service.LosDto;
import com.lp.server.fertigung.service.LosgutschlechtDto;
import com.lp.server.fertigung.service.LossollarbeitsplanDto;
import com.lp.server.fertigung.service.LossollmaterialDto;
import com.lp.server.partner.ejb.HvTypedQuery;
import com.lp.server.partner.service.KundeDto;
import com.lp.server.partner.service.PartnerDto;
import com.lp.server.partner.service.PartnerReportFac;
import com.lp.server.personal.assembler.MaschinengruppeDtoAssembler;
import com.lp.server.personal.ejb.AuszahlungBVA;
import com.lp.server.personal.ejb.Bereitschaft;
import com.lp.server.personal.ejb.Bereitschafttag;
import com.lp.server.personal.ejb.Diaeten;
import com.lp.server.personal.ejb.Diaetentagessatz;
import com.lp.server.personal.ejb.Gleitzeitsaldo;
import com.lp.server.personal.ejb.Maschine;
import com.lp.server.personal.ejb.MaschineQuery;
import com.lp.server.personal.ejb.Maschineleistungsfaktor;
import com.lp.server.personal.ejb.Maschinengruppe;
import com.lp.server.personal.ejb.MaschinengruppeQuery;
import com.lp.server.personal.ejb.Maschinenkosten;
import com.lp.server.personal.ejb.Maschinenzeitdaten;
import com.lp.server.personal.ejb.Maschinenzeitdatenverrechnet;
import com.lp.server.personal.ejb.Personal;
import com.lp.server.personal.ejb.Personalzeitmodell;
import com.lp.server.personal.ejb.Projektzeiten;
import com.lp.server.personal.ejb.Reise;
import com.lp.server.personal.ejb.Reiselog;
import com.lp.server.personal.ejb.Reisespesen;
import com.lp.server.personal.ejb.Reiseverrechnet;
import com.lp.server.personal.ejb.Schichtzeitmodell;
import com.lp.server.personal.ejb.Sonderzeiten;
import com.lp.server.personal.ejb.Taetigkeit;
import com.lp.server.personal.ejb.Taetigkeitart;
import com.lp.server.personal.ejb.Taetigkeitartspr;
import com.lp.server.personal.ejb.TaetigkeitartsprPK;
import com.lp.server.personal.ejb.Taetigkeitspr;
import com.lp.server.personal.ejb.TaetigkeitsprPK;
import com.lp.server.personal.ejb.Tagesart;
import com.lp.server.personal.ejb.Tagesartspr;
import com.lp.server.personal.ejb.TagesartsprPK;
import com.lp.server.personal.ejb.Telefonzeiten;
import com.lp.server.personal.ejb.Telefonzeitenverrechnet;
import com.lp.server.personal.ejb.UebertragBVA;
import com.lp.server.personal.ejb.Zeitdaten;
import com.lp.server.personal.ejb.ZeitdatenQuery;
import com.lp.server.personal.ejb.Zeitdatenpruefen;
import com.lp.server.personal.ejb.ZeitdatenpruefenQuery;
import com.lp.server.personal.ejb.Zeitdatenverrechnet;
import com.lp.server.personal.ejb.Zeitgutschrift;
import com.lp.server.personal.ejb.Zeitmodell;
import com.lp.server.personal.ejb.Zeitmodellspr;
import com.lp.server.personal.ejb.ZeitmodellsprPK;
import com.lp.server.personal.ejb.Zeitmodelltag;
import com.lp.server.personal.ejb.Zeitmodelltagpause;
import com.lp.server.personal.ejb.Zeitstift;
import com.lp.server.personal.ejb.Zeitverteilung;
import com.lp.server.personal.fastlanereader.generated.FLRAnwesenheitsbestaetigung;
import com.lp.server.personal.fastlanereader.generated.FLRArtikelzulage;
import com.lp.server.personal.fastlanereader.generated.FLRArtikelzuschlag;
import com.lp.server.personal.fastlanereader.generated.FLRBereitschaft;
import com.lp.server.personal.fastlanereader.generated.FLREintrittaustritt;
import com.lp.server.personal.fastlanereader.generated.FLRLohnartstundenfaktor;
import com.lp.server.personal.fastlanereader.generated.FLRMaschine;
import com.lp.server.personal.fastlanereader.generated.FLRMaschinenzeitdaten;
import com.lp.server.personal.fastlanereader.generated.FLRPersonal;
import com.lp.server.personal.fastlanereader.generated.FLRPersonalverfuegbarkeit;
import com.lp.server.personal.fastlanereader.generated.FLRPersonalzeitmodell;
import com.lp.server.personal.fastlanereader.generated.FLRReise;
import com.lp.server.personal.fastlanereader.generated.FLRSonderzeiten;
import com.lp.server.personal.fastlanereader.generated.FLRTaetigkeit;
import com.lp.server.personal.fastlanereader.generated.FLRTaetigkeitspr;
import com.lp.server.personal.fastlanereader.generated.FLRTelefonzeiten;
import com.lp.server.personal.fastlanereader.generated.FLRZeitabschluss;
import com.lp.server.personal.fastlanereader.generated.FLRZeitdaten;
import com.lp.server.personal.fastlanereader.generated.FLRZeitdatenLos;
import com.lp.server.personal.service.*;
import com.lp.server.personal.service.ZeitdatenpruefenAttributDto.Attribut;
import com.lp.server.projekt.ejb.Projekt;
import com.lp.server.projekt.service.ProjektDto;
import com.lp.server.projekt.service.ProjektServiceFac;
import com.lp.server.rechnung.ejb.Rechnung;
import com.lp.server.rechnung.service.RechnungDto;
import com.lp.server.rechnung.service.RechnungPositionDto;
import com.lp.server.stueckliste.ejb.Stueckliste;
import com.lp.server.stueckliste.ejb.Stuecklistearbeitsplan;
import com.lp.server.stueckliste.ejb.Stuecklisteposition;
import com.lp.server.stueckliste.service.StuecklisteDto;
import com.lp.server.stueckliste.service.StuecklisteFac;
import com.lp.server.system.ejb.Keyvalue;
import com.lp.server.system.ejb.KeyvaluePK;
import com.lp.server.system.ejbfac.EJBExcFactory;
import com.lp.server.system.jcr.service.PrintInfoDto;
import com.lp.server.system.jcr.service.docnode.DocNodeWochenabschlussBeleg;
import com.lp.server.system.jcr.service.docnode.DocPath;
import com.lp.server.system.pkgenerator.PKConst;
import com.lp.server.system.pkgenerator.bl.PKGeneratorObj;
import com.lp.server.system.service.KostenstelleDto;
import com.lp.server.system.service.LocaleFac;
import com.lp.server.system.service.MandantDto;
import com.lp.server.system.service.MandantFac;
import com.lp.server.system.service.ParameterFac;
import com.lp.server.system.service.ParametermandantDto;
import com.lp.server.system.service.SystemFac;
import com.lp.server.system.service.SystemServicesFac;
import com.lp.server.system.service.TheClientDto;
import com.lp.server.system.service.VersandanhangDto;
import com.lp.server.system.service.VersandauftragDto;
import com.lp.server.util.DatumsfilterVonBis;
import com.lp.server.util.HelperServer;
import com.lp.server.util.HvList;
import com.lp.server.util.LPReport;
import com.lp.server.util.Validator;
import com.lp.server.util.collection.CollectionTools;
import com.lp.server.util.collection.ISelect;
import com.lp.server.util.fastlanereader.FLRSessionFactory;
import com.lp.server.util.logger.HvDtoLogger;
import com.lp.server.util.report.JasperPrintLP;
import com.lp.util.EJBExceptionLP;
import com.lp.util.Helper;
import com.lp.util.LPDatenSubreport;

import net.sf.jasperreports.engine.JRDataSource;
import net.sf.jasperreports.engine.JRException;
import net.sf.jasperreports.engine.JRField;

@Stateless
@SuppressWarnings("unused")
@Local(ZeiterfassungFacLocal.class)
@Remote(ZeiterfassungFac.class)
public class ZeiterfassungFacBean extends LPReport implements JRDataSource, ZeiterfassungFac, ZeiterfassungFacLocal {
	@PersistenceContext
	private EntityManager em;

	private Object[][] data = null;
	private String sAktuellerReport = null;

	public static int REPORT_MONATSABRECHNUNG_KALENDERWOCHE = 0;
	public static int REPORT_MONATSABRECHNUNG_WOCHENTAG = 1;
	public static int REPORT_MONATSABRECHNUNG_TAG = 2;
	public static int REPORT_MONATSABRECHNUNG_VON = 3;
	public static int REPORT_MONATSABRECHNUNG_BIS = 4;
	public static int REPORT_MONATSABRECHNUNG_UNTER = 5;
	public static int REPORT_MONATSABRECHNUNG_SOLL = 6;
	public static int REPORT_MONATSABRECHNUNG_IST = 7;
	public static int REPORT_MONATSABRECHNUNG_DIFF = 8;
	public static int REPORT_MONATSABRECHNUNG_FEIERTAG = 9;
	public static int REPORT_MONATSABRECHNUNG_URLAUB = 10;
	public static int REPORT_MONATSABRECHNUNG_URLAUBTAGEWEISE = 11;
	public static int REPORT_MONATSABRECHNUNG_ARZT = 12;
	public static int REPORT_MONATSABRECHNUNG_BEHOERDE = 13;
	public static int REPORT_MONATSABRECHNUNG_ZEITAUSGLEICH = 14;
	public static int REPORT_MONATSABRECHNUNG_KRANK = 15;
	public static int REPORT_MONATSABRECHNUNG_MEHRZEIT = 16;
	public static int REPORT_MONATSABRECHNUNG_UESTD50 = 17;
	public static int REPORT_MONATSABRECHNUNG_UESTD100 = 18;
	public static int REPORT_MONATSABRECHNUNG_UESTD50TAGESWEISEFREI = 19;
	public static int REPORT_MONATSABRECHNUNG_UESTD100FREI = 20;
	public static int REPORT_MONATSABRECHNUNG_UESTD200 = 21;
	public static int REPORT_MONATSABRECHNUNG_BEMERKUNG = 22;
	public static int REPORT_MONATSABRECHNUNG_SONSTIGE_BEZAHLTETAETIGKEITEN = 23;
	public static int REPORT_MONATSABRECHNUNG_SONSTIGE_UNBEZAHLTETAETIGKEITEN = 24;
	public static int REPORT_MONATSABRECHNUNG_ZUSATZBEZEICHNUNG = 25;
	public static int REPORT_MONATSABRECHNUNG_REISE = 26;
	public static int REPORT_MONATSABRECHNUNG_UESTD50TAGEWEISE = 27;
	public static int REPORT_MONATSABRECHNUNG_JAHR = 28;
	public static int REPORT_MONATSABRECHNUNG_TAGESART = 29;
	public static int REPORT_MONATSABRECHNUNG_ZEITMODELL = 30;
	public static int REPORT_MONATSABRECHNUNG_KINDKRANK = 31;
	public static int REPORT_MONATSABRECHNUNG_SUBREPORT_ZULAGEN = 32;
	public static int REPORT_MONATSABRECHNUNG_PLATZHALTER_FUER_SUREPORTZEIDATENJOURNAL = 33;
	public static int REPORT_MONATSABRECHNUNG_MONAT = 34;
	public static int REPORT_MONATSABRECHNUNG_QUALIFIKATIONSFAKTOR = 35;
	public static int REPORT_MONATSABRECHNUNG_SUBREPORT_SCHICHTZEITEN = 36;
	public static int REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_GEHT = 37;
	public static int REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_KOMMT = 38;
	public static int REPORT_MONATSABRECHNUNG_DATUM = 39;
	// PJ20486
	public static int REPORT_MONATSABRECHNUNG_BV_A_GLEITZEIT = 40;
	public static int REPORT_MONATSABRECHNUNG_BV_A_UEST50_UEBER_GLEITZEIT = 41;
	public static int REPORT_MONATSABRECHNUNG_BV_A_UESTD50 = 42;
	public static int REPORT_MONATSABRECHNUNG_BV_A_UESDT100 = 43;
	public static int REPORT_MONATSABRECHNUNG_BV_A_UEST50_UEBER_GLEITZEIT_ZUSCHLAG = 44;
	public static int REPORT_MONATSABRECHNUNG_BV_A_UESTD50_ZUSCHLAG = 45;
	public static int REPORT_MONATSABRECHNUNG_BV_A_UESDT100_ZUSCHLAG = 46;
	public static int REPORT_MONATSABRECHNUNG_REISE_PASSIV = 47;
	public static int REPORT_MONATSABRECHNUNG_SCHICHTZEITEN_FUER_EXPORT = 48;
	public static int REPORT_MONATSABRECHNUNG_URLAUB_AUTOMATIK = 49;
	public static int REPORT_MONATSABRECHNUNG_ZEITMODELL_I_ID = 50;
	public static int REPORT_MONATSABRECHNUNG_SONSTIGE_SONDERTAETIGKEITEN_FUER_EXPORT = 51;
	public static int REPORT_MONATSABRECHNUNG_ANZAHL_SPALTEN = 52;

	private static int REPORT_ANWESENHEITSLISTE_ANWESEND = 0;
	private static int REPORT_ANWESENHEITSLISTE_NAME = 1;
	private static int REPORT_ANWESENHEITSLISTE_PERSONALNUMMER = 2;
	private static int REPORT_ANWESENHEITSLISTE_TEL_PRIVAT = 3;
	private static int REPORT_ANWESENHEITSLISTE_TAETIGKEIT = 4;
	private static int REPORT_ANWESENHEITSLISTE_ZEIT = 5;
	private static int REPORT_ANWESENHEITSLISTE_QUELLE = 6;
	private static int REPORT_ANWESENHEITSLISTE_SONDERZEIT = 7;
	private static int REPORT_ANWESENHEITSLISTE_SONDERZEIT_STUNDEN = 8;
	private static int REPORT_ANWESENHEITSLISTE_SONDERZEIT_ART = 9;
	private static int REPORT_ANWESENHEITSLISTE_ABWESENHEITSART_KENNUNG = 10;
	private static int REPORT_ANWESENHEITSLISTE_ABWESENHEITSART_BEZEICHNUNG = 11;

	private static int REPORT_ANWESENHEITSLISTE_TAETIGKEIT_ARTIKELNUMMER = 12;
	private static int REPORT_ANWESENHEITSLISTE_TAETIGKEIT_BEZEICHNUNG = 13;
	private static int REPORT_ANWESENHEITSLISTE_KUNDE_KURZBEZEICHNUNG = 14;
	private static int REPORT_ANWESENHEITSLISTE_PARTNER_KURZBEZEICHNUNG = 15;
	private static int REPORT_ANWESENHEITSLISTE_PROJEKTNUMMER = 16;
	private static int REPORT_ANWESENHEITSLISTE_PROJEKTBEZEICHNUNG = 17;
	private static int REPORT_ANWESENHEITSLISTE_LOSNUMMER = 18;
	private static int REPORT_ANWESENHEITSLISTE_AUFTRAGSNUMMER = 19;
	private static int REPORT_ANWESENHEITSLISTE_LOS_KOMMENTAR = 20;
	private static int REPORT_ANWESENHEITSLISTE_LOS_AGNUMMER = 21;
	private static int REPORT_ANWESENHEITSLISTE_LOS_UAGNUMMER = 22;
	private static int REPORT_ANWESENHEITSLISTE_LOS_MASCHINE_INVENTARNUMMER = 23;
	private static int REPORT_ANWESENHEITSLISTE_LOS_MASCHINE_BEZEICHNUNG = 24;
	private static int REPORT_ANWESENHEITSLISTE_MASCHINE_INVENTARNUMMER = 25;
	private static int REPORT_ANWESENHEITSLISTE_MASCHINE_BEZEICHNUNG = 26;
	private static int REPORT_ANWESENHEITSLISTE_PERSONAL_I_ID = 27;
	private static int REPORT_ANWESENHEITSLISTE_VORNAME = 28;
	private static int REPORT_ANWESENHEITSLISTE_NACHNAME = 29;
	private static int REPORT_ANWESENHEITSLISTE_ANZAHL_SPALTEN = 30;

	private static int REPORT_SONDERTAETIGKEITENLISTE_PERSONALNUMMER_GRUPPIERUNG = 0;
	private static int REPORT_SONDERTAETIGKEITENLISTE_PERSONALNUMMER = 1;
	private static int REPORT_SONDERTAETIGKEITENLISTE_NAME = 2;
	private static int REPORT_SONDERTAETIGKEITENLISTE_TAETIGKEIT = 3;
	private static int REPORT_SONDERTAETIGKEITENLISTE_ZEIT = 4;
	private static int REPORT_SONDERTAETIGKEITENLISTE_FAKTORBEZAHLT = 5;
	private static int REPORT_SONDERTAETIGKEITENLISTE_LFD_FEHLTAGE = 6;
	private static int REPORT_SONDERTAETIGKEITENLISTE_WARNMEDLUNG_IN_KALENDERTAGEN = 7;
	private static int REPORT_SONDERTAETIGKEITENLISTE_PARTNER_DTO = 8;
	private static int REPORT_SONDERTAETIGKEITENLISTE_TAGE = 9;
	private static int REPORT_SONDERTAETIGKEITENLISTE_SUBREPORT_DETAILS = 10;
	public static int REPORT_SONDERTAETIGKEITENLISTE_ANZAHL_SPALTEN = 11;

	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSONAL_ID = 0;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG = 1;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS = 2;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_ANGEBOT = 3;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT = 4;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKTBEZEICHNUNG = 5;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE = 6;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_DAUER = 7;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_STKLNR = 8;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_STKLBEZ = 9;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOSKLASSEN = 10;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_TAETIGKEIT = 11;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_TAETIGKEIT_BEZEICHNUNG = 12;

	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_AGART = 13;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_RUESTZEIT = 14;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_STUECKZEIT = 15;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_GUTSTUECK = 16;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_SCHLECHTSTUECK = 17;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_INARBEIT = 18;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_LOSGROESSE = 19;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_ZEITANTEIL = 20;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_FERTIG = 21;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_GESAMTZEIT = 22;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_AGNUMMER = 23;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_UAGNUMMER = 24;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_RUESTEN_MITRECHNEN = 25;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_PROJEKTKLAMMER = 26;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKTKATEGORIE_PROJEKTKLAMMER = 27;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_TELEFONZEIT = 28;

	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_NAME = 29;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_IST_GESAMT = 30;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_INTERN = 31;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_EXTERN = 32;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_PROZENTINTERN = 33;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_PROZENTEXTERN = 34;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_LEISTUNGSWERT = 35;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_SUBREPORT_SONDERTAETIGKEITEN = 36;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_KOSTENSTELLE = 37;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_ABTEILUNG = 38;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_FERTIUNGSGRUPPE = 39;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE_BRANCHE = 40;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE_PARTNERKLASSE = 41;

	private static int REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG_KOSTENSTELLE = 42;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG_KOSTENSTELLE_BEZEICHNUNG = 43;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_PERSONALGRUPPE = 44;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_LOS_KOSTENSTELLE = 45;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG_BESTELLNUMMER = 46;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_BEREICH = 47;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_I_ID = 48;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_BEMERKUNG = 49;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_KOMMENTAR_INTERN = 50;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_KOMMENTAR_EXTERN = 51;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_OFFENE_ZEITEN_VORHANDEN = 52;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_BEREICH_PROJEKTKLAMMER = 53;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_I_ID_PROJEKTKLAMMER = 54;

	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_EXTERN_VERRECHENBAR = 55;
	private static int REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_EXTERN_NICHT_VERRECHENBAR = 56;

	private static int REPORT_PRODUKTIVITAETISSTATISTIK_ANZAHL_SPALTEN = 57;

	private static int REPORT_SONDERTAETIGKEITEN_KENNUNG = 0;
	private static int REPORT_SONDERTAETIGKEITEN_BEZEICHNUNG = 1;

	private static int REPORT_ZEITSALDO_PERSON = 0;
	private static int REPORT_ZEITSALDO_PERSONALNUMMER = 1;
	private static int REPORT_ZEITSALDO_SOLL = 2;
	private static int REPORT_ZEITSALDO_IST = 3;
	private static int REPORT_ZEITSALDO_FTGSOLL = 4;
	private static int REPORT_ZEITSALDO_FTG = 5;
	private static int REPORT_ZEITSALDO_ARZT = 6;
	private static int REPORT_ZEITSALDO_KRANK = 7;
	private static int REPORT_ZEITSALDO_BEHOERDE = 8;
	private static int REPORT_ZEITSALDO_URLAUBSTD = 9;
	private static int REPORT_ZEITSALDO_SONSTIGEBEZAHLT = 10;
	private static int REPORT_ZEITSALDO_REISE = 11;
	private static int REPORT_ZEITSALDO_SONSTIGENICHTBEZAHLT = 12;
	private static int REPORT_ZEITSALDO_URLAUBTAGE_URLAUBREST = 13;
	private static int REPORT_ZEITSALDO_URLAUBTAGE_URLAUBRESTVERBRAUCHT = 14;
	private static int REPORT_ZEITSALDO_URLAUBTAGE_ALIQUOT = 15;
	private static int REPORT_ZEITSALDO_URLAUBTAGE_URLAUBAKTUELLVERBRAUCHT = 16;
	private static int REPORT_ZEITSALDO_URLAUBTAGE_URLAUBAKTUELL = 17;
	private static int REPORT_ZEITSALDO_URLAUBTAGE_URLAUB_GEPLANT = 18;
	private static int REPORT_ZEITSALDO_URLAUBTAGE_URLAUB_VERFUGBAR = 19;
	private static int REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUBREST = 20;
	private static int REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUBRESTVERBRAUCHT = 21;
	private static int REPORT_ZEITSALDO_URLAUBSTUNDEN_ALIQUOT = 22;
	private static int REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUBAKUTELLVERBRAUCHT = 23;
	private static int REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUBAKUTELL = 24;
	private static int REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUB_GEPLANT = 25;
	private static int REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUB_VERFUGBAR = 26;
	private static int REPORT_ZEITSALDO_UESTDSALDO100 = 27;
	private static int REPORT_ZEITSALDO_UESTDSALDO50 = 28;
	private static int REPORT_ZEITSALDO_UESTDSALDO100STF = 29;
	private static int REPORT_ZEITSALDO_UESTDSALDO50STF = 30;
	private static int REPORT_ZEITSALDO_UESTDSALDOMEHRSTD = 31;
	private static int REPORT_ZEITSALDO_GLEITZEITSALDOVORMONAT = 32;
	private static int REPORT_ZEITSALDO_GLEITZEITSALDOAKTUELLERMONAT = 33;
	private static int REPORT_ZEITSALDO_MONAT = 34;
	private static int REPORT_ZEITSALDO_URLAUBTAGE_URLAUBVORJAHR = 35;
	private static int REPORT_ZEITSALDO_UESTDSALDO200 = 36;
	private static int REPORT_ZEITSALDO_AUSBEZAHLTNORMALSTD = 37;
	private static int REPORT_ZEITSALDO_AUSBEZAHLTMEHRSTD = 38;
	private static int REPORT_ZEITSALDO_AUSBEZAHLT50 = 39;
	private static int REPORT_ZEITSALDO_AUSBEZAHLT50STF = 40;
	private static int REPORT_ZEITSALDO_AUSBEZAHLT100 = 41;
	private static int REPORT_ZEITSALDO_AUSBEZAHLT100STF = 42;
	private static int REPORT_ZEITSALDO_AUSBEZAHLT200 = 43;
	private static int REPORT_ZEITSALDO_AUSBEZAHLTGUTSTD = 44;
	private static int REPORT_ZEITSALDO_QUALIPRAEMIE = 45;
	private static int REPORT_ZEITSALDO_KIND_KRANK = 46;
	private static int REPORT_ZEITSALDO_KOSTENSTELLE = 47;
	private static int REPORT_ZEITSALDO_ABTEILUNG = 48;
	private static int REPORT_ZEITSALDO_EINTRITTSDATUM = 49;

	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_GLEITZEIT = 50;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD50_UEBER_GLEITZEIT = 51;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD50 = 52;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD100 = 53;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD100_ZUSCHLAG = 54;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD50_ZUSCHLAG = 55;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD50_UEBER_GLEITZEIT_ZUSCHLAG = 56;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_GLEITZEIT_DIFF = 57;

	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_GLEITZEIT = 58;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD50_UEBER_GLEITZEIT = 59;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD50 = 60;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD100 = 61;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD50_UEBERGLEITZEIT_ZUSCHLAG = 62;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD50_ZUSCHLAG = 63;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD100_ZUSCHLAG = 64;

	private static int REPORT_ZEITSALDO_KOLLEKTIV_ABRECHNUNGSART = 65;

	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_GLEITZEIT = 66;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD50_UEBER_GLEITZEIT = 67;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD50 = 68;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD100 = 69;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD50_UEBERGLEITZEIT_ZUSCHLAG = 70;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD50_ZUSCHLAG = 71;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD100_ZUSCHLAG = 72;

	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_GLEITZEIT = 73;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD50_UEBER_GLEITZEIT = 74;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD50 = 75;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD100 = 76;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD50_UEBERGLEITZEIT_ZUSCHLAG = 77;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD50_ZUSCHLAG = 78;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD100_ZUSCHLAG = 79;

	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_ENTSPRICHT_NORMALSTUNDEN = 80;
	private static int REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_GLEITZEIT_DIFF_AKTUELLES_MONAT = 81;
	private static int REPORT_ZEITSALDO_URLAUBTAGE_ALIQUOT_ENDEMONAT = 82;
	private static int REPORT_ZEITSALDO_URLAUBSTUNDEN_ALIQUOT_ENDEMONAT = 83;

	private static int REPORT_ZEITSALDO_REISE_PASSIV = 84;
	private static int REPORT_ZEITSALDO_SUBREPORT_SONDERZEITEN = 85;

	private static int REPORT_ZEITSALDO_ANZAHL_ZEILEN = 86;

	private static int REPORT_WOCHENABSCHLUSS_DATUM = 0;
	private static int REPORT_WOCHENABSCHLUSS_KOMMT = 1;
	private static int REPORT_WOCHENABSCHLUSS_GEHT = 2;
	private static int REPORT_WOCHENABSCHLUSS_SOLL = 3;
	private static int REPORT_WOCHENABSCHLUSS_IST = 4;
	private static int REPORT_WOCHENABSCHLUSS_SUBREPORT_BELEGZEITEN = 5;
	private static int REPORT_WOCHENABSCHLUSS_FEIERTAG = 6;
	private static int REPORT_WOCHENABSCHLUSS_ARZT = 7;
	private static int REPORT_WOCHENABSCHLUSS_KRANK = 8;
	private static int REPORT_WOCHENABSCHLUSS_KINDKRANK = 9;
	private static int REPORT_WOCHENABSCHLUSS_BEHOERDE = 10;
	private static int REPORT_WOCHENABSCHLUSS_URLAUB = 11;
	private static int REPORT_WOCHENABSCHLUSS_SONSTIGE_BEZAHLT = 12;
	private static int REPORT_WOCHENABSCHLUSS_SONSTIGE_UNBEZAHLT = 13;
	private static int REPORT_WOCHENABSCHLUSS_FEHLER = 14;
	private static int REPORT_WOCHENABSCHLUSS_WOCHENTAG = 15;
	private static int REPORT_WOCHENABSCHLUSS_ANZAHL_SPALTEN = 16;

	/**
	 * Berechne die TagesArbeitszeit eines Tages zu einer Person, ohne Paarweisen
	 * Sondertaetigkeiten meldet Fehler, wenn die Tagesarbeitszeit nicht berechnet
	 * werden konnte
	 * 
	 * @param personalIId  Die Person
	 * @param d_datum      Das Datum
	 * @param theClientDto User-ID
	 * @return String beinhaltet Tagesarbeitszeit
	 * @exception EJBExceptionLP
	 */

	public VonBisErfassungTagesdatenDto berechneTagesArbeitszeitVonBisZeiterfassungOhneKommtGeht(Integer personalIId,
			java.sql.Date d_datum, TheClientDto theClientDto) {

		VonBisErfassungTagesdatenDto vonBisDto = new VonBisErfassungTagesdatenDto();

		// Hole Dto der Unterbrechung
		TaetigkeitDto taetigkeitDto_Unter = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER, theClientDto);
		// Hole Dto des Arztbesuchs
		TaetigkeitDto taetigkeitDto_Arzt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ARZT, theClientDto);
		// Hole Dto der Behoerde
		TaetigkeitDto taetigkeitDto_Behoerde = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_BEHOERDE, theClientDto);
		// Hole Dto des Urlaub
		TaetigkeitDto taetigkeitDto_Urlaub = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_URLAUB, theClientDto);
		// Hole Dto des Zeitausgleichs
		TaetigkeitDto taetigkeitDto_ZA = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ZEITAUSGLEICH, theClientDto);
		// Hole Dto der Behoerde
		TaetigkeitDto taetigkeitDto_Krank = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KRANK, theClientDto);
		TaetigkeitDto taetigkeitDto_Kindkrank = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KINDKRANK,
				theClientDto);

		// Berechnungsdatum abschneiden, damit nur mehr JJJJ.MM.TT ueberbleibt
		Calendar c = Calendar.getInstance();
		c.setTime(d_datum);
		c.set(Calendar.HOUR_OF_DAY, 0);
		c.set(Calendar.MINUTE, 0);
		c.set(Calendar.SECOND, 0);
		c.set(Calendar.MILLISECOND, 0);
		d_datum = new java.sql.Date(c.getTime().getTime());
		// Heutiges Datum herausfinden und abschneiden, damit nur mehr
		// JJJJ.MM.TT ueberbleibt
		c.setTimeInMillis(System.currentTimeMillis());
		c.set(Calendar.HOUR_OF_DAY, 0);
		c.set(Calendar.MINUTE, 0);
		c.set(Calendar.SECOND, 0);
		c.set(Calendar.MILLISECOND, 0);
		java.sql.Date d_heute = new java.sql.Date(c.getTime().getTime());

		ZeitdatenDto[] zeitdatenDtos = null;

		// try {
		// Hole Zeitdaten eines Tages
		Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
		query.setParameter(1, personalIId);
		query.setParameter(2, new java.sql.Timestamp(d_datum.getTime()));
		query.setParameter(3, Helper.addiereTageZuTimestamp(new java.sql.Timestamp(d_datum.getTime()), 1));
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// zeitdatenDtos = null;
		// }
		// else {

		zeitdatenDtos = assembleZeitdatenDtosOhneEnde(cl);

		for (int i = 0; i < zeitdatenDtos.length; i++) {
			ZeitdatenDto zeitdatenDto_Aktuell = zeitdatenFindByPrimaryKey(zeitdatenDtos[i].getIId(), theClientDto);

			if (zeitdatenDto_Aktuell.getCBelegartnr() != null) {

				// eigentlich sollte nun eine Bis-Zeit vorhanden sein
				if (zeitdatenDto_Aktuell.gettZeit_Bis() != null) {

					java.sql.Time tDauer = new java.sql.Time(zeitdatenDto_Aktuell.gettZeit_Bis().getTime()
							- zeitdatenDto_Aktuell.getTZeit().getTime() - 3600000);

					double dIstZeile = Helper.time2Double(tDauer);
					vonBisDto.setdIst(vonBisDto.getdIst() + dIstZeile);
				}

			} else if (zeitdatenDto_Aktuell.getTaetigkeitIId() != null) {

				if (zeitdatenDto_Aktuell.gettZeit_Bis() != null) {

					java.sql.Time tDauer = new java.sql.Time(zeitdatenDto_Aktuell.gettZeit_Bis().getTime()
							- zeitdatenDto_Aktuell.getTZeit().getTime() - 3600000);

					double dIstZeile = Helper.time2Double(tDauer);

					if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitDto_Unter.getIId())) {
						vonBisDto.setdUnter(vonBisDto.getdUnter() + dIstZeile);
					} else if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitDto_Arzt.getIId())) {
						vonBisDto.setdArzt(vonBisDto.getdArzt() + dIstZeile);
					} else if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitDto_Behoerde.getIId())) {
						vonBisDto.setdBehoerde(vonBisDto.getdBehoerde() + dIstZeile);
					} else if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitDto_Kindkrank.getIId())) {
						vonBisDto.setdKindkrank(vonBisDto.getdKindkrank() + dIstZeile);
					} else if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitDto_Krank.getIId())) {
						vonBisDto.setdKrank(vonBisDto.getdKrank() + dIstZeile);
					} else if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitDto_Urlaub.getIId())) {
						vonBisDto.setdUrlaub(vonBisDto.getdUrlaub() + dIstZeile);
					} else if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitDto_ZA.getIId())) {
						vonBisDto.setdZeitausgleich(vonBisDto.getdZeitausgleich() + dIstZeile);
					} else {
						TaetigkeitDto tDto = taetigkeitFindByPrimaryKey(zeitdatenDto_Aktuell.getTaetigkeitIId(),
								theClientDto);

						if (tDto.getFBezahlt() == 0) {
							vonBisDto.setdSonstigeNichtBezahlt(vonBisDto.getdSonstigeNichtBezahlt() + dIstZeile);
						} else {

							double dSumme = Helper
									.rundeKaufmaennisch(new BigDecimal(dIstZeile)
											.multiply(new BigDecimal(tDto.getFBezahlt().doubleValue() / 100)), 2)
									.doubleValue();

							vonBisDto.setdSontigeBezahlt(vonBisDto.getdSontigeBezahlt() + dSumme);

							vonBisDto.setSZusatzbezeichnung(
									vonBisDto.getSZusatzbezeichnung() + tDto.getCNr().trim() + " " + dSumme + ",");
						}

					}

				}

			}

		}

		return vonBisDto;

	}

	public Double berechneTagesArbeitszeit(Integer personalIId, java.sql.Date d_datum, TheClientDto theClientDto) {
		return berechneTagesArbeitszeit(personalIId, d_datum, true, theClientDto);
	}

	public Double berechneTagesArbeitszeit(Integer personalIId, java.sql.Date d_datum, boolean bAnwesenheitszeit,
			TheClientDto theClientDto) throws EJBExceptionLP {
		if (personalIId == null || d_datum == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("personalIId == null || d_datum == null"));
		}

		// Hole id der Taetigkeit KOMMT
		Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();
		// Hole id der Taetigkeit GEHT
		Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();

		Integer taetigkeitIId_Telefon = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_TELEFON, theClientDto).getIId();
		Integer taetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();

		// Berechnungsdatum abschneiden, damit nur mehr JJJJ.MM.TT ueberbleibt
		Calendar c = Calendar.getInstance();
		c.setTime(d_datum);
		c.set(Calendar.HOUR_OF_DAY, 0);
		c.set(Calendar.MINUTE, 0);
		c.set(Calendar.SECOND, 0);
		c.set(Calendar.MILLISECOND, 0);
		d_datum = new java.sql.Date(c.getTime().getTime());
		// Heutiges Datum herausfinden und abschneiden, damit nur mehr
		// JJJJ.MM.TT ueberbleibt
		c.setTimeInMillis(System.currentTimeMillis());
		c.set(Calendar.HOUR_OF_DAY, 0);
		c.set(Calendar.MINUTE, 0);
		c.set(Calendar.SECOND, 0);
		c.set(Calendar.MILLISECOND, 0);
		java.sql.Date d_heute = new java.sql.Date(c.getTime().getTime());

		ZeitdatenDto[] zeitdatenDtos = null;

		// try {
		// Hole Zeitdaten eines Tages
		Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
		query.setParameter(1, personalIId);
		query.setParameter(2, new java.sql.Timestamp(d_datum.getTime()));
		query.setParameter(3, Helper.addiereTageZuTimestamp(new java.sql.Timestamp(d_datum.getTime()), 1));
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// zeitdatenDtos = null;
		// }
		// else {

		zeitdatenDtos = assembleZeitdatenDtosOhneBelegzeiten(cl);
		ZeitdatenDto[] zeitdatenDtosMitBelegzeiten = assembleZeitdatenDtos(cl);

		zeitdatenDtos = simuliereMitternachssprung(personalIId, d_datum, taetigkeitIId_Kommt, taetigkeitIId_Geht,
				zeitdatenDtos);

		if (bAnwesenheitszeit == false && zeitdatenDtos.length > 1) {

			TaetigkeitDto taetigkeitDto_Unter = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER, theClientDto);
			// Hole Dto des Arztbesuchs
			TaetigkeitDto taetigkeitDto_Arzt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ARZT, theClientDto);
			// Hole Dto der Behoerde
			TaetigkeitDto taetigkeitDto_Behoerde = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_BEHOERDE,
					theClientDto);

			Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
			Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();
			// Berechnungsdatum abschneiden, damit nur mehr JJJJ.MM.TT
			// ueberbleibt

			// Heutiges Datum herausfinden und abschneiden, damit nur mehr
			// JJJJ.MM.TT ueberbleibt
			ZeitmodelltagDto zeitmodelltagDto = getZeitmodelltagZuDatum(personalIId,
					Helper.cutTimestamp(zeitdatenDtos[0].getTZeit()), tagesartIId_Feiertag, tagesartIId_Halbtag, false,
					theClientDto);

			// Auf KOMMT-GEHT Bloecke aufteilen
			boolean bKommt = false;
			ArrayList<ZeitdatenDto> kommtGehtBlock = new ArrayList<ZeitdatenDto>();

			ArrayList<ArrayList<ZeitdatenDto>> bloecke = new ArrayList<ArrayList<ZeitdatenDto>>();
			int iLetzterTag = -1;
			for (int i = 0; i < zeitdatenDtos.length; i++) {
				ZeitdatenDto zeitdatenDto_Zeile = zeitdatenDtos[i];

				Calendar c2 = Calendar.getInstance();
				c2.setTimeInMillis(zeitdatenDto_Zeile.getTZeit().getTime());
				int iTag = c2.get(Calendar.DAY_OF_MONTH);
				if (iLetzterTag != -1 && iTag != iLetzterTag && kommtGehtBlock.size() > 0) {

					bloecke.add(kommtGehtBlock);
					kommtGehtBlock = new ArrayList<ZeitdatenDto>();
					bKommt = false;
				}

				kommtGehtBlock.add(zeitdatenDto_Zeile);

				if (bKommt == false) {
					if (zeitdatenDto_Zeile.getTaetigkeitIId() != null
							&& zeitdatenDto_Zeile.getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {
						bKommt = true;
					} else {
						// FEHLER: 2 KOMMT NACHEINANDER
					}
				} else if (bKommt == true) {
					if (zeitdatenDto_Zeile.getTaetigkeitIId() != null
							&& zeitdatenDto_Zeile.getTaetigkeitIId().equals(taetigkeitIId_Geht)) {
						bKommt = false;

						bloecke.add(kommtGehtBlock);
						kommtGehtBlock = new ArrayList<ZeitdatenDto>();
					}

				}

				if (i == zeitdatenDtos.length - 1 && kommtGehtBlock.size() > 0) {
					bloecke.add(kommtGehtBlock);
				}

			}

			for (int i = 0; i < bloecke.size(); i++) {

				// PJ21439
				bloecke.set(i, rundungZugunstenDesUnternehmens(bloecke.get(i), zeitmodelltagDto));

				// SP8199
				zeitmodelltagDto = schichtErkennen(personalIId, theClientDto, taetigkeitIId_Kommt, taetigkeitIId_Geht,
						tagesartIId_Feiertag, tagesartIId_Halbtag, zeitmodelltagDto, bloecke.get(i));

				bloecke.set(i,
						fruehestesKommtUndSpaetestesGehtUndMaximaleTagesanwesenheitVerschieben(taetigkeitDto_Unter,
								taetigkeitDto_Arzt, taetigkeitDto_Behoerde, bloecke.get(i), zeitmodelltagDto, null));
			}

			ArrayList<ZeitdatenDto> kopie = new ArrayList<ZeitdatenDto>();
			for (int i = 0; i < bloecke.size(); i++) {
				kopie.addAll(bloecke.get(i));
			}

			ZeitdatenDto[] returnArray = new ZeitdatenDto[kopie.size()];
			zeitdatenDtos = (ZeitdatenDto[]) kopie.toArray(returnArray);

		}

		// Wenn Heute und die letzte Taetigkeit ist kein GEHT, dann GEHT
		// simulieren, damit Tagesarbeitszeit bis JETZT berechnet werden kann
		if (d_datum.equals(d_heute)) {
			if (zeitdatenDtos != null && zeitdatenDtos.length > 0) {
				ZeitdatenDto zeitdatenDto_LetzterEintrag = zeitdatenDtos[zeitdatenDtos.length - 1];

				if (zeitdatenDto_LetzterEintrag.getTaetigkeitIId() == null
						|| zeitdatenDto_LetzterEintrag.getTaetigkeitIId().intValue() != taetigkeitIId_Geht.intValue()) {
					ZeitdatenDto[] dtosTemp = new ZeitdatenDto[zeitdatenDtos.length + 1];

					for (int i = 0; i < zeitdatenDtos.length; i++) {
						dtosTemp[i] = zeitdatenDtos[i];
					}

					// Neue Zeile
					ZeitdatenDto dtoTemp = new ZeitdatenDto();
					dtoTemp.setPersonalIId(personalIId);
					dtoTemp.setTaetigkeitIId(taetigkeitIId_Geht);
					dtoTemp.setTZeit(new Timestamp(System.currentTimeMillis()));
					dtoTemp.setPersonalIId(personalIId);
					dtoTemp.setPersonalIId(personalIId);
					dtosTemp[zeitdatenDtos.length] = dtoTemp;
					zeitdatenDtos = dtosTemp;

				}

			}
		}

		// }
		// catch (FinderException ex) {
		// zeitdatenDtos = null;
		// }
		double dGesamt = 0;
		// Wenn Zeitdaten zum gewuenschten Tag vorhanden sind, dann
		// Tagesarbeitszeit berechnen
		if (!d_datum.equals(d_heute) && zeitdatenDtos != null && zeitdatenDtos.length == 1) {
			if (d_datum.before(d_heute)) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITERFASSUNG_FEHLER_ZEITDATEN,
						new Exception("FEHLER_ZEITERFASSUNG_FEHLER_ZEITDATEN"));
			}
		}
		if (zeitdatenDtos != null && zeitdatenDtos.length > 1) {
			ZeitdatenDto zeitdatenDto_Vorher = null;
			// Ersten und letzten Eintrag des Tages setzen
			long t1 = zeitdatenDtos[0].getTZeit().getTime();
			long t2 = zeitdatenDtos[zeitdatenDtos.length - 1].getTZeit().getTime();
			;

			double differenzInMS = (t2 - t1);

			Double dIstUestd = differenzInMS / 3600000;

			if (!d_datum.equals(d_heute) && !taetigkeitIId_Kommt.equals(zeitdatenDtos[0].getTaetigkeitIId())) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITERFASSUNG_TAETIGKEIT_VOR_KOMMT,
						new Exception("FEHLER_ZEITERFASSUNG_TAETIGKEIT_VOR_KOMMT"));
			}
			if (!d_datum.equals(d_heute)
					&& !taetigkeitIId_Geht.equals(zeitdatenDtos[zeitdatenDtos.length - 1].getTaetigkeitIId())) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITERFASSUNG_GEHT_FEHLT,
						new Exception("FEHLER_ZEITERFASSUNG_GEHT_FEHLT"));
			}

			// Ueber jede Zeitbuchung iterieren
			dGesamt = dIstUestd;

			for (int i = 0; i < zeitdatenDtos.length; i++) {
				ZeitdatenDto zeitdatenDto_Aktuell = zeitdatenDtos[i];

				// Milliskunden auf 0 setzen
				Timestamp tsTemp = zeitdatenDto_Aktuell.getTZeit();
				Calendar c2 = Calendar.getInstance();
				c2.setTimeInMillis(tsTemp.getTime());
				c2.set(Calendar.MILLISECOND, 0);
				tsTemp = new Timestamp(c2.getTimeInMillis());
				zeitdatenDto_Aktuell.setTZeit(tsTemp);

				// Bei jeder Geraden Zahl mit dem Vorgaenger vergleichen
				if (i % 2 == 0 && i != 0 && zeitdatenDto_Aktuell.getTaetigkeitIId() != null) {
					if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitIId_Kommt)
							&& zeitdatenDto_Vorher.getTaetigkeitIId().equals(taetigkeitIId_Geht)) {
						// Wenn KOMMT - GEHT, dann nicht dazuzaehlen

						long d1 = zeitdatenDto_Vorher.getTZeit().getTime();
						long d2 = zeitdatenDto_Aktuell.getTZeit().getTime();
						double diffMS = (d2 - d1);

						double dSumme = diffMS / 3600000;
						dGesamt -= dSumme;
					} else if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(zeitdatenDto_Vorher.getTaetigkeitIId())) {

						if (!zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitIId_Telefon)) {
							long d1 = zeitdatenDto_Vorher.getTZeit().getTime();
							long d2 = zeitdatenDto_Aktuell.getTZeit().getTime();

							// SP3999 Sind Buchungen dazwischen

							for (int m = 0; m < zeitdatenDtosMitBelegzeiten.length; m++) {

								Calendar cOhneMs = Calendar.getInstance();
								cOhneMs.setTimeInMillis(zeitdatenDtosMitBelegzeiten[m].getTZeit().getTime());
								cOhneMs.set(Calendar.MILLISECOND, 0);

								long tBelegzeit = cOhneMs.getTimeInMillis();

								if (tBelegzeit > d1 && tBelegzeit < d2
										&& zeitdatenDtosMitBelegzeiten[m].getArtikelIId() != null) {
									// Dann muss die Buchung dazwischen liegen
									throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BELEGZEITEN_IN_UNTERBRECHUNG,
											new Exception("FEHLER_BELEGZEITEN_IN_UNTERBRECHUNG"));

								}

							}

							double diffMS = (d2 - d1);

							double dSumme = diffMS / 3600000;
							dGesamt -= dSumme;
						}

						// Wenn KOMMT, dann Mehrfaches KOMMT
						if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {
							throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITERFASSUNG_MEHRFACHES_KOMMT,
									new Exception("FEHLER_ZEITERFASSUNG_MEHRFACHES_KOMMT"));

						}
						// Wenn GEHT, dann Mehrfaches GEHT
						else if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitIId_Geht)) {

							throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITERFASSUNG_MEHRFACHES_GEHT,
									new Exception("FEHLER_ZEITERFASSUNG_MEHRFACHES_GEHT"));

						}

						// Ansonsten muss Taetigkeit bei sonstigen bezahlten
						// oder nicht bezahlten Taetigkeiten dabei sein

					} else {
						if (!d_datum.equals(d_heute)) {
							throw new EJBExceptionLP(
									EJBExceptionLP.FEHLER_ZEITERFASSUNG_SONDERTAETIGKEIT_MUSS_BEENDET_WERDEN,
									new Exception("FEHLER_ZEITERFASSUNG_SONDERTAETIGKEIT_MUSS_BEENDET_WERDEN"));
						}
					}
				}

				zeitdatenDto_Vorher = zeitdatenDto_Aktuell;
			}
		}

		return dGesamt;
	}

	public BigDecimal berechneBelegzeitenEinesTages(Integer personalIId, java.sql.Date d_datum,
			TheClientDto theClientDto) {

		// Hole id der Taetigkeit GEHT
		Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();

		Integer taetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();

		// Berechnungsdatum abschneiden, damit nur mehr JJJJ.MM.TT ueberbleibt
		Calendar c = Calendar.getInstance();
		c.setTime(d_datum);
		c.set(Calendar.HOUR_OF_DAY, 0);
		c.set(Calendar.MINUTE, 0);
		c.set(Calendar.SECOND, 0);
		c.set(Calendar.MILLISECOND, 0);
		d_datum = new java.sql.Date(c.getTime().getTime());
		// Heutiges Datum herausfinden und abschneiden, damit nur mehr
		// JJJJ.MM.TT ueberbleibt
		c.setTimeInMillis(System.currentTimeMillis());
		c.set(Calendar.HOUR_OF_DAY, 0);
		c.set(Calendar.MINUTE, 0);
		c.set(Calendar.SECOND, 0);
		c.set(Calendar.MILLISECOND, 0);
		java.sql.Date d_heute = new java.sql.Date(c.getTime().getTime());

		ZeitdatenDto[] zeitdatenDtos = null;

		// try {
		// Hole Zeitdaten eines Tages
		Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
		query.setParameter(1, personalIId);
		query.setParameter(2, new java.sql.Timestamp(d_datum.getTime()));
		query.setParameter(3, Helper.addiereTageZuTimestamp(new java.sql.Timestamp(d_datum.getTime()), 1));
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// zeitdatenDtos = null;
		// }
		// else {

		zeitdatenDtos = assembleZeitdatenDtosOhneBelegzeiten(cl);
		ZeitdatenDto[] zeitdatenDtosMitBelegzeiten = assembleZeitdatenDtos(cl);

		BigDecimal bdSummeBelegzeiten = BigDecimal.ZERO;
		ZeitdatenDto[] tagesDaten = zeitdatenDtosMitBelegzeiten.clone();

		// Auftragsbeginn suchen
		int iAbDaBelegDaten = 0;
		for (int j = 0; j < tagesDaten.length; j++) {
			ZeitdatenDto bewegungsdatensatz = tagesDaten[j];
			if (bewegungsdatensatz.getArtikelIId() != null) {

				iAbDaBelegDaten = j;
				break;

			}
		}

		ArrayList<ZeitdatenDto> zdTemp = new ArrayList<ZeitdatenDto>();
		for (int j = iAbDaBelegDaten; j < tagesDaten.length; j++) {
			zdTemp.add(tagesDaten[j]);
		}

		tagesDaten = zdTemp.toArray(new ZeitdatenDto[zdTemp.size()]);

		if (tagesDaten.length > 1) {
			ArrayList<ZeitdatenDtoBelegzeiten[]> alAuftragszeit = new ArrayList<ZeitdatenDtoBelegzeiten[]>();

			int iZaehler = 0;
			for (int j = 0; j < tagesDaten.length; j++) {
				ZeitdatenDto bewegungsdatensatz = tagesDaten[j];

				iZaehler++;
				// Auftrag wird durch ENDE,GEHT oder neuen Beleg
				// abgeschlossen
				if ((bewegungsdatensatz.getTaetigkeitIId() != null
						&& bewegungsdatensatz.getTaetigkeitIId().equals(taetigkeitIId_Ende))
						|| (bewegungsdatensatz.getTaetigkeitIId() != null
								&& bewegungsdatensatz.getTaetigkeitIId().equals(taetigkeitIId_Geht))
						|| (bewegungsdatensatz.getCBelegartnr() != null && bewegungsdatensatz.getIBelegartid() != null
								&& j > 0)) {

					if (iZaehler % 2 == 1) {
						ArrayList<Object> al = new ArrayList<Object>();
						al.add(bewegungsdatensatz.getPersonalIId());
						al.add(tagesDaten[0].getTZeit());

						PersonalDto pDto = getPersonalFac()
								.personalFindByPrimaryKey(bewegungsdatensatz.getPersonalIId(), theClientDto);

						throw new EJBExceptionLP(EJBExceptionLP.FEHLER_IN_ZEITDATEN, al,
								new Exception("FEHLER_IN_ZEITDATEN" + " (" + pDto.getCKurzzeichen() + ") "
										+ Helper.formatTimestamp(tagesDaten[0].getTZeit(), theClientDto.getLocUi())));
					}

					ZeitdatenDtoBelegzeiten[] alleZeitdatenEinesAuftrages = new ZeitdatenDtoBelegzeiten[iZaehler];
					for (int l = 0; l < iZaehler; l++) {
						ZeitdatenDtoBelegzeiten dtoTemp = new ZeitdatenDtoBelegzeiten();

						dtoTemp.setZeitdatenDto(tagesDaten[l]);

						alleZeitdatenEinesAuftrages[l] = dtoTemp;
					}

					alAuftragszeit.add(alleZeitdatenEinesAuftrages);

					break;
				}

			}

			for (int i = 0; i < alAuftragszeit.size(); i++) {
				ZeitdatenDtoBelegzeiten[] einePositionDto = alAuftragszeit.get(i);

				AuftragzeitenDto azDtos = new AuftragzeitenDto();

				if (einePositionDto.length > 1) {

					for (int x = 0; x < einePositionDto.length - 1; x++) {
						if (x % 2 == 0) {

							ZeitdatenDto dtoBeginn = einePositionDto[x].getZeitdatenDto();
							ZeitdatenDto dtoEnde = einePositionDto[x + 1].getZeitdatenDto();
							azDtos = new AuftragzeitenDto();
							azDtos.setBelegpositionIId(einePositionDto[0].getZeitdatenDto().getIBelegartpositionid());
							azDtos.setZeitdatenIIdBelegbuchung(einePositionDto[0].getZeitdatenDto().getIId());

							java.sql.Time tDauer = new java.sql.Time(
									dtoEnde.getTZeit().getTime() - dtoBeginn.getTZeit().getTime());
							tDauer.setTime(tDauer.getTime() - 3600000);
							azDtos.setTDauer(tDauer);
							Double dDauer = Helper.time2Double(tDauer);

							bdSummeBelegzeiten = bdSummeBelegzeiten.add(new BigDecimal(dDauer));

						}

					}
				}

			}

		}

		bdSummeBelegzeiten = Helper.rundeKaufmaennisch(bdSummeBelegzeiten, 2);

		return bdSummeBelegzeiten;
	}

	private ZeitdatenDto[] simuliereMitternachssprung(Integer personalIId, java.sql.Date d_datum,
			Integer taetigkeitIId_Kommt, Integer taetigkeitIId_Geht, ZeitdatenDto[] zeitdatenDtos) {

		// Wenn die erste Buchung des tages kein Kommt ist,
		if (zeitdatenDtos.length == 0 || zeitdatenDtos[0].getTaetigkeitIId() == null
				|| !zeitdatenDtos[0].getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {

			// Wenn noch eine Sondertaetigkeit offen ist
			if (zeitdatenDtos.length > 0) {
				Integer letzteSondertaetigkeitIId = zeitdatenDtos[0].getTaetigkeitIId();
				int iAnzahl = 1;
				for (int i = 1; i < zeitdatenDtos.length; i++) {
					if (!zeitdatenDtos[i].getTaetigkeitIId().equals(letzteSondertaetigkeitIId) && iAnzahl % 2 == 1) {

						if (!zeitdatenDtos[i].getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {

							ZeitdatenDto[] zeitdatenDtosTemp = new ZeitdatenDto[zeitdatenDtos.length + 1];
							// Neue Zeile
							ZeitdatenDto dtoTemp = new ZeitdatenDto();
							dtoTemp.setPersonalIId(personalIId);
							dtoTemp.setTaetigkeitIId(letzteSondertaetigkeitIId);
							dtoTemp.setTZeit(Helper.cutTimestamp(new java.sql.Timestamp(d_datum.getTime())));
							dtoTemp.setPersonalIId(personalIId);
							dtoTemp.setBAutomatikbuchung(Helper.boolean2Short(true));
							dtoTemp.setBTaetigkeitgeaendert(Helper.boolean2Short(false));

							zeitdatenDtosTemp[0] = dtoTemp;

							for (int j = 0; j < zeitdatenDtos.length; j++) {
								zeitdatenDtosTemp[j + 1] = zeitdatenDtos[j];

							}
							zeitdatenDtos = zeitdatenDtosTemp;
						}
						break;
					}
					iAnzahl++;
				}
			}
			String sQuery = "select zeitdaten FROM FLRZeitdaten zeitdaten WHERE zeitdaten.t_zeit<'"
					+ Helper.formatDateWithSlashes(d_datum) + "' AND zeitdaten.personal_i_id=" + personalIId
					+ " AND (zeitdaten.taetigkeit_i_id=" + taetigkeitIId_Kommt + " OR zeitdaten.taetigkeit_i_id="
					+ taetigkeitIId_Geht + ") ORDER BY zeitdaten.t_zeit DESC";

			Session session = FLRSessionFactory.getFactory().openSession();

			org.hibernate.Query letzteKommtGeht = session.createQuery(sQuery);
			letzteKommtGeht.setMaxResults(1);

			List<?> resultList = letzteKommtGeht.list();

			Iterator<?> resultListIterator = resultList.iterator();

			if (resultListIterator.hasNext()) {
				FLRZeitdaten l = (FLRZeitdaten) resultListIterator.next();
				// Wenn zuletzt ein Kommt gebucht wurde, dann OK

				if (l.getTaetigkeit_i_id().equals(taetigkeitIId_Kommt)) {
					// KOMMT um 00:00 simulieren

					ZeitdatenDto[] zeitdatenDtosTemp = new ZeitdatenDto[zeitdatenDtos.length + 1];

					// Neue Zeile
					ZeitdatenDto dtoTemp = new ZeitdatenDto();
					dtoTemp.setPersonalIId(personalIId);
					dtoTemp.setTaetigkeitIId(taetigkeitIId_Kommt);
					dtoTemp.setTZeit(Helper.cutTimestamp(new java.sql.Timestamp(d_datum.getTime())));
					dtoTemp.setPersonalIId(personalIId);
					dtoTemp.setBAutomatikbuchung(Helper.boolean2Short(true));
					dtoTemp.setBTaetigkeitgeaendert(Helper.boolean2Short(false));

					zeitdatenDtosTemp[0] = dtoTemp;

					for (int i = 0; i < zeitdatenDtos.length; i++) {
						zeitdatenDtosTemp[i + 1] = zeitdatenDtos[i];

					}
					zeitdatenDtos = zeitdatenDtosTemp;
				}
			}
		}

		// Wenn die letzte Buchung des tages kein Geht ist,
		if (zeitdatenDtos.length == 0 || zeitdatenDtos[zeitdatenDtos.length - 1].getTaetigkeitIId() == null
				|| !zeitdatenDtos[zeitdatenDtos.length - 1].getTaetigkeitIId().equals(taetigkeitIId_Geht)) {
			if (zeitdatenDtos.length > 0) {
				// Wenn noch eine Sondertaetigkeit offen ist
				if (!zeitdatenDtos[zeitdatenDtos.length - 1].getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {
					Integer letzteSondertaetigkeitIId = zeitdatenDtos[zeitdatenDtos.length - 1].getTaetigkeitIId();
					int iAnzahl = 1;
					for (int i = zeitdatenDtos.length - 2; i >= 0; --i) {
						if (!zeitdatenDtos[i].getTaetigkeitIId().equals(letzteSondertaetigkeitIId)
								&& iAnzahl % 2 == 1) {

							if (!zeitdatenDtos[i].getTaetigkeitIId().equals(taetigkeitIId_Geht)) {

								ZeitdatenDto[] zeitdatenDtosTemp = new ZeitdatenDto[zeitdatenDtos.length + 1];
								// Neue Zeile
								ZeitdatenDto dtoTemp = new ZeitdatenDto();
								dtoTemp.setPersonalIId(personalIId);
								dtoTemp.setTaetigkeitIId(letzteSondertaetigkeitIId);
								dtoTemp.setTZeit(Helper.cutTimestamp(
										new java.sql.Timestamp(Helper.addiereTageZuDatum(d_datum, 1).getTime())));
								dtoTemp.setPersonalIId(personalIId);
								dtoTemp.setBAutomatikbuchung(Helper.boolean2Short(true));
								dtoTemp.setBTaetigkeitgeaendert(Helper.boolean2Short(false));
								for (int j = 0; j < zeitdatenDtos.length; j++) {
									zeitdatenDtosTemp[j] = zeitdatenDtos[j];
								}

								zeitdatenDtosTemp[zeitdatenDtos.length] = dtoTemp;

								zeitdatenDtos = zeitdatenDtosTemp;
							}
							break;
						}
						iAnzahl++;
					}

				}
			}
			String sQuery = "select zeitdaten FROM FLRZeitdaten zeitdaten WHERE zeitdaten.t_zeit>='"
					+ Helper.formatDateWithSlashes(Helper.addiereTageZuDatum(d_datum, 1))
					+ "' AND zeitdaten.personal_i_id=" + personalIId + " AND (zeitdaten.taetigkeit_i_id="
					+ taetigkeitIId_Kommt + " OR zeitdaten.taetigkeit_i_id=" + taetigkeitIId_Geht
					+ ") ORDER BY zeitdaten.t_zeit ASC";

			Session session = FLRSessionFactory.getFactory().openSession();

			org.hibernate.Query letzteKommtGeht = session.createQuery(sQuery);
			letzteKommtGeht.setMaxResults(1);

			List<?> resultList = letzteKommtGeht.list();

			Iterator<?> resultListIterator = resultList.iterator();

			if (resultListIterator.hasNext()) {
				FLRZeitdaten l = (FLRZeitdaten) resultListIterator.next();
				// Wenn zuletzt ein GEHT gebucht wurde, dann OK

				if (l.getTaetigkeit_i_id().equals(taetigkeitIId_Geht)) {
					// GEHT um 23:59:59:999 simulieren

					ZeitdatenDto[] zeitdatenDtosTemp = new ZeitdatenDto[zeitdatenDtos.length + 1];

					// Neue Zeile
					ZeitdatenDto dtoTemp = new ZeitdatenDto();
					dtoTemp.setPersonalIId(personalIId);
					dtoTemp.setTaetigkeitIId(taetigkeitIId_Geht);
					dtoTemp.setTZeit(Helper
							.cutTimestamp(new java.sql.Timestamp(Helper.addiereTageZuDatum(d_datum, 1).getTime())));
					dtoTemp.setPersonalIId(personalIId);
					dtoTemp.setBAutomatikbuchung(Helper.boolean2Short(true));
					dtoTemp.setBTaetigkeitgeaendert(Helper.boolean2Short(false));
					for (int i = 0; i < zeitdatenDtos.length; i++) {
						zeitdatenDtosTemp[i] = zeitdatenDtos[i];
					}

					zeitdatenDtosTemp[zeitdatenDtos.length] = dtoTemp;

					zeitdatenDtos = zeitdatenDtosTemp;
				}
			}
		}

		return zeitdatenDtos;
	}

	public BigDecimal getSollzeitEinerPersonUndEinesTages(PersonalDto personalDto, Integer tagesartIId_Feiertag,
			Integer tagesartIId_Halbtag, Timestamp tDatum, TheClientDto theClientDto) {

		ZeitmodelltagDto zmtagDto = getZeitmodelltagZuDatum(personalDto.getIId(), tDatum, tagesartIId_Feiertag,
				tagesartIId_Halbtag, false, theClientDto);

		Double d = new Double(0);
		if (zmtagDto != null) {
			d = Helper.time2Double(zmtagDto.getUSollzeit());
		}

		if (d != null && d.doubleValue() > 0) {

			// TAGEWEISE SONDERZEITEN ABZIEHEN
			SonderzeitenDto[] sonderzeitenDtos = sonderzeitenFindByPersonalIIdDDatum(personalDto.getIId(),
					Helper.cutTimestamp(tDatum));
			double dHalbtag = d.doubleValue() / 2;
			for (int k = 0; k < sonderzeitenDtos.length; k++) {
				SonderzeitenDto sonderzeitenDto = sonderzeitenDtos[k];
				if (Helper.short2boolean(sonderzeitenDto.getBTag())) {
					d = new Double(0);
				} else if (Helper.short2boolean(sonderzeitenDto.getBHalbtag())) {
					d = new Double(d.doubleValue() - dHalbtag);
				} else {
					d = new Double(d.doubleValue() - Helper.time2Double(sonderzeitenDto.getUStunden()).doubleValue());
				}
			}
			// STUNDENWEISE SONDERZEITEN ABZIEHEN
			if (d.doubleValue() > 0) {
				// try {
				Query query1 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
				query1.setParameter(1, personalDto.getIId());
				query1.setParameter(2, Helper.cutTimestamp(tDatum));
				query1.setParameter(3,
						Helper.cutTimestamp(Helper.addiereTageZuTimestamp(new Timestamp(tDatum.getTime()), 1)));

				ZeitdatenDto[] zeitdatenDtos = assembleZeitdatenDtosOhneBelegzeiten(query1.getResultList());
				if (zeitdatenDtos.length > 1) {
					Query query = em.createNamedQuery("TaetigkeitfindByBTagbuchbar");
					query.setParameter(1, Helper.boolean2Short(false));
					TaetigkeitDto[] dtos = assembleTaetigkeitDtos(query.getResultList());
					double dDauerGesamt = 0;
					for (int m = 0; m < dtos.length; m++) {
						TaetigkeitDto taetigkeit = dtos[m];
						if (taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ENDE)
								|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_GEHT)
								|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KOMMT)
								|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KRANK)) {
						} else {
							try {
								dDauerGesamt += berechnePaarweiserSondertaetigkeiten(zeitdatenDtos,
										taetigkeit.getIId());
							} catch (Exception ex2) {
								// FEHLERHAFTE BUCHUNGEN
							}
						}
					}

					d = new Double(d.doubleValue() - dDauerGesamt);
					if (d.doubleValue() < 0) {
						d = new Double(0);
					}
				}
				// }
				// catch (FinderException ex1) {
				// }
			}

		}

		// BigDecimal ret = new BigDecimal(0);
		BigDecimal ret = BigDecimal.ZERO;
		if (d != null) {
			ret = new BigDecimal(d.doubleValue());
		}
		return ret;
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	@SuppressWarnings("static-access")
	public SollverfuegbarkeitDto[] getVerfuegbareSollzeit(java.sql.Timestamp tVon, java.sql.Timestamp tBis,
			TheClientDto theClientDto) throws EJBExceptionLP {

		if (tVon == null || tBis == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("tVon == null || tBis == null"));
		}

		tVon = Helper.cutTimestamp(tVon);
		tBis = Helper.cutTimestamp(tBis);

		Calendar c = Calendar.getInstance();
		c.setTime(tVon);
		int iAnzahlTage = Helper.getDifferenzInTagen(tVon, tBis);

		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();
		// MASCHINENARBEITSZEITEN

		HashMap<Integer, BigDecimal> maschinengruppen = new HashMap<Integer, BigDecimal>();

		org.hibernate.Criteria crit = session.createCriteria(FLRMaschine.class)
				.add(Restrictions.eq("mandant_c_nr", theClientDto.getMandant()));
		List<?> resultList = crit.list();

		Iterator<?> resultListIterator = resultList.iterator();
		while (resultListIterator.hasNext()) {
			FLRMaschine flrmaschine = (FLRMaschine) resultListIterator.next();
			// Maschinen haben jeden Tag dieselbe Verfuegbarkeit

			double stunden = 0;
			for (int i = 0; i < iAnzahlTage; i++) {

				BigDecimal bdVerfuegbarkeitInStunden = getMaschineFac().getVerfuegbarkeitInStundenZuDatum(
						flrmaschine.getI_id(), new java.sql.Date(c.getTimeInMillis()), theClientDto);

				if (bdVerfuegbarkeitInStunden != null) {
					stunden += bdVerfuegbarkeitInStunden.doubleValue();
				}

				c.set(c.DATE, c.get(c.DATE) + 1);

			}

			BigDecimal verfuegbareStungen = new BigDecimal(stunden);

			if (maschinengruppen.containsKey(flrmaschine.getMaschinengruppe_i_id())) {
				BigDecimal vorhandeneStunden = (BigDecimal) maschinengruppen.get(flrmaschine.getMaschinengruppe_i_id());
				maschinengruppen.put(flrmaschine.getMaschinengruppe_i_id(), vorhandeneStunden.add(verfuegbareStungen));
			} else {
				maschinengruppen.put(flrmaschine.getMaschinengruppe_i_id(), verfuegbareStungen);
			}

		}

		session.close();

		// MANNARBEITSZEITEN

		HashMap<Object, Number> artikelgruppen = new HashMap<Object, Number>();
		// BigDecimal artikelgruppeSonstiges = new BigDecimal(0);
		BigDecimal artikelgruppeSonstiges = BigDecimal.ZERO;

		Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
		Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();

		c.setTime(tVon);
		ArrayList<SollverfuegbarkeitDto> alArtikelgruppen = new ArrayList<SollverfuegbarkeitDto>();
		for (int i = 0; i < iAnzahlTage; i++) {

			Timestamp tKey = Helper.cutTimestamp(new Timestamp(c.getTimeInMillis()));

			String sQuery = "SELECT distinct e.personal_i_id FROM FLREintrittaustritt e WHERE e.flrpersonal.mandant_c_nr='"
					+ theClientDto.getMandant() + "' AND e.t_eintritt<='"
					+ Helper.formatDateWithSlashes(new java.sql.Date(tKey.getTime()))
					+ "' AND (e.t_austritt IS NULL OR e.t_austritt > '"
					+ Helper.formatDateWithSlashes(new java.sql.Date(tKey.getTime())) + "' )";
			Session sessionEA = FLRSessionFactory.getFactory().openSession();
			org.hibernate.Query queryEA = sessionEA.createQuery(sQuery);

			List<?> results = queryEA.list();
			Iterator<?> resultListIteratorEA = results.iterator();

			while (resultListIteratorEA.hasNext()) {

				Integer personalIId = (Integer) resultListIteratorEA.next();

				ZeitmodelltagDto zmtagDto = getZeitmodelltagZuDatum(personalIId, new Timestamp(c.getTimeInMillis()),
						tagesartIId_Feiertag, tagesartIId_Halbtag, false, theClientDto);

				Double d = new Double(0);
				if (zmtagDto != null) {
					d = Helper.time2Double(zmtagDto.getUSollzeit());
				}

				if (d != null && d.doubleValue() > 0) {

					// TAGEWEISE SONDERZEITEN ABZIEHEN
					SonderzeitenDto[] sonderzeitenDtos = sonderzeitenFindByPersonalIIdDDatum(personalIId,
							Helper.cutTimestamp(new Timestamp(c.getTimeInMillis())));
					double dHalbtag = d.doubleValue() / 2;
					for (int k = 0; k < sonderzeitenDtos.length; k++) {
						SonderzeitenDto sonderzeitenDto = sonderzeitenDtos[k];
						if (Helper.short2boolean(sonderzeitenDto.getBTag())) {
							d = new Double(0);
						} else if (Helper.short2boolean(sonderzeitenDto.getBHalbtag())) {
							d = new Double(d.doubleValue() - dHalbtag);
						} else {
							d = new Double(
									d.doubleValue() - Helper.time2Double(sonderzeitenDto.getUStunden()).doubleValue());
						}
					}
					// STUNDENWEISE SONDERZEITEN ABZIEHEN
					if (d.doubleValue() > 0) {
						// try {
						Query query1 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
						query1.setParameter(1, personalIId);
						query1.setParameter(2, Helper.cutTimestamp(new Timestamp(c.getTimeInMillis())));
						query1.setParameter(3, Helper
								.cutTimestamp(Helper.addiereTageZuTimestamp(new Timestamp(c.getTimeInMillis()), 1)));

						ZeitdatenDto[] zeitdatenDtos = assembleZeitdatenDtosOhneBelegzeiten(query1.getResultList());
						if (zeitdatenDtos.length > 1) {
							Query query = em.createNamedQuery("TaetigkeitfindByBTagbuchbar");
							query.setParameter(1, Helper.boolean2Short(false));
							TaetigkeitDto[] dtos = assembleTaetigkeitDtos(query.getResultList());
							double dDauerGesamt = 0;
							for (int m = 0; m < dtos.length; m++) {
								TaetigkeitDto taetigkeit = dtos[m];
								if (taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ENDE)
										|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_GEHT)
										|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KOMMT)
										|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KRANK)) {
								} else {
									try {
										dDauerGesamt += berechnePaarweiserSondertaetigkeiten(zeitdatenDtos,
												taetigkeit.getIId());
									} catch (Exception ex2) {
										// FEHLERHAFTE BUCHUNGEN
									}
								}
							}

							d = new Double(d.doubleValue() - dDauerGesamt);
							if (d.doubleValue() < 0) {
								d = new Double(0);
							}
						}
						// }
						// catch (FinderException ex1) {
						// }
					}

					session = factory.openSession();
					crit = session.createCriteria(FLRPersonalverfuegbarkeit.class).createAlias("flrpersonal", "p")
							.add(Restrictions.eq("p.i_id", personalIId));

					resultList = crit.list();

					resultListIterator = resultList.iterator();
					while (resultListIterator.hasNext()) {
						FLRPersonalverfuegbarkeit flrPersonalverfuegbarkeit = (FLRPersonalverfuegbarkeit) resultListIterator
								.next();

						double dVerfuegbareZeit = d.doubleValue()
								* (flrPersonalverfuegbarkeit.getF_anteilprozent().doubleValue() / 100);

						// Sonderzeiten abziehen

						if (flrPersonalverfuegbarkeit.getFlrartikel().getFlrartikelgruppe() != null) {
							Integer artikelgruppeIId = flrPersonalverfuegbarkeit.getFlrartikel().getFlrartikelgruppe()
									.getI_id();

							if (artikelgruppen.containsKey(artikelgruppeIId)) {
								BigDecimal dZeitvorhanden = (BigDecimal) artikelgruppen.get(artikelgruppeIId);
								artikelgruppen.put(artikelgruppeIId,
										dZeitvorhanden.add(new BigDecimal(dVerfuegbareZeit)));

							} else {
								artikelgruppen.put(artikelgruppeIId, new BigDecimal(dVerfuegbareZeit));
							}

						} else {

							artikelgruppeSonstiges = artikelgruppeSonstiges.add(new BigDecimal(dVerfuegbareZeit));
						}

					}

					session.close();
				}
			}

			sessionEA.close();

			Iterator<?> ag = artikelgruppen.keySet().iterator();
			while (ag.hasNext()) {
				Integer key = (Integer) ag.next();
				BigDecimal value = (BigDecimal) artikelgruppen.get(key);

				SollverfuegbarkeitDto dtoGruppe = new SollverfuegbarkeitDto();
				dtoGruppe.setBMannarbeitszeit(true);
				dtoGruppe.setIGruppeid(key);
				dtoGruppe.setNSollstunden(Helper.rundeKaufmaennisch(value, 2));
				dtoGruppe.setTDatum(new java.sql.Timestamp(c.getTimeInMillis()));
				if (value.doubleValue() > 0) {
					alArtikelgruppen.add(dtoGruppe);
				}
			}

			SollverfuegbarkeitDto dtoGruppeSonstiges = new SollverfuegbarkeitDto();
			dtoGruppeSonstiges.setBMannarbeitszeit(true);
			dtoGruppeSonstiges.setTDatum(new java.sql.Timestamp(c.getTimeInMillis()));
			dtoGruppeSonstiges.setNSollstunden(Helper.rundeKaufmaennisch(artikelgruppeSonstiges, 2));
			if (artikelgruppeSonstiges.doubleValue() > 0) {
				alArtikelgruppen.add(dtoGruppeSonstiges);
			}
			artikelgruppen = new HashMap<Object, Number>();
			artikelgruppeSonstiges = new BigDecimal(0);

			c.set(c.DATE, c.get(c.DATE) + 1);
		}

		int groesse = maschinengruppen.size() + alArtikelgruppen.size();

		SollverfuegbarkeitDto[] sollverfuegbarkeitDtos = new SollverfuegbarkeitDto[groesse];
		int iZeile = 0;

		Iterator<?> it = maschinengruppen.keySet().iterator();
		while (it.hasNext()) {
			Integer key = (Integer) it.next();
			BigDecimal stunden = (BigDecimal) maschinengruppen.get(key);
			SollverfuegbarkeitDto dto = new SollverfuegbarkeitDto();
			dto.setBMannarbeitszeit(false);
			dto.setIGruppeid(key);
			dto.setNSollstunden(Helper.rundeKaufmaennisch(stunden, 2));
			dto.setTDatum(null);
			sollverfuegbarkeitDtos[iZeile] = dto;
			iZeile++;
		}

		// sollverfuegbarkeitDtos[iZeile]=
		for (int i = 0; i < alArtikelgruppen.size(); i++) {

			sollverfuegbarkeitDtos[iZeile] = (SollverfuegbarkeitDto) alArtikelgruppen.get(i);
			iZeile++;
		}

		return sollverfuegbarkeitDtos;
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	@SuppressWarnings("static-access")
	public TreeMap<Timestamp, BigDecimal> getVerfuegbareSollzeitAusPersonalgehalt(java.sql.Timestamp tVon,
			java.sql.Timestamp tBis, TheClientDto theClientDto) {

		TreeMap<Timestamp, BigDecimal> tmVerfuegbarkeiten = new TreeMap<Timestamp, BigDecimal>();

		tVon = Helper.cutTimestamp(tVon);
		tBis = Helper.cutTimestamp(tBis);

		Calendar c = Calendar.getInstance();
		c.setTime(tVon);
		int iAnzahlTage = Helper.getDifferenzInTagen(tVon, tBis);

		Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
		Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();

		c.setTime(tVon);
		ArrayList<SollverfuegbarkeitDto> alArtikelgruppen = new ArrayList<SollverfuegbarkeitDto>();
		for (int i = 0; i < iAnzahlTage; i++) {

			Timestamp tKey = Helper.cutTimestamp(new Timestamp(c.getTimeInMillis()));

			String sQuery = "SELECT distinct e.personal_i_id FROM FLREintrittaustritt e WHERE e.flrpersonal.mandant_c_nr='"
					+ theClientDto.getMandant() + "' AND e.t_eintritt<='"
					+ Helper.formatDateWithSlashes(new java.sql.Date(tKey.getTime()))
					+ "' AND (e.t_austritt IS NULL OR e.t_austritt > '"
					+ Helper.formatDateWithSlashes(new java.sql.Date(tKey.getTime())) + "' )";
			Session sessionEA = FLRSessionFactory.getFactory().openSession();
			org.hibernate.Query queryEA = sessionEA.createQuery(sQuery);

			List<?> results = queryEA.list();
			Iterator<?> resultListIterator = results.iterator();

			while (resultListIterator.hasNext()) {

				Integer personalIId = (Integer) resultListIterator.next();

				ZeitmodelltagDto zmtagDto = getZeitmodelltagZuDatum(personalIId, new Timestamp(c.getTimeInMillis()),
						tagesartIId_Feiertag, tagesartIId_Halbtag, false, theClientDto);

				Double d = new Double(0);
				if (zmtagDto != null) {
					d = Helper.time2Double(zmtagDto.getUSollzeit());
				}

				if (d != null && d.doubleValue() > 0) {

					// TAGEWEISE SONDERZEITEN ABZIEHEN
					SonderzeitenDto[] sonderzeitenDtos = sonderzeitenFindByPersonalIIdDDatum(personalIId,
							Helper.cutTimestamp(new Timestamp(c.getTimeInMillis())));
					double dHalbtag = d.doubleValue() / 2;
					for (int k = 0; k < sonderzeitenDtos.length; k++) {
						SonderzeitenDto sonderzeitenDto = sonderzeitenDtos[k];
						if (Helper.short2boolean(sonderzeitenDto.getBTag())) {
							d = new Double(0);
						} else if (Helper.short2boolean(sonderzeitenDto.getBHalbtag())) {
							d = new Double(d.doubleValue() - dHalbtag);
						} else {
							d = new Double(
									d.doubleValue() - Helper.time2Double(sonderzeitenDto.getUStunden()).doubleValue());
						}
					}
					// STUNDENWEISE SONDERZEITEN ABZIEHEN
					if (d.doubleValue() > 0) {
						// try {
						Query query1 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
						query1.setParameter(1, personalIId);
						query1.setParameter(2, Helper.cutTimestamp(new Timestamp(c.getTimeInMillis())));
						query1.setParameter(3, Helper
								.cutTimestamp(Helper.addiereTageZuTimestamp(new Timestamp(c.getTimeInMillis()), 1)));

						ZeitdatenDto[] zeitdatenDtos = assembleZeitdatenDtosOhneBelegzeiten(query1.getResultList());
						if (zeitdatenDtos.length > 1) {
							Query query = em.createNamedQuery("TaetigkeitfindByBTagbuchbar");
							query.setParameter(1, Helper.boolean2Short(false));
							TaetigkeitDto[] dtos = assembleTaetigkeitDtos(query.getResultList());
							double dDauerGesamt = 0;
							for (int m = 0; m < dtos.length; m++) {
								TaetigkeitDto taetigkeit = dtos[m];
								if (taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ENDE)
										|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_GEHT)
										|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KOMMT)
										|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KRANK)) {
								} else {
									try {
										dDauerGesamt += berechnePaarweiserSondertaetigkeiten(zeitdatenDtos,
												taetigkeit.getIId());
									} catch (Exception ex2) {
										// FEHLERHAFTE BUCHUNGEN
									}
								}
							}

							d = new Double(d.doubleValue() - dDauerGesamt);
							if (d.doubleValue() < 0) {
								d = new Double(0);
							}
						}
						// }
						// catch (FinderException ex1) {
						// }
					}

					Double verfuegbarkeit = 0D;
					Double leistungswert = 100D;
					try {
						PersonalgehaltDto pgDto = getPersonalFac().personalgehaltFindLetztePersonalgehalt(personalIId,
								c.get(Calendar.YEAR), c.get(Calendar.MONTH));
						if (pgDto != null) {
							verfuegbarkeit = pgDto.getFVerfuegbarkeit();
							if (pgDto.getFLeistungswert() != null) {
								leistungswert = pgDto.getFLeistungswert();
							}

						}

					} catch (RemoteException e) {
						throwEJBExceptionLPRespectOld(e);
					}

					double dVerfuegbareZeit = d.doubleValue() * (verfuegbarkeit.doubleValue() / 100)
							* (leistungswert.doubleValue() / 100);

					BigDecimal bdVerfuegbarkeitEinerPerson = new BigDecimal(dVerfuegbareZeit);

					bdVerfuegbarkeitEinerPerson = Helper.rundeKaufmaennisch(bdVerfuegbarkeitEinerPerson, 4);

					if (tmVerfuegbarkeiten.containsKey(tKey)) {
						BigDecimal bdVerfuegbarkeitEinerPersonTemp = tmVerfuegbarkeiten.get(tKey);

						bdVerfuegbarkeitEinerPersonTemp = bdVerfuegbarkeitEinerPersonTemp
								.add(bdVerfuegbarkeitEinerPerson);
						tmVerfuegbarkeiten.put(tKey, bdVerfuegbarkeitEinerPersonTemp);

					} else {
						tmVerfuegbarkeiten.put(tKey, bdVerfuegbarkeitEinerPerson);
					}

				}

			}
			if (!tmVerfuegbarkeiten.containsKey(tKey)) {
				tmVerfuegbarkeiten.put(tKey, BigDecimal.ZERO);
			}

			c.set(c.DATE, c.get(c.DATE) + 1);
		}

		return tmVerfuegbarkeiten;
	}

	/**
	 * Berechne die TagesArbeitszeit eines Zeitraumes zu einer Person, ohne
	 * Paarweisen Sondertaetigkeiten meldet Fehler, wenn die Tagesarbeitszeit nicht
	 * berechnet werden konnte
	 * 
	 * @param personalIId  Die Person
	 * @param dDatumVon    Das Von
	 * @param dDatumBis    Das Bis
	 * @param theClientDto User-ID
	 * @return String beinhaltet Tagesarbeitszeit
	 * @exception EJBExceptionLP
	 */
	@SuppressWarnings("static-access")
	public Double berechneArbeitszeitImZeitraum(Integer personalIId, java.sql.Date dDatumVon, java.sql.Date dDatumBis,
			boolean bAbzueglichTelefonzeiten, TheClientDto theClientDto) {
		if (personalIId == null || dDatumVon == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("personalIId == null || dDatumVon == null"));
		}
		Helper.cutDate(dDatumVon);
		Helper.cutDate(dDatumBis);

		boolean bVonBisZeiterfassungOhneKommtGeht = false;
		boolean bKommtGeht = true;
		boolean bVonBis = false;

		TreeMap<String, Object[]> tmDatenSubreportSchichtzulagen = new TreeMap<String, Object[]>();

		try {
			ParametermandantDto parameter = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_VON_BIS_ERFASSUNG);

			bVonBis = (Boolean) parameter.getCWertAsObject();

			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_VON_BIS_ERFASSUNG_KOMMT_GEHT_BUCHEN);

			bKommtGeht = (Boolean) parameter.getCWertAsObject();

			if (bVonBis == true && bKommtGeht == false) {
				bVonBisZeiterfassungOhneKommtGeht = true;
			}

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		// SP4141
		if (bVonBisZeiterfassungOhneKommtGeht) {
			Double d = 0D;

			int iAnzahlTage = Helper.getDifferenzInTagen(dDatumVon, dDatumBis);

			Calendar c = Calendar.getInstance();
			c.setTimeInMillis(dDatumVon.getTime());
			for (int i = 0; i < iAnzahlTage; i++) {
				d += berechneTagesArbeitszeitVonBisZeiterfassungOhneKommtGeht(personalIId,
						new java.sql.Date(c.getTime().getTime()), theClientDto).getdIst();
				c.set(Calendar.DATE, c.get(Calendar.DATE) + 1);
			}

			return d;

		}

		// Hole id der Taetigkeit ENDE
		Integer taetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();
		// Hole id der Taetigkeit KOMMT
		Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();
		// Hole id der Taetigkeit GEHT
		Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();
		// Hole id der Taetigkeit GEHT
		Integer taetigkeitIId_Telefon = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_TELEFON, theClientDto).getIId();

		ArrayList<Object> daten = new ArrayList<Object>();
		// Alle Zeitdaten des Zeitraums holen
		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();
		org.hibernate.Criteria zeitdatenEinesMonats = session.createCriteria(FLRZeitdaten.class);

		zeitdatenEinesMonats.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalIId));
		zeitdatenEinesMonats
				.add(Expression.ge(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, new java.sql.Timestamp(dDatumVon.getTime())));
		zeitdatenEinesMonats
				.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, new java.sql.Timestamp(dDatumBis.getTime())));
		zeitdatenEinesMonats.addOrder(Order.asc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));

		List<?> resultListZeitdaten = zeitdatenEinesMonats.list();

		Iterator<?> resultListIterator = resultListZeitdaten.iterator();

		List<ZeitdatenDto> tagZeitdaten = new ArrayList<ZeitdatenDto>();

		Calendar c = Calendar.getInstance();
		c.setTimeInMillis(dDatumVon.getTime());

		int iTagVorher = c.get(c.DAY_OF_MONTH);
		int rowZeile = 0;
		// Monatsdaten auf Tagesdaten aufteilen
		while (resultListIterator.hasNext()) {
			FLRZeitdaten flrzeitdaten = (FLRZeitdaten) resultListIterator.next();

			if (flrzeitdaten.getFlrtaetigkeit() != null
					&& (taetigkeitIId_Ende.equals(flrzeitdaten.getFlrtaetigkeit().getI_id()))) {

			} else {

				Calendar cTemp = Calendar.getInstance();
				cTemp.setTimeInMillis(flrzeitdaten.getT_zeit().getTime());

				ZeitdatenDto tempDto = new ZeitdatenDto();

				if (flrzeitdaten.getFlrtaetigkeit() != null) {
					tempDto.setTaetigkeitIId(flrzeitdaten.getFlrtaetigkeit().getI_id());
				} else if (flrzeitdaten.getFlrartikel() != null) {
					tempDto.setArtikelIId(flrzeitdaten.getFlrartikel().getI_id());
					tempDto.setCBelegartnr(flrzeitdaten.getC_belegartnr());
					tempDto.setIBelegartpositionid(flrzeitdaten.getI_belegartpositionid());
					tempDto.setIBelegartid(flrzeitdaten.getI_belegartid());
				}
				tempDto.setTZeit(new Timestamp(flrzeitdaten.getT_zeit().getTime()));
				tempDto.setIId(flrzeitdaten.getI_id());

				int iTagAktuell = cTemp.get(cTemp.DAY_OF_MONTH);
				if (iTagVorher != iTagAktuell) {
					ZeitdatenDto[] returnArrayZeitdaten = new ZeitdatenDto[tagZeitdaten.size()];
					daten.add(tagZeitdaten.toArray(returnArrayZeitdaten));
					/*
					 * daten[iTagVorher - 1] = (ZeitdatenDto[])
					 * tagZeitdaten.toArray(returnArrayZeitdaten);
					 */
					tagZeitdaten = new ArrayList<ZeitdatenDto>();

					if (flrzeitdaten.getFlrtaetigkeit() != null) {
						tagZeitdaten.add(tempDto);
					}
				} else {

					if (flrzeitdaten.getFlrtaetigkeit() != null) {
						tagZeitdaten.add(tempDto);
					}

					if (resultListIterator.hasNext() == false) {
						ZeitdatenDto[] returnArrayZeitdaten = new ZeitdatenDto[tagZeitdaten.size()];
						if (flrzeitdaten.getFlrtaetigkeit() != null) {
							daten.add(tagZeitdaten.toArray(returnArrayZeitdaten));

							/*
							 * daten[iTagAktuell - 1] = (ZeitdatenDto[])
							 * tagZeitdaten.toArray(returnArrayZeitdaten);
							 */
						}
					}
				}
				iTagVorher = iTagAktuell;
			}

			rowZeile++;
		}
		session.close();
		double dGesamt = 0;

		try {
			for (int k = 0; k < daten.size(); k++) {
				ZeitdatenDto[] zeitdatenDtos = (ZeitdatenDto[]) daten.get(k);

				java.sql.Time u_gesamt = new java.sql.Time(-3600000);

				java.sql.Time u_before = null;

				java.sql.Time u_kommt = null;
				java.sql.Time u_geht = null;
				boolean b_kommt = false;
				boolean bEnde = false;
				Integer sTaetigkeit_before = null;

				// Wenn Zeitdaten zum gewuenschten Tag vorhanden sind, dann
				// Tagesarbeitszeit berechnen
				if (zeitdatenDtos != null && zeitdatenDtos.length > 0) {

					zeitdatenDtos = simuliereMitternachssprung(personalIId,
							new java.sql.Date(zeitdatenDtos[0].getTZeit().getTime()), taetigkeitIId_Kommt,
							taetigkeitIId_Geht, zeitdatenDtos);

					for (int i = 0; i < zeitdatenDtos.length; i++) {
						ZeitdatenDto row = zeitdatenDtos[i];
						java.sql.Time u_aktuell = new java.sql.Time(row.getTZeit().getTime());

						Integer sTaetigkeit_aktuell = row.getTaetigkeitIId();

						if (!sTaetigkeit_aktuell.equals(taetigkeitIId_Kommt) && i == 0) {
							throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITERFASSUNG_TAETIGKEIT_VOR_KOMMT,
									new Exception("FEHLER_ZEITERFASSUNG_TAETIGKEIT_VOR_KOMMT"));
						}

						// Das KOMMT herausfinden
						if (sTaetigkeit_aktuell.equals(taetigkeitIId_Kommt) && b_kommt == false) {
							u_kommt = new java.sql.Time(row.getTZeit().getTime());
							b_kommt = true;

						}

						if (bEnde == false) {
							if (sTaetigkeit_aktuell.equals(sTaetigkeit_before)) {
								if (sTaetigkeit_aktuell.equals(taetigkeitIId_Kommt)) {
									throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITERFASSUNG_MEHRFACHES_KOMMT,
											new Exception("FEHLER_ZEITERFASSUNG_MEHRFACHES_KOMMT"));
								}
								if (sTaetigkeit_aktuell.equals(taetigkeitIId_Geht)) {
									throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITERFASSUNG_MEHRFACHES_GEHT,
											new Exception("FEHLER_ZEITERFASSUNG_MEHRFACHES_GEHT"));
								}

								java.sql.Time u_pause = new java.sql.Time(row.getTZeit().getTime());
								long l_pause = u_pause.getTime() - u_before.getTime();

								if (bAbzueglichTelefonzeiten == false) {
									if (!sTaetigkeit_aktuell.equals(taetigkeitIId_Telefon)) {
										u_gesamt.setTime(u_gesamt.getTime() - l_pause);
									}
								} else {
									u_gesamt.setTime(u_gesamt.getTime() - l_pause);
								}

								bEnde = true;

							}
						} else {
							bEnde = false;
						}

						if (sTaetigkeit_aktuell.equals(taetigkeitIId_Geht)) {
							if (u_kommt == null) {
								throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITERFASSUNG_GEHT_OHNE_KOMMT,
										new Exception("FEHLER_ZEITERFASSUNG_GEHT_OHNE_KOMMT"));
							}
							u_geht = (java.sql.Time) new java.sql.Time(row.getTZeit().getTime());
							u_gesamt.setTime(u_gesamt.getTime() + (u_geht.getTime() - u_kommt.getTime()));
							b_kommt = false;
						}

						sTaetigkeit_before = sTaetigkeit_aktuell;
						u_before = u_aktuell;
					}
					java.sql.Date d_heute = Helper.cutDate(new java.sql.Date(System.currentTimeMillis()));
					if (!Helper.cutDate(new java.sql.Date(zeitdatenDtos[0].getTZeit().getTime())).equals(d_heute)
							&& u_geht == null) {
						// SP8151
						throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITERFASSUNG_GEHT_FEHLT,
								new Exception("FEHLER_ZEITERFASSUNG_GEHT_FEHLT"));
					}

				}
				dGesamt = dGesamt + Helper.time2Double(u_gesamt).doubleValue();
			}
		} catch (EJBExceptionLP ex) {
			// SP2936
			return -1D;
		}
		return new Double(dGesamt);
	}

	public double berechneDauerPaarweiserSondertaetigkeitenEinerPersonUndEinesZeitraumes(Integer personalIId,
			java.sql.Timestamp tVon, java.sql.Timestamp tBis, Integer iTaetigkeit) {
		tVon = Helper.cutTimestamp(tVon);
		tBis = Helper.cutTimestamp(tBis);

		double dDauerGesamt = 0;

		for (long l = tVon.getTime(); l <= tBis.getTime(); l = l + (24 * 3600000)) {
			java.sql.Timestamp t_datum = new java.sql.Timestamp(l);
			try {
				Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
				query.setParameter(1, personalIId);
				query.setParameter(2, Helper.cutTimestamp(t_datum));
				query.setParameter(3,
						Helper.cutTimestamp(Helper.addiereTageZuTimestamp(new Timestamp(t_datum.getTime()), 1)));

				ZeitdatenDto[] dtos = assembleZeitdatenDtos(query.getResultList());

				// Wenn Mehr als 2 buchungen sind
				if (dtos.length > 2) {
					dDauerGesamt = dDauerGesamt + berechnePaarweiserSondertaetigkeiten(dtos, iTaetigkeit);
				}
			} catch (Exception e) {
				/** @todo Was machen wir hier PJ 4659 */
			}

		}
		return dDauerGesamt;
	}

	private double berechneDauerPaarweiserSondertaetigkeitenEinerPersonUndEinesZeitraumesVonBis(Integer personalIId,
			java.sql.Timestamp tVon, java.sql.Timestamp tBis, Integer iTaetigkeit, TheClientDto theClientDto) {
		tVon = Helper.cutTimestamp(tVon);
		tBis = Helper.cutTimestamp(tBis);

		double dDauerGesamt = 0;

		for (long l = tVon.getTime(); l <= tBis.getTime(); l = l + (24 * 3600000)) {
			java.sql.Timestamp t_datum = new java.sql.Timestamp(l);
			try {
				Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
				query.setParameter(1, personalIId);
				query.setParameter(2, Helper.cutTimestamp(t_datum));
				query.setParameter(3,
						Helper.cutTimestamp(Helper.addiereTageZuTimestamp(new Timestamp(t_datum.getTime()), 1)));

				ZeitdatenDto[] dtos = assembleZeitdatenDtos(query.getResultList());

				for (int j = 0; j < dtos.length; j++) {

					if (dtos[j].getTaetigkeitIId() != null && dtos[j].getTaetigkeitIId().equals(iTaetigkeit)) {

						ZeitdatenDto zDtoEnde = getZeiterfassungFac().getZugehoerigeEndeBuchung(dtos[j], theClientDto);
						if (zDtoEnde != null) {

							java.sql.Time tDauer = new java.sql.Time(
									zDtoEnde.getTZeit().getTime() - dtos[j].getTZeit().getTime() - 3600000);

							double dIstZeile = Helper.time2Double(tDauer);
							dDauerGesamt += dIstZeile;
						}
					}
				}
			} catch (Exception e) {
				/** @todo Was machen wir hier PJ 4659 */
			}

		}
		return dDauerGesamt;
	}

	/**
	 * Ermittelt die Summe paarweiser Sondertaetigkeiten eines Tages (dezimal in
	 * Stunden)
	 * 
	 * @param personalIId
	 * @param iMonat
	 * @param iJahr
	 * @return Summe der Unterbrechungen
	 * @exception RemoteException
	 * @exception Exception
	 */
	public BigDecimal berechneKalkJahresIstStunden(Integer personalIId, Integer iMonat, Integer iJahr,
			TheClientDto theClientDto) {

		try {
			ParametermandantDto parameter = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_LOHNSTUNDENSATZKALKULATION_KALENDERWOCHEN);

			Double dLohnstundensatzKalenderwochen = (Double) parameter.getCWertAsObject();
			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_LOHNSTUNDENSATZKALKULATION_KRANKWOCHEN);

			Double dLohnstundensatzKrankwochen = (Double) parameter.getCWertAsObject();
			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_LOHNSTUNDENSATZKALKULATION_FEIERTAGSWOCHEN);

			Double dLohnstundensatzFeiertagswochen = (Double) parameter.getCWertAsObject();

			if (dLohnstundensatzKalenderwochen > 0) {
				Calendar c = Calendar.getInstance();
				c.set(Calendar.YEAR, iJahr);
				c.set(Calendar.MONTH, iMonat);
				c.set(Calendar.DATE, 1);

				PersonalzeitmodellDto dto = getPersonalFac().personalzeitmodellFindZeitmodellZuDatum(personalIId,
						Helper.cutTimestamp(new java.sql.Timestamp(c.getTimeInMillis())), theClientDto);
				if (dto != null) {

					double dJahresurlaubInWochen = 0;
					UrlaubsanspruchDto[] uDtos = getPersonalFac()
							.urlaubsanspruchFindByPersonalIIdIJahrKleiner(personalIId, iJahr);
					if (uDtos.length > 0) {
						dJahresurlaubInWochen = uDtos[0].getFJahresurlaubinwochen();

					}

					return new BigDecimal(getSummeSollzeitMontagBisSonntag(dto.getZeitmodellIId())
							* (dLohnstundensatzKalenderwochen - dJahresurlaubInWochen - dLohnstundensatzKrankwochen
									- dLohnstundensatzFeiertagswochen));
				} else {
					return BigDecimal.ZERO;
				}
			}

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		return BigDecimal.ZERO;
	}

	public double berechnePaarweiserSondertaetigkeiten(ZeitdatenDto[] zeitdaten, Integer iTaetigkeit) throws Exception {
		return berechnePaarweiserSondertaetigkeiten(zeitdaten, true, iTaetigkeit);
	}

	public double berechnePaarweiserSondertaetigkeiten(ZeitdatenDto[] zeitdaten, boolean bAuf2StellenGerundet,
			Integer iTaetigkeit) throws Exception {

		java.sql.Time tUnterbrechungszeit = null;
		Float fUnterbrechungszeit = null;
		Integer iStelleLetzteUnterbrechungBeginn = null;
		boolean bUnterbrechungBeginn = false;
		Float fUnterbrechungBeginn = null;
		Float fUnterbrechungEnde = null;

		double fSummeUnterbrechungen = 0;

		int iAnzahlBuchungen = zeitdaten.length;
		ZeitdatenDto vEineZeile = null;

		try {
			for (int i = 0; i < iAnzahlBuchungen; i++) {
				vEineZeile = zeitdaten[i];

				if (iTaetigkeit.equals(vEineZeile.getTaetigkeitIId())) {
					tUnterbrechungszeit = null;
					// Konvertierung der Unterbrechungszeit in ein Float-Objekt
					tUnterbrechungszeit = new java.sql.Time(vEineZeile.getTZeit().getTime());
					Calendar c = Calendar.getInstance();
					c.setTimeInMillis(tUnterbrechungszeit.getTime());
					float hour = c.get(Calendar.HOUR_OF_DAY);
					float minuten = c.get(Calendar.MINUTE);
					float minutendecimal = minuten / 60;
					if (bAuf2StellenGerundet) {
						minutendecimal = Math.round(minutendecimal * 100) / 100f;
					}
					fUnterbrechungszeit = new Float(hour + minutendecimal);

					// Es gibt noch keinen 'Unterbrechung Beginn'
					if (bUnterbrechungBeginn == false) {
						fUnterbrechungBeginn = fUnterbrechungszeit;
						bUnterbrechungBeginn = true;
						iStelleLetzteUnterbrechungBeginn = new Integer(i);
					}
					// Es gibt schon einen 'Beginn- Eintrag'
					// Demnach muss dies jetzt der 'Ende- Eintrag' sein
					// und zwar direkt folgend nach dem Beginn -> dh. zw.
					// Unterbrechung Beginn und
					// Unterbrechung Ende darf keine weitere Buchung vorhanden
					// sein
					else {
						// kein Buchung zw. Unterbrechung Beginn und Ende
						if ((i - 1) == iStelleLetzteUnterbrechungBeginn.intValue()) {
							fUnterbrechungEnde = fUnterbrechungszeit;
							bUnterbrechungBeginn = false;
							iStelleLetzteUnterbrechungBeginn = null;
						}
						// Buchung zw. Unterbrechung Beginn und Ende
						else {
							Taetigkeit taetigkeit = em.find(Taetigkeit.class, iTaetigkeit);
							throw new Exception("Buchung zw. " + taetigkeit.getCNr().trim() + " Beginn/Ende");
						}
					}

					if (fUnterbrechungBeginn != null && fUnterbrechungEnde != null) {
						// Addieren der Pause zur Summe der Unterbrechungen
						fSummeUnterbrechungen = fSummeUnterbrechungen
								+ (fUnterbrechungEnde.floatValue() - fUnterbrechungBeginn.floatValue());
						fUnterbrechungBeginn = null;
						fUnterbrechungEnde = null;
					}
				}
			}
			if (fUnterbrechungBeginn != null && fUnterbrechungEnde == null) {
				// Nach Unterbrechung Beginn folgt kein Unterbrechung Ende
				Taetigkeit taetigkeit = em.find(Taetigkeit.class, iTaetigkeit);
				throw new Exception("kein " + taetigkeit.getCNr().trim() + " Ende");
			}
		} catch (Exception e) {
			throw new Exception(e.getMessage());
		}
		// Runden auf 2-Nachkommastellen
		if (bAuf2StellenGerundet) {
			fSummeUnterbrechungen = Math.round(fSummeUnterbrechungen * 100) / 100f;
		}

		return fSummeUnterbrechungen;
	}

	public Integer createZeitmodell(ZeitmodellDto zeitmodellDto, TheClientDto theClientDto) throws EJBExceptionLP {
		if (zeitmodellDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitmodellDto == null"));
		}
		if (zeitmodellDto.getCNr() == null || zeitmodellDto.getFUrlaubstageprowoche() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("zeitmodellDto.getCNr() == null || zeitmodellDto.getIUrlaubstageprowoche() == null"));
		}
		try {
			Query query = em.createNamedQuery("ZeitmodellfindByCNrMandantCNr");
			query.setParameter(1, zeitmodellDto.getCNr());
			query.setParameter(2, theClientDto.getMandant());
			// @todo getSingleResult oder getResultList ?
			Zeitmodell doppelt = (Zeitmodell) query.getSingleResult();
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_ZEITMODELL.CNR"));
		} catch (NoResultException ex) {

		}

		if (zeitmodellDto.getIMinutenabzug() == null) {
			zeitmodellDto.setIMinutenabzug(0);
		}

		if (zeitmodellDto.getBFeiertagssollAddieren() == null) {
			zeitmodellDto.setBFeiertagssollAddieren(Helper.boolean2Short(true));
		}

		if (zeitmodellDto.getBFixepauseTrotzkommtgeht() == null) {
			zeitmodellDto.setBFixepauseTrotzkommtgeht(Helper.boolean2Short(false));
		}

		if (zeitmodellDto.getBFirmenzeitmodell() == null) {
			zeitmodellDto.setBFirmenzeitmodell(Helper.boolean2Short(false));
		}

		if (zeitmodellDto.getBUnproduktivAlsPause() == null) {
			zeitmodellDto.setBUnproduktivAlsPause(Helper.boolean2Short(false));
		}

		if (zeitmodellDto.getBFeiertagAmNaechstenTag() == null) {
			zeitmodellDto.setBFeiertagAmNaechstenTag(Helper.boolean2Short(false));
		}

		if (Helper.short2boolean(zeitmodellDto.getBFirmenzeitmodell())) {
			try {
				Query query = em.createNamedQuery("ZeitmodellfindByBFirmenzeitmodellMandantCNr");
				query.setParameter(1, zeitmodellDto.getBFirmenzeitmodell());
				query.setParameter(2, theClientDto.getMandant());
				// @todo getSingleResult oder getResultList ?
				Collection c = query.getResultList();
				if (c.size() > 0) {
					ArrayList al = new ArrayList();
					al.add(((Zeitmodell) c.iterator().next()).getCNr());
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FIRMENZEITMODELL_BEREITS_VORHANDEN, al,
							new Exception("PERS_ZEITMODELL.B_FIRMENZEITMODELL"));
				}

			} catch (NoResultException ex) {

			}
		}

		// generieren von primary key
		PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
		Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_ZEITMODELL);
		zeitmodellDto.setIId(pk);
		zeitmodellDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		zeitmodellDto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));
		try {
			Zeitmodell zeitmodell = new Zeitmodell(zeitmodellDto.getIId(), theClientDto.getMandant(),
					zeitmodellDto.getCNr(), zeitmodellDto.getPersonalIIdAendern(),
					zeitmodellDto.getFUrlaubstageprowoche(), zeitmodellDto.getBDynamisch(),
					zeitmodellDto.getIMinutenabzug(), zeitmodellDto.getBFeiertagssollAddieren(),
					zeitmodellDto.getBFixepauseTrotzkommtgeht(), zeitmodellDto.getBFirmenzeitmodell(),
					zeitmodellDto.getBUnproduktivAlsPause(), zeitmodellDto.getBFeiertagAmNaechstenTag());
			em.persist(zeitmodell);
			em.flush();
			if (zeitmodellDto.getBTeilzeit() == null) {
				zeitmodellDto.setBTeilzeit(zeitmodell.getBTeilzeit());
			}
			if (zeitmodellDto.getBVersteckt() == null) {
				zeitmodellDto.setBVersteckt(zeitmodell.getBVersteckt());
			}
			setZeitmodellFromZeitmodellDto(zeitmodell, zeitmodellDto);
			if (zeitmodellDto.getZeitmodellsprDto() != null) {
				Zeitmodellspr zeitmodellspr = new Zeitmodellspr(zeitmodellDto.getIId(),
						theClientDto.getLocMandantAsString());
				em.persist(zeitmodellspr);
				em.flush();
				setZeitmodellsprFromZeitmodellsprDto(zeitmodellspr, zeitmodellDto.getZeitmodellsprDto());
			}
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
		return zeitmodellDto.getIId();
	}

	public void removeZeitmodell(ZeitmodellDto zeitmodellDto) throws EJBExceptionLP {
		myLogger.entry();
		if (zeitmodellDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitmodellDto == null"));
		}
		if (zeitmodellDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("zeitmodellDto.getIId() == null"));
		}
		try {
			// try {
			Query query = em.createNamedQuery("ZeitmodellsprfindByZeitmodellIId");
			query.setParameter(1, zeitmodellDto.getIId());
			Collection<?> allZeitmodellspr = query.getResultList();
			Iterator<?> iter = allZeitmodellspr.iterator();
			while (iter.hasNext()) {
				Zeitmodellspr artgrusprTemp = (Zeitmodellspr) iter.next();
				em.remove(artgrusprTemp);
			}
			// }
			// catch (RemoveException ex) {
			// throw new EJBExceptionLP(EJBExceptionLP.
			// FEHLER_BEIM_LOESCHEN, ex);
			// }
			Zeitmodell zeitmodell = em.find(Zeitmodell.class, zeitmodellDto.getIId());
			if (zeitmodell == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
			}
			em.remove(zeitmodell);
			em.flush();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, e);
		}
	}

	public void updateZeitmodell(ZeitmodellDto zeitmodellDto, TheClientDto theClientDto) throws EJBExceptionLP {
		if (zeitmodellDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitmodellDto == null"));
		}
		if (zeitmodellDto.getIId() == null || zeitmodellDto.getCNr() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("zeitmodellDto.getIId() == null || zeitmodellDto.getCNr() == null"));
		}
		if (zeitmodellDto.getBTeilzeit() == null || zeitmodellDto.getBVersteckt() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("zeitmodellDto.getBTeilzeit() == null || zeitmodellDto.getBVersteckt() == null"));
		}
		Integer iId = zeitmodellDto.getIId();
		Zeitmodell zeitmodell = null;
		// try {
		zeitmodell = em.find(Zeitmodell.class, iId);
		if (zeitmodell == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		// }
		// catch (FinderException ex1) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// ex1);

		// }

		try {
			Query query = em.createNamedQuery("ZeitmodellfindByCNrMandantCNr");
			query.setParameter(1, zeitmodellDto.getCNr());
			query.setParameter(2, theClientDto.getMandant());
			Integer iIdVorhanden = ((Zeitmodell) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_ZEITMODELL.C_NR"));
			}

		} catch (NoResultException ex) {
			//
		}

		if (Helper.short2boolean(zeitmodellDto.getBFirmenzeitmodell())) {

			try {
				Query query = em.createNamedQuery("ZeitmodellfindByBFirmenzeitmodellMandantCNr");
				query.setParameter(1, zeitmodellDto.getBFirmenzeitmodell());
				query.setParameter(2, theClientDto.getMandant());
				// @todo getSingleResult oder getResultList ?
				Collection c = query.getResultList();
				if (c.size() > 0) {

					Zeitmodell zm = (Zeitmodell) c.iterator().next();

					if (zm.getIId().equals(iId) == false) {

						ArrayList al = new ArrayList();
						al.add(((Zeitmodell) c.iterator().next()).getCNr());
						throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FIRMENZEITMODELL_BEREITS_VORHANDEN, al,
								new Exception("PERS_ZEITMODELL.B_FIRMENZEITMODELL"));
					}

				}

			} catch (NoResultException ex) {

			}
		}

		zeitmodell.setPersonalIIdAendern(theClientDto.getIDPersonal());
		zeitmodell.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));
		setZeitmodellFromZeitmodellDto(zeitmodell, zeitmodellDto);

		try {
			if (zeitmodellDto.getZeitmodellsprDto() != null) {
				Zeitmodellspr zeitmodellspr = em.find(Zeitmodellspr.class,
						new ZeitmodellsprPK(iId, theClientDto.getLocMandantAsString()));
				if (zeitmodellspr == null) {
					zeitmodellspr = new Zeitmodellspr(iId, theClientDto.getLocMandantAsString());
					em.persist(zeitmodellspr);
					em.flush();
				}
				setZeitmodellsprFromZeitmodellsprDto(zeitmodellspr, zeitmodellDto.getZeitmodellsprDto());
			}
		} catch (Exception e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, e);
		}
	}

	public void uebersteuereZeitmodellFuerEinenTag(Integer personalIId, Integer zeitmodellIId, java.sql.Date dDatum,
			TheClientDto theClientDto) {

		java.sql.Timestamp tDatum = Helper.cutTimestamp(new java.sql.Timestamp(dDatum.getTime()));
		java.sql.Timestamp tMorgen = Helper.cutTimestamp(new java.sql.Timestamp(dDatum.getTime() + 25 * 3600000));
		try {
			PersonalzeitmodellDto dto = getPersonalFac().personalzeitmodellFindZeitmodellZuDatum(personalIId, tDatum,
					theClientDto);
			if (dto != null && zeitmodellIId != null && dto.getZeitmodellIId().equals(zeitmodellIId)) {
				return;
			}

			PersonalzeitmodellDto dtoNeu = new PersonalzeitmodellDto();
			dtoNeu.setPersonalIId(personalIId);

			if (dto != null) {
				// Fuer heute anderes Zeitmodell eintragen, wenn heute keines
				// existiert, ansonsten updaten
				dtoNeu.setZeitmodellIId(zeitmodellIId);
				dtoNeu.setTGueltigab(tDatum);
				if (!tDatum.equals(dto.getTGueltigab())) {
					// Heute eintragen
					getPersonalFac().createPersonalzeitmodell(dtoNeu);
					// Morgen eintragen, wenn keines exitiert
					PersonalzeitmodellDto dtoExists = getPersonalFac()
							.personalzeitmodellFindByPersonalIIdTDatumOhneExc(personalIId, tMorgen);
					if (dtoExists == null) {
						dto.setTGueltigab(tMorgen);
						getPersonalFac().createPersonalzeitmodell(dto);
					}
				} else {
					dtoNeu.setIId(dto.getIId());
					getPersonalFac().updatePersonalzeitmodell(dtoNeu);
					PersonalzeitmodellDto dtoExists = getPersonalFac()
							.personalzeitmodellFindByPersonalIIdTDatumOhneExc(personalIId, tMorgen);
					if (dtoExists != null) {
						dtoExists.setZeitmodellIId(dto.getZeitmodellIId());
						getPersonalFac().updatePersonalzeitmodell(dtoExists);
					} else {
						dto.setTGueltigab(tMorgen);

						getPersonalFac().createPersonalzeitmodell(dto);

					}

				}
			} else {
				dtoNeu.setTGueltigab(tDatum);
				dtoNeu.setZeitmodellIId(zeitmodellIId);
				getPersonalFac().createPersonalzeitmodell(dtoNeu);
			}
		} catch (RemoteException ex) {
			throwEJBExceptionLPRespectOld(ex);
		}
	}

	public ZeitmodellDto zeitmodellFindByCNr(String cNr, TheClientDto theClientDto) throws EJBExceptionLP {
		try {
			Query query = em.createNamedQuery("ZeitmodellfindByCNrMandantCNr");
			query.setParameter(1, cNr);
			query.setParameter(2, theClientDto.getMandant());
			Zeitmodell zeitmodell = (Zeitmodell) query.getSingleResult();
			return assembleZeitmodellDto(zeitmodell);
		} catch (NoResultException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, e);
		}

	}

	public ZeitmodellDto zeitmodellFindByPrimaryKey(Integer iId, TheClientDto theClientDto) throws EJBExceptionLP {
		if (iId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}
		// try {
		Zeitmodell zeitmodell = em.find(Zeitmodell.class, iId);
		if (zeitmodell == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		ZeitmodellDto artgruDto = assembleZeitmodellDto(zeitmodell);
		ZeitmodellsprDto zeitmodellsprDto = null;
		// try {
		Zeitmodellspr zeitmodellspr = em.find(Zeitmodellspr.class,
				new ZeitmodellsprPK(iId, theClientDto.getLocMandantAsString()));
		if (zeitmodellspr != null) {
			zeitmodellsprDto = assembleZeitmodellsprDto(zeitmodellspr);
			// if (zeitmodellsprDto == null) {
			// nothing here
		}
		// }
		// catch (NoResultException ex) {
		// nothing here
		// }
		if (zeitmodellsprDto == null) {
			// try {
			Zeitmodellspr temp = em.find(Zeitmodellspr.class,
					new ZeitmodellsprPK(iId, theClientDto.getLocKonzernAsString()));
			if (temp != null) {
				zeitmodellsprDto = assembleZeitmodellsprDto(temp);
			}
			// }
			// catch (NoResultException ex) {
			// nothing here
			// }
		}
		artgruDto.setZeitmodellsprDto(zeitmodellsprDto);
		return artgruDto;
		// }
		// catch (Exception e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	private void setZeitmodellFromZeitmodellDto(Zeitmodell zeitmodell, ZeitmodellDto zeitmodellDto) {
		zeitmodell.setCNr(zeitmodellDto.getCNr());
		zeitmodell.setBTeilzeit(zeitmodellDto.getBTeilzeit());
		zeitmodell.setBVersteckt(zeitmodellDto.getBVersteckt());
		zeitmodell.setFUrlaubstageprowoche(zeitmodellDto.getFUrlaubstageprowoche());
		zeitmodell.setNSollstundenfix(zeitmodellDto.getNSollstundenfix());
		zeitmodell.setBDynamisch(zeitmodellDto.getBDynamisch());
		zeitmodell.setIMinutenabzug(zeitmodellDto.getIMinutenabzug());
		zeitmodell.setBFeiertagssollAddieren(zeitmodellDto.getBFeiertagssollAddieren());
		zeitmodell.setNMaximalesWochenist(zeitmodellDto.getNMaximalesWochenist());
		zeitmodell.setNMaximaleMehrzeit(zeitmodellDto.getNMaximaleMehrzeit());
		zeitmodell.setBFixepauseTrotzkommtgeht(zeitmodellDto.getBFixepauseTrotzkommtgeht());
		zeitmodell.setSchichtIId(zeitmodellDto.getSchichtIId());
		zeitmodell.setBFirmenzeitmodell(zeitmodellDto.getBFirmenzeitmodell());
		zeitmodell.setUGutschriftGeht(zeitmodellDto.getUGutschriftGeht());
		zeitmodell.setUGutschriftKommt(zeitmodellDto.getUGutschriftKommt());
		zeitmodell.setBUnproduktivAlsPause(zeitmodellDto.getBUnproduktivAlsPause());
		zeitmodell.setBFeiertagAmNaechstenTag(zeitmodellDto.getBFeiertagAmNaechstenTag());
		em.merge(zeitmodell);
		em.flush();
	}

	private ZeitmodellDto assembleZeitmodellDto(Zeitmodell zeitmodell) {
		return ZeitmodellDtoAssembler.createDto(zeitmodell);
	}

	private ZeitmodellDto[] assembleZeitmodellDtos(Collection<?> zeitmodells) {
		List<ZeitmodellDto> list = new ArrayList<ZeitmodellDto>();
		if (zeitmodells != null) {
			Iterator<?> iterator = zeitmodells.iterator();
			while (iterator.hasNext()) {
				Zeitmodell zeitmodell = (Zeitmodell) iterator.next();
				list.add(assembleZeitmodellDto(zeitmodell));
			}
		}
		ZeitmodellDto[] returnArray = new ZeitmodellDto[list.size()];
		return (ZeitmodellDto[]) list.toArray(returnArray);
	}

	private void setZeitmodellsprFromZeitmodellsprDto(Zeitmodellspr zeitmodellspr, ZeitmodellsprDto zeitmodellsprDto) {
		zeitmodellspr.setCBez(zeitmodellsprDto.getCBez());
		em.merge(zeitmodellspr);
		em.flush();
	}

	private ZeitmodellsprDto assembleZeitmodellsprDto(Zeitmodellspr zeitmodellspr) {
		return ZeitmodellsprDtoAssembler.createDto(zeitmodellspr);
	}

	private ZeitmodellsprDto[] assembleZeitmodellsprDtos(Collection<?> zeitmodellsprs) {
		List<ZeitmodellsprDto> list = new ArrayList<ZeitmodellsprDto>();
		if (zeitmodellsprs != null) {
			Iterator<?> iterator = zeitmodellsprs.iterator();
			while (iterator.hasNext()) {
				Zeitmodellspr zeitmodellspr = (Zeitmodellspr) iterator.next();
				list.add(assembleZeitmodellsprDto(zeitmodellspr));
			}
		}
		ZeitmodellsprDto[] returnArray = new ZeitmodellsprDto[list.size()];
		return (ZeitmodellsprDto[]) list.toArray(returnArray);
	}

	public Integer kopiereZeitmodelltag(Integer zeitmodelltagIId, TheClientDto theClientDto) {

		ZeitmodelltagDto zmTag = zeitmodelltagFindByPrimaryKey(zeitmodelltagIId);

		Query query = em.createNamedQuery("TagesartfindAll");
		Collection<?> clArten = query.getResultList();
		Iterator<?> itArten = clArten.iterator();
		while (itArten.hasNext()) {
			Tagesart tagesartTemp = (Tagesart) itArten.next();

			if (tagesartTemp.getIId().equals(zmTag.getTagesartIId())) {

				while (itArten.hasNext()) {

					Tagesart tagesartTempNaechster = (Tagesart) itArten.next();

					Query query2 = em.createNamedQuery("ZeitmodelltagfindByZeitmodellIIdTagesartIId");
					query2.setParameter(1, zmTag.getZeitmodellIId());
					query2.setParameter(2, tagesartTempNaechster.getIId());
					Collection c = query2.getResultList();

					if (c.size() == 0) {

						zmTag.setIId(null);
						zmTag.setTagesartIId(tagesartTempNaechster.getIId());
						Integer zmTagIIdNeu = createZeitmodelltag(zmTag, theClientDto);
						// +Pauesen

						Query queryPausen = em.createNamedQuery("ZeitmodelltagpausefindByZeitmodelltagIId");
						queryPausen.setParameter(1, zeitmodelltagIId);

						Collection<?> cl = queryPausen.getResultList();

						ZeitmodelltagpauseDto[] zeitmodelltagpauseDtos = assembleZeitmodelltagpauseDtos(cl);

						for (int i = 0; i < zeitmodelltagpauseDtos.length; i++) {

							zeitmodelltagpauseDtos[i].setIId(null);
							zeitmodelltagpauseDtos[i].setZeitmodelltagIId(zmTagIIdNeu);

							createZeitmodelltagpause(zeitmodelltagpauseDtos[i], theClientDto);
						}

						return zmTagIIdNeu;

					}

				}

			}
		}

		return null;

	}

	public Integer createZeitmodelltag(ZeitmodelltagDto zeitmodelltagDto, TheClientDto theClientDto)
			throws EJBExceptionLP {
		if (zeitmodelltagDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitmodelltagDto == null"));
		}
		if (zeitmodelltagDto.getUSollzeit() == null || zeitmodelltagDto.getZeitmodellIId() == null
				|| zeitmodelltagDto.getTagesartIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"zeitmodelltagDto.getUSollzeit() == null || zeitmodelltagDto.getZeitmodellIId() == null || zeitmodelltagDto.getTagesartIId() == null"));
		}
		if (zeitmodelltagDto.getIRundungbeginn() == null || zeitmodelltagDto.getIRundungende() == null
				|| zeitmodelltagDto.getBRundesondertaetigkeiten() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"zeitmodelltagDto.getIRundungbeginn() == null || zeitmodelltagDto.getIRundungende() == null || zeitmodelltagDto.getBRundesondertaetigkeiten()"));
		}
		try {
			Query query = em.createNamedQuery("ZeitmodelltagfindByZeitmodellIIdTagesartIId");
			query.setParameter(1, zeitmodelltagDto.getZeitmodellIId());
			query.setParameter(2, zeitmodelltagDto.getTagesartIId());
			Zeitmodelltag doppelt = (Zeitmodelltag) query.getSingleResult();
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_ZEITMODELLTAG.CNR"));
		} catch (NoResultException ex) {
			//
		}

		if (zeitmodelltagDto.getBBeginnVortag() == null) {
			zeitmodelltagDto.setBBeginnVortag(Helper.boolean2Short(false));
		}

		// generieren von primary key
		PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
		Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_ZEITMODELLTAG);
		zeitmodelltagDto.setIId(pk);
		zeitmodelltagDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		zeitmodelltagDto.setTAendern(new Timestamp(System.currentTimeMillis()));
		try {
			Zeitmodelltag zeitmodelltag = new Zeitmodelltag(zeitmodelltagDto.getIId(),
					zeitmodelltagDto.getZeitmodellIId(), zeitmodelltagDto.getTagesartIId(),
					zeitmodelltagDto.getPersonalIIdAendern(), zeitmodelltagDto.getUSollzeit(),
					zeitmodelltagDto.getIRundungbeginn(), zeitmodelltagDto.getIRundungende(),
					zeitmodelltagDto.getBRundesondertaetigkeiten(), zeitmodelltagDto.getBBeginnVortag());
			em.persist(zeitmodelltag);
			em.flush();
			setZeitmodelltagFromZeitmodelltagDto(zeitmodelltag, zeitmodelltagDto);
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
		return zeitmodelltagDto.getIId();
	}

	public void removeZeitmodelltag(ZeitmodelltagDto zeitmodelltagDto) throws EJBExceptionLP {
		myLogger.entry();
		if (zeitmodelltagDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitmodelltagDto == null"));
		}
		if (zeitmodelltagDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("zeitmodelltagDto.getIId() == null"));
		}

		// try {
		Zeitmodelltag toRemove = em.find(Zeitmodelltag.class, zeitmodelltagDto.getIId());
		if (toRemove == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		try {
			em.remove(toRemove);
			em.flush();
		} catch (EntityExistsException er) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, er);
		}
		// }
		// catch (RemoveException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEIM_LOESCHEN,
		// e);
		// }
	}

	public void updateZeitmodelltag(ZeitmodelltagDto zeitmodelltagDto, TheClientDto theClientDto)
			throws EJBExceptionLP {

		if (zeitmodelltagDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitmodelltagDto == null"));
		}
		if (zeitmodelltagDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("zeitmodelltagDto.getIId() == null"));
		}
		if (zeitmodelltagDto.getUSollzeit() == null || zeitmodelltagDto.getZeitmodellIId() == null
				|| zeitmodelltagDto.getTagesartIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"zeitmodelltagDto.getUSollzeit() == null || zeitmodelltagDto.getZeitmodellIId() == null || zeitmodelltagDto.getTagesartIId() == null"));
		}

		Integer iId = zeitmodelltagDto.getIId();
		// try {
		Zeitmodelltag zeitmodelltag = em.find(Zeitmodelltag.class, iId);
		if (zeitmodelltag == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		try {
			Query query = em.createNamedQuery("ZeitmodelltagfindByZeitmodellIIdTagesartIId");
			query.setParameter(1, zeitmodelltagDto.getZeitmodellIId());
			query.setParameter(2, zeitmodelltagDto.getTagesartIId());
			Integer iIdVorhanden = ((Zeitmodelltag) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE,
						new Exception("PERS_ZEITMODELLTAG.UK"));
			}
		} catch (NoResultException ex) {

		}

		zeitmodelltagDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		zeitmodelltagDto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));

		setZeitmodelltagFromZeitmodelltagDto(zeitmodelltag, zeitmodelltagDto);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }

	}

	public ZeitmodelltagDto zeitmodelltagFindByPrimaryKey(Integer iId) throws EJBExceptionLP {
		// try {
		Zeitmodelltag zeitmodelltag = em.find(Zeitmodelltag.class, iId);
		if (zeitmodelltag == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleZeitmodelltagDto(zeitmodelltag);
		// }
		// catch (NoResultException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
		// ex);
		// }

	}

	public UebertragBVADto uebertragBVADtoFindByPrimaryKey(Integer iId) {
		UebertragBVA uebertrag = em.find(UebertragBVA.class, iId);
		if (uebertrag == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return UebertragBVADtoAssembler.createDto(uebertrag);

	}

	public AuszahlungBVADto auszahlungBVADtoFindByPrimaryKey(Integer iId) {
		AuszahlungBVA auszahlung = em.find(AuszahlungBVA.class, iId);
		if (auszahlung == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return AuszahlungBVADtoAssembler.createDto(auszahlung);

	}

	public AuszahlungBVADto[] auszahlungBVAFindByPersonalIIdIJahrIMonat(Integer personalIId, Integer iJahr,
			Integer iMonat) {
		Calendar c = Calendar.getInstance();
		c.set(Calendar.YEAR, iJahr.intValue());
		c.set(Calendar.MONTH, iMonat.intValue());
		c.set(Calendar.DAY_OF_MONTH, 1);
		c.set(Calendar.HOUR_OF_DAY, 0);
		c.set(Calendar.MINUTE, 0);
		c.set(Calendar.SECOND, 0);
		c.set(Calendar.MILLISECOND, 0);

		Timestamp tVon = new Timestamp(c.getTime().getTime());

		c.set(Calendar.DAY_OF_MONTH, Helper.ermittleAnzahlTageEinesMonats(iJahr, iMonat));

		Timestamp tBis = new Timestamp(c.getTime().getTime());

		Query query = em.createNamedQuery("AuszahlungBVAfindByPersonalIIdTDatumVonTDatumBis");
		query.setParameter(1, personalIId);
		query.setParameter(2, tVon);
		query.setParameter(3, tBis);
		Collection<?> cl = query.getResultList();
		return AuszahlungBVADtoAssembler.createDtos(cl);
	}

	public ZeitmodelltagDto[] zeitmodelltagFindByZeitmodellIId(Integer iId) throws EJBExceptionLP {
		// try {
		Query query = em.createNamedQuery("ZeitmodelltagfindByZeitmodellIId");
		query.setParameter(1, iId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty() ) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, null);
		// }
		return assembleZeitmodelltagDtos(cl);
		// }
		// catch (NoResultException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, ex);
		// }

	}

	private void setZeitmodelltagFromZeitmodelltagDto(Zeitmodelltag zeitmodelltag, ZeitmodelltagDto zeitmodelltagDto) {
		zeitmodelltag.setZeitmodellIId(zeitmodelltagDto.getZeitmodellIId());
		zeitmodelltag.setTagesartIId(zeitmodelltagDto.getTagesartIId());
		zeitmodelltag.setUSollzeit(zeitmodelltagDto.getUSollzeit());
		zeitmodelltag.setUMindestpause(zeitmodelltagDto.getUMindestpause());
		zeitmodelltag.setUMindestpause2(zeitmodelltagDto.getUMindestpause2());
		zeitmodelltag.setUMindestpause3(zeitmodelltagDto.getUMindestpause3());
		zeitmodelltag.setIMindestpausenanzahl(zeitmodelltagDto.getIMindestpausenanzahl());
		zeitmodelltag.setIRundungbeginn(zeitmodelltagDto.getIRundungbeginn());
		zeitmodelltag.setIRundungende(zeitmodelltagDto.getIRundungende());
		zeitmodelltag.setUBeginn(zeitmodelltagDto.getUBeginn());
		zeitmodelltag.setUEnde(zeitmodelltagDto.getUEnde());
		zeitmodelltag.setUUeberstd(zeitmodelltagDto.getUUeberstd());
		zeitmodelltag.setUAutopauseab(zeitmodelltagDto.getUAutopauseab());
		zeitmodelltag.setUAutopauseab2(zeitmodelltagDto.getUAutopauseab2());
		zeitmodelltag.setUAutopauseab3(zeitmodelltagDto.getUAutopauseab3());
		zeitmodelltag.setUMehrstd(zeitmodelltagDto.getUMehrstd());
		zeitmodelltag.setBRundesondertaetigkeiten(zeitmodelltagDto.getBRundesondertaetigkeiten());
		zeitmodelltag.setUErlaubteanwesenheitszeit(zeitmodelltagDto.getUErlaubteanwesenheitszeit());
		zeitmodelltag.setPersonalIIdAendern(zeitmodelltagDto.getPersonalIIdAendern());
		zeitmodelltag.setTAendern(zeitmodelltagDto.getTAendern());
		zeitmodelltag.setUEndeAkzeptiertAb(zeitmodelltagDto.getUEndeAkzeptiertAb());
		zeitmodelltag.setUBeginnAkzeptiertBis(zeitmodelltagDto.getUBeginnAkzeptiertBis());
		zeitmodelltag.setUSchichterkennung(zeitmodelltagDto.getUSchichterkennung());
		zeitmodelltag.setBBeginnVortag(zeitmodelltagDto.getBBeginnVortag());

		em.merge(zeitmodelltag);
		em.flush();
	}

	private ZeitmodelltagDto assembleZeitmodelltagDto(Zeitmodelltag zeitmodelltag) {
		return ZeitmodelltagDtoAssembler.createDto(zeitmodelltag);
	}

	private ZeitmodelltagDto[] assembleZeitmodelltagDtos(Collection<?> zeitmodelltags) {
		List<ZeitmodelltagDto> list = new ArrayList<ZeitmodelltagDto>();
		if (zeitmodelltags != null) {
			Iterator<?> iterator = zeitmodelltags.iterator();
			while (iterator.hasNext()) {
				Zeitmodelltag zeitmodelltag = (Zeitmodelltag) iterator.next();
				list.add(assembleZeitmodelltagDto(zeitmodelltag));
			}
		}
		ZeitmodelltagDto[] returnArray = new ZeitmodelltagDto[list.size()];
		return (ZeitmodelltagDto[]) list.toArray(returnArray);
	}

	/**
	 * Hole alle Tagesarten nach Spr.
	 * 
	 * @param cNrSpracheI String
	 * @throws EJBExceptionLP
	 * @return Map
	 */
	public Map getAllSprTagesarten(String cNrSpracheI) throws EJBExceptionLP {

		Map tmArten = new LinkedHashMap<Integer, Object>();
		// try {
		Query query = em.createNamedQuery("TagesartfindAll");
		Collection<?> clArten = query.getResultList();
		Iterator<?> itArten = clArten.iterator();
		while (itArten.hasNext()) {
			Tagesart tagesartTemp = (Tagesart) itArten.next();
			Integer key = tagesartTemp.getIId();
			Object value = null;
			// try {
			Tagesartspr tagesartspr = em.find(Tagesartspr.class, new TagesartsprPK(cNrSpracheI, tagesartTemp.getIId()));
			if (tagesartspr == null || tagesartspr.getCBez() == null) {
				// fuer locale und C_NR keine Bezeichnug vorhanden ...
				value = tagesartTemp.getCNr();
			} else {
				value = tagesartspr.getCBez();
			}
			// }
			// catch (NoResultException ex1) {
			// fuer locale und C_NR keine Bezeichnug vorhanden ...
			// value = tagesartTemp.getCNr();
			// }
			tmArten.put(key, value);
		}
		// }
		// catch (NoResultException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY, ex);
		// }
		return tmArten;
	}

	/**
	 * Hole alle Tagesarten, die in einem Zeitmodell definiert sind nach Spr.
	 * 
	 * @param cNrSpracheI   String
	 * @param zeitmodellIId Zeitmodell
	 * @throws EJBExceptionLP
	 * @return Map
	 */
	public Map getAllSprTagesartenEinesZeitmodells(Integer zeitmodellIId, String cNrSpracheI) throws EJBExceptionLP {

		Map tmArten = new HashMap<Integer, Object>();
		// try {
		Query query = em.createNamedQuery("ZeitmodelltagfindByZeitmodellIId");
		query.setParameter(1, zeitmodellIId);
		Collection<?> clArten = query.getResultList();
		// if (clArten.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY, null);
		// }
		Iterator<?> itArten = clArten.iterator();
		while (itArten.hasNext()) {
			Zeitmodelltag tagesartTemp = (Zeitmodelltag) itArten.next();
			Integer key = tagesartTemp.getTagesartIId();
			Object value = null;
			// try {
			Tagesartspr tagesartspr = em.find(Tagesartspr.class, new TagesartsprPK(cNrSpracheI, tagesartTemp.getIId()));

			if (tagesartspr == null) {
				// fuer locale und C_NR keine Bezeichnu g vorhanden ...
				Tagesart tagesart = em.find(Tagesart.class, tagesartTemp.getIId());
				if (tagesart == null) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
				} else {
					value = tagesart.getCNr();
				}
			} else {
				value = tagesartspr.getCBez();
			}
			// }
			// catch (NoResultException ex1) {
			// fuer locale und C_NR keine Bezeichnu g vorhanden ...
			// value = em.find(Tagesart.class, tagesartTemp.getIId()).getCNr();
			// }
			tmArten.put(key, value);
		}
		// }
		// catch (NoResultException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY, ex);
		// }

		return tmArten;
	}

	/**
	 * Hole alle Taetigkeitarten nach Spr.
	 * 
	 * @param cNrSpracheI String
	 * @throws EJBExceptionLP
	 * @return Map
	 */
	public Map getAllSprTaetigkeitarten(String cNrSpracheI) throws EJBExceptionLP {

		myLogger.entry();

		Map tmArten = new HashMap<String, Object>();
		// try {
		Query query = em.createNamedQuery("TaetigkeitartfindAll");
		Collection<?> clArten = query.getResultList();
		// if (clArten.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY, null);
		// }
		Iterator<?> itArten = clArten.iterator();
		while (itArten.hasNext()) {
			Taetigkeitart taetigkeitartTemp = (Taetigkeitart) itArten.next();
			String key = taetigkeitartTemp.getCNr();
			Object value = null;
			// try {
			Taetigkeitartspr taetigkeitartspr = em.find(Taetigkeitartspr.class,
					new TaetigkeitartsprPK(cNrSpracheI, taetigkeitartTemp.getCNr()));
			if (taetigkeitartspr == null) {
				// fuer locale und C_NR keine Bezeichnug vorhanden ...
				value = taetigkeitartTemp.getCNr();
			} else {
				value = taetigkeitartspr.getCBez();
			}
			// }
			// catch (NoResultException ex1) {
			// fuer locale und C_NR keine Bezeichnug vorhanden ...
			// value = taetigkeitartTemp.getCNr();
			// }
			tmArten.put(key, value);
		}
		// }
		// catch (NoResultException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY, ex);
		// }

		return tmArten;
	}

	@TransactionAttribute(TransactionAttributeType.SUPPORTS)
	public Double getSummeZeitenEinesBeleges(String belegartCNr, Integer belegartIId, Integer belegartpositionIId,
			Integer personalIId, java.sql.Timestamp tVon, java.sql.Timestamp tBis, TheClientDto theClientDto)
			throws EJBExceptionLP {
		AuftragzeitenDto[] dtos = getAllZeitenEinesBeleges(belegartCNr, belegartIId, belegartpositionIId, personalIId,
				tVon, tBis, SORTIERUNG_ZEITDATEN_ARTIKEL, theClientDto);

		double zeiten = 0;
		for (int i = 0; i < dtos.length; i++) {
			if (dtos[i] != null && dtos[i].getDdDauer() != null) {
				zeiten = zeiten + dtos[i].getDdDauer().doubleValue();
			}
		}
		return new Double(zeiten);
	}

	@TransactionAttribute(TransactionAttributeType.SUPPORTS)
	public Double getSummeMaschinenZeitenEinesBeleges(Integer losIId, Integer lossollarbeitsplanIId,
			java.sql.Timestamp tZeitenBis, TheClientDto theClientDto) {
		AuftragzeitenDto[] dtos = getAllMaschinenzeitenEinesBeleges(losIId, lossollarbeitsplanIId, null, tZeitenBis,
				theClientDto);

		double zeiten = 0;
		for (int i = 0; i < dtos.length; i++) {
			if (dtos[i] != null && dtos[i].getDdDauer() != null) {
				zeiten = zeiten + dtos[i].getDdDauer().doubleValue();
			}
		}
		return new Double(zeiten);
	}

	@TransactionAttribute(TransactionAttributeType.SUPPORTS)
	public Double getSummeMaschinenZeitenEinesBeleges(Integer losIId, Integer lossollarbeitsplanIId,
			java.sql.Timestamp tZeitenVon, java.sql.Timestamp tZeitenBis, TheClientDto theClientDto) {
		AuftragzeitenDto[] dtos = getAllMaschinenzeitenEinesBeleges(losIId, lossollarbeitsplanIId, tZeitenVon,
				tZeitenBis, theClientDto);

		double zeiten = 0;
		for (int i = 0; i < dtos.length; i++) {
			if (dtos[i] != null && dtos[i].getDdDauer() != null) {
				zeiten = zeiten + dtos[i].getDdDauer().doubleValue();
			}
		}
		return new Double(zeiten);
	}

	public BigDecimal getDauerEinerTaetigkeitEinesTages(String personalnummer, String artikelnr, java.util.Date dDatum,
			TheClientDto theClientDto) {

		ArtikelDto aDto = getArtikelFac().artikelFindByCNrMandantCNrOhneExc(artikelnr, theClientDto.getMandant());
		PersonalDto personalDto = null;
		try {
			personalDto = getPersonalFac().personalFindByCPersonalnrMandantCNrOhneExc(personalnummer,
					theClientDto.getMandant());

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		BigDecimal bdDauer = BigDecimal.ZERO;

		if (aDto != null & personalDto != null) {
			// Alle Belegbuchungen mit Zulagen-Artikeln holen
			Session sessionBelegeMitZulagen = FLRSessionFactory.getFactory().openSession();

			org.hibernate.Criteria belegeMitzulagen = sessionBelegeMitZulagen.createCriteria(FLRZeitdaten.class);
			belegeMitzulagen.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalDto.getIId()));
			belegeMitzulagen.add(Expression.ge(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, Helper.cutDate(dDatum)));

			belegeMitzulagen.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT,
					Helper.addiereTageZuTimestamp(new Timestamp(Helper.cutDate(dDatum).getTime()), 1)));

			belegeMitzulagen.add(Expression.isNotNull(ZeiterfassungFac.FLR_ZEITDATEN_ARTIKEL_I_ID));
			belegeMitzulagen.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_ARTIKEL_I_ID, aDto.getIId()));

			belegeMitzulagen.addOrder(Order.asc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));

			List<?> resultListBelegeMitZulagen = belegeMitzulagen.list();

			Iterator<?> resultListIteratorBelegeMitZulagen = resultListBelegeMitZulagen.iterator();

			HashSet hsBelegeUndTag = new HashSet();

			while (resultListIteratorBelegeMitZulagen.hasNext()) {
				FLRZeitdaten belegzeit = (FLRZeitdaten) resultListIteratorBelegeMitZulagen.next();

				Calendar c = Calendar.getInstance();
				c.setTime(belegzeit.getT_zeit());

				Integer iTag = c.get(Calendar.DAY_OF_MONTH);

				String sVergl = iTag + " " + belegzeit.getC_belegartnr() + belegzeit.getI_belegartid() + " "
						+ belegzeit.getI_belegartpositionid();

				if (!hsBelegeUndTag.contains(sVergl)) {
					hsBelegeUndTag.add(sVergl);
					Timestamp tBis = Helper.addiereTageZuTimestamp(new Timestamp(Helper.cutDate(dDatum).getTime()), 1);

					AuftragzeitenDto[] azDtos = getAllZeitenEinesBeleges(belegzeit.getC_belegartnr(),
							belegzeit.getI_belegartid(), belegzeit.getI_belegartpositionid(), personalDto.getIId(),
							new Timestamp(belegzeit.getT_zeit().getTime()), Helper.cutTimestamp(tBis),
							SORTIERUNG_ZEITDATEN_ARTIKEL, false, theClientDto);

					for (int i = 0; i < azDtos.length; i++) {
						Integer artikelIId = azDtos[i].getArtikelIId();

						if (aDto.getIId().equals(artikelIId)) {
							bdDauer = bdDauer.add(new BigDecimal(azDtos[i].getDdDauer()));
						}

					}
				}
			}
		}

		return bdDauer;
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public JasperPrintLP printLohndatenexport(Integer personalIId, Integer iJahr, Integer iMonat, boolean bisMonatsende,
			java.sql.Date d_datum_bis, TheClientDto theClientDto, Integer iOption, Integer kostenstelleIIdAbteilung,
			Integer iOptionSortierung, Boolean bPlusVersteckte, boolean bNachLohnartVerdichten) {

		try {

			int iVersatz = 0;
			try {
				ParametermandantDto parameter = (ParametermandantDto) getParameterFac().getMandantparameter(
						theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
						ParameterFac.PARAMETER_PERSONALZEITDATENEXPORT_PERIODENVERSATZ);

				iVersatz = ((Integer) parameter.getCWertAsObject()).intValue();

			} catch (RemoteException ex5) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
			}

			PersonalDto[] personalDtos = null;

			if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON) {

				if (personalIId == null) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
							new Exception("personalIId == null"));
				}

				personalDtos = new PersonalDto[1];

				personalDtos[0] = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);

			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_PERSONEN) {
				personalDtos = getPersonalFac().personalFindByMandantCNr(theClientDto.getMandant(), bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_EINE_ABTEILUNG) {
				PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);
				personalDtos = getPersonalFac().personalFindAllPersonenEinerAbteilung(kostenstelleIIdAbteilung,
						theClientDto.getMandant(), bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ARBEITER) {
				personalDtos = getPersonalFac().personalFindAllArbeiterEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ANGESTELLTE) {
				personalDtos = getPersonalFac().personalFindAllAngestellteEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
			} else {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER, new Exception("OPTION NICHT VERFUEGBAR"));
			}

			int iJahrMitVersatz = iJahr;
			int iMonatMitVersatz = iMonat;
			if (iVersatz > 0) {

				Calendar c = Calendar.getInstance();
				c.set(Calendar.YEAR, iJahr);
				c.set(Calendar.MONTH, iMonat);

				c.set(Calendar.MONTH, iMonat + iVersatz);

				iJahrMitVersatz = c.get(Calendar.YEAR);
				iMonatMitVersatz = c.get(Calendar.MONTH);

			}

			ArrayList alDaten = new ArrayList();
			for (int i = 0; i < personalDtos.length; i++) {

				try {
					MonatsabrechnungDto moaDto = erstelleMonatsAbrechnung(personalDtos[i].getIId(), iJahr, iMonat,
							bisMonatsende, d_datum_bis, theClientDto, false, iOptionSortierung, null);

					HashMap parameter = moaDto.getParameter();

					// Lohnarten holen

					String sQuery = "SELECT s FROM FLRLohnartstundenfaktor s WHERE s.flrlohnart.personalart_c_nr='"
							+ personalDtos[i].getPersonalartCNr() + "' OR s.flrlohnart.personalart_c_nr IS NULL";

					SessionFactory factory = FLRSessionFactory.getFactory();
					Session session = factory.openSession();

					org.hibernate.Query inventurliste = session.createQuery(sQuery);

					List<?> resultList = inventurliste.list();

					Iterator<?> resultListIterator = resultList.iterator();

					double dExtern = 0;
					double dIntern = 0;
					data = new Object[resultList.size()][REPORT_PRODUKTIVITAETISSTATISTIK_ANZAHL_SPALTEN];

					while (resultListIterator.hasNext()) {
						FLRLohnartstundenfaktor f = (FLRLohnartstundenfaktor) resultListIterator.next();

						if (f.getFlrlohnart().getI_ausfall_wochen() != null
								&& f.getFlrlohnart().getF_mindestuestd() != null) {

							Calendar c = Calendar.getInstance();
							c.set(Calendar.YEAR, iJahr);
							c.set(Calendar.MONTH, iMonat);
							c.set(Calendar.DATE, 1);

							Timestamp tBisWA = new Timestamp(c.getTimeInMillis());

							c.add(Calendar.WEEK_OF_YEAR, -f.getFlrlohnart().getI_ausfall_wochen());

							Timestamp tVonWA = new Timestamp(c.getTimeInMillis());

							JasperPrintLP print = erstelleWochenabrechnung(personalIId, tVonWA, tBisWA, false, false,
									theClientDto);

							if (print != null && print.getMapParameters().containsKey("P_SUMME_UEBERSTUNDEN")) {
								BigDecimal bdSummeUebst = (BigDecimal) print.getMapParameters()
										.get("P_SUMME_UEBERSTUNDEN");

								if (bdSummeUebst != null
										&& bdSummeUebst.doubleValue() >= f.getFlrlohnart().getF_mindestuestd()) {
									// Dann drucken
								} else {
									// Sonst auslassen
									continue;
								}

							}

						}

						BigDecimal bdIstGesamt = new BigDecimal(0);
						BigDecimal bdSollGesamt = new BigDecimal(0);
						BigDecimal bdFtg = new BigDecimal(0);
						BigDecimal bdArzt = new BigDecimal(0);
						BigDecimal bdBehoerde = new BigDecimal(0);
						BigDecimal bdKrank = new BigDecimal(0);
						BigDecimal bdUrlaub = new BigDecimal(0);
						BigDecimal bdSonstBez = new BigDecimal(0);
						BigDecimal bdSonstNBez = new BigDecimal(0);

						BigDecimal bdUest50F = new BigDecimal(0);
						BigDecimal bdUest50P = new BigDecimal(0);
						BigDecimal bdUest100F = new BigDecimal(0);
						BigDecimal bdUest100P = new BigDecimal(0);
						BigDecimal bdMehrstd = new BigDecimal(0);

						BigDecimal bdGutstunden = new BigDecimal(0);

						BigDecimal bdZeitgutschriftKommt = new BigDecimal(0);
						BigDecimal bdZeitgutschriftGeht = new BigDecimal(0);

						BigDecimal bdBVA_Gz = new BigDecimal(0);
						BigDecimal bdBVA_Uest50Gz = new BigDecimal(0);
						BigDecimal bdBVA_Uest50 = new BigDecimal(0);
						BigDecimal bdBVA_Uest100 = new BigDecimal(0);

						BigDecimal bdBVA_Uest50GzZuschlag = new BigDecimal(0);
						BigDecimal bdBVA_Uest50Zuschlag = new BigDecimal(0);
						BigDecimal bdBVA_Uest100Zuschlag = new BigDecimal(0);

						BigDecimal bdSchichtstunden = new BigDecimal(0);

						BigDecimal bdSonstigeSondertaetigkeit = new BigDecimal(0);

						StundenabrechnungDto[] stundeabrechnungDtos = getPersonalFac()
								.stundenabrechnungFindByPersonalIIdIJahrIMonat(personalIId, iJahr, iMonat);

						for (int j = 0; j < stundeabrechnungDtos.length; j++) {
							bdGutstunden = bdGutstunden.add(stundeabrechnungDtos[j].getNGutstunden());
						}

						Date dEintrittsdatum = new Date();

						Object[][] datenMoa = moaDto.getData();
						for (int j = 0; j < datenMoa.length; j++) {
							Object[] zeileMoa = datenMoa[j];

							String tagesart = (String) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_TAGESART];

							Integer zeitmodellIId = (Integer) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_ZEITMODELL_I_ID];

							Timestamp tDatum = (Timestamp) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_DATUM];

							BigDecimal bdSollzeit = BigDecimal.ZERO;
							if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SOLL] != null) {
								bdSollzeit = (BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SOLL];
							}

							if (f.getZeitmodell_i_id() != null && f.getZeitmodell_i_id() == 36) {
								int z = 0;
							}

							if (f.getFlrtagesart() == null || f.getFlrtagesart().getC_nr().equals(tagesart)) {

								if (f.getZeitmodell_i_id() == null || f.getZeitmodell_i_id().equals(zeitmodellIId)) {

									bdIstGesamt = bdIstGesamt.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_IST]);
									bdSollGesamt = bdSollGesamt.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SOLL]);
									bdFtg = bdFtg.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_FEIERTAG]);
									bdArzt = bdArzt.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_ARZT]);
									bdBehoerde = bdBehoerde.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BEHOERDE]);
									bdKrank = bdKrank.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_KRANK]);
									bdUrlaub = bdUrlaub.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_URLAUB]);

									bdUest50P = bdUest50P.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_UESTD50TAGEWEISE]);
									bdUest50F = bdUest50F.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_UESTD50TAGESWEISEFREI]);
									bdUest100F = bdUest100F.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_UESTD100FREI]);
									bdUest100P = bdUest100P.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_UESTD100]);
									bdMehrstd = bdMehrstd.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_MEHRZEIT]);

									bdSonstBez = bdSonstBez.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SONSTIGE_BEZAHLTETAETIGKEITEN]);
									bdSonstNBez = bdSonstNBez.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SONSTIGE_UNBEZAHLTETAETIGKEITEN]);

									bdZeitgutschriftKommt = bdZeitgutschriftKommt.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_KOMMT]);
									bdZeitgutschriftGeht = bdZeitgutschriftGeht.add(
											(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_GEHT]);

									if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_GLEITZEIT] != null) {
										bdBVA_Gz = bdBVA_Gz.add(
												(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_GLEITZEIT]);
									}
									if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UEST50_UEBER_GLEITZEIT] != null) {
										bdBVA_Uest50Gz = bdBVA_Uest50Gz.add(
												(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UEST50_UEBER_GLEITZEIT]);
									}
									if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESTD50] != null) {
										bdBVA_Uest50 = bdBVA_Uest50.add(
												(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESTD50]);
									}
									if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESDT100] != null) {
										bdBVA_Uest100 = bdBVA_Uest100.add(
												(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESDT100]);
									}

									if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UEST50_UEBER_GLEITZEIT_ZUSCHLAG] != null) {
										bdBVA_Uest50GzZuschlag = bdBVA_Uest50GzZuschlag.add(
												(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UEST50_UEBER_GLEITZEIT_ZUSCHLAG]);
									}
									if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESTD50_ZUSCHLAG] != null) {
										bdBVA_Uest50Zuschlag = bdBVA_Uest50Zuschlag.add(
												(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESTD50_ZUSCHLAG]);
									}
									if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESDT100_ZUSCHLAG] != null) {
										bdBVA_Uest100Zuschlag = bdBVA_Uest100Zuschlag.add(
												(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESDT100_ZUSCHLAG]);
									}
									if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SCHICHTZEITEN_FUER_EXPORT] != null) {

										HashMap hmSchichtstunden = (HashMap) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SCHICHTZEITEN_FUER_EXPORT];

										Iterator it = hmSchichtstunden.keySet().iterator();
										BigDecimal bdDauerGesamt = BigDecimal.ZERO;
										while (it.hasNext()) {
											Integer schichtzeitIId = (Integer) it.next();

											if (f.getSchichtzeit_i_id() == null
													|| f.getSchichtzeit_i_id().equals(schichtzeitIId)) {
												BigDecimal bdDauer = (BigDecimal) hmSchichtstunden.get(schichtzeitIId);
												bdDauerGesamt = bdDauerGesamt.add(bdDauer);
											}
										}

										bdSchichtstunden = bdSchichtstunden.add(bdDauerGesamt);
									}

									if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SONSTIGE_SONDERTAETIGKEITEN_FUER_EXPORT] != null) {

										HashMap hmSonstigeSondertaetigkeiten = (HashMap) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SONSTIGE_SONDERTAETIGKEITEN_FUER_EXPORT];

										Iterator it = hmSonstigeSondertaetigkeiten.keySet().iterator();
										BigDecimal bdDauerGesamt = BigDecimal.ZERO;
										while (it.hasNext()) {
											Integer taetigkeitIId = (Integer) it.next();

											if (f.getTaetigkeit_i_id() != null) {
												int x = 0;
											}

											if (f.getTaetigkeit_i_id() == null
													|| f.getTaetigkeit_i_id().equals(taetigkeitIId)) {
												BigDecimal bdDauer = (BigDecimal) hmSonstigeSondertaetigkeiten
														.get(taetigkeitIId);
												bdDauerGesamt = bdDauerGesamt.add(bdDauer);
											}
										}

										bdSonstigeSondertaetigkeit = bdSonstigeSondertaetigkeit.add(bdDauerGesamt);
									}

								}
							}

						}

						/*
						 * boolean bBetriebsvereinbarungA = false; if (personalDtos[i].getKollektivIId()
						 * != null) { if (getPersonalFac() .kollektivFindByPrimaryKey(
						 * personalDtos[i].getKollektivIId()) .getCAbrechungsart() .equals(PersonalFac.
						 * KOLLEKTIV_ABRECHNUNGSART_BETRIEBSVEREINBARUNG_A)) { bBetriebsvereinbarungA =
						 * true; } }
						 */

						BigDecimal bdNormalstunden = null;
						/*
						 * if (bBetriebsvereinbarungA) { bdNormalstunden = BigDecimal.ZERO; bdSollGesamt
						 * = BigDecimal.ZERO; } else {
						 */

						bdNormalstunden = bdIstGesamt;
						bdNormalstunden = bdNormalstunden.subtract(bdFtg).subtract(bdUest50P).subtract(bdUest50F)
								.subtract(bdUest100F).subtract(bdUest100P).subtract(bdMehrstd);

						// }

						BigDecimal stunden = new BigDecimal(0);
						BigDecimal faktor = new BigDecimal(f.getF_faktor().doubleValue());

						if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_SOLL)) {
							stunden = bdSollGesamt;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_GST)) {
							stunden = bdIstGesamt;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_FTG)) {
							stunden = bdFtg;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_GUT)) {
							stunden = bdGutstunden;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_MST)) {
							stunden = bdMehrstd;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_NST)) {
							stunden = bdNormalstunden;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_U100F)) {
							stunden = bdUest100F;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_U100P)) {
							stunden = bdUest100P;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_U50F)) {
							stunden = bdUest50F;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_U50P)) {
							stunden = bdUest50P;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_ZG_GEHT)) {
							stunden = bdZeitgutschriftGeht;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_ZG_KOMMT)) {
							stunden = bdZeitgutschriftKommt;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_URLAUB)) {
							stunden = bdUrlaub;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_KRANK)) {
							stunden = bdKrank;

						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_ARZT)) {
							stunden = bdArzt;

						} else if (f.getFlrlohnstundenart().getC_nr()
								.equals(PersonalFac.LOHNSTUNDENART_SONSTIGE_SONDER)) {
							stunden = bdSonstigeSondertaetigkeit;

						}

						else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_BVA_GZ)) {
							stunden = bdBVA_Gz;
						} else if (f.getFlrlohnstundenart().getC_nr()
								.equals(PersonalFac.LOHNSTUNDENART_SCHICHTSTUNDEN)) {
							stunden = bdSchichtstunden;
						} else if (f.getFlrlohnstundenart().getC_nr()
								.equals(PersonalFac.LOHNSTUNDENART_BVA_UESTD50_GZ)) {
							stunden = bdBVA_Uest50Gz;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_BVA_UESTD50)) {
							stunden = bdBVA_Uest50;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_BVA_UESTD100)) {
							stunden = bdBVA_Uest100;
						} else if (f.getFlrlohnstundenart().getC_nr()
								.equals(PersonalFac.LOHNSTUNDENART_BVA_UESTD50_GZ_ZUSCHLAG)) {
							stunden = bdBVA_Uest50GzZuschlag;
						} else if (f.getFlrlohnstundenart().getC_nr()
								.equals(PersonalFac.LOHNSTUNDENART_BVA_UESTD50_ZUSCHLAG)) {
							stunden = bdBVA_Uest50Zuschlag;
						} else if (f.getFlrlohnstundenart().getC_nr()
								.equals(PersonalFac.LOHNSTUNDENART_BVA_UESTD100_ZUSCHLAG)) {
							stunden = bdBVA_Uest100Zuschlag;
						} else if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_URLAUB_TAGE)) {
							if (parameter.containsKey("P_VERFUEGBARERURLAUBTAGE")) {
								stunden = (BigDecimal) parameter.get("P_VERFUEGBARERURLAUBTAGE");
							}
						}

						LPDatenSubreport lpDatenSubreport = null;
						ArrayList<Timestamp[]> alDatenSubreport = new ArrayList<Timestamp[]>();

						if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_URLAUB)
								|| f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_KRANK)
								|| f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_KINDKRANK)) {

							Timestamp tVon = null;
							Timestamp tBis = null;

							for (int j = 0; j < datenMoa.length; j++) {
								Object[] zeileMoa = datenMoa[j];

								String tagesart = (String) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_TAGESART];

								Timestamp tDatum = (Timestamp) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_DATUM];

								BigDecimal bdSollzeit = BigDecimal.ZERO;
								if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SOLL] != null) {
									bdSollzeit = (BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SOLL];
								}

								Integer taetigkeitIId = null;

								if (f.getFlrlohnstundenart().getC_nr().equals(PersonalFac.LOHNSTUNDENART_URLAUB)) {
									taetigkeitIId = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_URLAUB,
											theClientDto).getIId();
								} else if (f.getFlrlohnstundenart().getC_nr()
										.equals(PersonalFac.LOHNSTUNDENART_KRANK)) {
									taetigkeitIId = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KRANK, theClientDto)
											.getIId();
								} else if (f.getFlrlohnstundenart().getC_nr()
										.equals(PersonalFac.LOHNSTUNDENART_KINDKRANK)) {
									taetigkeitIId = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KINDKRANK,
											theClientDto).getIId();
								}

								SonderzeitenDto[] szDtos = sonderzeitenFindByPersonalIIdDDatumBTag(personalIId,
										Helper.cutTimestamp(tDatum), Helper.boolean2Short(true));

								SonderzeitenDto szDto = null;
								if (szDtos.length > 0) {
									szDto = szDtos[0];
								}

								// Reset passiert, wenn SonderzeitenDto NULL und Soll >0 oder
								// SonderzeitenDto.taetigkeitIId<>taetigkeitIId oder wir sind am letzten des
								// Monats angelangt

								if (szDto != null && szDto.getTaetigkeitIId().equals(taetigkeitIId) && tVon == null) {
									tVon = tDatum;
								}

								if ((bdSollzeit.doubleValue() > 0 && szDto == null)
										|| (szDto != null && !szDto.getTaetigkeitIId().equals(taetigkeitIId))
										|| j == datenMoa.length - 1) {
									// subreport add von / bis

									if (tVon != null) {

										if (j == datenMoa.length - 1) {
											tBis = tDatum;
										}

										if (tBis == null) {
											tBis = tDatum;
										}

										Timestamp[] o = new Timestamp[2];
										o[0] = tVon;
										o[1] = tBis;
										alDatenSubreport.add(o);

										tVon = null;
										tBis = null;
									}
								}

								if (szDto != null && szDto.getTaetigkeitIId().equals(taetigkeitIId) && tVon != null) {
									tBis = tDatum;
								}

							}

							String[] fieldnames = new String[] { "F_VON", "F_BIS" };

							Object[][] dataSub = new Object[alDatenSubreport.size()][fieldnames.length];
							dataSub = (Object[][]) alDatenSubreport.toArray(dataSub);

							lpDatenSubreport = new LPDatenSubreport(dataSub, fieldnames);

						}

						stunden = stunden.multiply(faktor);
						Object[] zeile = new Object[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_ANZAHL_SPALTEN];

						zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_PERSONALNUMMER] = personalDtos[i]
								.getCPersonalnr();
						zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_JAHR] = iJahrMitVersatz + "";
						zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_MONAT] = new DateFormatSymbols(
								theClientDto.getLocUi()).getMonths()[iMonatMitVersatz];
						zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_LOHNART] = f.getFlrlohnart().getC_bez();
						zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_LOHNART_NR] = f.getFlrlohnart().getI_lohnart();
						zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_LOHNSTUNDENART] = f.getFlrlohnstundenart()
								.getC_bez();
						if (f.getZeitmodell_i_id() != null) {
							zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_ZEITMODELL] = zeitmodellFindByPrimaryKey(
									f.getZeitmodell_i_id(), theClientDto).getBezeichnung();
						}

						if (f.getSchichtzeit_i_id() != null) {

							SchichtzeitDto szDto = getSchichtFac().schichtzeitFindByPrimaryKey(f.getSchichtzeit_i_id());
							SchichtDto schichtDto = getSchichtFac().schichtFindByPrimaryKey(szDto.getSchichtIId());

							zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_SCHICHTZEIT] = schichtDto.getCBez() + " "
									+ szDto.getuBeginn() + "-" + szDto.getuEnde();
						}

						if (f.getTaetigkeit_i_id() != null) {

							TaetigkeitDto taetigkeitDto = getZeiterfassungFac()
									.taetigkeitFindByPrimaryKey(f.getTaetigkeit_i_id(), theClientDto);

							zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_TAETIGKEIT] = taetigkeitDto.getCNr();
						}

						zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_STUNDEN] = stunden;

						zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_AUSFALLSPRINZIP_UESTD] = f.getFlrlohnart()
								.getF_mindestuestd();
						zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_AUSFALLSPRINZIP_WOCHEN] = f.getFlrlohnart()
								.getI_ausfall_wochen();

						PartnerDto pDto = getPartnerFac().partnerFindByPrimaryKey(personalDtos[i].getPartnerIId(),
								theClientDto);

						zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_VORNAME] = pDto.getCName2vornamefirmazeile2();
						zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_NACHNAME] = pDto.getCName1nachnamefirmazeile1();

						zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_SUBREPORT_SONDERZEITEN_VON_BIS] = lpDatenSubreport;

						zeile[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_ARRAYLIST_VON_BIS] = alDatenSubreport;

						// Verdichten

						if (bNachLohnartVerdichten) {

							if (stunden.doubleValue() == 0) {
								continue;
							}

							boolean bGefunden = false;
							for (int j = 0; j < alDaten.size(); j++) {

								Object[] zeileVorhanden = (Object[]) alDaten.get(j);

								if (zeileVorhanden[REPORT_LOHNDATENEXPORT_LOHNART_NR]
										.equals(f.getFlrlohnart().getI_lohnart())) {

									BigDecimal bdStundenVorhanden = (BigDecimal) zeileVorhanden[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_STUNDEN];
									bdStundenVorhanden = bdStundenVorhanden.add(stunden);
									zeileVorhanden[ZeiterfassungFac.REPORT_LOHNDATENEXPORT_STUNDEN] = bdStundenVorhanden;

									alDaten.set(j, zeileVorhanden);
									bGefunden = true;
									break;
								}

							}
							if (bGefunden == false) {
								alDaten.add(zeile);
							}

						} else {
							alDaten.add(zeile);
						}

					}

				} catch (EJBExceptionLP ex1) {
					if (ex1.getCode() == EJBExceptionLP.FEHLER_PERSONAL_FEHLER_BEI_EINTRITTSDATUM && iOption
							.intValue() != ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON) {
						// NICHTS - PERSON WIRD AUSGELASSEN

					} else {
						throw ex1;
					}

				}

			}

			HashMap<String, Object> parameter = new HashMap<String, Object>();

			data = new Object[alDaten.size()][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_ANZAHL_SPALTEN];
			data = (Object[][]) alDaten.toArray(data);

			index = -1;
			sAktuellerReport = ZeiterfassungFac.REPORT_LOHNDATENEXPORT;

			initJRDS(parameter, ZeiterfassungFac.REPORT_MODUL, ZeiterfassungFac.REPORT_LOHNDATENEXPORT,
					theClientDto.getMandant(), theClientDto.getLocUi(), theClientDto);
			return getReportPrint();

		} catch (RemoteException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		}

	}

	private Object[] befuelleProjektausauftragFuerProduktivitaetsstatistik(Integer auftragIId, Object[] oZeile,
			TheClientDto theClientDto) {

		if (auftragIId != null) {

			AuftragDto aDto = getAuftragFac().auftragFindByPrimaryKey(auftragIId);

			Integer projektIId = aDto.getProjektIId();

			try {
				if (projektIId == null) {
					// aus Angebot holen
					if (aDto.getAngebotIId() != null) {
						AngebotDto agDto = getAngebotFac().angebotFindByPrimaryKey(aDto.getAngebotIId(), theClientDto);
						projektIId = agDto.getProjektIId();

					}

				}

				if (projektIId != null) {
					ProjektDto projektDto = null;

					projektDto = getProjektFac().projektFindByPrimaryKey(projektIId);
					oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_PROJEKTKLAMMER] = projektDto.getCNr();
					oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKTKATEGORIE_PROJEKTKLAMMER] = projektDto
							.getKategorieCNr();
					oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_BEREICH_PROJEKTKLAMMER] = getProjektServiceFac()
							.bereichFindByPrimaryKey(projektDto.getBereichIId()).getCBez();
					oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_I_ID_PROJEKTKLAMMER] = projektDto.getIId();

				}

			} catch (RemoteException ex3) {
				throwEJBExceptionLPRespectOld(ex3);
			}

		}
		return oZeile;
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public JasperPrintLP printProduktivitaetsstatistik(Integer personalIId, java.sql.Timestamp tVon,
			java.sql.Timestamp tBis, Integer iOption, Integer kostenstelleIIdAbteilung, Boolean bPlusVersteckte,
			boolean bNurAnwesende, boolean bVerdichtet, boolean bMonatsbetrachtung, boolean projekteZusammengefasst,
			TheClientDto theClientDto) {
		boolean bProjektklammer = false;
		if (getMandantFac().darfAnwenderAufZusatzfunktionZugreifen(MandantFac.ZUSATZFUNKTION_PROJEKTKLAMMER,
				theClientDto)) {
			bProjektklammer = true;
		}

		if (tVon == null || tBis == null || personalIId == iOption) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("tVon == null || tBis == null || personalIId == iOption"));
		}
		tVon = Helper.cutTimestamp(tVon);
		tBis = Helper.cutTimestamp(tBis);

		if (tVon.after(tBis)) {
			java.sql.Timestamp h = tVon;
			tVon = tBis;
			tBis = h;
		}

		JasperPrintLP print = null;
		PersonalDto[] personalDtos = null;
		MandantDto mandantDto = null;
		try {
			mandantDto = getMandantFac().mandantFindByPrimaryKey(theClientDto.getMandant(), theClientDto);
		} catch (RemoteException ex2) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex2);
		}
		try {
			if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON) {

				if (personalIId == null) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
							new Exception("personalIId == null"));
				}

				personalDtos = new PersonalDto[1];

				personalDtos[0] = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);

			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_PERSONEN) {
				personalDtos = getPersonalFac().personalFindByMandantCNr(theClientDto.getMandant(), bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_EINE_ABTEILUNG) {
				PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);
				personalDtos = getPersonalFac().personalFindAllPersonenEinerAbteilung(kostenstelleIIdAbteilung,
						theClientDto.getMandant(), bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ARBEITER) {
				personalDtos = getPersonalFac().personalFindAllArbeiterEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ANGESTELLTE) {
				personalDtos = getPersonalFac().personalFindAllAngestellteEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
			} else {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER, new Exception("OPTION NICHT VERFUEGBAR"));
			}

			if (bNurAnwesende) {
				personalDtos = getZeiterfassungFac().entferneNichtAnwesendePersonen(tVon, tBis, personalDtos,
						theClientDto);
			}

		} catch (RemoteException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		}

		HashMap parameter = new HashMap<Object, Object>();
		parameter.put("P_VERDICHTET", new Boolean(bVerdichtet));
		parameter.put("P_MONATSBETRACHTUNG", new Boolean(bMonatsbetrachtung));
		parameter.put("P_PROJEKTE_ZUSAMMENGEFASST", new Boolean(projekteZusammengefasst));

		parameter.put("P_VON", tVon);
		parameter.put("P_NUR_ANWESENDE", new Boolean(bNurAnwesende));

		// SP9626
		if (kostenstelleIIdAbteilung != null) {
			parameter.put("P_KOSTENSTELLE_ABTEILUNG", getSystemFac()
					.kostenstelleFindByPrimaryKey(kostenstelleIIdAbteilung).formatKostenstellenbezeichnung());
		}

		parameter.put("P_BIS", Helper.addiereTageZuTimestamp(new java.sql.Timestamp(tBis.getTime()), -1));
		try {
			ParametermandantDto parameterVonBis = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_VON_BIS_ERFASSUNG);
			parameter.put("P_VON_BIS_ERFASSUNG", ((Boolean) parameterVonBis.getCWertAsObject()));
		} catch (RemoteException e1) {
			throwEJBExceptionLPRespectOld(e1);
		}

		ArrayList alDatenGesamt = new ArrayList();

		double dExternGesamt = 0;

		double dExternVerrechenbarGesamt = 0;
		double dExternNichtverrechenbarGesamt = 0;

		double dInternGesamt = 0;
		double dAnwesenheitszeitGesamt = 0;

		for (int i = 0; i < personalDtos.length; i++) {
			ArrayList alDaten = new ArrayList();
			PersonalDto personalDto = personalDtos[i];

			personalDto
					.setPartnerDto(getPartnerFac().partnerFindByPrimaryKey(personalDto.getPartnerIId(), theClientDto));
			if (personalDto.getKostenstelleIIdAbteilung() != null) {
				personalDto.setKostenstelleDto_Abteilung(
						getSystemFac().kostenstelleFindByPrimaryKey(personalDto.getKostenstelleIIdAbteilung()));
			}
			if (personalDto.getKostenstelleIIdStamm() != null) {
				personalDto.setKostenstelleDto_Stamm(
						getSystemFac().kostenstelleFindByPrimaryKey(personalDto.getKostenstelleIIdStamm()));
			}

			// Anwesenheitszeit VON BIS berechnen
			double dIstGesamt = 0;
			Double dGesamt = berechneArbeitszeitImZeitraum(personalDto.getIId(), new java.sql.Date(tVon.getTime()),
					new java.sql.Date(tBis.getTime()), false, theClientDto);

			if (dGesamt != null) {
				dIstGesamt = dGesamt.doubleValue();
			}

			dAnwesenheitszeitGesamt = dAnwesenheitszeitGesamt + dIstGesamt;

			String sQuery = "select distinct zeitdaten.c_belegartnr,zeitdaten.i_belegartid";

			if (bVerdichtet == false) {
				sQuery += ",zeitdaten.i_belegartpositionid";
			}

			// PJ 16557

			// Hole Zeitdaten eines Tages
			Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
			query.setParameter(1, personalIId);
			query.setParameter(2, new java.sql.Timestamp(tVon.getTime()));
			query.setParameter(3, Helper.addiereTageZuTimestamp(tVon, 1));
			Collection<?> cl = query.getResultList();
			ZeitdatenDto[] zeitdatenDtos = assembleZeitdatenDtosOhneBelegzeiten(cl);

			Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();

			// Daten einen Tag vorher wg. Mitternachtssprung holen
			java.sql.Date dVon = new java.sql.Date(tVon.getTime() - (3600000 * 24));
			if (zeitdatenDtos.length > 0 && zeitdatenDtos[0].getTaetigkeitIId() != null
					&& zeitdatenDtos[0].getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {
				// Ausser die erste Taetigkeit ist ein Kommt, dann nicht
				dVon = new java.sql.Date(tVon.getTime());
			}

			sQuery += " from FLRZeitdaten zeitdaten WHERE zeitdaten.flrpersonal.i_id=" + personalDto.getIId()
					+ "AND zeitdaten.c_belegartnr is not null AND zeitdaten.t_zeit>='"
					+ Helper.formatDateWithSlashes(dVon) + "' AND zeitdaten.t_zeit<'"
					+ Helper.formatDateWithSlashes(new java.sql.Date(tBis.getTime())) + "'";

			SessionFactory factory = FLRSessionFactory.getFactory();
			Session session = factory.openSession();

			org.hibernate.Query inventurliste = session.createQuery(sQuery);

			List<?> resultList = inventurliste.list();

			Iterator<?> resultListIterator = resultList.iterator();

			double dExtern = 0;
			double dExternVerrechenbar = 0;
			double dExternNichtVerrechenbar = 0;

			double dIntern = 0;
			data = new Object[resultList.size()][REPORT_PRODUKTIVITAETISSTATISTIK_ANZAHL_SPALTEN];

			// PJ18906
			if (resultList.size() == 0 && projekteZusammengefasst == false) {
				// Wenn keine Zeiten auf Auftraege, dann trotzdem in Statistik
				// anzeigen
				Object[] oZeile = new Object[REPORT_PRODUKTIVITAETISSTATISTIK_ANZAHL_SPALTEN];
				oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSONAL_ID] = personalDto.getIId();
				oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_TELEFONZEIT] = Boolean.FALSE;
				alDaten.add(oZeile);
			}

			while (resultListIterator.hasNext()) {

				Object[] o = (Object[]) resultListIterator.next();

				Object[] oZeile = new Object[REPORT_PRODUKTIVITAETISSTATISTIK_ANZAHL_SPALTEN];

				oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_TELEFONZEIT] = Boolean.FALSE;

				try {

					String sBezeichnung = "";
					com.lp.server.partner.service.PartnerDto partnerDto = null;

					boolean bVerrechenbar = false;
					if (((String) o[0]).equals(LocaleFac.BELEGART_AUFTRAG)) {
						AuftragDto auftragDto = getAuftragFac().auftragFindByPrimaryKey((Integer) o[1]);
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG] = auftragDto.getCNr();
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG_BESTELLNUMMER] = auftragDto.getCBestellnummer();

						if (auftragDto.getKostIId() != null) {

							KostenstelleDto kstDto = getSystemFac()
									.kostenstelleFindByPrimaryKey(auftragDto.getKostIId());
							oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG_KOSTENSTELLE] = kstDto.getCNr();
							oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG_KOSTENSTELLE_BEZEICHNUNG] = kstDto
									.getCBez();
						}

						sBezeichnung = auftragDto.getCBezProjektbezeichnung();
						KundeDto kundeDto = getKundeFac()
								.kundeFindByPrimaryKeyOhneExc(auftragDto.getKundeIIdAuftragsadresse(), theClientDto);
						if (kundeDto != null) {
							partnerDto = kundeDto.getPartnerDto();
						}

						if (bProjektklammer) {
							befuelleProjektausauftragFuerProduktivitaetsstatistik(auftragDto.getIId(), oZeile,
									theClientDto);
						}

						VerrechenbarDto verrDto = getAuftragServiceFac()
								.verrechenbarFindByPrimaryKey(auftragDto.getVerrechenbarIId());
						if (Helper.short2boolean(verrDto.getBVerrechenbar())) {
							bVerrechenbar = true;
						}

					} else if (((String) o[0]).equals(LocaleFac.BELEGART_LOS)) {
						com.lp.server.fertigung.service.LosDto losDto = getFertigungFac()
								.losFindByPrimaryKey((Integer) o[1]);
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_LOS] = losDto.getCNr();
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_FERTIUNGSGRUPPE] = getStuecklisteFac()
								.fertigungsgruppeFindByPrimaryKey(losDto.getFertigungsgruppeIId()).getCBez();
						sBezeichnung = losDto.getCProjekt();

						// PJ19946
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_KOSTENSTELLE] = getSystemFac()
								.kostenstelleFindByPrimaryKey(losDto.getKostenstelleIId())
								.formatKostenstellenbezeichnung();

						Session sessionLosklasse = factory.openSession();
						String queryLosklasse = "FROM FLRLoslosklasse l where l.los_i_id=" + losDto.getIId();

						org.hibernate.Query loslosklasse = sessionLosklasse.createQuery(queryLosklasse);

						List resultListLosklasse = loslosklasse.list();

						Iterator resultListIteratorLosklasse = resultListLosklasse.iterator();

						String losklassen = "";
						while (resultListIteratorLosklasse.hasNext()) {
							com.lp.server.fertigung.fastlanereader.generated.FLRLoslosklasse lk = (com.lp.server.fertigung.fastlanereader.generated.FLRLoslosklasse) resultListIteratorLosklasse
									.next();

							losklassen += lk.getFlrlosklasse().getC_nr() + ",";

						}

						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_LOSKLASSEN] = losklassen;

						sessionLosklasse.close();

						if (losDto.getAuftragIId() != null || losDto.getKundeIId() != null) {

							KundeDto kundeDto = null;
							if (losDto.getAuftragIId() != null) {
								AuftragDto auftragDto = getAuftragFac().auftragFindByPrimaryKey(losDto.getAuftragIId());
								oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG] = auftragDto.getCNr();
								kundeDto = getKundeFac().kundeFindByPrimaryKeyOhneExc(
										auftragDto.getKundeIIdAuftragsadresse(), theClientDto);

								if (bProjektklammer) {
									befuelleProjektausauftragFuerProduktivitaetsstatistik(auftragDto.getIId(), oZeile,
											theClientDto);
								}

								if (auftragDto.getKostIId() != null) {

									KostenstelleDto kstDto = getSystemFac()
											.kostenstelleFindByPrimaryKey(auftragDto.getKostIId());
									oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG_KOSTENSTELLE] = kstDto.getCNr();
									oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG_KOSTENSTELLE_BEZEICHNUNG] = kstDto
											.getCBez();
								}

								VerrechenbarDto verrDto = getAuftragServiceFac()
										.verrechenbarFindByPrimaryKey(auftragDto.getVerrechenbarIId());
								if (Helper.short2boolean(verrDto.getBVerrechenbar())) {
									bVerrechenbar = true;
								}

							} else if (losDto.getKundeIId() != null) {
								kundeDto = getKundeFac().kundeFindByPrimaryKeyOhneExc(losDto.getKundeIId(),
										theClientDto);
							}
							if (kundeDto != null) {
								partnerDto = kundeDto.getPartnerDto();
							}
						}

						if (losDto.getStuecklisteIId() != null) {
							ArtikelDto artikelDto = getStuecklisteFac()
									.stuecklisteFindByPrimaryKey(losDto.getStuecklisteIId(), theClientDto)
									.getArtikelDto();
							oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_STKLNR] = artikelDto.getCNr();
							oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_STKLBEZ] = artikelDto.formatBezeichnung();
						}
					} else if (((String) o[0]).equals(LocaleFac.BELEGART_PROJEKT)) {
						ProjektDto projektDto = null;
						try {
							projektDto = getProjektFac().projektFindByPrimaryKey((Integer) o[1]);
						} catch (EJBExceptionLP ex3) {
							throw new EJBExceptionLP(ex3);
						}
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT] = projektDto.getCNr();

						if (bProjektklammer) {

							// PJ18422
							oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_PROJEKTKLAMMER] = projektDto.getCNr();
							oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_I_ID_PROJEKTKLAMMER] = projektDto.getIId();
							oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKTKATEGORIE_PROJEKTKLAMMER] = projektDto
									.getKategorieCNr();
							oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_BEREICH_PROJEKTKLAMMER] = getProjektServiceFac()
									.bereichFindByPrimaryKey(projektDto.getBereichIId()).getCBez();
						}

						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_I_ID] = projektDto.getIId();
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_BEREICH] = getProjektServiceFac()
								.bereichFindByPrimaryKey(projektDto.getBereichIId()).getCBez();

						sBezeichnung = projektDto.getCTitel();
						partnerDto = getPartnerFac().partnerFindByPrimaryKey(projektDto.getPartnerIId(), theClientDto);

						if (projektDto.getIVerrechenbar().equals(ProjektServiceFac.PROJEKT_VERRECHENBAR_VERRECHENBAR)) {
							bVerrechenbar = true;
						}

					} else if (((String) o[0]).equals(LocaleFac.BELEGART_ANGEBOT)) {
						AngebotDto angebotDto = getAngebotFac().angebotFindByPrimaryKey((Integer) o[1], theClientDto);
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_ANGEBOT] = angebotDto.getCNr();

						sBezeichnung = angebotDto.getCBez();
						KundeDto kundeDto = getKundeFac()
								.kundeFindByPrimaryKeyOhneExc(angebotDto.getKundeIIdAngebotsadresse(), theClientDto);

						if (kundeDto != null) {
							partnerDto = kundeDto.getPartnerDto();
						}

						// PJ18422
						if (bProjektklammer) {
							if (angebotDto.getProjektIId() != null) {

								ProjektDto projektDto = null;
								try {
									projektDto = getProjektFac().projektFindByPrimaryKey(angebotDto.getProjektIId());
								} catch (EJBExceptionLP ex3) {
									throw new EJBExceptionLP(ex3);
								}

								oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_I_ID_PROJEKTKLAMMER] = projektDto
										.getIId();
								oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_PROJEKTKLAMMER] = projektDto.getCNr();
								oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKTKATEGORIE_PROJEKTKLAMMER] = projektDto
										.getKategorieCNr();
								oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_BEREICH_PROJEKTKLAMMER] = getProjektServiceFac()
										.bereichFindByPrimaryKey(projektDto.getBereichIId()).getCBez();
							}
						}

					}

					if (partnerDto != null) {
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE] = partnerDto.formatTitelAnrede();

						if (partnerDto.getBrancheIId() != null) {

							oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE_BRANCHE] = getPartnerServicesFac()
									.brancheFindByPrimaryKey(partnerDto.getBrancheIId(), theClientDto).getCNr();
						}
						if (partnerDto.getPartnerklasseIId() != null) {
							oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE_PARTNERKLASSE] = getPartnerFac()
									.partnerklasseFindByPrimaryKey(partnerDto.getPartnerklasseIId(), theClientDto)
									.getCNr();
						}

					}
					oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKTBEZEICHNUNG] = sBezeichnung;
					oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSONAL_ID] = personalDto.getIId();

					Double dDauer = new Double(0);

					Double dDauerAnhandFVerrechenbar = new Double(0);

					Integer belegpositionIId = null;
					if (bVerdichtet == false) {
						belegpositionIId = (Integer) o[2];
					}

					AuftragzeitenDto[] dtos = getAllZeitenEinesBeleges((String) o[0], (Integer) o[1], belegpositionIId,
							personalDto.getIId(), tVon, tBis, SORTIERUNG_ZEITDATEN_ARTIKEL, false, theClientDto);

					// SP4176 Wenn nicht verdichtet und auf keine
					// Belegposition gebucht wurde, dann die Zeilen auf
					// Belegpositionen entfernen
					if (bVerdichtet == false && o[2] == null) {

						ArrayList auftragszeiten = new ArrayList();

						for (int k = 0; k < dtos.length; k++) {
							if (dtos[k] != null && dtos[k].getDdDauer() != null) {

								if (dtos[k].getBelegpositionIId() != null) {
									continue;
								}
								auftragszeiten.add(dtos[k]);
							}
						}

						dtos = new AuftragzeitenDto[auftragszeiten.size()];
						dtos = (AuftragzeitenDto[]) auftragszeiten.toArray(dtos);
					}

					boolean bOffeneZeitenVorhanden = false;

					for (int k = 0; k < dtos.length; k++) {

						if (dtos[k].getSZeitbuchungtext() != null && dtos[k].getSZeitbuchungtext().contains("OFFEN")) {
							bOffeneZeitenVorhanden = true;
						}

						if (dtos[k] != null && dtos[k].getDdDauer() != null) {
							dDauer = dDauer + dtos[k].getDdDauer().doubleValue();

							// SP9122 Hotfix
							// SP9122 TODO woher kommt die null wirklich?
							Double verrechenbar = dtos[k].getFVerrechenbarInProzent();
							if (verrechenbar == null) {
								verrechenbar = new Double(100.0d);
							}
							dDauerAnhandFVerrechenbar = dDauerAnhandFVerrechenbar
									+ Helper.getProzentWert(new BigDecimal(dtos[k].getDdDauer()),
											new BigDecimal(verrechenbar), 2).doubleValue();
						}
					}

					if ((partnerDto != null && mandantDto.getPartnerIId().equals(partnerDto.getIId()))
							|| partnerDto == null) {
						dIntern = dIntern + dDauer.doubleValue();
					} else if (partnerDto != null) {
						dExtern = dExtern + dDauer.doubleValue();

						if (bVerrechenbar) {
							dExternVerrechenbar = dExternVerrechenbar + dDauerAnhandFVerrechenbar.doubleValue();
							dExternNichtVerrechenbar = dExternNichtVerrechenbar
									+ (dDauer.doubleValue() - dDauerAnhandFVerrechenbar.doubleValue());
						} else {
							dExternNichtVerrechenbar = dExternNichtVerrechenbar + dDauer.doubleValue();
						}
					}

					if (bVerdichtet) {
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_DAUER] = dDauer;

						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_OFFENE_ZEITEN_VORHANDEN] = bOffeneZeitenVorhanden;

						alDaten.add(oZeile);

					} else {

						HashMap hmAGBereitsVorhanden = new HashMap();

						for (int k = 0; k < dtos.length; k++) {
							if (dtos[k] != null && dtos[k].getDdDauer() != null) {

								Object[] oZeileZusaetzlich = oZeile.clone();

								if (dtos[k].getSZeitbuchungtext() != null
										&& dtos[k].getSZeitbuchungtext().contains("OFFEN")) {
									oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_OFFENE_ZEITEN_VORHANDEN] = true;
								} else {
									oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_OFFENE_ZEITEN_VORHANDEN] = false;
								}

								oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_TAETIGKEIT] = dtos[k]
										.getSArtikelcnr();
								oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_TAETIGKEIT_BEZEICHNUNG] = dtos[k]
										.getSArtikelbezeichnung();
								oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_DAUER] = dtos[k].getDdDauer();

								oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_BEMERKUNG] = dtos[k]
										.getSZeitbuchungtext();
								oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_KOMMENTAR_INTERN] = dtos[k]
										.getSKommentarIntern();
								oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_KOMMENTAR_EXTERN] = dtos[k]
										.getSKommentar();

								if (((String) o[0]).equals(LocaleFac.BELEGART_LOS)) {
									com.lp.server.fertigung.service.LosDto losDto = getFertigungFac()
											.losFindByPrimaryKey((Integer) o[1]);

									if (o[2] != null) {

										LossollarbeitsplanDto saDto = null;
										try {
											saDto = getFertigungFac()
													.lossollarbeitsplanFindByPrimaryKey((Integer) o[2]);
										} catch (EJBExceptionLP e) {
											// nicht mehr vorhanden
										}

										if (saDto != null) {
											AuftragzeitenDto[] dtosGesamt = getAllZeitenEinesBeleges((String) o[0],
													(Integer) o[1], saDto.getIId(), null, null, null,
													SORTIERUNG_ZEITDATEN_ARTIKEL, theClientDto);

											BigDecimal zeitDerPersonAufArbeitsgang = new BigDecimal(0);
											BigDecimal zeitAllerPersonenAufArbeitsgang = new BigDecimal(0);
											for (int p = 0; p < dtosGesamt.length; p++) {
												if (dtosGesamt[p] != null && dtosGesamt[p].getDdDauer() != null) {

													BigDecimal zeitTemp = new BigDecimal(
															dtosGesamt[p].getDdDauer().doubleValue());
													zeitAllerPersonenAufArbeitsgang = zeitAllerPersonenAufArbeitsgang
															.add(zeitTemp);
													if (dtosGesamt[p].getIPersonalMaschinenId()
															.equals(personalDto.getIId())) {
														zeitDerPersonAufArbeitsgang = zeitDerPersonAufArbeitsgang
																.add(zeitTemp);
													}

												}
											}

											BigDecimal zeitanteil = new BigDecimal(100);
											if (zeitAllerPersonenAufArbeitsgang.doubleValue() != 0) {
												zeitanteil = zeitDerPersonAufArbeitsgang
														.divide(zeitAllerPersonenAufArbeitsgang, 4,
																BigDecimal.ROUND_HALF_EVEN)
														.multiply(new BigDecimal(100));
											}
											oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_ZEITANTEIL] = zeitanteil;

											oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_LOSGROESSE] = losDto
													.getNLosgroesse();
											oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_AGART] = saDto
													.getAgartCNr();

											oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_AGNUMMER] = saDto
													.getIArbeitsgangnummer();
											oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_UAGNUMMER] = saDto
													.getIUnterarbeitsgang();
											oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_FERTIG] = Helper
													.short2Boolean(saDto.getBFertig());

											oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_STUECKZEIT] = new BigDecimal(
													saDto.getLStueckzeit()).divide(new BigDecimal(3600000), 4,
															BigDecimal.ROUND_HALF_EVEN);
											oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_RUESTZEIT] = new BigDecimal(
													saDto.getLRuestzeit()).divide(new BigDecimal(3600000), 4,
															BigDecimal.ROUND_HALF_EVEN);

											oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_GESAMTZEIT] = saDto
													.getNGesamtzeit();

											// Alle Zeiten des Arbeitsganges
											// nach Zeit sortieren
											for (int p = dtosGesamt.length - 1; p > 0; --p) {
												for (int j = 0; j < p; ++j) {
													if (dtosGesamt[j].getTsBeginn()
															.after(dtosGesamt[j + 1].getTsBeginn())) {
														AuftragzeitenDto tauschDto = dtosGesamt[j];
														dtosGesamt[j] = dtosGesamt[j + 1];
														dtosGesamt[j + 1] = tauschDto;
													}
												}
											}
											Boolean bRuestenMitrechnen = false;
											// Wenn ich nun der erste bin, dann
											// Ruesten mitrechnen
											if (dtosGesamt.length > 0) {
												if (dtosGesamt[0].getTsBeginn().after(tVon) && dtosGesamt[0]
														.getIPersonalMaschinenId().equals(personalDto.getIId())) {
													bRuestenMitrechnen = true;
												}
											}

											LosgutschlechtDto[] loguDtos = getFertigungFac()
													.losgutschlechtFindByLossollarbeitsplanIId(saDto.getIId());

											BigDecimal bdGut = new BigDecimal(0);
											BigDecimal bdSchlecht = new BigDecimal(0);
											BigDecimal bdInarbeit = new BigDecimal(0);

											for (int z = 0; z < loguDtos.length; z++) {

												if (loguDtos[z].getZeitdatenIId() != null) {

													ZeitdatenDto zDto = zeitdatenFindByPrimaryKey(
															loguDtos[z].getZeitdatenIId(), theClientDto);

													if (personalDto.getIId().equals(zDto.getPersonalIId())
															&& zDto.getTZeit().after(tVon)
															&& zDto.getTZeit().before(tBis)) {
														bdGut = bdGut.add(loguDtos[z].getNGut());
														bdSchlecht = bdSchlecht.add(loguDtos[z].getNSchlecht());
														bdInarbeit = bdInarbeit.add(loguDtos[z].getNInarbeit());
													}
												}
											}

											if (!hmAGBereitsVorhanden.containsKey(belegpositionIId)) {

												oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_RUESTEN_MITRECHNEN] = bRuestenMitrechnen;
												oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_GUTSTUECK] = bdGut;
												oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_SCHLECHTSTUECK] = bdSchlecht;
												oZeileZusaetzlich[REPORT_PRODUKTIVITAETISSTATISTIK_LOS_INARBEIT] = bdInarbeit;
												hmAGBereitsVorhanden.put(belegpositionIId, "");
											}
										}
									}
								}

								alDaten.add(oZeileZusaetzlich);
							}
						}
					}

				} catch (RemoteException ex1) {
					/** @todo CK PJ 4659 */
				}
			}
			session.close();

			// Telefonzeiten

			ArtikelDto artikelDto_DefaultAZ = null;

			Session sessionTel = FLRSessionFactory.getFactory().openSession();

			String sQueryTel = "SELECT t FROM FLRTelefonzeiten as t "

					+ " WHERE t.t_von>='" + Helper.formatDateWithSlashes(new java.sql.Date(tVon.getTime()))
					+ "' AND t.t_bis<'" + Helper.formatDateWithSlashes(new java.sql.Date(tBis.getTime())) + "' ";

			sQueryTel += " AND t.personal_i_id=" + personalDto.getIId();

			org.hibernate.Query queryTelefon = sessionTel.createQuery(sQueryTel);

			List<?> resultListTelefon = queryTelefon.list();

			Iterator<?> resultListIteratorTelefon = resultListTelefon.iterator();

			TreeMap<String, Object[]> tmTelefonzeitenPJ = new TreeMap<String, Object[]>();
			TreeMap<String, Object[]> tmTelefonzeitenRest = new TreeMap<String, Object[]>();
			int k = 0;
			while (resultListIteratorTelefon.hasNext()) {
				FLRTelefonzeiten tel = (FLRTelefonzeiten) resultListIteratorTelefon.next();
				if (artikelDto_DefaultAZ == null) {
					artikelDto_DefaultAZ = getZeiterfassungFac().getDefaultArbeitszeitartikel(theClientDto);
				}

				java.sql.Time tDauer = new java.sql.Time(tel.getT_bis().getTime() - tel.getT_von().getTime());
				tDauer.setTime(tDauer.getTime() - 3600000);
				Double dDauer = Helper.time2Double(tDauer);

				Double dDauerAnhandFVerrechenbar = Helper
						.getProzentWert(new BigDecimal(dDauer), new BigDecimal(tel.getF_verrechenbar()), 2)
						.doubleValue();

				k++;
				try {
					Object[] oZeile = new Object[REPORT_PRODUKTIVITAETISSTATISTIK_ANZAHL_SPALTEN];

					oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_TELEFONZEIT] = Boolean.TRUE;

					oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_DAUER] = dDauer;

					oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSONAL_ID] = personalDto.getIId();

					oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_TAETIGKEIT] = artikelDto_DefaultAZ.getCNr();
					if (artikelDto_DefaultAZ.getArtikelsprDto() != null) {
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_TAETIGKEIT_BEZEICHNUNG] = artikelDto_DefaultAZ
								.getArtikelsprDto().getCBez();
					}

					if (tel.getFlrauftrag() != null) {
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG] = tel.getFlrauftrag().getC_nr();
						AuftragDto auftragDto = getAuftragFac().auftragFindByPrimaryKey(tel.getFlrauftrag().getI_id());
						KostenstelleDto kstDto = getSystemFac().kostenstelleFindByPrimaryKey(auftragDto.getKostIId());
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG_KOSTENSTELLE] = kstDto.getCNr();
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG_KOSTENSTELLE_BEZEICHNUNG] = kstDto.getCBez();

					}
					if (tel.getFlrangebot() != null) {
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_ANGEBOT] = tel.getFlrangebot().getC_nr();
					}

					if (tel.getProjekt_i_id() != null) {

						ProjektDto pjDto = getProjektFac().projektFindByPrimaryKey(tel.getProjekt_i_id());

						PartnerDto partnerDto = getPartnerFac().partnerFindByPrimaryKey(pjDto.getPartnerIId(),
								theClientDto);

						if (mandantDto.getPartnerIId().equals(partnerDto.getIId())) {
							dIntern = dIntern + dDauer.doubleValue();
						} else {

							dExtern = dExtern + dDauer.doubleValue();

							if (pjDto.getIVerrechenbar().equals(ProjektServiceFac.PROJEKT_VERRECHENBAR_VERRECHENBAR)) {
								dExternVerrechenbar = dExternVerrechenbar + dDauerAnhandFVerrechenbar.doubleValue();
								dExternNichtVerrechenbar = dExternNichtVerrechenbar
										+ (dDauer.doubleValue() - dDauerAnhandFVerrechenbar.doubleValue());
							} else {
								dExternNichtVerrechenbar = dExternNichtVerrechenbar + dDauer.doubleValue();
							}

						}

						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT] = pjDto.getCNr();
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKTBEZEICHNUNG] = pjDto.getCTitel();

						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_I_ID] = pjDto.getIId();
						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_BEREICH] = getProjektServiceFac()
								.bereichFindByPrimaryKey(pjDto.getBereichIId()).getCBez();

						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE] = partnerDto.formatTitelAnrede();

						if (partnerDto.getBrancheIId() != null) {

							oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE_BRANCHE] = getPartnerServicesFac()
									.brancheFindByPrimaryKey(partnerDto.getBrancheIId(), theClientDto).getCNr();
						}
						if (partnerDto.getPartnerklasseIId() != null) {
							oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE_PARTNERKLASSE] = getPartnerFac()
									.partnerklasseFindByPrimaryKey(partnerDto.getPartnerklasseIId(), theClientDto)
									.getCNr();
						}

						if (bVerdichtet) {

							if (tmTelefonzeitenPJ.containsKey(pjDto.getCNr())) {
								// Dauer addieren
								Object[] oZeileTemp = tmTelefonzeitenPJ.get(pjDto.getCNr());
								Double dauerVorhanden = ((Double) oZeileTemp[REPORT_PRODUKTIVITAETISSTATISTIK_DAUER])
										.doubleValue();
								oZeileTemp[REPORT_PRODUKTIVITAETISSTATISTIK_DAUER] = dauerVorhanden + dDauer;

								tmTelefonzeitenPJ.put(pjDto.getCNr(), oZeileTemp);
							} else {
								tmTelefonzeitenPJ.put(pjDto.getCNr(), oZeile);
							}

						} else {
							tmTelefonzeitenPJ.put(pjDto.getCNr() + k, oZeile);
						}

					} else {

						String partner = "";
						if (tel.getFlrpartner() != null) {
							partner = HelperServer.formatNameAusFLRPartner(tel.getFlrpartner());

							if (mandantDto.getPartnerIId().equals(tel.getFlrpartner().getI_id())) {
								dIntern = dIntern + dDauer.doubleValue();
							} else {
								dExtern = dExtern + dDauer.doubleValue();
								dExternNichtVerrechenbar = dExternNichtVerrechenbar + dDauer.doubleValue();

							}

							if (tel.getFlrpartner().getFlrbranche() != null) {
								oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE_BRANCHE] = tel.getFlrpartner()
										.getFlrbranche().getC_nr();
							}
							if (tel.getFlrpartner().getFlrpartnerklasse() != null) {
								oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE_PARTNERKLASSE] = tel.getFlrpartner()
										.getFlrpartnerklasse().getC_nr();
							}

						} else {
							dExtern = dExtern + dDauer.doubleValue();
							dExternNichtVerrechenbar = dExternNichtVerrechenbar + dDauer.doubleValue();

						}

						oZeile[REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE] = partner;

						if (bVerdichtet) {
							// Dauer addieren

							if (tmTelefonzeitenRest.containsKey(partner)) {

								Object[] oZeileTemp = tmTelefonzeitenRest.get(partner);
								Double dauerVorhanden = ((Double) oZeileTemp[REPORT_PRODUKTIVITAETISSTATISTIK_DAUER])
										.doubleValue();
								oZeileTemp[REPORT_PRODUKTIVITAETISSTATISTIK_DAUER] = dauerVorhanden + dDauer;
							} else {

								tmTelefonzeitenRest.put(partner, oZeile);
							}
						} else {
							tmTelefonzeitenRest.put(partner + k, oZeile);
						}

					}

				} catch (RemoteException ex1) {
					throwEJBExceptionLPRespectOld(ex1);
				}

			}

			Iterator it = tmTelefonzeitenPJ.keySet().iterator();
			while (it.hasNext()) {
				alDaten.add(tmTelefonzeitenPJ.get(it.next()));
			}
			it = tmTelefonzeitenRest.keySet().iterator();
			while (it.hasNext()) {
				alDaten.add(tmTelefonzeitenRest.get(it.next()));
			}

			dIntern = Helper.rundeKaufmaennisch(new java.math.BigDecimal(dIntern), 2).doubleValue();
			dExtern = Helper.rundeKaufmaennisch(new java.math.BigDecimal(dExtern), 2).doubleValue();

			dExternVerrechenbar = Helper.rundeKaufmaennisch(new java.math.BigDecimal(dExternVerrechenbar), 2)
					.doubleValue();
			dExternNichtVerrechenbar = Helper.rundeKaufmaennisch(new java.math.BigDecimal(dExternNichtVerrechenbar), 2)
					.doubleValue();

			dInternGesamt = dInternGesamt + dIntern;
			dExternGesamt = dExternGesamt + dExtern;

			dExternVerrechenbarGesamt = dExternVerrechenbarGesamt + dExternVerrechenbar;
			dExternNichtverrechenbarGesamt = dExternNichtverrechenbarGesamt + dExternNichtVerrechenbar;

			double dProzentExtern = 0;
			double dProzentIntern = 0;
			if (dIstGesamt > 0) {
				dProzentExtern = dExtern / dIstGesamt;
				dProzentExtern = Helper.rundeKaufmaennisch(new java.math.BigDecimal(dProzentExtern * 100), 2)
						.doubleValue();

				dProzentIntern = dIntern / dIstGesamt;
				dProzentIntern = Helper.rundeKaufmaennisch(new java.math.BigDecimal(dProzentIntern * 100), 2)
						.doubleValue();
			}

			Calendar c = Calendar.getInstance();
			c.setTimeInMillis(tVon.getTime());

			Double leistungswert = null;
			try {
				PersonalgehaltDto pgDto = getPersonalFac().personalgehaltFindLetztePersonalgehalt(personalIId,
						c.get(Calendar.YEAR), c.get(Calendar.MONTH));
				if (pgDto != null) {
					leistungswert = pgDto.getFLeistungswert();
				}

			} catch (RemoteException e) {
				throwEJBExceptionLPRespectOld(e);
			}

			// Zeit Sondertaetigkeiten:
			TaetigkeitDto[] taetigkeitenDtos = getAllSondertaetigkeitenOhneKommtUndGeht(theClientDto);

			Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
			Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();

			// Datenquelle Subreport
			ArrayList<Object[]> al = new ArrayList<Object[]>();
			for (int j = 0; j < taetigkeitenDtos.length; j++) {
				BigDecimal bdDauer = new BigDecimal(getGesamtDauerEinerSondertaetigkeitImZeitraum(personalDto.getIId(),
						tVon, tBis, taetigkeitenDtos[j].getIId(), theClientDto, tagesartIId_Feiertag,
						tagesartIId_Halbtag).dStunden);

				if (bdDauer.doubleValue() > 0) {
					Object[] o = new Object[2];
					o[0] = taetigkeitenDtos[j].getBezeichnung();
					o[1] = bdDauer;
					al.add(o);
				}
			}

			String[] fieldnames = new String[] { "F_SONDERTAETIGKEITEN", "F_DAUER" };

			Object[][] dataSub = new Object[al.size()][fieldnames.length];
			dataSub = (Object[][]) al.toArray(dataSub);

			for (int m = 0; m < alDaten.size(); m++) {
				Object[] zeile = (Object[]) alDaten.get(m);

				zeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_NAME] = personalDto.getCPersonalnr() + " "
						+ personalDto.getPartnerDto().formatAnrede();
				if (personalDto.getKostenstelleDto_Stamm() != null) {
					zeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_KOSTENSTELLE] = personalDto.getKostenstelleDto_Stamm()
							.formatKostenstellenbezeichnung();
				}
				if (personalDto.getKostenstelleDto_Abteilung() != null) {
					zeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_ABTEILUNG] = personalDto
							.getKostenstelleDto_Abteilung().formatKostenstellenbezeichnung();
				}

				if (personalDto.getPersonalgruppeIId() != null) {
					zeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_PERSONALGRUPPE] = getPersonalFac()
							.personalgruppeFindByPrimaryKey(personalDto.getPersonalgruppeIId()).getCBez();
				}
				zeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_IST_GESAMT] = new Double(dIstGesamt);
				zeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_INTERN] = new Double(dIntern);
				zeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_EXTERN] = new Double(dExtern);
				zeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_PROZENTINTERN] = new Double(dProzentIntern);
				zeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_PROZENTEXTERN] = new Double(dProzentExtern);
				zeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_LEISTUNGSWERT] = leistungswert;
				zeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_SUBREPORT_SONDERTAETIGKEITEN] = new LPDatenSubreport(
						dataSub, fieldnames);

				zeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_EXTERN_VERRECHENBAR] = new Double(dExternVerrechenbar);
				zeile[REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_EXTERN_NICHT_VERRECHENBAR] = new Double(
						dExternNichtVerrechenbar);

				alDaten.set(m, zeile);

			}

			alDatenGesamt.addAll(alDaten);

		}

		parameter.put("P_INTERN_GESAMT", dInternGesamt);
		parameter.put("P_EXTERN_GESAMT", dExternGesamt);

		parameter.put("P_EXTERN_VERRECHENBAR_GESAMT", dExternVerrechenbarGesamt);
		parameter.put("P_EXTERN_NICHT_VERRECHENBAR_GESAMT", dExternNichtverrechenbarGesamt);

		parameter.put("P_ANWESENHEITSZEIT_GESAMT", dAnwesenheitszeitGesamt);

		if (projekteZusammengefasst) {
			for (int p = alDatenGesamt.size() - 1; p > 0; --p) {
				for (int j = 0; j < p; ++j) {

					Object[] zeile1 = (Object[]) alDatenGesamt.get(j);
					Object[] zeile2 = (Object[]) alDatenGesamt.get(j + 1);

					String beleg1 = Helper.fitString2LengthAuchNull(
							(String) zeile1[REPORT_PRODUKTIVITAETISSTATISTIK_BEREICH_PROJEKTKLAMMER], 20, ' ')
							+ Helper.fitString2LengthAuchNull(
									(String) zeile1[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_PROJEKTKLAMMER], 20, ' ')
							+ Helper.fitString2LengthAuchNull(
									(String) zeile1[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_BEREICH], 20, ' ')
							+ Helper.fitString2LengthAuchNull((String) zeile1[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT],
									20, ' ')
							+ Helper.fitString2LengthAuchNull((String) zeile1[REPORT_PRODUKTIVITAETISSTATISTIK_ANGEBOT],
									20, ' ')
							+ Helper.fitString2LengthAuchNull((String) zeile1[REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG],
									20, ' ')
							+ Helper.fitString2LengthAuchNull((String) zeile1[REPORT_PRODUKTIVITAETISSTATISTIK_LOS], 20,
									' ');
					String beleg2 = Helper.fitString2LengthAuchNull(
							(String) zeile2[REPORT_PRODUKTIVITAETISSTATISTIK_BEREICH_PROJEKTKLAMMER], 20, ' ')
							+ Helper.fitString2LengthAuchNull(
									(String) zeile2[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_PROJEKTKLAMMER], 20, ' ')
							+ Helper.fitString2LengthAuchNull(
									(String) zeile2[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_BEREICH], 20, ' ')
							+ Helper.fitString2LengthAuchNull((String) zeile2[REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT],
									20, ' ')
							+ Helper.fitString2LengthAuchNull((String) zeile2[REPORT_PRODUKTIVITAETISSTATISTIK_ANGEBOT],
									20, ' ')
							+ Helper.fitString2LengthAuchNull((String) zeile2[REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG],
									20, ' ')
							+ Helper.fitString2LengthAuchNull((String) zeile2[REPORT_PRODUKTIVITAETISSTATISTIK_LOS], 20,
									' ');

					if (beleg1.compareTo(beleg2) > 0) {
						Object[] tausch = (Object[]) alDatenGesamt.get(j);
						alDatenGesamt.set(j, alDatenGesamt.get(j + 1));
						alDatenGesamt.set(j + 1, tausch);
					}
				}
			}
		}

		Object[][] returnArray = new Object[alDatenGesamt.size()][REPORT_PRODUKTIVITAETISSTATISTIK_ANZAHL_SPALTEN];
		data = (Object[][]) alDatenGesamt.toArray(returnArray);

		index = -1;
		sAktuellerReport = ZeiterfassungFac.REPORT_PRODUKTIVITAETSSTATISTIK;

		initJRDS(parameter, ZeiterfassungFac.REPORT_MODUL, ZeiterfassungFac.REPORT_PRODUKTIVITAETSSTATISTIK,
				theClientDto.getMandant(), theClientDto.getLocUi(), theClientDto);

		return getReportPrint();

	}

	private LPDatenSubreport getSubreportZeitdatenjournalFuerWochenabrechnung(Integer personalIId, int iKW, int iJahr,
			TheClientDto theClientDto) {

		Calendar cVon = Calendar.getInstance();
		cVon.set(Calendar.YEAR, iJahr);
		cVon.set(Calendar.WEEK_OF_YEAR, iKW);
		cVon.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);

		Timestamp tVon = new Timestamp(cVon.getTimeInMillis());

		cVon.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);

		Timestamp tBis = new Timestamp(cVon.getTimeInMillis());

		Object[][] oDaten = getZeiterfassungReportFac().erstelleZeitdatenjournal(personalIId, tVon, tBis,
				ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON, null, true, theClientDto);

		Object[][] dataSub = new Object[oDaten.length][2];
		String[] fieldnames = new String[] { "Personalnummer", "Name", "Zeit", "Taetigkeit", "Auftrag",
				"Projektbezeichnung", "Tagessumme", "Maschine", "Position", "Buchungsart", "Bemerkung", "Gutstueck",
				"Schlechtstueck", "Kunde", "Dauer", "Kommentar", "Quelle", "TaetigkeitSonderzeit", "DauerSonderzeit",
				"DatumSonderzeit", "Artikelbezeichnung", "Sollzeit" };

		for (int i = 0; i < oDaten.length; i++) {
			Object[] zeileSub = oDaten[i];

			zeileSub[0] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_PERSONALNR];
			zeileSub[1] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_NAME];
			zeileSub[2] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_ZEIT];
			zeileSub[3] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_TAETIGKEIT];
			zeileSub[4] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_AUFTRAG];
			zeileSub[5] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_PROJEKTBEZEICHNUNG];
			zeileSub[6] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_TAGESSUMME];
			zeileSub[7] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_MASCHINE];
			zeileSub[8] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_POSITION];
			zeileSub[9] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_BUCHUNGSART];
			zeileSub[10] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_BEMERKUNG];
			zeileSub[11] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_GUTSTK];
			zeileSub[12] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_SCHLECHTSTK];
			zeileSub[13] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_KUNDE];
			zeileSub[14] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_DAUER];
			zeileSub[15] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_KOMMENTAR];
			zeileSub[16] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_QUELLE];
			zeileSub[17] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_TAETIGKEIT_SONDERZEIT];
			zeileSub[18] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_DAUER_SONDERZEIT];
			zeileSub[19] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_DATUM_SONDERZEIT];
			zeileSub[20] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_ARTIKELBEZEICHNUNG];
			zeileSub[21] = oDaten[i][ZeiterfassungReportFac.REPORT_ZEITDATEN_SOLLZEIT];
			dataSub[i] = zeileSub;
		}

		return new LPDatenSubreport(dataSub, fieldnames);
	}

	public LPDatenSubreport getSubreportGestarteteMaschinen(Integer personalIId, TheClientDto theClientDto) {

		String sQuery = "SELECT mz  from FLRMaschinenzeitdaten mz WHERE mz.flrmaschine.mandant_c_nr='"
				+ theClientDto.getMandant() + "' AND mz.t_von <='"
				+ Helper.formatTimestampWithSlashes(new Timestamp(System.currentTimeMillis()))
				+ "' AND mz.t_bis IS NULL AND mz.personal_i_id_gestartet=" + personalIId
				+ " ORDER BY mz.flrmaschine.c_identifikationsnr ASC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query query = session.createQuery(sQuery);

		List<?> resultList = query.list();

		Iterator<?> resultListIterator = resultList.iterator();

		String[] fieldnames = new String[] { "Startzeitpunkt", "MaschineIdentifikationsnummer",
				"MaschineInventarnummer", "MaschineBezeichnung", "Losnummer", "AG", "UAG", "MaschineSeriennummer", };
		Object[][] alDataSub = new Object[resultList.size()][fieldnames.length];
		int i = 0;
		while (resultListIterator.hasNext()) {
			FLRMaschinenzeitdaten mz = (FLRMaschinenzeitdaten) resultListIterator.next();

			alDataSub[i][0] = mz.getT_von();
			alDataSub[i][1] = mz.getFlrmaschine().getC_identifikationsnr();
			alDataSub[i][2] = mz.getFlrmaschine().getC_inventarnummer();
			alDataSub[i][3] = mz.getFlrmaschine().getC_bez();
			alDataSub[i][4] = mz.getFlrlossollarbeitsplan().getFlrlos().getC_nr();
			alDataSub[i][5] = mz.getFlrlossollarbeitsplan().getI_arbeitsgangsnummer();
			alDataSub[i][6] = mz.getFlrlossollarbeitsplan().getI_unterarbeitsgang();
			alDataSub[i][7] = mz.getFlrmaschine().getC_seriennummer();

			i++;

		}

		return new LPDatenSubreport(alDataSub, fieldnames);
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public JasperPrintLP erstelleWochenabrechnung(Integer personalIId, Timestamp tVon, Timestamp tBis,
			boolean bMitUrlaubZumAbrechnungsbeginn, boolean bMitSubreportZeitdatenjournal, TheClientDto theClientDto) {

		Calendar c = Calendar.getInstance();
		c.setTimeInMillis(tVon.getTime());

		int iErsteKW = c.get(Calendar.WEEK_OF_YEAR);
		c.set(Calendar.DAY_OF_WEEK, c.getFirstDayOfWeek());
		int iErstesJahr = c.get(Calendar.YEAR);

		Calendar cBis = Calendar.getInstance();
		cBis.setTimeInMillis(tBis.getTime());
		int iLetzteKW = cBis.get(Calendar.WEEK_OF_YEAR);
		int iLetztesJahr = cBis.get(Calendar.YEAR);
		ArrayList alDaten = new ArrayList();

		c.set(Calendar.DAY_OF_MONTH, 1);
		while (c.getTimeInMillis() < tBis.getTime()) {

			try {
				MonatsabrechnungDto monatsabrechnungDto = erstelleMonatsAbrechnung(personalIId, c.get(Calendar.YEAR),
						c.get(Calendar.MONTH), true, null, theClientDto, false,
						ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_PERSONALNUMMER, null);

				for (int i = 0; i < monatsabrechnungDto.getData().length; i++) {
					alDaten.add(monatsabrechnungDto.getData()[i]);
				}
			} catch (EJBExceptionLP e) {
				if (e.getCode() == EJBExceptionLP.FEHLER_PERSONAL_FEHLER_BEI_EINTRITTSDATUM) {
					// auslassen, da noch nicht eingetreten
				} else {
					throw e;
				}
			}
			c.add(Calendar.MONTH, 1);
		}

		// Wochensummen bilden

		java.util.TreeMap wochensummen = new java.util.TreeMap();

		BigDecimal bdSummeUestd = BigDecimal.ZERO;

		for (int i = 0; i < alDaten.size(); i++) {
			Object[] zeileMonatsabrechnung = (Object[]) alDaten.get(i);

			int iAktuelleKW = ((Integer) zeileMonatsabrechnung[0]).intValue();
			int iAktuellesJahr = ((Integer) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_JAHR]).intValue();

			if (iErstesJahr == iAktuellesJahr && iAktuelleKW < iErsteKW) {
				continue;
			}
			if (iLetztesJahr == iAktuellesJahr && iAktuelleKW > iLetzteKW) {
				continue;
			}

			String key = (iAktuellesJahr * 100 + iAktuelleKW) + "";

			if (wochensummen.containsKey(key)) {
				Object[] oTemp = (Object[]) wochensummen.get(key);

				// Aufsummieren
				oTemp[REPORT_MONATSABRECHNUNG_SOLL] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_SOLL])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_SOLL]);
				oTemp[REPORT_MONATSABRECHNUNG_IST] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_IST])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_IST]);
				oTemp[REPORT_MONATSABRECHNUNG_DIFF] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_DIFF])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_DIFF]);
				oTemp[REPORT_MONATSABRECHNUNG_UNTER] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_UNTER])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_UNTER]);
				oTemp[REPORT_MONATSABRECHNUNG_FEIERTAG] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_FEIERTAG])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_FEIERTAG]);
				oTemp[REPORT_MONATSABRECHNUNG_URLAUB] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_URLAUB])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_URLAUB]);

				oTemp[REPORT_MONATSABRECHNUNG_ARZT] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_ARZT])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_ARZT]);

				oTemp[REPORT_MONATSABRECHNUNG_KRANK] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_KRANK])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_KRANK]);
				oTemp[REPORT_MONATSABRECHNUNG_KINDKRANK] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_KINDKRANK])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_KINDKRANK]);

				oTemp[REPORT_MONATSABRECHNUNG_BEHOERDE] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_BEHOERDE])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_BEHOERDE]);

				oTemp[REPORT_MONATSABRECHNUNG_SONSTIGE_BEZAHLTETAETIGKEITEN] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_SONSTIGE_BEZAHLTETAETIGKEITEN])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_SONSTIGE_BEZAHLTETAETIGKEITEN]);

				if (oTemp[REPORT_MONATSABRECHNUNG_UESTD100] == null) {
					oTemp[REPORT_MONATSABRECHNUNG_UESTD100] = new BigDecimal(0);
				}
				oTemp[REPORT_MONATSABRECHNUNG_UESTD100] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_UESTD100])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_UESTD100]);

				oTemp[REPORT_MONATSABRECHNUNG_UESTD200] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_UESTD200])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_UESTD200]);
				oTemp[REPORT_MONATSABRECHNUNG_UESTD100FREI] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_UESTD100FREI])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_UESTD100FREI]);
				oTemp[REPORT_MONATSABRECHNUNG_UESTD50] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_UESTD50])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_UESTD50]);
				oTemp[REPORT_MONATSABRECHNUNG_UESTD50TAGESWEISEFREI] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_UESTD50TAGESWEISEFREI])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_UESTD50TAGESWEISEFREI]);
				oTemp[REPORT_MONATSABRECHNUNG_UESTD50TAGEWEISE] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_UESTD50TAGEWEISE])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_UESTD50TAGEWEISE]);
				oTemp[REPORT_MONATSABRECHNUNG_MEHRZEIT] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_MEHRZEIT])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_MEHRZEIT]);

				oTemp[REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_KOMMT] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_KOMMT])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_KOMMT]);
				oTemp[REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_GEHT] = ((BigDecimal) oTemp[REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_GEHT])
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_GEHT]);

				// PJ21745
				bdSummeUestd = bdSummeUestd.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_UESTD100]);
				bdSummeUestd = bdSummeUestd
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_UESTD100FREI]);
				bdSummeUestd = bdSummeUestd.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_UESTD50]);
				bdSummeUestd = bdSummeUestd
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_UESTD50TAGESWEISEFREI]);
				bdSummeUestd = bdSummeUestd
						.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_UESTD50TAGEWEISE]);
				bdSummeUestd = bdSummeUestd.add((BigDecimal) zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_UESTD200]);

				wochensummen.put(key, oTemp);

			} else {

				if (bMitSubreportZeitdatenjournal) {
					zeileMonatsabrechnung[REPORT_MONATSABRECHNUNG_PLATZHALTER_FUER_SUREPORTZEIDATENJOURNAL] = getSubreportZeitdatenjournalFuerWochenabrechnung(
							personalIId, iAktuelleKW, iAktuellesJahr, theClientDto);
				}

				wochensummen.put(key, zeileMonatsabrechnung);

			}

		}

		data = new Object[wochensummen.size()][REPORT_MONATSABRECHNUNG_ANZAHL_SPALTEN];

		int iZeile = 0;
		Iterator it = wochensummen.keySet().iterator();

		while (it.hasNext()) {
			data[iZeile] = (Object[]) wochensummen.get(it.next());

			iZeile++;
		}

		HashMap parameter = new HashMap();

		parameter.put("P_VON", tVon);
		parameter.put("P_BIS", tBis);
		parameter.put("P_KWVON", iErsteKW + "");
		parameter.put("P_KWBIS", iLetzteKW + "");

		PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);

		parameter.put("P_PERSON", personalDto.formatAnrede());
		parameter.put("P_PERSONALNUMMER", personalDto.getCPersonalnr());

		parameter.put("P_SUMME_UEBERSTUNDEN", bdSummeUestd);

		// PJ18264 Urlaubsanspruch zum Abrechnungsbeginn
		if (bMitUrlaubZumAbrechnungsbeginn) {
			UrlaubsabrechnungDto v;
			try {
				v = berechneUrlaubsAnspruch(personalDto.getIId(), new java.sql.Date(tVon.getTime()), theClientDto);
				parameter.put("P_URLAUBVERFUEGBAR_TAGE", v.getNVerfuegbarerUrlaubTage());
				parameter.put("P_URLAUBVERFUEGBAR_STUNDEN", v.getNVerfuegbarerUrlaubStunden());
			} catch (EJBExceptionLP e) {
				if (e.getCode() == EJBExceptionLP.FEHLER_PERSONAL_FEHLER_BEI_EINTRITTSDATUM) {
					// aulsassen
				} else {
					throw e;
				}
			}

		}

		if (bMitUrlaubZumAbrechnungsbeginn) {
			index = -1;
			sAktuellerReport = ZeiterfassungFac.REPORT_WOCHENABRECHNUNG;
			initJRDS(parameter, ZeiterfassungFac.REPORT_MODUL, ZeiterfassungFac.REPORT_WOCHENJOURNAL,
					theClientDto.getMandant(), theClientDto.getLocUi(), theClientDto);
			return getReportPrint();
		} else {
			index = -1;
			sAktuellerReport = ZeiterfassungFac.REPORT_WOCHENABRECHNUNG;
			initJRDS(parameter, ZeiterfassungFac.REPORT_MODUL, ZeiterfassungFac.REPORT_WOCHENABRECHNUNG,
					theClientDto.getMandant(), theClientDto.getLocUi(), theClientDto);
			return getReportPrint();
		}

	}

	private BigDecimal getSummeAusMonatsabrechnungsZeile(ArrayList<Object[]> alTag, int field) {
		BigDecimal bdSumme = BigDecimal.ZERO;

		for (int i = 0; i < alTag.size(); i++) {

			Object o = alTag.get(i)[field];
			if (o instanceof BigDecimal) {
				bdSumme = bdSumme.add((BigDecimal) o);
			}

		}

		return bdSumme;
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public WochenabschlussReportDto printWochenabschluss(Integer personalIId, java.sql.Timestamp tKW,
			TheClientDto theClientDto) {

		HashMap<String, Object> parameter = new HashMap<String, Object>();
		PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);
		parameter.put("P_PERSON", personalDto.getPartnerDto().formatFixTitelName1Name2());
		WochenabschlussReportDto wDto = new WochenabschlussReportDto();
		// Vorher ev. 2 Monatsabrechnungen durchfuehren, wenn Woche ueber 2
		// Monate
		// geht

		Calendar c = Calendar.getInstance();
		c.setTimeInMillis(tKW.getTime());

		int kwAktuell = c.get(Calendar.WEEK_OF_YEAR);

		parameter.put("P_KW", kwAktuell);

		Timestamp tKWVon = new Timestamp(tKW.getTime());
		Timestamp tKWBis = new Timestamp(tKW.getTime());

		Timestamp[] tVonBis = Helper.getTimestampVonBisEinerKW(tKW);
		tKWVon = tVonBis[0];
		tKWBis = tVonBis[1];

		parameter.put("P_VON", tKWVon);
		parameter.put("P_BIS", tKWBis);

		String sQueryZeitabschluss = "SELECT za  from FLRZeitabschluss za WHERE za.personal_i_id=" + personalIId
				+ " ORDER BY za.t_abgeschlossen_bis DESC";

		Session sessionZeitabschluss = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query queryZeitabschluss = sessionZeitabschluss.createQuery(sQueryZeitabschluss);
		queryZeitabschluss.setMaxResults(1);

		List<?> resultListZeitabschluss = queryZeitabschluss.list();

		Iterator<?> resultListIteratorZeitabschluss = resultListZeitabschluss.iterator();

		if (resultListIteratorZeitabschluss.hasNext()) {
			FLRZeitabschluss flr = (FLRZeitabschluss) resultListIteratorZeitabschluss.next();
			sessionZeitabschluss.close();

			parameter.put("P_ZEITENABGESCHLOSSEN", new Timestamp(flr.getT_abgeschlossen_bis().getTime()));
		}

		BigDecimal nMaxWochenanwesenheit = null;
		BigDecimal nKumuliertesWochenist = BigDecimal.ZERO;

		boolean bNurWarnung = false;
		ParametermandantDto parameterMand = null;
		try {
			parameterMand = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_AUTOMATISCHE_PAUSEN_NUR_WARNUNG);

			bNurWarnung = (Boolean) parameterMand.getCWertAsObject();

			PersonalzeitmodellDto dto = getPersonalFac().personalzeitmodellFindZeitmodellZuDatum(personalIId,
					Helper.cutTimestamp(tKW), theClientDto);

			if (dto != null && dto.getZeitmodellIId() != null) {
				ZeitmodellDto zmDto = getZeiterfassungFac().zeitmodellFindByPrimaryKey(dto.getZeitmodellIId(),
						theClientDto);
				nMaxWochenanwesenheit = zmDto.getNMaximalesWochenist();
			}

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		Calendar cVon = Calendar.getInstance();
		cVon.setTimeInMillis(tKWVon.getTime());
		int iJahrVon = cVon.get(Calendar.YEAR);
		int iMonatVon = cVon.get(Calendar.MONTH);

		Calendar cBis = Calendar.getInstance();
		cBis.setTimeInMillis(tKWBis.getTime());
		int iJahrBis = cBis.get(Calendar.YEAR);
		int iMonatBis = cBis.get(Calendar.MONTH);

		ArrayList<Object[]> alDatenMonatsabrechnung = new ArrayList<Object[]>();

		if (iMonatVon != iMonatBis) {
			MonatsabrechnungDto moaDtoVormonat = erstelleMonatsAbrechnung(personalIId, iJahrVon, iMonatVon, true, null,
					theClientDto, false, ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_PERSONALNUMMER,
					false, true, null);

			Object[][] oZeilen = moaDtoVormonat.getData();
			for (int i = 0; i < oZeilen.length; i++) {
				Object[] oZeile = oZeilen[i];

				int iKW = (Integer) oZeile[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_KALENDERWOCHE];

				if (iKW == kwAktuell) {
					alDatenMonatsabrechnung.add(oZeile);
				}

			}

		}

		MonatsabrechnungDto report = erstelleMonatsAbrechnung(personalDto.getIId(), iJahrBis, iMonatBis, false,
				new java.sql.Date(tKWBis.getTime()), theClientDto, false,
				ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_PERSONALNUMMER, false, true, null);

		Object[][] oZeilen = report.getData();
		for (int i = 0; i < oZeilen.length; i++) {
			Object[] oZeile = oZeilen[i];

			int iKW = (Integer) oZeile[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_KALENDERWOCHE];

			if (iKW == kwAktuell) {
				alDatenMonatsabrechnung.add(oZeile);
			}
		}

		// SP3403
		Calendar cEinenTagVorher = Calendar.getInstance();
		cEinenTagVorher.setTime(new java.sql.Date(tKWVon.getTime()));
		cEinenTagVorher.add(Calendar.DAY_OF_YEAR, -1);

		// PJ18816
		// Damit ich die Parameter zum Von-datum habe
		report = erstelleMonatsAbrechnung(personalDto.getIId(), cEinenTagVorher.get(Calendar.YEAR),
				cEinenTagVorher.get(Calendar.MONTH), false, new java.sql.Date(cEinenTagVorher.getTime().getTime()),
				theClientDto, false, ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_PERSONALNUMMER,
				false, false, null);
		HashMap hmParameterMonatsabrechnungVon = report.getParameter();

		parameter.put("P_VERFUEGBARERURLAUBTAGE_ZUM_VON_DATUM",
				hmParameterMonatsabrechnungVon.get("P_VERFUEGBARERURLAUBTAGE"));
		parameter.put("P_VERFUEGBARERURLAUBSTUNDEN_ZUM_VON_DATUM",
				hmParameterMonatsabrechnungVon.get("P_VERFUEGBARERURLAUBSTUNDEN"));

		parameter.put("P_VERFUEGBARERGLEITZEITSALDO_ZUM_VON_DATUM",
				hmParameterMonatsabrechnungVon.get("P_GLEITZEITSALDO_ABRECHNUNGSZEITPUNKT"));

		// Nochmal rechnen zum Bis-Datum
		report = erstelleMonatsAbrechnung(personalDto.getIId(), iJahrBis, iMonatBis, false,
				new java.sql.Date(tKWBis.getTime()), theClientDto, false,
				ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_PERSONALNUMMER, false, false, null);

		HashMap hmParameterMonatsabrechnung = report.getParameter();

		parameter.put("P_VERFUEGBARERURLAUBTAGE", hmParameterMonatsabrechnung.get("P_VERFUEGBARERURLAUBTAGE"));
		parameter.put("P_VERFUEGBARERURLAUBSTUNDEN", hmParameterMonatsabrechnung.get("P_VERFUEGBARERURLAUBSTUNDEN"));

		parameter.put("P_VERFUEGBARERGLEITZEITSALDO",
				hmParameterMonatsabrechnung.get("P_GLEITZEITSALDO_ABRECHNUNGSZEITPUNKT"));

		// Urlaubsanspruch zum Ende des Jahres

		BigDecimal bdAlterAspruchStunden = (BigDecimal) hmParameterMonatsabrechnung
				.get("P_ALTERURLAUBSANSPRUCHSTUNDEN");
		BigDecimal bdAlterVerbrauchtStunden = (BigDecimal) hmParameterMonatsabrechnung
				.get("P_ALTERURLAUBSVERBRAUCHTSTUNDEN");
		BigDecimal bdAktuellerAnspruchStunden = (BigDecimal) hmParameterMonatsabrechnung
				.get("P_AKTUELLERURLAUBSANSPRUCHSTUNDEN");
		BigDecimal bdAktuellerAnspruchVerbrauchtStunden = (BigDecimal) hmParameterMonatsabrechnung
				.get("P_AKTUELLERURLAUBSVERBRAUCHTSTUNDEN");

		parameter.put("P_URLAUBSANSPRUCH_ZUM_ENDE_DES_JAHRES_STUNDEN",
				bdAlterAspruchStunden.subtract(bdAlterVerbrauchtStunden).add(bdAktuellerAnspruchStunden));
		parameter.put("P_VERFUEGBARER_URLAUB_ZUM_ENDE_DES_JAHRES_STUNDEN",
				bdAlterAspruchStunden.subtract(bdAlterVerbrauchtStunden).add(bdAktuellerAnspruchStunden)
						.subtract(bdAktuellerAnspruchVerbrauchtStunden));

		BigDecimal bdAlterAspruchTage = (BigDecimal) hmParameterMonatsabrechnung.get("P_ALTERURLAUBSANSPRUCHTAGE");
		BigDecimal bdAlterVerbrauchtTage = (BigDecimal) hmParameterMonatsabrechnung.get("P_ALTERURLAUBSVERBRAUCHTTAGE");
		BigDecimal bdAktuellerAnspruchTage = (BigDecimal) hmParameterMonatsabrechnung
				.get("P_AKTUELLERURLAUBSANSPRUCHTAGE");
		BigDecimal bdAktuellerAnspruchVerbrauchtTage = (BigDecimal) hmParameterMonatsabrechnung
				.get("P_AKTUELLERURLAUBSVERBRAUCHTTAGE");

		parameter.put("P_URLAUBSANSPRUCH_ZUM_ENDE_DES_JAHRES_TAGE",
				bdAlterAspruchTage.subtract(bdAlterVerbrauchtTage).add(bdAktuellerAnspruchTage));
		parameter.put("P_VERFUEGBARER_URLAUB_ZUM_ENDE_DES_JAHRES_TAGE",
				bdAlterAspruchTage.subtract(bdAlterVerbrauchtTage).add(bdAktuellerAnspruchTage)
						.subtract(bdAktuellerAnspruchVerbrauchtTage));

		Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
		Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();

		// Nun nach Tage gruppieren, da wir ja ansonsten mit Kommt-Geht-Bloecken
		// rechnen

		LinkedHashMap<Integer, ArrayList<Object[]>> hmDatenTageweise = new LinkedHashMap<Integer, ArrayList<Object[]>>();
		for (int i = 0; i < alDatenMonatsabrechnung.size(); i++) {

			Object[] oZeile = alDatenMonatsabrechnung.get(i);

			Integer iTag = (Integer) oZeile[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_TAG];

			if (hmDatenTageweise.containsKey(iTag)) {

				ArrayList<Object[]> alTag = hmDatenTageweise.get(iTag);

				alTag.add(oZeile);
				hmDatenTageweise.put(iTag, alTag);

			} else {
				ArrayList<Object[]> alTag = new ArrayList<Object[]>();

				alTag.add(oZeile);
				hmDatenTageweise.put(iTag, alTag);

			}
		}

		ArrayList alDaten = new ArrayList();

		Iterator<Integer> it = hmDatenTageweise.keySet().iterator();
		while (it.hasNext()) {
			Integer iTag = it.next();
			ArrayList<Object[]> alTag = hmDatenTageweise.get(iTag);

			java.sql.Time kommt = (java.sql.Time) alTag.get(0)[REPORT_MONATSABRECHNUNG_VON];
			java.sql.Time geht = (java.sql.Time) alTag.get(alTag.size() - 1)[REPORT_MONATSABRECHNUNG_BIS];

			Object[] oZeileWochenabschluss = new Object[REPORT_WOCHENABSCHLUSS_ANZAHL_SPALTEN];

			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_KOMMT] = kommt;
			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_GEHT] = geht;

			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_WOCHENTAG] = alTag.get(0)[REPORT_MONATSABRECHNUNG_WOCHENTAG];

			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_SOLL] = getSummeAusMonatsabrechnungsZeile(alTag,
					REPORT_MONATSABRECHNUNG_SOLL);
			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_IST] = getSummeAusMonatsabrechnungsZeile(alTag,
					REPORT_MONATSABRECHNUNG_IST);

			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_FEIERTAG] = getSummeAusMonatsabrechnungsZeile(alTag,
					REPORT_MONATSABRECHNUNG_FEIERTAG);
			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_ARZT] = getSummeAusMonatsabrechnungsZeile(alTag,
					REPORT_MONATSABRECHNUNG_ARZT);
			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_KINDKRANK] = getSummeAusMonatsabrechnungsZeile(alTag,
					REPORT_MONATSABRECHNUNG_KINDKRANK);
			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_KRANK] = getSummeAusMonatsabrechnungsZeile(alTag,
					REPORT_MONATSABRECHNUNG_KRANK);
			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_BEHOERDE] = getSummeAusMonatsabrechnungsZeile(alTag,
					REPORT_MONATSABRECHNUNG_BEHOERDE);

			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_URLAUB] = getSummeAusMonatsabrechnungsZeile(alTag,
					REPORT_MONATSABRECHNUNG_URLAUB);
			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_SONSTIGE_BEZAHLT] = getSummeAusMonatsabrechnungsZeile(alTag,
					REPORT_MONATSABRECHNUNG_SONSTIGE_BEZAHLTETAETIGKEITEN);
			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_SONSTIGE_UNBEZAHLT] = getSummeAusMonatsabrechnungsZeile(alTag,
					REPORT_MONATSABRECHNUNG_SONSTIGE_UNBEZAHLTETAETIGKEITEN);

			Calendar cDatum = Calendar.getInstance();
			cDatum.set(Calendar.YEAR, (Integer) alTag.get(0)[REPORT_MONATSABRECHNUNG_JAHR]);
			cDatum.set(Calendar.MONTH, (Integer) alTag.get(0)[REPORT_MONATSABRECHNUNG_MONAT]);
			cDatum.set(Calendar.DAY_OF_MONTH, (Integer) alTag.get(0)[REPORT_MONATSABRECHNUNG_TAG]);
			java.sql.Timestamp tDatum = Helper.cutTimestamp(new Timestamp(cDatum.getTimeInMillis()));

			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_DATUM] = tDatum;

			try {
				Double dTagesanwesenheitszeit = getZeiterfassungFac().berechneTagesArbeitszeit(personalDto.getIId(),
						new java.sql.Date(tDatum.getTime()), theClientDto);
				nKumuliertesWochenist = nKumuliertesWochenist.add(new BigDecimal(dTagesanwesenheitszeit));

				// Pruefen ob ueberschritten

				ZeitmodelltagDto zmTagDto = getZeitmodelltagZuDatum(personalIId, tDatum, tagesartIId_Feiertag,
						tagesartIId_Halbtag, false, theClientDto);
				if (zmTagDto != null && zmTagDto.getUErlaubteanwesenheitszeit() != null
						&& zmTagDto.getUErlaubteanwesenheitszeit().getTime() != -3600000) {
					double dMaxAnwesenheit = Helper.time2Double(zmTagDto.getUErlaubteanwesenheitszeit());
					if (dTagesanwesenheitszeit != null && dTagesanwesenheitszeit > dMaxAnwesenheit) {
						wDto.setBFehlerVorhanden(true);
						oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_FEHLER] = getTextRespectUISpr(
								"pers.wochenabschluss.tagesarbeitszeitueberschritten", theClientDto.getMandant(),
								theClientDto.getLocUi());
					}
				}

			} catch (javax.ejb.EJBException ex3) {

				oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_FEHLER] = "Fehler in Zeitdaten";
				// SP5323
				wDto.setBFehlerVorhanden(true);
			} catch (EJBExceptionLP ex4) {

				oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_FEHLER] = "Fehler in Zeitdaten";
				// SP5323
				wDto.setBFehlerVorhanden(true);
			} catch (RemoteException e) {
				throwEJBExceptionLPRespectOld(e);

			}

			if (nMaxWochenanwesenheit != null
					&& nKumuliertesWochenist.doubleValue() > nMaxWochenanwesenheit.doubleValue()) {
				wDto.setBFehlerVorhanden(true);
				String sMsgVorhanden = (String) oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_FEHLER];
				if (sMsgVorhanden != null) {
					sMsgVorhanden += ";" + getTextRespectUISpr("pers.wochenabschluss.wochenarbeitszeitueberschritten",
							theClientDto.getMandant(), theClientDto.getLocUi());
				} else {
					sMsgVorhanden = getTextRespectUISpr("pers.wochenabschluss.wochenarbeitszeitueberschritten",
							theClientDto.getMandant(), theClientDto.getLocUi());
				}
				oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_FEHLER] = sMsgVorhanden;
			}

			if (geht != null && bNurWarnung == true) {

				Calendar cUhrzeit = Calendar.getInstance();
				cUhrzeit.setTimeInMillis(geht.getTime());

				Calendar cDatumMitUhrzeit = Calendar.getInstance();
				cDatumMitUhrzeit.setTimeInMillis(tDatum.getTime());
				cDatumMitUhrzeit.set(Calendar.HOUR_OF_DAY, cUhrzeit.get(Calendar.HOUR_OF_DAY));
				cDatumMitUhrzeit.set(Calendar.MINUTE, cUhrzeit.get(Calendar.MINUTE));
				cDatumMitUhrzeit.set(Calendar.SECOND, cUhrzeit.get(Calendar.SECOND));
				cDatumMitUhrzeit.set(Calendar.MILLISECOND, cUhrzeit.get(Calendar.MILLISECOND));

				String sMeldung = erstelleAutomatischeMindestpause(new Timestamp(cDatumMitUhrzeit.getTimeInMillis()),
						personalIId, theClientDto);

				if (sMeldung != null) {
					wDto.setBFehlerVorhanden(true);
					String sMsgVorhanden = (String) oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_FEHLER];
					if (sMsgVorhanden != null) {
						sMsgVorhanden += ";" + sMeldung;
					} else {
						sMsgVorhanden = sMeldung;
					}
					oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_FEHLER] = sMsgVorhanden;
				}

			}

			// Belegzeiten verdichtet

			String sQueryBelegzeiten = "SELECT distinct zeitdaten.c_belegartnr,zeitdaten.i_belegartid,zeitdaten.i_belegartpositionid  from FLRZeitdaten zeitdaten WHERE zeitdaten.flrpersonal.i_id="
					+ personalDto.getIId() + "AND zeitdaten.c_belegartnr is not null AND zeitdaten.t_zeit>='"
					+ Helper.formatTimestampWithSlashes(Helper.cutTimestamp(tDatum)) + "' AND zeitdaten.t_zeit<'"
					+ Helper.formatTimestampWithSlashes(
							Helper.cutTimestamp(Helper.addiereTageZuTimestamp(new Timestamp(tDatum.getTime()), 1)))
					+ "'";

			String[] fieldnames = new String[] { "Belegart", "Belegnummer", "Bezeichnung", "Partner", "Dauer" };

			Session session = FLRSessionFactory.getFactory().openSession();

			org.hibernate.Query query = session.createQuery(sQueryBelegzeiten);

			List<?> resultList = query.list();

			Iterator<?> resultListIterator = resultList.iterator();

			ArrayList alDataSub = new ArrayList();

			while (resultListIterator.hasNext()) {
				Object[] o = (Object[]) resultListIterator.next();

				String belegartCNr = (String) o[0];
				Integer belegartId = (Integer) o[1];
				Integer belegartpositionId = (Integer) o[2];

				BelegInfos bi = null;
				try {
					bi = getLagerFac().getBelegInfos(belegartCNr, belegartId, null, theClientDto);
				} catch (RemoteException e) {
					throwEJBExceptionLPRespectOld(e);
				}

				Object[] oZeileSub = new Object[5];
				oZeileSub[0] = belegartCNr;
				oZeileSub[1] = bi.getBelegnummer();
				oZeileSub[2] = bi.getBelegbezeichnung();
				oZeileSub[3] = bi.getKundeLieferant();
				if (belegartId != null) {

					oZeileSub[4] = getSummeZeitenEinesBeleges(belegartCNr, belegartId, null, personalIId,
							Helper.cutTimestamp(tDatum),
							Helper.cutTimestamp(Helper.addiereTageZuTimestamp(new Timestamp(tDatum.getTime()), 1)),
							theClientDto);
				} else {
					int z = 0;
				}
				alDataSub.add(oZeileSub);
			}

			Object[][] dataSub = new Object[alDataSub.size()][fieldnames.length];
			dataSub = (Object[][]) alDataSub.toArray(dataSub);

			oZeileWochenabschluss[REPORT_WOCHENABSCHLUSS_SUBREPORT_BELEGZEITEN] = new LPDatenSubreport(dataSub,
					fieldnames);

			alDaten.add(oZeileWochenabschluss);

		}

		Object[][] returnArray = new Object[alDaten.size()][REPORT_WOCHENABSCHLUSS_ANZAHL_SPALTEN];
		data = (Object[][]) alDaten.toArray(returnArray);

		sAktuellerReport = ZeiterfassungFac.REPORT_WOCHENABSCHLUSS;

		initJRDS(parameter, ZeiterfassungReportFac.REPORT_MODUL, ZeiterfassungFac.REPORT_WOCHENABSCHLUSS,
				theClientDto.getMandant(), theClientDto.getLocUi(), theClientDto);

		JasperPrintLP print = getReportPrint();

		if (print != null) {
			PrintInfoDto values = new PrintInfoDto();
			values.setDocPath(
					new DocPath(new DocNodeWochenabschlussBeleg(personalDto, personalDto.getPartnerDto(), tKWBis)));
			print.setOInfoForArchive(values);
		}

		wDto.setJasperPrintLP(getReportPrint());

		return wDto;
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public JasperPrintLP printWochenabrechnung(Integer personalIId, Timestamp tVon, Timestamp tBis,
			TheClientDto theClientDto, Integer iOption, Integer kostenstelleIIdAbteilung, Boolean bPlusVersteckte)
			throws EJBExceptionLP {
		JasperPrintLP print = null;
		try {

			PersonalDto[] personalDtos = null;

			if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON) {

				if (personalIId == null) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
							new Exception("personalIId == null"));
				}

				personalDtos = new PersonalDto[1];

				personalDtos[0] = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);

			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_PERSONEN) {
				personalDtos = getPersonalFac().personalFindByMandantCNr(theClientDto.getMandant(), bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_EINE_ABTEILUNG) {
				PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);
				personalDtos = getPersonalFac().personalFindAllPersonenEinerAbteilung(kostenstelleIIdAbteilung,
						theClientDto.getMandant(), bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ARBEITER) {
				personalDtos = getPersonalFac().personalFindAllArbeiterEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ANGESTELLTE) {
				personalDtos = getPersonalFac().personalFindAllAngestellteEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
			} else {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER, new Exception("OPTION NICHT VERFUEGBAR"));
			}

			for (int i = 0; i < personalDtos.length; i++) {

				try {
					if (print != null) {

						print = Helper.addReport2Report(print, erstelleWochenabrechnung(personalDtos[i].getIId(), tVon,
								tBis, false, false, theClientDto).getPrint());
					} else {
						print = erstelleWochenabrechnung(personalDtos[i].getIId(), tVon, tBis, false, false,
								theClientDto);
					}
				} catch (javax.ejb.EJBException ex1) {
					if (ex1.getCause() instanceof EJBExceptionLP) {
						if (((EJBExceptionLP) ex1.getCause())
								.getCode() == EJBExceptionLP.FEHLER_PERSONAL_FEHLER_BEI_EINTRITTSDATUM
								&& iOption
										.intValue() != ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON) {
							// NICHTS - PERSON WIRD AUSGELASSEN
						} else {
							throw new EJBExceptionLP(ex1);
						}

					} else {
						throw new EJBExceptionLP(ex1);
					}

				}
			}
		} catch (RemoteException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		}

		return print;
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public JasperPrintLP printWochenjournal(Integer personalIId, Timestamp tVon, Timestamp tBis,
			TheClientDto theClientDto, Integer iOption, Integer kostenstelleIIdAbteilung, Boolean bPlusVersteckte,
			boolean bNurAnwesende) {
		JasperPrintLP print = null;
		try {

			PersonalDto[] personalDtos = null;

			if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON) {

				if (personalIId == null) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
							new Exception("personalIId == null"));
				}

				personalDtos = new PersonalDto[1];

				personalDtos[0] = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);

			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_PERSONEN) {
				personalDtos = getPersonalFac().personalFindByMandantCNr(theClientDto.getMandant(), bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_EINE_ABTEILUNG) {
				PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);
				personalDtos = getPersonalFac().personalFindAllPersonenEinerAbteilung(kostenstelleIIdAbteilung,
						theClientDto.getMandant(), bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ARBEITER) {
				personalDtos = getPersonalFac().personalFindAllArbeiterEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ANGESTELLTE) {
				personalDtos = getPersonalFac().personalFindAllAngestellteEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
			} else {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER, new Exception("OPTION NICHT VERFUEGBAR"));
			}

			if (bNurAnwesende) {
				personalDtos = getZeiterfassungFac().entferneNichtAnwesendePersonen(tVon, tBis, personalDtos,
						theClientDto);
			}

			for (int i = 0; i < personalDtos.length; i++) {

				try {
					if (print != null) {

						print = Helper.addReport2Report(print,
								erstelleWochenabrechnung(personalDtos[i].getIId(), tVon, tBis, true, true, theClientDto)
										.getPrint());
					} else {
						print = erstelleWochenabrechnung(personalDtos[i].getIId(), tVon, tBis, true, true,
								theClientDto);
					}
				} catch (javax.ejb.EJBException ex1) {
					if (ex1.getCause() instanceof EJBExceptionLP) {
						if (((EJBExceptionLP) ex1.getCause())
								.getCode() == EJBExceptionLP.FEHLER_PERSONAL_FEHLER_BEI_EINTRITTSDATUM
								&& iOption
										.intValue() != ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON) {
							// NICHTS - PERSON WIRD AUSGELASSEN
						} else {
							throw new EJBExceptionLP(ex1);
						}

					} else {
						throw new EJBExceptionLP(ex1);
					}

				}
			}
		} catch (RemoteException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		}

		return print;
	}

	public PersonalDto[] getPersonenDieZeitmodellVerwenden(Integer zeitmodellIId, TheClientDto theClientDto)
			throws EJBExceptionLP {
		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Criteria personal = session.createCriteria(FLRPersonal.class);
		personal.add(Restrictions.eq("mandant_c_nr", theClientDto.getMandant()));

		List<?> resultListArtikel = personal.list();

		Iterator<?> resultListIterator = resultListArtikel.iterator();
		ArrayList<PersonalDto> al = new ArrayList<PersonalDto>();
		while (resultListIterator.hasNext()) {
			FLRPersonal person = (FLRPersonal) resultListIterator.next();
			try {
				PersonalzeitmodellDto zeitmodellDto = getPersonalFac().personalzeitmodellFindZeitmodellZuDatum(
						person.getI_id(), new Timestamp(System.currentTimeMillis()), theClientDto);

				if (zeitmodellDto != null) {
					if (zeitmodellIId.equals(zeitmodellDto.getZeitmodellIId())) {
						al.add(getPersonalFac().personalFindByPrimaryKey(person.getI_id(), theClientDto));
					}
				}
			} catch (RemoteException ex) {
				throwEJBExceptionLPRespectOld(ex);
			}
		}
		PersonalDto[] returnArray = new PersonalDto[al.size()];
		return (PersonalDto[]) al.toArray(returnArray);
	}

	public ArrayList<MaschinenzeitdatenDto> getZeitdatenEinerMaschine(Integer maschineIId,
			java.sql.Timestamp tZeitenVon, java.sql.Timestamp tZeitenBis,

			TheClientDto theClientDto) {

		Session session = FLRSessionFactory.getFactory().openSession();
		org.hibernate.Criteria critMaschine = session.createCriteria(FLRMaschine.class)
				.add(Restrictions.eq("mandant_c_nr", theClientDto.getMandant()));
		if (maschineIId != null) {
			critMaschine.add(Restrictions.eq("i_id", maschineIId));
		}
		List<?> resultListMaschine = critMaschine.list();
		Iterator<?> resultListIteratorMaschine = resultListMaschine.iterator();

		ArrayList<MaschinenzeitdatenDto> alDaten = new ArrayList<MaschinenzeitdatenDto>();

		while (resultListIteratorMaschine.hasNext()) {
			FLRMaschine flrmaschine = (FLRMaschine) resultListIteratorMaschine.next();

			if (Helper.short2boolean(flrmaschine.getB_manuelle_bedienung())) {

				AuftragzeitenDto[] azDtos = getAllZeitenEinesBeleges(null, null, null, null, tZeitenVon, tZeitenBis,
						SORTIERUNG_ZEITDATEN_ZEITPUNKT_PERSONAL, false, null, flrmaschine.getI_id(),
						BELEGZEITEN_NUR_MASCHINENZEITEN, theClientDto);

				for (int i = 0; i < azDtos.length; i++) {
					MaschinenzeitdatenDto dto = new MaschinenzeitdatenDto();

					if (azDtos[i].getBelegpositionIId() != null) {
						dto.setLossollarbeitsplanIId(azDtos[i].getBelegpositionIId());
					}
					dto.setTVon(azDtos[i].getTsBeginn());

					dto.setTBis(azDtos[i].getTsEnde());

					dto.setMaschineIId(flrmaschine.getI_id());
					dto.setCBemerkung(azDtos[i].getSKommentar());
					dto.setBParallel(Helper.boolean2Short(false));

					if (azDtos[i].getZeitdatenIIdBelegbuchung() != null) {
						try {
							ZeitdatenDto zDto = getZeiterfassungFac()
									.zeitdatenFindByPrimaryKey(azDtos[i].getZeitdatenIIdBelegbuchung(), theClientDto);
							dto.setPersonalIIdGestartet(zDto.getPersonalIId());

							dto.setLosIId_WennBeiManuellerBedinungAufkeinenAGGebuchtwurde(zDto.getIBelegartid());

						} catch (RemoteException e) {
							throwEJBExceptionLPRespectOld(e);
						}
					}

					alDaten.add(dto);
				}

			} else {
				SessionFactory factory = FLRSessionFactory.getFactory();
				Session sessionZeitdaten = factory.openSession();

				org.hibernate.Criteria crit = sessionZeitdaten.createCriteria(FLRMaschinenzeitdaten.class)
						.createAlias(ZeiterfassungFac.FLR_ZEITDATEN_FLRMASCHINE, "m")
						.add(Restrictions.eq("m.mandant_c_nr", theClientDto.getMandant()));

				if (maschineIId != null) {
					crit.add(Restrictions.eq("maschine_i_id", maschineIId));
				}

				crit.add(Restrictions.ge(ZeiterfassungFac.FLR_MASCHINENZEITDATEN_T_VON, tZeitenVon));
				crit.add(Restrictions.lt(ZeiterfassungFac.FLR_MASCHINENZEITDATEN_T_VON, tZeitenBis));

				crit.addOrder(Order.asc(ZeiterfassungFac.FLR_MASCHINENZEITDATEN_T_VON));

				List<?> resultList = crit.list();

				Iterator<?> resultListIterator = resultList.iterator();

				int row = 0;
				while (resultListIterator.hasNext()) {
					FLRMaschinenzeitdaten flrzeitdaten = (FLRMaschinenzeitdaten) resultListIterator.next();
					MaschinenzeitdatenDto dto = new MaschinenzeitdatenDto();
					dto.setIId(flrzeitdaten.getI_id());
					dto.setLossollarbeitsplanIId(flrzeitdaten.getFlrlossollarbeitsplan().getI_id());
					dto.setTVon(new Timestamp(flrzeitdaten.getT_von().getTime()));
					if (flrzeitdaten.getT_bis() == null) {
						dto.setTBis(new Timestamp(System.currentTimeMillis()));
					} else {
						dto.setTBis(new Timestamp(flrzeitdaten.getT_bis().getTime()));
					}
					dto.setMaschineIId(flrzeitdaten.getMaschine_i_id());
					dto.setPersonalIIdGestartet(flrzeitdaten.getPersonal_i_id_gestartet());
					dto.setCBemerkung(flrzeitdaten.getC_bemerkung());
					dto.setBParallel(flrzeitdaten.getB_parallel());

					alDaten.add(dto);

				}
				sessionZeitdaten.close();

			}

		}
		return alDaten;
	}

	public Map getAllMaschinen(TheClientDto theClientDto) {

		LinkedHashMap<String, String> tmArten = new LinkedHashMap<String, String>();

		String sQuery = "select m FROM FLRMaschine m WHERE m.mandant_c_nr = '" + theClientDto.getMandant()
				+ "' ORDER BY m.flrmaschinengruppe.c_bez, m.c_bez ASC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query query = session.createQuery(sQuery);

		List<?> resultList = query.list();

		Iterator<?> resultListIterator = resultList.iterator();

		while (resultListIterator.hasNext()) {
			FLRMaschine m = (FLRMaschine) resultListIterator.next();

			if (!tmArten.containsValue(m.getFlrmaschinengruppe().getC_bez())) {
				tmArten.put("G" + m.getFlrmaschinengruppe().getI_id(), m.getFlrmaschinengruppe().getC_bez());
			}

			String cBez = "";
			if (m.getC_bez() != null) {
				cBez = m.getC_bez();
			}

			cBez = "    " + cBez;

			tmArten.put("M" + m.getI_id(), cBez);

		}

		return tmArten;
	}

	public ArrayList<AuftragzeitenDto> getAllTelefonzeitenEinesProjekts(Integer projektIId, Integer personalIId,
			java.sql.Timestamp tVon, java.sql.Timestamp tZeitenBis, TheClientDto theClientDto) {

		ArrayList<AuftragzeitenDto> alDaten = new ArrayList<AuftragzeitenDto>();

		// PJ18444 Telefonzeiten hinzufuegen
		int iOption = 0;
		ParametermandantDto parameter = null;
		try {
			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_PERSONALKOSTEN_QUELLE);

			iOption = ((Integer) parameter.getCWertAsObject()).intValue();

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		HashMap hmGestpreise = new HashMap();
		ArtikelDto artikelDtoDefaultArbeiztszeit = getDefaultArbeitszeitartikel(theClientDto);

		Session sessionTelefon = FLRSessionFactory.getFactory().openSession();

		String sQuerytelefon = "SELECT tz FROM FLRTelefonzeiten tz WHERE tz.projekt_i_id=" + projektIId;

		if (tVon != null) {

			sQuerytelefon += " AND tz.t_von>='" + Helper.formatTimestampWithSlashes(Helper.cutTimestamp(tVon)) + "'";

		}

		if (tZeitenBis != null) {
			sQuerytelefon += " AND tz.t_bis<='" + Helper.formatTimestampWithSlashes(tZeitenBis) + "'";
		}

		if (personalIId != null) {

			sQuerytelefon += " AND tz.personal_i_id=" + personalIId;

		}

		org.hibernate.Query queryTelefon = sessionTelefon.createQuery(sQuerytelefon);

		List<?> resultListTelefon = queryTelefon.list();
		Iterator<?> resultListIteratorTelefon = resultListTelefon.iterator();
		while (resultListIteratorTelefon.hasNext()) {

			FLRTelefonzeiten flrTelefonzeiten = (FLRTelefonzeiten) resultListIteratorTelefon.next();

			// 2 Zeilen hinzufuegen

			AuftragzeitenDto dtoTemp = new AuftragzeitenDto();
			dtoTemp.setBTelefonzeit(true);
			dtoTemp.setSArtikelcnr(artikelDtoDefaultArbeiztszeit.getCNr());
			dtoTemp.setArtikelIId(artikelDtoDefaultArbeiztszeit.getIId());

			if (artikelDtoDefaultArbeiztszeit.getArtikelsprDto() != null) {
				dtoTemp.setSArtikelbezeichnung(artikelDtoDefaultArbeiztszeit.getArtikelsprDto().getCBez());
				dtoTemp.setSArtikelzusatzbezeichnung(artikelDtoDefaultArbeiztszeit.getArtikelsprDto().getCZbez());
			}
			dtoTemp.setTsBeginn(new Timestamp(flrTelefonzeiten.getT_von().getTime()));
			dtoTemp.setTsEnde(new Timestamp(flrTelefonzeiten.getT_bis().getTime()));

			java.sql.Time tDauer = new java.sql.Time(
					flrTelefonzeiten.getT_bis().getTime() - flrTelefonzeiten.getT_von().getTime());
			tDauer.setTime(tDauer.getTime() - 3600000);
			dtoTemp.setTDauer(tDauer);
			Double dDauer = Helper.time2Double(tDauer);
			dtoTemp.setDdDauer(dDauer);
			dtoTemp.setSBewegungsart(ZeiterfassungFac.TAETIGKEIT_TELEFON);

			String sName = flrTelefonzeiten.getFlrpersonal().getFlrpartner().getC_name1nachnamefirmazeile1();
			if (flrTelefonzeiten.getFlrpersonal().getFlrpartner().getC_name2vornamefirmazeile2() != null) {
				sName = flrTelefonzeiten.getFlrpersonal().getFlrpartner().getC_name2vornamefirmazeile2() + " " + sName;
			}

			dtoTemp.setSPersonalMaschinenname(sName);

			String sNameNachnameVorname = flrTelefonzeiten.getFlrpersonal().getFlrpartner()
					.getC_name1nachnamefirmazeile1();
			if (flrTelefonzeiten.getFlrpersonal().getFlrpartner().getC_name2vornamefirmazeile2() != null) {
				sNameNachnameVorname = sNameNachnameVorname + " "
						+ flrTelefonzeiten.getFlrpersonal().getFlrpartner().getC_name2vornamefirmazeile2();
			}

			dtoTemp.setsPersonNachnameVorname(sNameNachnameVorname);

			dtoTemp.setSPersonalKurzzeichen(flrTelefonzeiten.getFlrpersonal().getC_kurzzeichen());

			dtoTemp.setSPersonalnummer(flrTelefonzeiten.getFlrpersonal().getC_personalnummer());
			dtoTemp.setSZeitbuchungtext(flrTelefonzeiten.getX_kommentarext());

			BigDecimal bdKostenProStunde = getPersonalKostenProStunde(theClientDto, hmGestpreise, iOption,
					artikelDtoDefaultArbeiztszeit.getIId(), flrTelefonzeiten.getFlrpersonal().getI_id(),
					new Timestamp(flrTelefonzeiten.getT_von().getTime()));
			dtoTemp.setBdKosten(bdKostenProStunde.multiply(new BigDecimal(dDauer)));

			alDaten.add(dtoTemp);

		}
		sessionTelefon.close();

		return alDaten;
	}

	public ArtikelDto getDefaultArbeitszeitartikel(TheClientDto theClientDto) {
		ArtikelDto artikelDtoDefaultArbeiztszeit = null;
		try {
			ParametermandantDto parameterDtoDefaultarbeitszeit = getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_ALLGEMEIN,
					ParameterFac.PARAMETER_DEFAULT_ARBEITSZEITARTIKEL);

			if (parameterDtoDefaultarbeitszeit != null && parameterDtoDefaultarbeitszeit.getCWert() != null
					&& !parameterDtoDefaultarbeitszeit.getCWert().trim().equals("")) {
				try {

					artikelDtoDefaultArbeiztszeit = getArtikelFac()
							.artikelFindByCNr(parameterDtoDefaultarbeitszeit.getCWert(), theClientDto);

				} catch (EJBExceptionLP ex2) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DEFAULT_ARBEITSZEITARTIKEL_NICHT_DEFINIERT,
							new Exception("FEHLER_DEFAULT_ARBEITSZEITARTIKEL_NICHT_DEFINIERT"));
				}
			} else {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DEFAULT_ARBEITSZEITARTIKEL_NICHT_DEFINIERT,
						new Exception("FEHLER_DEFAULT_ARBEITSZEITARTIKEL_NICHT_DEFINIERT"));
			}
		} catch (RemoteException e) {
			throwEJBExceptionLPRespectOld(e);
		}
		return artikelDtoDefaultArbeiztszeit;
	}

	public AuftragzeitenDto[] getAllMaschinenzeitenEinesBeleges(Integer losIId, Integer lossollarbeitsplanIId,
			java.sql.Timestamp tVon, java.sql.Timestamp tZeitenBis, TheClientDto theClientDto) throws EJBExceptionLP {

		boolean bTheoretischeIstZeit = false;

		try {
			ParametermandantDto parameterIstZeit = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_THEORETISCHE_IST_ZEIT_RECHNUNG);

			bTheoretischeIstZeit = ((Boolean) parameterIstZeit.getCWertAsObject());

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();

		String s = "SELECT m, (SELECT spr.c_bez FROM FLRArtikellistespr as spr WHERE spr.Id.artikelliste=m.flrlossollarbeitsplan.flrartikel.i_id AND spr.Id.locale='"
				+ theClientDto.getLocUiAsString()
				+ "' ),(SELECT spr.c_zbez FROM FLRArtikellistespr as spr WHERE spr.Id.artikelliste=m.flrlossollarbeitsplan.flrartikel.i_id AND spr.Id.locale='"
				+ theClientDto.getLocUiAsString()
				+ "' ) FROM FLRMaschinenzeitdaten m WHERE m.flrmaschine.b_manuelle_bedienung=0 ";

		if (losIId != null) {
			s += " AND m.flrlossollarbeitsplan.flrlos.i_id=" + losIId;
		}

		if (lossollarbeitsplanIId != null) {
			s += " AND m.flrlossollarbeitsplan.i_id=" + lossollarbeitsplanIId;
		}

		if (bTheoretischeIstZeit == true) {
			// Es gibt dann fuer Umspannzeit/Laufzeit nur die Theoretische
			// IST-Zeit
			s += " AND m.flrlossollarbeitsplan.agart_c_nr IS NULL ";
		}
		if (tVon != null) {
			s += " AND m.t_von>='" + Helper.formatTimestampWithSlashes(tVon) + "' ";
		}
		if (tZeitenBis != null) {
			s += " AND m.t_bis<'" + Helper.formatTimestampWithSlashes(tZeitenBis) + "'";
		}

		s += " ORDER BY m.t_von";

		org.hibernate.Query inventurliste = session.createQuery(s);

		List<?> resultList = inventurliste.list();

		Iterator<?> resultListIterator = resultList.iterator();
		ArrayList<AuftragzeitenDto> al = new ArrayList<AuftragzeitenDto>();
		while (resultListIterator.hasNext()) {
			Object[] o = (Object[]) resultListIterator.next();
			FLRMaschinenzeitdaten flrBelege = (FLRMaschinenzeitdaten) o[0];

			AuftragzeitenDto dto = new AuftragzeitenDto();

			dto.setZeitdatenIIdBelegbuchung(flrBelege.getI_id());
			dto.setSZeitbuchungtext(flrBelege.getC_bemerkung());
			dto.setBelegpositionIId(flrBelege.getFlrlossollarbeitsplan().getI_id());
			dto.setSPersonalnummer(flrBelege.getFlrmaschine().getC_inventarnummer());
			dto.setMaschinengruppe(flrBelege.getFlrmaschine().getFlrmaschinengruppe().getC_bez());
			dto.setIPersonalMaschinenId(flrBelege.getFlrmaschine().getI_id());

			dto.setSArtikelcnr(flrBelege.getFlrlossollarbeitsplan().getFlrartikel().getC_nr());

			dto.setSArtikelbezeichnung((String) o[1]);
			dto.setSArtikelzusatzbezeichnung((String) o[2]);

			dto.setArtikelIId(flrBelege.getFlrlossollarbeitsplan().getFlrartikel().getI_id());

			String maschinenname = "M:";
			if (flrBelege.getFlrmaschine().getC_identifikationsnr() != null) {
				maschinenname += flrBelege.getFlrmaschine().getC_identifikationsnr() + " ";
			}

			dto.setiArbeitsgang(flrBelege.getFlrlossollarbeitsplan().getI_arbeitsgangsnummer());
			dto.setiUnterarbeitsgang(flrBelege.getFlrlossollarbeitsplan().getI_unterarbeitsgang());

			maschinenname += flrBelege.getFlrmaschine().getC_bez();
			dto.setSPersonalMaschinenname(maschinenname);
			dto.setsPersonNachnameVorname(maschinenname);
			dto.setTsBeginn(new Timestamp(flrBelege.getT_von().getTime()));

			Timestamp tBis = null;

			if (flrBelege.getT_bis() != null) {
				tBis = new Timestamp(flrBelege.getT_bis().getTime());
			} else {
				tBis = new Timestamp(System.currentTimeMillis());
			}

			dto.setTsEnde(tBis);

			java.sql.Time tDauer = new java.sql.Time(tBis.getTime() - flrBelege.getT_von().getTime());
			tDauer.setTime(tDauer.getTime() - 3600000);
			dto.setTDauer(tDauer);
			Double dDauer = ((double) tBis.getTime() - (double) flrBelege.getT_von().getTime()) / (double) 3600000;
			dto.setDdDauer(dDauer);

			BigDecimal stundensatz = getMaschinenKostenZumZeitpunkt(flrBelege.getFlrmaschine().getI_id(),
					new Timestamp(flrBelege.getT_von().getTime()), LocaleFac.BELEGART_LOS,
					flrBelege.getFlrlossollarbeitsplan().getI_id()).getBdStundensatz();

			dto.setBdKosten(stundensatz.multiply(new BigDecimal(dDauer.doubleValue())));

			al.add(dto);

		}
		session.close();

		// SP7102
		AuftragzeitenDto[] maschinenzeitenAusPersonalzeitdaten = getAllZeitenEinesBeleges(LocaleFac.BELEGART_LOS,
				losIId, lossollarbeitsplanIId, null, tVon, tZeitenBis, SORTIERUNG_ZEITDATEN_PERSONAL, false, null, null,
				BELEGZEITEN_NUR_MASCHINENZEITEN, theClientDto);
		for (int i = 0; i < maschinenzeitenAusPersonalzeitdaten.length; i++) {
			al.add(maschinenzeitenAusPersonalzeitdaten[i]);
		}

		AuftragzeitenDto[] azDtos = new AuftragzeitenDto[al.size()];
		for (int i = 0; i < al.size(); i++) {
			azDtos[i] = (AuftragzeitenDto) al.get(i);
		}

		// PJ 15810 Wenn Los, dann Theoretische Ist-Zeit berechnen

		if (bTheoretischeIstZeit == true && losIId != null) {
			azDtos = theoretischeIstzeitHinzufuegen(azDtos, losIId, lossollarbeitsplanIId, null, null, null, true,
					theClientDto);
		}

		for (int i = azDtos.length - 1; i > 0; --i) {
			for (int j = 0; j < i; ++j) {
				if (azDtos[j].getSPersonalMaschinenname().compareTo(azDtos[j + 1].getSPersonalMaschinenname()) > 0) {
					AuftragzeitenDto tauschDto = azDtos[j];
					azDtos[j] = azDtos[j + 1];
					azDtos[j + 1] = tauschDto;
				}
			}
		}

		return azDtos;
	}

	public ArrayList<Integer> getMaschinenzeitenEinesTagesEinesAGsUndEinerPerson(Integer personalIId,
			Integer lossollarbeitsplanIId, java.sql.Date tDatum, TheClientDto theClientDto) {

		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();

		String s = "SELECT m  FROM FLRMaschinenzeitdaten m WHERE m.flrlossollarbeitsplan.i_id=" + lossollarbeitsplanIId;

		s += " AND m.personal_i_id_gestartet=" + personalIId;

		s += " AND m.t_von>='" + Helper.formatDateWithSlashes(tDatum) + "' ";

		s += " AND m.t_von<'" + Helper.formatDateWithSlashes(Helper.addiereTageZuDatum(tDatum, 1)) + "' ";

		s += " ORDER BY m.i_id";

		org.hibernate.Query inventurliste = session.createQuery(s);

		List<?> resultList = inventurliste.list();

		Iterator<?> resultListIterator = resultList.iterator();
		ArrayList<Integer> al = new ArrayList<Integer>();
		while (resultListIterator.hasNext()) {
			FLRMaschinenzeitdaten o = (FLRMaschinenzeitdaten) resultListIterator.next();

			al.add(o.getI_id());

		}
		session.close();

		return al;
	}

	public boolean sindBelegzeitenVorhanden(String cBelegartnr, Integer belegartIId) {
		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();
		org.hibernate.Criteria zeitdatenEinesBelegs = session.createCriteria(FLRZeitdaten.class);

		zeitdatenEinesBelegs.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_I_BELEGARTID, belegartIId));
		zeitdatenEinesBelegs.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_C_BELEGARTNR, cBelegartnr));

		List<?> resultList = zeitdatenEinesBelegs.list();

		if (resultList.size() > 0) {
			return true;
		} else {
			return false;
		}

	}

	public boolean sindZuvieleZeitdatenEinesBelegesVorhanden(String belegartCNr, Integer belegartIId,
			TheClientDto theClientDto) {

		int iAnzahl = 50;

		ParametermandantDto parameter = null;
		try {
			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_MAXIMALE_EINTRAEGE_SOLLZEITPRUEFUNG);

			iAnzahl = ((Integer) parameter.getCWertAsObject()).intValue();

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		String sQuery = "select count(*) FROM FLRZeitdaten zeitdaten WHERE zeitdaten.c_belegartnr='" + belegartCNr
				+ "' AND zeitdaten.i_belegartid=" + belegartIId;

		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();

		org.hibernate.Query inventurliste = session.createQuery(sQuery);

		List<?> resultList = inventurliste.list();

		Iterator<?> resultListIterator = resultList.iterator();

		if (resultListIterator.hasNext()) {
			Long l = (Long) resultListIterator.next();
			if (l > iAnzahl) {
				return true;
			}
		}

		return false;

	}

	@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
	public AuftragzeitenDto[] getAllZeitenEinesBeleges(String belegartCNr, Integer belegartIId,
			Integer belegartpositionIId, Integer personalIId, java.sql.Timestamp tZeitenVon,
			java.sql.Timestamp tZeitenBis, int iSortierung, TheClientDto theClientDto) {
		return getAllZeitenEinesBeleges(belegartCNr, belegartIId, belegartpositionIId, personalIId, tZeitenVon,
				tZeitenBis, iSortierung, true, theClientDto);
	}

	@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
	public AuftragzeitenDto[] getAllZeitenEinesBeleges(String belegartCNr, Integer belegartIId,
			Integer belegartpositionIId, Integer personalIId, java.sql.Timestamp tZeitenVon,
			java.sql.Timestamp tZeitenBis, int iSortierung, boolean bBeruecksichtigeLeistungsfaktor,
			TheClientDto theClientDto) {
		return getAllZeitenEinesBeleges(belegartCNr, belegartIId, belegartpositionIId, personalIId, tZeitenVon,
				tZeitenBis, iSortierung, bBeruecksichtigeLeistungsfaktor, null, null, BELEGZEITEN_NUR_PERSONALZEITEN,
				theClientDto);
	}

	@TransactionAttribute(TransactionAttributeType.SUPPORTS)
	public AuftragzeitenDto[] getAllZeitenEinesBeleges(String belegartCNr, Integer belegartIId,
			Integer belegartpositionIId, Integer personalIId, java.sql.Timestamp tZeitenVon,
			java.sql.Timestamp tZeitenBis, int iSortierung, boolean bBeruecksichtigeLeistungsfaktor,
			Integer zeitdatenIId, Integer maschineIId, int iArtBelegzeiten, TheClientDto theClientDto) {

		HashMap<String, PersonalgehaltDto> personalgehaltCache = new HashMap<String, PersonalgehaltDto>();

		HashMap<Integer, TaetigkeitDto> taetigkeitenCache = new HashMap<Integer, TaetigkeitDto>();

		boolean bTheoretischeIstZeit = false;
		boolean bVonBisErfassung = false;

		try {
			ParametermandantDto parameterIstZeit = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_THEORETISCHE_IST_ZEIT_RECHNUNG);

			bTheoretischeIstZeit = ((Boolean) parameterIstZeit.getCWertAsObject());

			ParametermandantDto parameterVonBis = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_VON_BIS_ERFASSUNG);

			bVonBisErfassung = ((Boolean) parameterVonBis.getCWertAsObject());

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		// Hole id der Taetigkeit GEHT
		Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();
		// Hole id der Taetigkeit ENDE
		Integer taetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();
		// Hole id der Taetigkeit UNTER
		Integer taetigkeitIId_Unter = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER, theClientDto).getIId();
		// try {

		String sQueryAuftragzeiten = "SELECT z,(SELECT spr.c_bez FROM FLRArtikellistespr as spr WHERE spr.Id.artikelliste=z.flrartikel.i_id AND spr.Id.locale='"
				+ theClientDto.getLocUiAsString()
				+ "' ),(SELECT spr.c_zbez FROM FLRArtikellistespr as spr WHERE spr.Id.artikelliste=z.flrartikel.i_id AND spr.Id.locale='"
				+ theClientDto.getLocUiAsString()
				+ "' ),(select min(t_zeit) FROM FLRZeitdaten zeitdaten WHERE zeitdaten.t_zeit>z.t_zeit AND zeitdaten.personal_i_id=z.personal_i_id AND (zeitdaten.taetigkeit_i_id ="
				+ taetigkeitIId_Geht + " OR zeitdaten.taetigkeit_i_id = " + taetigkeitIId_Ende
				+ " OR zeitdaten.i_belegartid IS NOT NULL)) FROM FLRZeitdatenLos z WHERE z.c_belegartnr IS NOT NULL AND z.i_belegartid IS NOT NULL ";

		if (belegartCNr != null) {
			sQueryAuftragzeiten += " AND z.c_belegartnr='" + belegartCNr + "'";
		}

		if (belegartIId != null) {
			sQueryAuftragzeiten += " AND z.i_belegartid=" + belegartIId;
		}

		if (personalIId != null) {

			sQueryAuftragzeiten += " AND z.personal_i_id=" + personalIId;

		}

		if (iArtBelegzeiten == BELEGZEITEN_NUR_MASCHINENZEITEN) {
			sQueryAuftragzeiten += " AND z.flrmaschine.i_id IS NOT NULL ";
		}

		if (maschineIId != null) {

			sQueryAuftragzeiten += " AND z.flrmaschine.i_id=" + maschineIId;

		}

		if (belegartpositionIId != null) {
			sQueryAuftragzeiten += " AND z.i_belegartpositionid=" + belegartpositionIId;
		}

		if (bTheoretischeIstZeit == true && belegartCNr != null && belegartCNr.equals(LocaleFac.BELEGART_LOS)) {
			sQueryAuftragzeiten += " AND z.flrlossollarbeitsplan.agart_c_nr IS NULL ";
		}

		if (zeitdatenIId != null) {
			sQueryAuftragzeiten += " AND z.i_id=" + zeitdatenIId;
		}

		// WG MITTERNACHTSSPRUNG
		// Daten einen Tag vorher holen wg. Mitternachtssprung

		if (tZeitenVon != null) {

			sQueryAuftragzeiten += " AND z.t_zeit>='" + Helper.formatTimestampWithSlashes(
					Helper.cutTimestamp(new Timestamp(tZeitenVon.getTime() - (3600000 * 24)))) + "'";

		}

		if (tZeitenBis != null) {
			sQueryAuftragzeiten += " AND z.t_zeit<'" + Helper.formatTimestampWithSlashes(tZeitenBis) + "'";
		}

		sQueryAuftragzeiten += " ORDER BY z.t_zeit ASC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query zeiten = session.createQuery(sQueryAuftragzeiten);

		List<?> resultList = zeiten.list();

		Iterator<?> resultListAuftraege = resultList.iterator();

		ArrayList<ZeitdatenDtoBelegzeiten[]> alAuftragszeit = new ArrayList<ZeitdatenDtoBelegzeiten[]>();

		HashMap hmGestpreise = new HashMap();

		while (resultListAuftraege.hasNext()) {
			Object[] o = (Object[]) resultListAuftraege.next();
			FLRZeitdatenLos auftragszeit = (FLRZeitdatenLos) o[0];

			Timestamp tBis = Helper
					.cutTimestamp(Helper.addiereTageZuTimestamp(new Timestamp(auftragszeit.getT_zeit().getTime()), 1));

			Timestamp tNaechstesGeht = (Timestamp) o[3];

			boolean bZeitIstOffen = false;

			if (tNaechstesGeht != null) {

				tBis = new Timestamp(tNaechstesGeht.getTime() + 5);
				if (tZeitenVon != null && tBis.before(tZeitenVon)) {
					continue;
				}
			} else {
				bZeitIstOffen = true;
			}

			Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
			query.setParameter(1, auftragszeit.getPersonal_i_id());
			query.setParameter(2, auftragszeit.getT_zeit());

			query.setParameter(3, tBis);
			ZeitdatenDto[] tagesDaten = assembleZeitdatenDtos(query.getResultList());

			// Hier Mitternachtssprung simulieren, d.h. wenn die letzte Buchung
			// kein Geht ist, dann das naechste Geht suchen
			if (tZeitenVon != null) {
				for (int i = 0; i < tagesDaten.length; i++) {
					if (tagesDaten[i].getTZeit().before(tZeitenVon)) {
						tagesDaten[i].setTZeit(tZeitenVon);
					}
				}
			}
			if (tZeitenBis != null) {
				for (int i = 0; i < tagesDaten.length; i++) {
					if (tagesDaten[i].getTZeit().after(tZeitenBis)) {
						tagesDaten[i].setTZeit(tZeitenBis);
					}
				}
			}

			if (bZeitIstOffen == true) {
				// Einen ENDE Eintrag hinzufuegen

				ArrayList<ZeitdatenDto> alNeu = new ArrayList<ZeitdatenDto>();

				ZeitdatenDto zDtoOffen = ZeitdatenDto.clone(tagesDaten[0]);

				for (int i = 0; i < tagesDaten.length; i++) {
					alNeu.add(tagesDaten[i]);
				}

				// SP3044 Wenn vorher auch noch ein Pause-Beginn jedoch kein
				// Pause Ende gebucht wurde, dann muss die Pause ebenfalls
				// beendet werden
				ArrayList<ZeitdatenDto> alUnter = new ArrayList<ZeitdatenDto>();
				for (int i = 0; i < alNeu.size(); i++) {
					ZeitdatenDto zeitdatenDto = alNeu.get(i);
					if (zeitdatenDto.getTaetigkeitIId() != null
							&& zeitdatenDto.getTaetigkeitIId().equals(taetigkeitIId_Unter)) {
						alUnter.add(zeitdatenDto);
					}
				}

				zDtoOffen.setArtikelIId(null);
				zDtoOffen.setCBelegartnr(null);
				zDtoOffen.setIBelegartid(null);
				zDtoOffen.setIBelegartpositionid(null);

				if (alUnter.size() % 2 == 1) {
					zDtoOffen.setTaetigkeitIId(taetigkeitIId_Unter);
					zDtoOffen.setTZeit(new Timestamp(System.currentTimeMillis()));
					alNeu.add(zDtoOffen);
				}
				zDtoOffen = ZeitdatenDto.clone(zDtoOffen);
				zDtoOffen.setTaetigkeitIId(taetigkeitIId_Ende);

				Timestamp tJetzt = new Timestamp(System.currentTimeMillis());

				if (tJetzt.before(tagesDaten[tagesDaten.length - 1].getTZeit())) {
					zDtoOffen.setTZeit(tagesDaten[tagesDaten.length - 1].getTZeit());
				} else {
					zDtoOffen.setTZeit(new Timestamp(System.currentTimeMillis()));
				}

				alNeu.add(zDtoOffen);

				tagesDaten = alNeu.toArray(new ZeitdatenDto[alNeu.size()]);

			}

			if (tagesDaten.length > 1) {
				int iZaehler = 0;
				for (int j = 0; j < tagesDaten.length; j++) {
					ZeitdatenDto bewegungsdatensatz = tagesDaten[j];

					iZaehler++;
					// Auftrag wird durch ENDE,GEHT oder neuen Beleg
					// abgeschlossen
					if ((bewegungsdatensatz.getTaetigkeitIId() != null
							&& bewegungsdatensatz.getTaetigkeitIId().equals(taetigkeitIId_Ende))
							|| (bewegungsdatensatz.getTaetigkeitIId() != null
									&& bewegungsdatensatz.getTaetigkeitIId().equals(taetigkeitIId_Geht))
							|| (bewegungsdatensatz.getCBelegartnr() != null
									&& bewegungsdatensatz.getIBelegartid() != null && j > 0)) {

						if (iZaehler % 2 == 1) {
							ArrayList<Object> al = new ArrayList<Object>();
							al.add(bewegungsdatensatz.getPersonalIId());
							al.add(tagesDaten[0].getTZeit());

							PersonalDto pDto = getPersonalFac()
									.personalFindByPrimaryKey(bewegungsdatensatz.getPersonalIId(), theClientDto);

							throw new EJBExceptionLP(EJBExceptionLP.FEHLER_IN_ZEITDATEN, al,
									new Exception("FEHLER_IN_ZEITDATEN" + " (" + pDto.getCKurzzeichen() + ") " + Helper
											.formatTimestamp(tagesDaten[0].getTZeit(), theClientDto.getLocUi())));
						}

						ZeitdatenDtoBelegzeiten[] alleZeitdatenEinesAuftrages = new ZeitdatenDtoBelegzeiten[iZaehler];
						for (int l = 0; l < iZaehler; l++) {
							ZeitdatenDtoBelegzeiten dtoTemp = new ZeitdatenDtoBelegzeiten();

							if (auftragszeit.getFlrartikel() != null) {
								dtoTemp.setArtikel(auftragszeit.getFlrartikel().getC_nr());
								if (auftragszeit.getFlrartikel().getFlrartikelgruppe() != null) {
									dtoTemp.setArtgruIId(auftragszeit.getFlrartikel().getFlrartikelgruppe().getI_id());
									dtoTemp.setSArtikelgruppe(
											auftragszeit.getFlrartikel().getFlrartikelgruppe().getC_nr());
								}
								if (auftragszeit.getFlrartikel().getFlrartikelklasse() != null) {
									dtoTemp.setArtklaIId(auftragszeit.getFlrartikel().getFlrartikelklasse().getI_id());
								}
								dtoTemp.setBezeichnung((String) o[1]);
								dtoTemp.setZusatzbezeichnung((String) o[2]);
							}

							if (auftragszeit.getC_belegartnr() != null
									&& auftragszeit.getC_belegartnr().equals(LocaleFac.BELEGART_LOS)
									&& auftragszeit.getI_belegartpositionid() != null) {

								try {

									if (auftragszeit.getFlrlossollarbeitsplan() != null) {

										dtoTemp.setArbeitsgang(
												auftragszeit.getFlrlossollarbeitsplan().getI_arbeitsgangsnummer());
										dtoTemp.setUnterarbeitsgang(
												auftragszeit.getFlrlossollarbeitsplan().getI_unterarbeitsgang());
									}
								} catch (Throwable e) {
									//
									int i = 0;
								}

							}

							String sName = auftragszeit.getFlrpersonal().getFlrpartner()
									.getC_name1nachnamefirmazeile1();
							if (auftragszeit.getFlrpersonal().getFlrpartner().getC_name2vornamefirmazeile2() != null) {
								sName = auftragszeit.getFlrpersonal().getFlrpartner().getC_name2vornamefirmazeile2()
										+ " " + sName;
							}

							dtoTemp.setPerson(sName);

							String sNameNachnameVorname = auftragszeit.getFlrpersonal().getFlrpartner()
									.getC_name1nachnamefirmazeile1();
							if (auftragszeit.getFlrpersonal().getFlrpartner().getC_name2vornamefirmazeile2() != null) {
								sNameNachnameVorname = sNameNachnameVorname + " "
										+ auftragszeit.getFlrpersonal().getFlrpartner().getC_name2vornamefirmazeile2();
							}

							dtoTemp.setPersonNachnameVorname(sNameNachnameVorname);
							dtoTemp.setSPersonalKurzzeichen(auftragszeit.getFlrpersonal().getC_kurzzeichen());

							dtoTemp.setPersonalnummer(auftragszeit.getFlrpersonal().getC_personalnummer());

							dtoTemp.setZeitdatenDto(tagesDaten[l]);

							// Beim letzten OFFEN hinzufuegen
							// SP2596 Ausser bei Von-Bis-Erfassung

							if (bVonBisErfassung == false) {

								if (bZeitIstOffen == true && l == iZaehler - 1) {
									dtoTemp.setbOffen(true);
								}
							}

							alleZeitdatenEinesAuftrages[l] = dtoTemp;
						}

						alAuftragszeit.add(alleZeitdatenEinesAuftrages);

						break;
					}

				}
			}
		}

		int iOption = 0;
		ParametermandantDto parameter = null;
		try {
			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_PERSONALKOSTEN_QUELLE);

			iOption = ((Integer) parameter.getCWertAsObject()).intValue();

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		ArrayList<AuftragzeitenDto> alAzDtos = new ArrayList<AuftragzeitenDto>();

		for (int i = 0; i < alAuftragszeit.size(); i++) {
			ZeitdatenDtoBelegzeiten[] einePositionDto = alAuftragszeit.get(i);

			AuftragzeitenDto azDtos = new AuftragzeitenDto();

			if (einePositionDto.length > 1) {

				for (int x = 0; x < einePositionDto.length - 1; x++) {
					if (x % 2 == 0) {

						ZeitdatenDto dtoBeginn = einePositionDto[x].getZeitdatenDto();
						ZeitdatenDto dtoEnde = einePositionDto[x + 1].getZeitdatenDto();
						azDtos = new AuftragzeitenDto();
						azDtos.setBelegpositionIId(einePositionDto[0].getZeitdatenDto().getIBelegartpositionid());
						azDtos.setZeitdatenIIdBelegbuchung(einePositionDto[0].getZeitdatenDto().getIId());

						java.sql.Time tDauer = new java.sql.Time(
								dtoEnde.getTZeit().getTime() - dtoBeginn.getTZeit().getTime());
						tDauer.setTime(tDauer.getTime() - 3600000);
						azDtos.setTDauer(tDauer);
						Double dDauer = Helper.time2Double(tDauer);

						azDtos.setSPersonalMaschinenname(einePositionDto[x].getPerson());
						azDtos.setSPersonalKurzzeichen(einePositionDto[x].getSPersonalKurzzeichen());
						azDtos.setsPersonNachnameVorname(einePositionDto[x].getPersonNachnameVorname());
						azDtos.setSPersonalnummer(einePositionDto[x].getPersonalnummer().toString());
						azDtos.setIPersonalMaschinenId(dtoBeginn.getPersonalIId());

						azDtos.setTsErledigt(einePositionDto[0].getZeitdatenDto().getTErledigt());
						azDtos.setFVerrechenbarInProzent(einePositionDto[0].getZeitdatenDto().getFVerrechenbar());
						azDtos.setSQuelle(dtoBeginn.getCWowurdegebucht());
						if (einePositionDto[0].getZeitdatenDto().getPersonalIIdErledigt() != null) {

							azDtos.setSPersonalKurzzeichenErledigt(getPersonalFac()
									.personalFindByPrimaryKeySmall(
											einePositionDto[0].getZeitdatenDto().getPersonalIIdErledigt())
									.getCKurzzeichen());
						}

						java.math.BigDecimal bdDauerGerundet = new BigDecimal(dDauer.doubleValue());
						// PJ 16661
						if (iOption == 0 && bBeruecksichtigeLeistungsfaktor == true) {
							// mit Leistungsfaktor multiplizieren
							try {
								Calendar c = Calendar.getInstance();
								c.setTimeInMillis(dtoBeginn.getTZeit().getTime());

								String key = dtoBeginn.getPersonalIId() + " " + c.get(Calendar.YEAR) + ""
										+ c.get(Calendar.MONTH);

								PersonalgehaltDto pgDto = null;

								if (personalgehaltCache.containsKey(key)) {
									pgDto = personalgehaltCache.get(key);
								} else {
									pgDto = getPersonalFac().personalgehaltFindLetztePersonalgehalt(
											dtoBeginn.getPersonalIId(), c.get(Calendar.YEAR), c.get(Calendar.MONTH));

									personalgehaltCache.put(key, pgDto);
								}

								if (pgDto != null && pgDto.getFLeistungswert() != null) {
									bdDauerGerundet = bdDauerGerundet.multiply(new BigDecimal(pgDto.getFLeistungswert())
											.divide(new BigDecimal(100), 4, BigDecimal.ROUND_HALF_UP));
								}
							} catch (RemoteException ex1) {
								throwEJBExceptionLPRespectOld(ex1);
							}
						}

						bdDauerGerundet = Helper.rundeKaufmaennisch(bdDauerGerundet, 3);

						azDtos.setDdDauer(new Double(bdDauerGerundet.doubleValue()));

						if (einePositionDto[0].getZeitdatenDto().getArtikelIId() != null) {

							azDtos.setArtikelgruppeIId(einePositionDto[0].getArtgruIId());
							azDtos.setSArtikelgruppe(einePositionDto[0].getSArtikelgruppe());
							azDtos.setArtikelklasseIId(einePositionDto[0].getArtklaIId());

							azDtos.setSArtikelcnr(einePositionDto[0].getArtikel());
							azDtos.setArtikelIId(einePositionDto[0].getZeitdatenDto().getArtikelIId());
							azDtos.setSArtikelbezeichnung(einePositionDto[0].getBezeichnung());

							azDtos.setSArtikelzusatzbezeichnung(einePositionDto[0].getZusatzbezeichnung());

							BigDecimal bdKostenProStunde = getPersonalKostenProStunde(theClientDto, hmGestpreise,
									iOption, einePositionDto[0].getZeitdatenDto().getArtikelIId(),
									dtoBeginn.getPersonalIId(), einePositionDto[0].getZeitdatenDto().getTZeit());
							azDtos.setBdKosten(bdKostenProStunde.multiply(bdDauerGerundet));

							azDtos.setiArbeitsgang(einePositionDto[0].getArbeitsgang());
							azDtos.setiUnterarbeitsgang(einePositionDto[0].getUnterarbeitsgang());
							azDtos.setiUnterarbeitsgang(einePositionDto[0].getUnterarbeitsgang());

						}

						String cBemerkung = dtoBeginn.getCBemerkungZuBelegart();

						if (einePositionDto[x + 1].isbOffen()) {

							if (cBemerkung != null) {
								cBemerkung = "OFFEN;" + cBemerkung;
							} else {
								cBemerkung = "OFFEN";
							}

						}

						azDtos.setSZeitbuchungtext(cBemerkung);
						azDtos.setSKommentar(einePositionDto[0].getZeitdatenDto().getXKommentar());
						azDtos.setSKommentarIntern(einePositionDto[0].getZeitdatenDto().getXKommentarIntern());
						azDtos.setTsBeginn(dtoBeginn.getTZeit());
						azDtos.setTsEnde(dtoEnde.getTZeit());

						if (dtoEnde.getTaetigkeitIId() != null) {
							TaetigkeitDto taetigkeitDto = null;

							if (taetigkeitenCache.containsKey(dtoEnde.getTaetigkeitIId())) {
								taetigkeitDto = taetigkeitenCache.get(dtoEnde.getTaetigkeitIId());
							} else {
								taetigkeitDto = taetigkeitFindByPrimaryKey(dtoEnde.getTaetigkeitIId(), theClientDto);
								taetigkeitenCache.put(dtoEnde.getTaetigkeitIId(), taetigkeitDto);
							}
							azDtos.setSBewegungsart(taetigkeitDto.getCNr());
						}

						// CK: entfernt, siehe Projekt 7120
						/*
						 * else { try { azDtos[iAktuellerDatensatz].setSBewegungsart (getArtikelFac().
						 * artikelFindByPrimaryKeySmall( dtoEnde.getArtikelIId(), idUser).getCNr()); }
						 * catch (RemoteException ex2) { throwEJBExceptionLPRespectOld(ex2); }
						 * 
						 * }
						 */

						if (iArtBelegzeiten == BELEGZEITEN_ALLE || iArtBelegzeiten == BELEGZEITEN_NUR_PERSONALZEITEN) {
							alAzDtos.add(azDtos);
						}

						if ((iArtBelegzeiten == BELEGZEITEN_ALLE || iArtBelegzeiten == BELEGZEITEN_NUR_MASCHINENZEITEN)
								&& einePositionDto[0].getZeitdatenDto().getMaschineIId() != null) {
							// Hier Maschine KLONEN
							try {
								MaschineDto mDto = getZeiterfassungFac().maschineFindByPrimaryKey(
										einePositionDto[0].getZeitdatenDto().getMaschineIId());
								MaschinengruppeDto mgDto = getZeiterfassungFac()
										.maschinengruppeFindByPrimaryKey(mDto.getMaschinengruppeIId());
								AuftragzeitenDto azDtosMaschine = AuftragzeitenDto.clone(azDtos);

								azDtosMaschine.setSPersonalnummer(mDto.getCInventarnummer());
								azDtosMaschine.setMaschinengruppe(mgDto.getCBez());
								azDtosMaschine.setIPersonalMaschinenId(mDto.getIId());

								String maschinenname = "M:";
								if (mDto.getCIdentifikationsnr() != null) {
									maschinenname += mDto.getCIdentifikationsnr() + " ";
								}

								maschinenname += mDto.getCBez();
								azDtosMaschine.setSPersonalMaschinenname(maschinenname);
								azDtosMaschine.setsPersonNachnameVorname(maschinenname);

								BigDecimal stundensatz = getMaschinenKostenZumZeitpunkt(mDto.getIId(),
										azDtosMaschine.getTsBeginn(), LocaleFac.BELEGART_LOS,
										einePositionDto[0].getZeitdatenDto().getIBelegartpositionid())
												.getBdStundensatz();

								// SP7393 Maschinenzeiten sind nicht mehrfach/parallel moeglich
								if (einePositionDto[0].getZeitdatenDto().getMaschineIId() != null) {
									String sEnde = "SELECT z FROM FLRZeitdaten z WHERE z.flrmaschine.i_id="
											+ einePositionDto[0].getZeitdatenDto().getMaschineIId() + " AND z.t_zeit>'"
											+ Helper.formatTimestampWithSlashes(azDtosMaschine.getTsBeginn())
											+ "' ORDER BY z.t_zeit ASC";

									Session sessionMEnde = FLRSessionFactory.getFactory().openSession();

									org.hibernate.Query qEnde = sessionMEnde.createQuery(sEnde);
									qEnde.setMaxResults(1);

									List<?> lEnde = qEnde.list();

									Iterator<?> resultListIteratorEnde = lEnde.iterator();

									if (resultListIteratorEnde.hasNext()) {
										FLRZeitdaten z = (FLRZeitdaten) resultListIteratorEnde.next();

										if (z.getT_zeit().before(azDtosMaschine.getTsEnde())) {
											azDtosMaschine.setTsEnde(new Timestamp(z.getT_zeit().getTime()));

											java.sql.Time tDauerMZ = new java.sql.Time(
													azDtosMaschine.getTsEnde().getTime()
															- azDtosMaschine.getTsBeginn().getTime());
											tDauerMZ.setTime(tDauerMZ.getTime() - 3600000);
											azDtosMaschine.setTDauer(tDauerMZ);
											dDauer = Helper.time2Double(tDauerMZ);
											azDtosMaschine.setDdDauer(dDauer);
											azDtosMaschine.setSZeitbuchungtext(null);

										}

									}

								}

								azDtosMaschine.setBdKosten(stundensatz.multiply(new BigDecimal(dDauer.doubleValue())));

								alAzDtos.add(azDtosMaschine);

							} catch (RemoteException e) {
								throwEJBExceptionLPRespectOld(e);
							}
						}

					}
				}
			}

		}

		// PJ22098

		if ((belegartCNr == null || belegartCNr.equals(LocaleFac.BELEGART_LOS))
				&& iArtBelegzeiten != BELEGZEITEN_NUR_MASCHINENZEITEN && zeitdatenIId == null) {
			String sQueryMaschinenzeitdaten = "SELECT m FROM FLRMaschinenzeitdaten m WHERE m.b_parallel = 1 ";

			if (belegartIId != null) {
				sQueryMaschinenzeitdaten += " AND m.flrlossollarbeitsplan.los_i_id=" + belegartIId;
			}

			if (personalIId != null) {
				sQueryMaschinenzeitdaten += " AND m.personal_i_id_gestartet=" + personalIId;
			}

			if (maschineIId != null) {
				sQueryMaschinenzeitdaten += " AND m.maschine_i_id=" + maschineIId;
			}

			if (belegartpositionIId != null) {
				sQueryMaschinenzeitdaten += " AND m.lossollarbeitsplan_i_id=" + belegartpositionIId;
			}

			if (tZeitenVon != null) {

				sQueryMaschinenzeitdaten += " AND m.t_von>='" + Helper.formatTimestampWithSlashes(tZeitenVon) + "'";

			}

			if (tZeitenBis != null) {
				sQueryMaschinenzeitdaten += " AND m.t_von<'" + Helper.formatTimestampWithSlashes(tZeitenBis) + "'";
			}

			sQueryMaschinenzeitdaten += " ORDER BY m.t_von ASC";

			Session sessionMaschinenzeiten = FLRSessionFactory.getFactory().openSession();

			org.hibernate.Query zeitenMaschinenzeiten = sessionMaschinenzeiten.createQuery(sQueryMaschinenzeitdaten);

			List<?> resultListMaschinenzeiten = zeitenMaschinenzeiten.list();

			Iterator<?> itMaschinenzeiten = resultListMaschinenzeiten.iterator();

			// Nach Personen und Tagen gruppieren
			HashMap<String, ArrayList<FLRMaschinenzeitdaten>> hmPersonal = new HashMap<String, ArrayList<FLRMaschinenzeitdaten>>();

			while (itMaschinenzeiten.hasNext()) {
				FLRMaschinenzeitdaten m = (FLRMaschinenzeitdaten) itMaschinenzeiten.next();

				String key = m.getPersonal_i_id_gestartet() + " "
						+ Helper.formatDateWithSlashes(new java.sql.Date(m.getT_von().getTime()));

				ArrayList<FLRMaschinenzeitdaten> alZeitdaten = null;
				if (hmPersonal.containsKey(key)) {
					alZeitdaten = hmPersonal.get(key);
				} else {
					alZeitdaten = new ArrayList<FLRMaschinenzeitdaten>();
				}

				alZeitdaten.add(m);

				hmPersonal.put(key, alZeitdaten);

			}

			Iterator itParallelbedienung = hmPersonal.keySet().iterator();
			while (itParallelbedienung.hasNext()) {
				Object key = itParallelbedienung.next();

				ArrayList<FLRMaschinenzeitdaten> alMaschinenzeitenEinesTagesUndEinerPerson = hmPersonal.get(key);

				Double bdGesamteMaschinenzeitEinesTages = 0D;
				for (int i = 0; i < alMaschinenzeitenEinesTagesUndEinerPerson.size(); i++) {
					FLRMaschinenzeitdaten m = (FLRMaschinenzeitdaten) alMaschinenzeitenEinesTagesUndEinerPerson.get(i);

					Double dDauer = 0D;
					if (m.getT_bis() != null) {
						java.sql.Time tDauer = new java.sql.Time(m.getT_bis().getTime() - m.getT_von().getTime());
						tDauer.setTime(tDauer.getTime() - 3600000);
						dDauer = Helper.time2Double(tDauer);

						bdGesamteMaschinenzeitEinesTages += dDauer;

					}
				}

				try {
					Double dTagesanwesenheitszeit = getZeiterfassungFac().berechneTagesArbeitszeit(
							alMaschinenzeitenEinesTagesUndEinerPerson.get(0).getPersonal_i_id_gestartet(),
							new java.sql.Date(alMaschinenzeitenEinesTagesUndEinerPerson.get(0).getT_von().getTime()),
							theClientDto);

					BigDecimal bdTagesarbeitszeit = Helper.rundeKaufmaennisch(new BigDecimal(dTagesanwesenheitszeit),
							2);

					BigDecimal bdBelegzeit = getZeiterfassungFac().berechneBelegzeitenEinesTages(
							alMaschinenzeitenEinesTagesUndEinerPerson.get(0).getPersonal_i_id_gestartet(),
							new java.sql.Date(alMaschinenzeitenEinesTagesUndEinerPerson.get(0).getT_von().getTime()),
							theClientDto);

					dTagesanwesenheitszeit = bdTagesarbeitszeit.subtract(bdBelegzeit).doubleValue();

					if (dTagesanwesenheitszeit > 0) {

						for (int i = 0; i < alMaschinenzeitenEinesTagesUndEinerPerson.size(); i++) {
							FLRMaschinenzeitdaten m = (FLRMaschinenzeitdaten) alMaschinenzeitenEinesTagesUndEinerPerson
									.get(i);

							ZeitdatenDtoBelegzeiten dtoTemp = new ZeitdatenDtoBelegzeiten();

							AuftragzeitenDto azDtos = new AuftragzeitenDto();

							azDtos.setSBewegungsart("PARALLEL");

							azDtos.setBelegpositionIId(m.getLossollarbeitsplan_i_id());

							Double dDauer = 0D;
							if (m.getT_bis() != null) {
								java.sql.Time tDauer = new java.sql.Time(
										m.getT_bis().getTime() - m.getT_von().getTime());
								tDauer.setTime(tDauer.getTime() - 3600000);
								azDtos.setTDauer(tDauer);
								dDauer = Helper.time2Double(tDauer);
							}

							//
							Double dAnteiligeDauer = 0D;
							if (bdGesamteMaschinenzeitEinesTages.doubleValue() > 0) {
								dAnteiligeDauer = (dTagesanwesenheitszeit
										/ bdGesamteMaschinenzeitEinesTages.doubleValue()) * dDauer;
							}

							azDtos.setSPersonalMaschinenname(HelperServer
									.formatPersonAusFLRPartner(m.getFlrpersonal_gestartet().getFlrpartner()));
							azDtos.setSPersonalKurzzeichen(m.getFlrpersonal_gestartet().getC_kurzzeichen());
							azDtos.setsPersonNachnameVorname(HelperServer
									.formatPersonAusFLRPartner(m.getFlrpersonal_gestartet().getFlrpartner()));
							azDtos.setSPersonalnummer(m.getFlrpersonal_gestartet().getC_personalnummer());
							azDtos.setIPersonalMaschinenId(m.getPersonal_i_id_gestartet());

							azDtos.setFVerrechenbarInProzent(m.getF_verrechenbar());
							if (m.getFlrpersonal_erledigt() != null) {

								azDtos.setSPersonalKurzzeichenErledigt(m.getFlrpersonal_erledigt().getC_kurzzeichen());
							}

							java.math.BigDecimal bdDauerGerundet = new BigDecimal(dAnteiligeDauer.doubleValue());

							bdDauerGerundet = Helper.rundeKaufmaennisch(bdDauerGerundet, 3);

							azDtos.setDdDauer(new Double(bdDauerGerundet.doubleValue()));

							if (m.getFlrlossollarbeitsplan().getFlrartikel() != null) {
								if (m.getFlrlossollarbeitsplan().getFlrartikel().getFlrartikelgruppe() != null) {
									azDtos.setArtikelgruppeIId(m.getFlrlossollarbeitsplan().getFlrartikel()
											.getFlrartikelgruppe().getI_id());
									azDtos.setSArtikelgruppe(m.getFlrlossollarbeitsplan().getFlrartikel()
											.getFlrartikelgruppe().getC_nr());
								}
								if (m.getFlrlossollarbeitsplan().getFlrartikel().getFlrartikelklasse() != null) {
									azDtos.setArtikelklasseIId(m.getFlrlossollarbeitsplan().getFlrartikel()
											.getFlrartikelklasse().getI_id());
								}

							}

							azDtos.setSArtikelcnr(m.getFlrlossollarbeitsplan().getFlrartikel().getC_nr());
							azDtos.setArtikelIId(m.getFlrlossollarbeitsplan().getFlrartikel().getI_id());

							ArtikelDto aDto = getArtikelFac().artikelFindByPrimaryKeySmall(
									m.getFlrlossollarbeitsplan().getFlrartikel().getI_id(), theClientDto);

							azDtos.setSArtikelbezeichnung(aDto.getCBezAusSpr());

							azDtos.setSArtikelzusatzbezeichnung(aDto.getCZBezAusSpr());

							BigDecimal bdKostenProStunde = getPersonalKostenProStunde(theClientDto, hmGestpreise,
									iOption, m.getFlrlossollarbeitsplan().getFlrartikel().getI_id(),
									m.getPersonal_i_id_gestartet(), new Timestamp(m.getT_von().getTime()));
							azDtos.setBdKosten(bdKostenProStunde.multiply(bdDauerGerundet));

							azDtos.setiArbeitsgang(m.getFlrlossollarbeitsplan().getI_arbeitsgangsnummer());
							azDtos.setiUnterarbeitsgang(m.getFlrlossollarbeitsplan().getI_unterarbeitsgang());

							String cBemerkung = " PARALLELBEDIENUNG Maschine "
									+ m.getFlrmaschine().getC_identifikationsnr();
							if (m.getT_bis() == null) {

								if (cBemerkung != null) {
									cBemerkung = "OFFEN;" + cBemerkung;
								} else {
									cBemerkung = "OFFEN";
								}

							}

							azDtos.setSZeitbuchungtext(cBemerkung);
							azDtos.setTsBeginn(new Timestamp(m.getT_von().getTime()));
							if (m.getT_bis() == null) {
								azDtos.setTsEnde(new Timestamp(System.currentTimeMillis()));
							} else {
								azDtos.setTsEnde(new Timestamp(m.getT_bis().getTime()));
							}

							alAzDtos.add(azDtos);

						}
					}
				} catch (RemoteException e) {
					throwEJBExceptionLPRespectOld(e);
				}

			}

		}

		AuftragzeitenDto[] azDtos = (AuftragzeitenDto[]) alAzDtos.toArray(new AuftragzeitenDto[alAzDtos.size()]);

		if (bTheoretischeIstZeit == true && iArtBelegzeiten != BELEGZEITEN_NUR_MASCHINENZEITEN) {

			// Zuerst verdichten
			TreeMap<Integer, AuftragzeitenDto> tm = new TreeMap<Integer, AuftragzeitenDto>();

			Integer letzteZeitdatenIId = null;
			BigDecimal bdDauer = new BigDecimal(0);
			for (int i = 0; i < alAzDtos.size(); i++) {

				if (tm.containsKey(alAzDtos.get(i).getZeitdatenIIdBelegbuchung())) {
					AuftragzeitenDto azTmp = tm.get(alAzDtos.get(i).getZeitdatenIIdBelegbuchung());

					azTmp.setDdDauer(azTmp.getDdDauer().doubleValue() + alAzDtos.get(i).getDdDauer());
					azTmp.setTsEnde(alAzDtos.get(i).getTsEnde());
					azTmp.setSBewegungsart(alAzDtos.get(i).getSBewegungsart());
					azTmp.setSArtikelcnr(alAzDtos.get(i).getSArtikelcnr());
					azTmp.setSArtikelbezeichnung(alAzDtos.get(i).getSArtikelbezeichnung());
					azTmp.setBdKosten(azTmp.getBdKosten().add(alAzDtos.get(i).getBdKosten()));

				} else {
					tm.put(alAzDtos.get(i).getZeitdatenIIdBelegbuchung(), alAzDtos.get(i));
				}

			}

			azDtos = new AuftragzeitenDto[tm.size()];
			Iterator it = tm.keySet().iterator();
			int i = 0;
			while (it.hasNext()) {
				AuftragzeitenDto azDto = tm.get(it.next());
				azDtos[i] = azDto;
				i++;
			}

			for (int k = 0; k < azDtos.length; k++) {

				// Wenn Ruestzeit, dann Umspannzeiten abziehen
				// Im ende der Ruestzeit sind immer die Gut-Schlecht-Stueck der
				// anderen Lose
				// waehrend des Ruestens enthalten
				AuftragzeitenDto azDto = azDtos[k];
				Timestamp tBis = Helper.cutTimestamp(new Timestamp(azDto.getTsEnde().getTime() + 10));
				Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
				query.setParameter(1, azDto.getIPersonalMaschinenId());
				query.setParameter(2, azDto.getTsBeginn());
				query.setParameter(3, tBis);
				ZeitdatenDto[] tagesDaten = assembleZeitdatenDtos(query.getResultList());

				for (int j = 1; j < tagesDaten.length; j++) {
					LosgutschlechtDto[] lgsDtos = getFertigungFac()
							.losgutschlechtFindByZeitdatenIId(tagesDaten[j].getIId());

					if (lgsDtos.length > 0) {

						BigDecimal bdAbzuziehen = new BigDecimal(0);

						BigDecimal bdGesamt = new BigDecimal(0);
						for (int z = 0; z < lgsDtos.length; z++) {
							LosgutschlechtDto lgsDto = lgsDtos[z];

							if (lgsDto.getNGut() != null) {
								bdGesamt = bdGesamt.add(lgsDto.getNGut());
							}
							if (lgsDto.getNSchlecht() != null) {
								bdGesamt = bdGesamt.add(lgsDto.getNSchlecht());
							}

							LossollarbeitsplanDto sollarbeitsplanAbzuziehenDto = getFertigungFac()
									.lossollarbeitsplanFindByPrimaryKeyOhneExc(lgsDto.getLossollarbeitsplanIId());

							if (sollarbeitsplanAbzuziehenDto.getAgartCNr() != null) {
								bdAbzuziehen = bdAbzuziehen
										.add(bdGesamt.multiply(sollarbeitsplanAbzuziehenDto.getStueckzeit()));
							}

						}

						if (new BigDecimal(azDto.getDdDauer()).subtract(bdAbzuziehen).doubleValue() < 0) {
							azDto.setDdDauer((double) 0);
						} else {
							azDto.setDdDauer(new BigDecimal(azDto.getDdDauer()).subtract(bdAbzuziehen).doubleValue());
						}

						break;
					}
				}

			}
		}
		// PJ 15810 Wenn Los, dann Theoretische Ist-Zeit berechnen
		if (belegartCNr != null && belegartCNr.equals(LocaleFac.BELEGART_LOS)) {
			if (bTheoretischeIstZeit == true && iArtBelegzeiten != BELEGZEITEN_NUR_MASCHINENZEITEN) {
				azDtos = theoretischeIstzeitHinzufuegen(azDtos, belegartIId, belegartpositionIId, personalIId,
						tZeitenVon, tZeitenBis, false, theClientDto);
			}
		}

		try {
			if (iSortierung == SORTIERUNG_ZEITDATEN_ARTIKEL) {

				for (int i = azDtos.length - 1; i > 0; --i) {
					for (int j = 0; j < i; ++j) {
						if (azDtos[j].getSArtikelcnr().compareTo(azDtos[j + 1].getSArtikelcnr()) > 0) {
							AuftragzeitenDto tauschDto = azDtos[j];
							azDtos[j] = azDtos[j + 1];
							azDtos[j + 1] = tauschDto;
						}
					}
				}
			}
			if (iSortierung == SORTIERUNG_ZEITDATEN_PERSONAL) {
				for (int i = azDtos.length - 1; i > 0; --i) {
					for (int j = 0; j < i; ++j) {
						if (azDtos[j].getsPersonNachnameVorname()
								.compareTo(azDtos[j + 1].getsPersonNachnameVorname()) > 0) {
							AuftragzeitenDto tauschDto = azDtos[j];
							azDtos[j] = azDtos[j + 1];
							azDtos[j + 1] = tauschDto;
						}
					}
				}
			}
			if (iSortierung == SORTIERUNG_ZEITDATEN_ZEITPUNKT_PERSONAL) {
				for (int i = azDtos.length - 1; i > 0; --i) {
					for (int j = 0; j < i; ++j) {
						if (azDtos[j].getTsBeginn().before(azDtos[j + 1].getTsBeginn())) {
							AuftragzeitenDto tauschDto = azDtos[j];
							azDtos[j] = azDtos[j + 1];
							azDtos[j + 1] = tauschDto;
						} else if (azDtos[j].getTsBeginn().equals(azDtos[j + 1].getTsBeginn())) {
							if (azDtos[j].getsPersonNachnameVorname()
									.compareTo(azDtos[j + 1].getsPersonNachnameVorname()) > 0) {
								AuftragzeitenDto tauschDto = azDtos[j];
								azDtos[j] = azDtos[j + 1];
								azDtos[j + 1] = tauschDto;
							}
						}
					}
				}
			}

		} catch (NullPointerException ex3) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_IN_ZEITDATEN, ex3);
		}

		return azDtos;
	}

	private BigDecimal getArtikelzuschlag(Integer artikelIId, Timestamp tZeitpunkt) {

		String sQuery = "select az FROM FLRArtikelzuschlag az WHERE az.t_gueltigab<='"
				+ Helper.formatDateWithSlashes(new java.sql.Date(tZeitpunkt.getTime())) + "' AND az.flrartikel.i_id="
				+ artikelIId + " ORDER BY az.t_gueltigab DESC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query letzteKommtGeht = session.createQuery(sQuery);
		letzteKommtGeht.setMaxResults(1);

		List<?> resultList = letzteKommtGeht.list();

		Iterator<?> resultListIterator = resultList.iterator();

		if (resultListIterator.hasNext()) {
			FLRArtikelzuschlag l = (FLRArtikelzuschlag) resultListIterator.next();
			return l.getN_zuschlag();
		} else {
			return BigDecimal.ZERO;
		}

	}

	public BigDecimal getPersonalKostenProStunde(TheClientDto theClientDto, HashMap hmGestpreise, int iOption,
			Integer artikelIId, Integer personalIId, Timestamp tZeitpunkt) {

		BigDecimal bdKostenProStunde = BigDecimal.ZERO;
		try {
			if (iOption == 2) {

				// Stundensatz aus Personalgehalt holen
				Calendar c = Calendar.getInstance();
				c.setTimeInMillis(tZeitpunkt.getTime());

				PersonalgehaltDto pgDto = getPersonalFac().personalgehaltFindLetztePersonalgehalt(personalIId,
						c.get(Calendar.YEAR), c.get(Calendar.MONTH));
				if (pgDto != null && pgDto.getNStundensatz() != null) {
					bdKostenProStunde = pgDto.getNStundensatz();
				}

				// PJ19375
				bdKostenProStunde = bdKostenProStunde.add(getArtikelzuschlag(artikelIId, tZeitpunkt));

			} else if (iOption == 1) {
				// Kosten aus Personalgruppe

				PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKeySmall(personalIId);

				if (personalDto.getPersonalgruppeIId() != null) {

					BigDecimal bdKostenAusPersonalgruppe = getPersonalFac()
							.getPersonalgruppeKostenZumZeitpunkt(personalDto.getPersonalgruppeIId(), tZeitpunkt);

					if (bdKostenAusPersonalgruppe != null) {
						bdKostenProStunde = bdKostenAusPersonalgruppe;
					}
				}
				// PJ19375
				bdKostenProStunde = bdKostenProStunde.add(getArtikelzuschlag(artikelIId, tZeitpunkt));
			} else {

				// Tel. mit UW (05-15-05): Preise werden in
				// Mandantenwaehrung zurueckgeliefert.

				if (hmGestpreise != null) {
					if (!hmGestpreise.containsKey(artikelIId)) {
						BigDecimal preis = getLagerFac()
								.getGemittelterGestehungspreisAllerLaegerEinesMandanten(artikelIId, theClientDto);
						hmGestpreise.put(artikelIId, preis);

					}
					BigDecimal preis = (BigDecimal) hmGestpreise.get(artikelIId);
					bdKostenProStunde = preis;
				} else {

					BigDecimal preis = getLagerFac().getGemittelterGestehungspreisAllerLaegerEinesMandanten(artikelIId,
							theClientDto);
					bdKostenProStunde = preis;

				}

			}
		} catch (RemoteException e) {
			throwEJBExceptionLPRespectOld(e);
		}

		return bdKostenProStunde;

	}

	private AuftragzeitenDto[] theoretischeIstzeitHinzufuegen(AuftragzeitenDto[] azDtos, Integer losIId,
			Integer lossollarbeitsplanIId, Integer personalId, java.sql.Timestamp tZeitenVon,
			java.sql.Timestamp tZeitenBis, boolean bMaschinenZeiten, TheClientDto theClientDto) {

		ArrayList<AuftragzeitenDto> alDaten = new ArrayList<AuftragzeitenDto>();

		for (int i = 0; i < azDtos.length; i++) {
			alDaten.add(azDtos[i]);
		}
		try {
			LossollarbeitsplanDto[] sollDtos = getFertigungFac().lossollarbeitsplanFindByLosIId(losIId);

			for (int i = 0; i < sollDtos.length; i++) {
				LossollarbeitsplanDto sollarbeitsplanDto = sollDtos[i];
				if (sollarbeitsplanDto != null) {

					if (sollarbeitsplanDto.getAgartCNr() != null) {
						// Wenn Umspannzeit oder Laufzeit

						LosgutschlechtDto[] lgsDtos = getFertigungFac()
								.losgutschlechtFindByLossollarbeitsplanIId(sollarbeitsplanDto.getIId());

						if (lgsDtos.length > 0) {

							if (lossollarbeitsplanIId != null
									&& !sollarbeitsplanDto.getIId().equals(lossollarbeitsplanIId)) {
								continue;
							}

							if (bMaschinenZeiten == true) {
								if (sollarbeitsplanDto.getMaschineIId() != null) {
									HashMap<Integer, BigDecimal> hmMaschinen = new HashMap<Integer, BigDecimal>();

									for (int z = 0; z < lgsDtos.length; z++) {
										LosgutschlechtDto lgsDto = lgsDtos[z];

										if (lgsDto.getMaschinenzeitdatenIId() != null) {
											MaschinenzeitdatenDto zDto = maschinenzeitdatenFindByPrimaryKey(
													lgsDto.getMaschinenzeitdatenIId());
											if (zDto.getMaschineIId().equals(sollarbeitsplanDto.getMaschineIId())) {
												BigDecimal bdGesamtMaschine = new BigDecimal(0);
												if (lgsDto.getNGut() != null) {
													bdGesamtMaschine = bdGesamtMaschine.add(lgsDto.getNGut());
												}
												if (lgsDto.getNSchlecht() != null) {
													bdGesamtMaschine = bdGesamtMaschine.add(lgsDto.getNSchlecht());
												}

												if (bdGesamtMaschine.doubleValue() > 0) {
													AuftragzeitenDto azDto = new AuftragzeitenDto();

													ArtikelDto artikelDto = getArtikelFac()
															.artikelFindByPrimaryKeySmall(
																	sollarbeitsplanDto.getArtikelIIdTaetigkeit(),
																	theClientDto);
													azDto.setArtikelIId(artikelDto.getIId());
													azDto.setArtikelgruppeIId(artikelDto.getArtgruIId());
													azDto.setTsBeginn(zDto.getTVon());
													azDto.setTsEnde(zDto.getTBis());
													azDto.setArtikelklasseIId(artikelDto.getArtklaIId());
													azDto.setSArtikelcnr(artikelDto.getCNr());
													azDto.setBelegpositionIId(sollarbeitsplanDto.getIId());
													String bezeichnung = "";
													if (artikelDto.getArtikelsprDto() != null) {
														bezeichnung = artikelDto.getArtikelsprDto().getCBez();
														azDto.setSArtikelzusatzbezeichnung(
																artikelDto.getArtikelsprDto().getCZbez());
													}
													azDto.setSArtikelbezeichnung("T:" + bezeichnung);
													azDto.setIPersonalMaschinenId(sollarbeitsplanDto.getMaschineIId());

													String maschinenname = "M:";
													MaschineDto maschineDto = getZeiterfassungFac()
															.maschineFindByPrimaryKey(
																	sollarbeitsplanDto.getMaschineIId());
													if (maschineDto.getCIdentifikationsnr() != null) {
														maschinenname += maschineDto.getCIdentifikationsnr() + " ";
														azDto.setSPersonalnummer(
																"M" + maschineDto.getCIdentifikationsnr());
													}
													maschinenname += maschineDto.getCBez();
													azDto.setSPersonalMaschinenname(maschinenname);
													azDto.setsPersonNachnameVorname(maschinenname);

													BigDecimal dauerNeu = bdGesamtMaschine
															.multiply(sollarbeitsplanDto.getStueckzeit());

													// PJ 16119
													if (sollarbeitsplanDto.getIAufspannung() != null
															&& sollarbeitsplanDto.getIAufspannung() >= 1) {
														dauerNeu = dauerNeu.divide(
																new BigDecimal(sollarbeitsplanDto.getIAufspannung()), 4,
																BigDecimal.ROUND_HALF_EVEN);
													}

													azDto.setDdDauer(new Double(dauerNeu.doubleValue()));

													BigDecimal stundensatz = getMaschinenKostenZumZeitpunkt(
															sollarbeitsplanDto.getMaschineIId(), azDto.getTsBeginn(),
															LocaleFac.BELEGART_LOS, sollarbeitsplanDto.getIId())
																	.getBdStundensatz();

													azDto.setBdKosten(stundensatz.multiply(dauerNeu));
													alDaten.add(azDto);
												}
											}
										}

									}

								}
							} else {
								if (!Helper.short2boolean(sollarbeitsplanDto.getBNurmaschinenzeit())) {
									HashMap<Integer, BigDecimal> hmPersonen = new HashMap<Integer, BigDecimal>();

									for (int z = 0; z < lgsDtos.length; z++) {
										LosgutschlechtDto lgsDto = lgsDtos[z];

										if (lgsDto.getZeitdatenIId() != null) {
											ZeitdatenDto zDto = zeitdatenFindByPrimaryKey(lgsDto.getZeitdatenIId(),
													theClientDto);

											if (tZeitenVon != null && tZeitenVon.after(zDto.getTZeit())) {
												continue;
											}
											if (tZeitenBis != null && tZeitenBis.before(zDto.getTZeit())) {
												continue;
											}

											if (personalId == null || personalId.equals(zDto.getPersonalIId())) {

												BigDecimal bdGesamtPerson = new BigDecimal(0);
												if (lgsDto.getNGut() != null) {
													bdGesamtPerson = bdGesamtPerson.add(lgsDto.getNGut());
												}
												if (lgsDto.getNSchlecht() != null) {
													bdGesamtPerson = bdGesamtPerson.add(lgsDto.getNSchlecht());
												}

												PersonalDto personalDto = getPersonalFac()
														.personalFindByPrimaryKey(zDto.getPersonalIId(), theClientDto);
												AuftragzeitenDto azDto = new AuftragzeitenDto();

												ArtikelDto artikelDto = getArtikelFac().artikelFindByPrimaryKeySmall(
														sollarbeitsplanDto.getArtikelIIdTaetigkeit(), theClientDto);

												azDto.setZeitdatenIIdBelegbuchung(zDto.getIId());
												azDto.setArtikelIId(artikelDto.getIId());
												azDto.setArtikelgruppeIId(artikelDto.getArtgruIId());
												azDto.setTsBeginn(zDto.getTZeit());
												azDto.setArtikelklasseIId(artikelDto.getArtklaIId());
												azDto.setSArtikelcnr(artikelDto.getCNr());
												azDto.setBelegpositionIId(sollarbeitsplanDto.getIId());
												String bezeichnung = "";
												if (artikelDto.getArtikelsprDto() != null) {
													bezeichnung = artikelDto.getArtikelsprDto().getCBez();
												}
												azDto.setSArtikelbezeichnung("T:" + bezeichnung);
												azDto.setSPersonalMaschinenname(
														personalDto.formatFixUFTitelName2Name1());
												azDto.setsPersonNachnameVorname(personalDto.formatFixName1Name2());

												azDto.setSPersonalKurzzeichen(personalDto.getCKurzzeichen());

												azDto.setSPersonalnummer(personalDto.getCPersonalnr() + "");

												azDto.setIPersonalMaschinenId(zDto.getPersonalIId());

												BigDecimal dauerNeu = bdGesamtPerson
														.multiply(sollarbeitsplanDto.getStueckzeit());
												// PJ 16119
												if (sollarbeitsplanDto.getIAufspannung() != null
														&& sollarbeitsplanDto.getIAufspannung() >= 1) {
													dauerNeu = dauerNeu.divide(
															new BigDecimal(sollarbeitsplanDto.getIAufspannung()), 4,
															BigDecimal.ROUND_HALF_EVEN);
												}
												azDto.setDdDauer(new Double(dauerNeu.doubleValue()));

												int iOption = 0;
												ParametermandantDto parameter = null;
												try {
													parameter = (ParametermandantDto) getParameterFac()
															.getMandantparameter(theClientDto.getMandant(),
																	ParameterFac.KATEGORIE_PERSONAL,
																	ParameterFac.PARAMETER_PERSONALKOSTEN_QUELLE);

													iOption = ((Integer) parameter.getCWertAsObject()).intValue();

												} catch (RemoteException ex5) {
													throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
												}

												if (iOption == 2) {
													BigDecimal bdPreis = new BigDecimal(0);
													// Stundensatz aus
													// Personalgehalt
													// holen
													Calendar c = Calendar.getInstance();
													c.setTimeInMillis(azDto.getTsBeginn().getTime());

													PersonalgehaltDto pgDto = getPersonalFac()
															.personalgehaltFindLetztePersonalgehalt(
																	azDto.getIPersonalMaschinenId(),
																	c.get(Calendar.YEAR), c.get(Calendar.MONTH));
													if (pgDto != null && pgDto.getNStundensatz() != null) {
														bdPreis = pgDto.getNStundensatz().multiply(dauerNeu);

													}

													azDto.setBdKosten(bdPreis);

												} else if (iOption == 1) {
													// Kosten aus Personalgruppe
													BigDecimal bdPreis = new BigDecimal(0);

													if (personalDto.getPersonalgruppeIId() != null) {

														BigDecimal bdKostenAusPersonalgruppe = getPersonalFac()
																.getPersonalgruppeKostenZumZeitpunkt(
																		personalDto.getPersonalgruppeIId(),
																		azDto.getTsBeginn());

														if (bdKostenAusPersonalgruppe != null) {
															bdPreis = bdKostenAusPersonalgruppe.multiply(dauerNeu);
														}
													}

													azDto.setBdKosten(bdPreis);

												} else {

													// Tel. mit UW (05-15-05):
													// Preise
													// werden
													// in
													// Mandantenwaehrung
													// zurueckgeliefert.

													BigDecimal preis = getLagerFac()
															.getGemittelterGestehungspreisAllerLaegerEinesMandanten(
																	azDto.getArtikelIId(), theClientDto);
													azDto.setBdKosten(preis.multiply(dauerNeu));

												}
												alDaten.add(azDto);
											}
										}

									}

								}
							}

						}
					}
				}
			}

		} catch (RemoteException e) {
			throwEJBExceptionLPRespectOld(e);
		}
		azDtos = new AuftragzeitenDto[alDaten.size()];
		azDtos = alDaten.toArray(azDtos);

		return azDtos;
	}

	/**
	 * Hole alle Artikelarten ohne Montag bis Sonntag nach Spr.
	 * 
	 * @param cNrSpracheI String
	 * @throws EJBExceptionLP
	 * @return Map
	 */
	public Map getAllSprTagesartenOhneMontagBisSonntag(String cNrSpracheI) throws EJBExceptionLP {
		Map tmArten = new HashMap<Integer, Object>();
		// try {
		Query query = em.createNamedQuery("TagesartfindAll");
		Collection<?> clArten = query.getResultList();
		// if (clArten.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY, null);
		// }
		Iterator<?> itArten = clArten.iterator();
		while (itArten.hasNext()) {
			Tagesart tagesartTemp = (Tagesart) itArten.next();
			Integer key = tagesartTemp.getIId();

			if (tagesartTemp.getCNr().equals(ZeiterfassungFac.TAGESART_MONTAG)) {
				key = null;
			} else if (tagesartTemp.getCNr().equals(ZeiterfassungFac.TAGESART_DIENSTAG)) {
				key = null;
			} else if (tagesartTemp.getCNr().equals(ZeiterfassungFac.TAGESART_MITTWOCH)) {
				key = null;
			} else if (tagesartTemp.getCNr().equals(ZeiterfassungFac.TAGESART_DONNERSTAG)) {
				key = null;
			} else if (tagesartTemp.getCNr().equals(ZeiterfassungFac.TAGESART_FREITAG)) {
				key = null;
			} else if (tagesartTemp.getCNr().equals(ZeiterfassungFac.TAGESART_SAMSTAG)) {
				key = null;
			} else if (tagesartTemp.getCNr().equals(ZeiterfassungFac.TAGESART_SONNTAG)) {
				key = null;
			}

			Object value = null;
			// try {
			Tagesartspr tagesartspr = em.find(Tagesartspr.class, new TagesartsprPK(cNrSpracheI, tagesartTemp.getIId()));
			if (tagesartspr == null) {
				// fuer locale und C_NR keine Bezeichnu g vorhanden ...
				value = tagesartTemp.getCNr();
			} else {
				value = tagesartspr.getCBez();
			}

			// }
			// catch (NoResultException ex1) {
			// fuer locale und C_NR keine Bezeichnu g vorhanden ...
			// value = tagesartTemp.getCNr();
			// }
			if (key != null) {
				tmArten.put(key, value);
			}
		}
		// }
		// catch (NoResultException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY, ex);
		// }

		return tmArten;
	}

	public Integer createTagesart(TagesartDto tagesartDto, TheClientDto theClientDto) throws EJBExceptionLP {
		if (tagesartDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("tagesartDto == null"));
		}
		if (tagesartDto.getCNr() == null || tagesartDto.getISort() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("tagesartDto.getCNr() == null || tagesartDto.getISort() == null"));
		}
		try {
			Query query = em.createNamedQuery("TagesartfindByCNr");
			query.setParameter(1, tagesartDto.getCNr());
			// @todo getSingleResult oder getResultList ?
			Tagesart doppelt = (Tagesart) query.getSingleResult();
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_TAGESART.CNR"));
		} catch (NoResultException ex) {
			//
		}
		try {
			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_TAGESART);
			tagesartDto.setIId(pk);
			Tagesart tagesart = new Tagesart(tagesartDto.getIId(), tagesartDto.getCNr(), tagesartDto.getISort());
			em.persist(tagesart);
			em.flush();
			setTagesartFromTagesartDto(tagesart, tagesartDto);
			if (tagesartDto.getTagesartsprDto() != null) {
				Tagesartspr tagesartspr = new Tagesartspr(theClientDto.getLocMandantAsString(), tagesartDto.getIId());
				em.persist(tagesartspr);
				em.flush();
				setTagesartsprFromTagesartsprDto(tagesartspr, tagesartDto.getTagesartsprDto());
			}
			return tagesartDto.getIId();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
	}

	public Double getSummeSollzeitWochentagsUndSonntags(Integer zeitmodellIId) {
		// wg AD + OpenGolf eingebaut, da Hr. Neureiter nur Samstag und Sonntag
		// arbeitet
		Double d = getSummeSollzeitWochentags(zeitmodellIId);
		try {
			// SONNTAG
			Query query = em.createNamedQuery("ZeitmodelltagfindSollzeitZuTagesart");
			query.setParameter(1, zeitmodellIId);
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_SONNTAG).getSingleResult()).getIId());
			Zeitmodelltag zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			long lGesamt = l + 3600000;
			double d_zeitdec = lGesamt / 3600000;
			d = new Double(d.doubleValue() + d_zeitdec);
		} catch (NoResultException ex) {
			// nothig here
		}

		return d;
	}

	public Double getSummeSollzeitWochentags(Integer zeitmodellIId) throws EJBExceptionLP {
		Zeitmodelltag zeitmodelltag;
		long lGesamt = 0;
		Query query = em.createNamedQuery("ZeitmodelltagfindSollzeitZuTagesart");
		try {
			// MONTAG
			query.setParameter(1, zeitmodellIId);
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_MONTAG).getSingleResult()).getIId());
			zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			lGesamt += l + 3600000;
		} catch (NoResultException ex) {
			// nothig here
		}
		try {
			// DIENSTAG
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_DIENSTAG).getSingleResult()).getIId());
			zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			lGesamt += l + 3600000;
		} catch (NoResultException ex) {
			// nothig here
		}
		try {
			// MITTWOCH
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_MITTWOCH).getSingleResult()).getIId());
			zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			lGesamt += l + 3600000;
		} catch (NoResultException ex) {
			// nothig here
		}
		try {
			// DONNERSTAG
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_DONNERSTAG).getSingleResult()).getIId());
			zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			lGesamt += l + 3600000;
		} catch (NoResultException ex) {
			// nothig here
		}
		try {
			// FREITAG
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_FREITAG).getSingleResult()).getIId());
			zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			lGesamt += l + 3600000;
		} catch (NoResultException ex) {
			// nothig here
		}
		try {
			// SAMSTAG
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_SAMSTAG).getSingleResult()).getIId());
			zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			lGesamt += l + 3600000;
		} catch (NoResultException ex) {
			// nothig here
		}

		double d_zeitdec = lGesamt / 36000;
		return new Double(d_zeitdec / 100);

	}

	public Double getSummeSollzeitMontagBisSonntag(Integer zeitmodellIId) {
		Zeitmodelltag zeitmodelltag;
		long lGesamt = 0;
		Query query = em.createNamedQuery("ZeitmodelltagfindSollzeitZuTagesart");
		try {
			// MONTAG
			query.setParameter(1, zeitmodellIId);
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_MONTAG).getSingleResult()).getIId());
			zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			lGesamt += l + 3600000;
		} catch (NoResultException ex) {
			// nothig here
		}
		try {
			// DIENSTAG
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_DIENSTAG).getSingleResult()).getIId());
			zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			lGesamt += l + 3600000;
		} catch (NoResultException ex) {
			// nothig here
		}
		try {
			// MITTWOCH
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_MITTWOCH).getSingleResult()).getIId());
			zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			lGesamt += l + 3600000;
		} catch (NoResultException ex) {
			// nothig here
		}
		try {
			// DONNERSTAG
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_DONNERSTAG).getSingleResult()).getIId());
			zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			lGesamt += l + 3600000;
		} catch (NoResultException ex) {
			// nothig here
		}
		try {
			// FREITAG
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_FREITAG).getSingleResult()).getIId());
			zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			lGesamt += l + 3600000;
		} catch (NoResultException ex) {
			// nothig here
		}
		try {
			// SAMSTAG
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_SAMSTAG).getSingleResult()).getIId());
			zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			lGesamt += l + 3600000;
		} catch (NoResultException ex) {
			// nothig here
		}
		try {
			// SAMSTAG
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_SONNTAG).getSingleResult()).getIId());
			zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			long l = zeitmodelltag.getUSollzeit().getTime();
			lGesamt += l + 3600000;
		} catch (NoResultException ex) {
			// nothig here
		}
		double d_zeitdec = lGesamt / 36000;
		return new Double(d_zeitdec / 100);

	}

	/**
	 * Ermittlt den Schnitt der Sollzeit eines Tages eines Zeitmodells
	 * 
	 * @param zeitmodellIId ID des Zeitmodells
	 * @return String Ergebnis als String
	 * @exception RemoteException
	 * @exception EJBExceptionLP
	 */
	public Double getWochenschnittEinesZeitmodellsProTag(Integer zeitmodellIId) throws EJBExceptionLP {
		double dSumme = 0;
		ZeitmodelltagDto[] dtos = null;
		// try {
		Query query = em.createNamedQuery("ZeitmodelltagfindByZeitmodellIId");
		query.setParameter(1, zeitmodellIId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FIND,
		// null);
		// }
		dtos = assembleZeitmodelltagDtos(cl);

		for (int i = 0; i < dtos.length; i++) {
			ZeitmodelltagDto dto = dtos[i];
			Query query2 = em.createNamedQuery("ZeitmodelltagfindSollzeitZuTagesart");
			query2.setParameter(1, zeitmodellIId);
			query2.setParameter(2, dto.getTagesartIId());
			Zeitmodelltag zeitmodelltag = (Zeitmodelltag) query2.getSingleResult();
			if (zeitmodelltag == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, "");
			}
			long l = zeitmodelltag.getUSollzeit().getTime();

			double d_zeitdec = (l + 3600000) / 36000;
			dSumme = dSumme + (d_zeitdec / 100);

		}
		// }
		// catch (NoResultException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FIND,
		// ex);
		// }
		if (dtos.length > 0) {
			dSumme = dSumme / dtos.length;
		} else {
			dSumme = 0;
		}
		return new Double(dSumme);

	}

	/**
	 * Ermittlt Summe der Sollzeit einer fuer Feiertag, Sonntag und Halbtag
	 * 
	 * @param zeitmodellIId ID des Zeitmodells
	 * @return String Ergebnis als String
	 * @exception RemoteException
	 * @exception EJBExceptionLP
	 */
	public Double getSummeSollzeitSonnUndFeiertags(Integer zeitmodellIId) throws EJBExceptionLP {
		long lGesamt = 0;
		Query query = em.createNamedQuery("ZeitmodelltagfindSollzeitZuTagesart");
		try {
			// SONNTAG
			query.setParameter(1, zeitmodellIId);
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_SONNTAG).getSingleResult()).getIId());
			Zeitmodelltag zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			if (zeitmodelltag != null) {
				long l = zeitmodelltag.getUSollzeit().getTime();
				lGesamt += l + 3600000;
			}
		} catch (NoResultException ex) {
			// nothig here
		}
		try {
			// HALBTAG
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_HALBTAG).getSingleResult()).getIId());
			Zeitmodelltag zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			if (zeitmodelltag != null) {
				long l = zeitmodelltag.getUSollzeit().getTime();
				lGesamt += l + 3600000;
			}
		} catch (NoResultException ex) {
			// nothig here
		}
		try {
			// FEIERTAG
			query.setParameter(2, ((Tagesart) em.createNamedQuery("TagesartfindByCNr")
					.setParameter(1, ZeiterfassungFac.TAGESART_FEIERTAG).getSingleResult()).getIId());
			Zeitmodelltag zeitmodelltag = (Zeitmodelltag) query.getSingleResult();
			if (zeitmodelltag != null) {
				long l = zeitmodelltag.getUSollzeit().getTime();
				lGesamt += l + 3600000;
			}
		} catch (NoResultException ex) {
			// nothig here
		}

		double d_zeitdec = lGesamt / 36000;
		return new Double(d_zeitdec / 100);

	}

	public void removeTagesart(TagesartDto tagesartDto) throws EJBExceptionLP {
		myLogger.entry();
		if (tagesartDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("tagesartDto == null"));
		}
		if (tagesartDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}
		// try {

		try {
			Query query = em.createNamedQuery("TagesartsprfindByTagesartIId");
			query.setParameter(1, tagesartDto.getIId());
			Collection<?> allTagesartspr = query.getResultList();

			Iterator<?> iter = allTagesartspr.iterator();
			while (iter.hasNext()) {
				Tagesartspr artgrusprTemp = (Tagesartspr) iter.next();
				em.remove(artgrusprTemp);
			}
			// }
			// catch (RemoveException ex) {
			// throw new EJBExceptionLP(EJBExceptionLP.
			// FEHLER_BEIM_LOESCHEN, ex);
			// }
			Tagesart tagesart = em.find(Tagesart.class, tagesartDto.getIId());
			if (tagesart == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
			}
			if (tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_MONTAG)
					|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_DIENSTAG)
					|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_MITTWOCH)
					|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_DONNERSTAG)
					|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_FREITAG)
					|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_SAMSTAG)
					|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_SONNTAG)
					|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_HALBTAG)
					|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_FEIERTAG)
					|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_BETRIEBSURLAUB)) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN,
						new Exception("DARF_NICHT_GELOESCHT_WERDEN"));

			}

			em.remove(tagesart);
			em.flush();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, e);
		}
	}

	public void bringeFehlerWennZeitabschlussvorhanden(Integer personalIId,
			java.sql.Timestamp tZeitWelcheGeaendertWerdenSoll, TheClientDto theClientDto) {
		if (getMandantFac().hatZusatzfunktionberechtigung(MandantFac.ZUSATZFUNKTION_ZEITEN_ABSCHLIESSEN,
				theClientDto)) {
			java.sql.Timestamp t = gibtEsBereitseinenZeitabschlussBisZurKW(personalIId, tZeitWelcheGeaendertWerdenSoll,
					theClientDto);

			if (t != null) {
				ArrayList al = new ArrayList();
				al.add(t);

				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITEN_BEREITS_ABGESCHLOSSEN, al,
						new Exception("FEHLER_ZEITEN_BEREITS_ABGESCHLOSSEN"));

			}
		}

	}

	public java.sql.Timestamp sindZeitenBereitsUnterschrieben(Integer personalIId, java.sql.Timestamp tZeitBis,
			TheClientDto theClientDto) {

		String sQueryBelegzeiten = "SELECT a from FLRAnwesenheitsbestaetigung a WHERE a.personal_i_id=" + personalIId
				+ " AND a.t_unterschrift>='" + Helper.formatTimestampWithSlashes(tZeitBis)
				+ "' ORDER BY a.t_unterschrift DESC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query query = session.createQuery(sQueryBelegzeiten);
		query.setMaxResults(1);

		List<?> resultList = query.list();

		Iterator<?> resultListIterator = resultList.iterator();

		ArrayList alDataSub = new ArrayList();

		if (resultListIterator.hasNext()) {
			FLRAnwesenheitsbestaetigung flr = (FLRAnwesenheitsbestaetigung) resultListIterator.next();
			session.close();
			return new Timestamp(flr.getT_unterschrift().getTime());
		} else {
			session.close();
			return null;
		}

	}

	public java.sql.Timestamp gibtEsBereitseinenZeitabschlussBisZurKW(Integer personalIId, java.sql.Timestamp tKW,
			TheClientDto theClientDto) {

		Timestamp[] tVonBisEinerKW = Helper.getTimestampVonBisEinerKW(tKW);

		Calendar c = Calendar.getInstance();
		c.setTimeInMillis(tKW.getTime());

		int kwAktuell = c.get(Calendar.WEEK_OF_YEAR);

		String sQueryBelegzeiten = "SELECT za  from FLRZeitabschluss za WHERE za.personal_i_id=" + personalIId
				+ " AND za.t_abgeschlossen_bis>='"
				+ Helper.formatTimestampWithSlashes(Helper.cutTimestamp(new Timestamp(tVonBisEinerKW[0].getTime())))
				+ "' ORDER BY za.t_abgeschlossen_bis DESC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query query = session.createQuery(sQueryBelegzeiten);
		query.setMaxResults(1);

		List<?> resultList = query.list();

		Iterator<?> resultListIterator = resultList.iterator();

		ArrayList alDataSub = new ArrayList();

		if (resultListIterator.hasNext()) {
			FLRZeitabschluss flr = (FLRZeitabschluss) resultListIterator.next();
			session.close();
			return new Timestamp(flr.getT_abgeschlossen_bis().getTime());
		} else {
			session.close();
			return null;
		}

	}

	public java.sql.Timestamp letzterZeitabschlussVorKW(Integer personalIId, java.sql.Timestamp tKW,
			TheClientDto theClientDto) {

		Timestamp[] tVonBisEinerKW = Helper.getTimestampVonBisEinerKW(tKW);

		Calendar c = Calendar.getInstance();
		c.setTimeInMillis(tKW.getTime());

		int kwAktuell = c.get(Calendar.WEEK_OF_YEAR);

		String sQueryBelegzeiten = "SELECT za  from FLRZeitabschluss za WHERE za.personal_i_id=" + personalIId
				+ " AND za.t_abgeschlossen_bis<'"
				+ Helper.formatTimestampWithSlashes(Helper.cutTimestamp(new Timestamp(tVonBisEinerKW[0].getTime())))
				+ "' ORDER BY za.t_abgeschlossen_bis DESC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query query = session.createQuery(sQueryBelegzeiten);
		query.setMaxResults(1);

		List<?> resultList = query.list();

		Iterator<?> resultListIterator = resultList.iterator();

		ArrayList alDataSub = new ArrayList();

		if (resultListIterator.hasNext()) {
			FLRZeitabschluss flr = (FLRZeitabschluss) resultListIterator.next();
			session.close();
			return new Timestamp(flr.getT_abgeschlossen_bis().getTime());
		} else {
			session.close();
			return null;
		}

	}

	public ProjektzeitenDto projektzeitenFindByPrimaryKey(Integer iId) {
		Projektzeiten projektzeiten = em.find(Projektzeiten.class, iId);

		ProjektzeitenDto dto = new ProjektzeitenDto();
		dto.setiId(projektzeiten.getiId());
		dto.setTelefonzeitenIId(projektzeiten.getTelefonzeitenIId());
		dto.setZeitdatenIId(projektzeiten.getZeitdatenIId());

		return dto;
	}

	public void zeitenAbschliessen(Integer personalIId, java.sql.Timestamp tKW, TheClientDto theClientDto) {
		java.sql.Timestamp t = gibtEsBereitseinenZeitabschlussBisZurKW(personalIId, tKW, theClientDto);
		if (t == null) {
			ZeitabschlussDto zaDto = new ZeitabschlussDto();
			Timestamp[] tKWVonBis = Helper.getTimestampVonBisEinerKW(tKW);
			zaDto.setPersonalIId(personalIId);
			zaDto.setTAbgeschlossenBis(Helper.cutTimestamp(tKWVonBis[1]));
			getPersonalFac().createZeitabschluss(zaDto, theClientDto);
		}
	}

	public void updateTagesart(TagesartDto tagesartDto, TheClientDto theClientDto) throws EJBExceptionLP {
		if (tagesartDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("tagesartDto == null"));
		}
		if (tagesartDto.getIId() == null || tagesartDto.getCNr() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("tagesartDto.getIId() == null || tagesartDto.getCNr() == null"));
		}
		Integer iId = tagesartDto.getIId();
		Tagesart tagesart = null;
		// try {
		tagesart = em.find(Tagesart.class, iId);
		if (tagesart == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");

		}

		// }
		// catch (NoResultException ex1) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// ex1);

		// }

		try {
			Query query = em.createNamedQuery("TagesartfindByCNr");
			query.setParameter(1, tagesartDto.getCNr());
			Integer iIdVorhanden = ((Tagesart) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_TAGESART.C_NR"));
			}

		} catch (NoResultException ex) {
			// nothing here
		}

		if ((tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_MONTAG)
				|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_DIENSTAG)
				|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_MITTWOCH)
				|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_DONNERSTAG)
				|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_FREITAG)
				|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_SAMSTAG)
				|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_SONNTAG)
				|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_HALBTAG)
				|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_FEIERTAG)
				|| tagesart.getCNr().equals(ZeiterfassungFac.TAGESART_BETRIEBSURLAUB))
				&& (!tagesart.getCNr().equals(tagesartDto.getCNr()))) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_UPDATE, new Exception("DARF_NICHT_UPGEDATED_WERDEN"));

		}

		setTagesartFromTagesartDto(tagesart, tagesartDto);
		try {
			if (tagesartDto.getTagesartsprDto() != null) {
				// try {
				Tagesartspr tagesartspr = em.find(Tagesartspr.class,
						new TagesartsprPK(theClientDto.getLocUiAsString(), iId));
				if (tagesartspr == null) {
					tagesartspr = new Tagesartspr(theClientDto.getLocUiAsString(), iId);
					em.persist(tagesartspr);
					em.flush();
					setTagesartsprFromTagesartsprDto(tagesartspr, tagesartDto.getTagesartsprDto());
				}
				setTagesartsprFromTagesartsprDto(tagesartspr, tagesartDto.getTagesartsprDto());
				// }
				// catch (NoResultException ex) {
				// Tagesartspr tagesartspr = new
				// Tagesartspr(getTheClient(idUser).getLocUiAsString(), iId);
				// em.persist(tagesartspr);
				// setTagesartsprFromTagesartsprDto(tagesartspr,
				// tagesartDto.getTagesartsprDto());
				// }
			}
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, e);
		}
	}

	public TagesartDto tagesartFindByPrimaryKey(Integer iId, TheClientDto theClientDto) throws EJBExceptionLP {
		if (iId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}
		// try {
		Tagesart tagesart = em.find(Tagesart.class, iId);
		if (tagesart == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		TagesartDto tagesartDto = assembleTagesartDto(tagesart);
		TagesartsprDto tagesartsprDto = null;
		// try {
		Tagesartspr tagesartspr = em.find(Tagesartspr.class, new TagesartsprPK(theClientDto.getLocUiAsString(), iId));
		if (tagesartspr != null) {
			tagesartsprDto = assembleTagesartsprDto(tagesartspr);
		}
		// }
		// catch (NoResultException ex) {
		// nothing here
		// }
		if (tagesartsprDto == null) {
			// try {
			tagesartspr = em.find(Tagesartspr.class, new TagesartsprPK(theClientDto.getLocKonzernAsString(), iId));
			if (tagesartspr != null) {
				tagesartsprDto = assembleTagesartsprDto(tagesartspr);
			}
			// catch (NoResultException ex) {
			// nothing here
			// }
		}
		tagesartDto.setTagesartsprDto(tagesartsprDto);
		return tagesartDto;
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	public TagesartDto tagesartFindByCNr(String cNr, TheClientDto theClientDto) throws EJBExceptionLP {
		if (cNr == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN, new Exception("cNr == null"));
		}

		try {
			Query query = em.createNamedQuery("TagesartfindByCNr");
			query.setParameter(1, cNr);
			return tagesartFindByPrimaryKey(((Tagesart) query.getSingleResult()).getIId(), theClientDto);
		} catch (NoResultException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, e);
		}
	}

	public TagesartDto[] tagesartFindAll() throws EJBExceptionLP {
		// try {
		Query query = em.createNamedQuery("TagesartfindAll");
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// null);
		// }
		return assembleTagesartDtos(cl);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);

		// }
	}

	public HashMap taetigkeitenMitImportkennzeichen() {

		Query query = em.createNamedQuery("TaetigkeitfindByCImportkennzeichenNotNull");
		Collection<?> cl = query.getResultList();

		HashMap hm = new HashMap();
		Iterator it = cl.iterator();
		while (it.hasNext()) {
			Taetigkeit t = (Taetigkeit) it.next();
			hm.put(t.getCImportkennzeichen(), t.getIId());
		}

		return hm;
	}

	private void setTagesartFromTagesartDto(Tagesart tagesart, TagesartDto tagesartDto) {
		tagesart.setCNr(tagesartDto.getCNr());
		tagesart.setISort(tagesartDto.getISort());
		em.merge(tagesart);
		em.flush();
	}

	private TagesartDto assembleTagesartDto(Tagesart tagesart) {
		return TagesartDtoAssembler.createDto(tagesart);
	}

	private TagesartDto[] assembleTagesartDtos(Collection<?> tagesarts) {
		List<TagesartDto> list = new ArrayList<TagesartDto>();
		if (tagesarts != null) {
			Iterator<?> iterator = tagesarts.iterator();
			while (iterator.hasNext()) {
				Tagesart tagesart = (Tagesart) iterator.next();
				list.add(assembleTagesartDto(tagesart));
			}
		}
		TagesartDto[] returnArray = new TagesartDto[list.size()];
		return (TagesartDto[]) list.toArray(returnArray);
	}

	private void setTagesartsprFromTagesartsprDto(Tagesartspr tagesartspr, TagesartsprDto tagesartsprDto) {
		tagesartspr.setCBez(tagesartsprDto.getCBez());
		em.merge(tagesartspr);
		em.flush();
	}

	private TagesartsprDto assembleTagesartsprDto(Tagesartspr tagesartspr) {
		return TagesartsprDtoAssembler.createDto(tagesartspr);
	}

	private TagesartsprDto[] assembleTagesartsprDtos(Collection<?> tagesartsprs) {
		List<TagesartsprDto> list = new ArrayList<TagesartsprDto>();
		if (tagesartsprs != null) {
			Iterator<?> iterator = tagesartsprs.iterator();
			while (iterator.hasNext()) {
				Tagesartspr tagesartspr = (Tagesartspr) iterator.next();
				list.add(assembleTagesartsprDto(tagesartspr));
			}
		}
		TagesartsprDto[] returnArray = new TagesartsprDto[list.size()];
		return (TagesartsprDto[]) list.toArray(returnArray);
	}

	private Timestamp sucheEndeZeitFuerRelativeZeitbuchung(Timestamp tsBeginn, Integer personalIId, long lZeitRelativ,
			boolean bIgnoriereFehler, TheClientDto theClientDto) throws EJBExceptionLP {
		Timestamp tsEnde = null;
		try {
			Query query1 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
			query1.setParameter(1, personalIId);
			query1.setParameter(2, new Timestamp(tsBeginn.getTime() + 11));
			query1.setParameter(3,
					Helper.cutTimestamp(Helper.addiereTageZuTimestamp(new Timestamp(tsBeginn.getTime()), 1)));

			ZeitdatenDto[] dtos = assembleZeitdatenDtosOhneBelegzeiten(query1.getResultList());

			if (dtos.length == 0) {
				return new Timestamp(tsBeginn.getTime() + lZeitRelativ);
			}

			int iGeht = dtos.length;

			Query query = em.createNamedQuery("TaetigkeitfindByCNr");
			query.setParameter(1, ZeiterfassungFac.TAETIGKEIT_GEHT);
			Integer taetigkeitIId_Geht = ((Taetigkeit) query.getSingleResult()).getIId();

			ZeitdatenDto dtoGeht = null;

			for (int i = 0; i < dtos.length; i++) {
				if (taetigkeitIId_Geht.equals(dtos[i].getTaetigkeitIId())) {
					iGeht = i;
					dtoGeht = dtos[i];
					break;
				}
			}

			ZeitdatenDto[] dtosAufbereitet = new ZeitdatenDto[iGeht];

			for (int i = 0; i < iGeht; i++) {
				dtosAufbereitet[i] = dtos[i];
			}

			if (dtosAufbereitet.length % 2 == 1) {
				// Wenn ungerade, Exception schmeissen -> Fehler in
				// Zeitbuchungen, ausser wenn Zeitvertileung auf Los, dann lt.
				// WH Fehler ingorieren

				if (bIgnoriereFehler == true) {
					return new Timestamp(tsBeginn.getTime() + lZeitRelativ);
				} else {

					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITERFASSUNG_RELATIVE_NICHT_MOEGLICH,
							new Exception("FEHLER_ZEITERFASSUNG_RELATIVE_NICHT_MOEGLICH"));
				}
			}

			tsEnde = new Timestamp(tsBeginn.getTime() + lZeitRelativ);

			for (int i = 0; i < dtosAufbereitet.length - 1; i = i + 2) {
				ZeitdatenDto aktuellerDatensatz = dtosAufbereitet[i];
				ZeitdatenDto naechsterDatensatz = dtosAufbereitet[i + 1];

				if (tsEnde.before(aktuellerDatensatz.getTZeit())) {
					return tsEnde;
				} else {
					long diff = naechsterDatensatz.getTZeit().getTime() - aktuellerDatensatz.getTZeit().getTime();
					tsEnde = new Timestamp(tsEnde.getTime() + diff);
				}
			}
			// 20 Millisekunden abziehen, damit es zu keiner Unique constaraint
			// verletzung kommt
			tsEnde = new Timestamp(tsEnde.getTime() + 20);

			if (dtoGeht != null) {
				if (tsEnde.after(dtoGeht.getTZeit())) {
					// Soviel Zeit ist nicht ueber
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_GEHT_VOR_ENDE,
							new Exception("FEHLER_GEHT_VOR_ENDE"));
				}
			}

		} catch (NoResultException ex) {
			// nichts
		}

		return tsEnde;
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public void automatikbuchungenAufrollen(java.sql.Date tVon, java.sql.Date tBis, Integer personalIId,
			TheClientDto theClientDto, boolean bLoeschen) throws EJBExceptionLP {

		Calendar c = Calendar.getInstance();
		c.setTime(tBis);
		c.set(Calendar.HOUR_OF_DAY, 23);
		c.set(Calendar.MINUTE, 59);
		c.set(Calendar.SECOND, 59);
		c.set(Calendar.MILLISECOND, 999);

		tVon = Helper.cutDate(tVon);

		java.util.Date dBis = c.getTime();

		if (bLoeschen == true) {

			getZeiterfassungFac().automatikbuchungenLoeschen(tVon, personalIId, theClientDto, dBis);
		}

		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();
		org.hibernate.Criteria autoPausen = session.createCriteria(FLRZeitdaten.class);
		autoPausen.createAlias("flrpersonal", "p");
		autoPausen.add(Restrictions.eq("p.mandant_c_nr", theClientDto.getMandant()));
		if (personalIId != null) {
			autoPausen.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalIId));
		}
		autoPausen.add(Restrictions.ge(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tVon));

		autoPausen.add(Restrictions.le(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, dBis));
		// Hole id der Taetigkeit GEHT
		Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();

		autoPausen.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID, taetigkeitIId_Geht));
		List<?> resultListAlleGehtimZeitraum = autoPausen.list();

		Iterator<?> resultListIterator = resultListAlleGehtimZeitraum.iterator();
		while (resultListIterator.hasNext()) {
			FLRZeitdaten zeitdaten = (FLRZeitdaten) resultListIterator.next();

			boolean bNurWarnung = false;
			ParametermandantDto parameter = null;
			try {
				parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
						ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_AUTOMATISCHE_PAUSEN_NUR_WARNUNG);

				bNurWarnung = (Boolean) parameter.getCWertAsObject();

			} catch (RemoteException ex5) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
			}
			if (bNurWarnung == false) {
				getZeiterfassungFac().pruefeUndErstelleAutomatischePausen(
						new java.sql.Timestamp(zeitdaten.getT_zeit().getTime()), zeitdaten.getPersonal_i_id(),
						theClientDto);
				getZeiterfassungFac().erstelleAutomatischeMindestpause(
						new java.sql.Timestamp(zeitdaten.getT_zeit().getTime()), zeitdaten.getPersonal_i_id(),
						theClientDto);
				getZeiterfassungFac().erstelleAutomatischePauseBeiUnproduktiverZeit(
						new java.sql.Timestamp(zeitdaten.getT_zeit().getTime()), zeitdaten.getPersonal_i_id(),
						theClientDto);
			}
			getZeiterfassungFac().pruefeUndErstelleAutomatischesEndeBeiGeht(
					new java.sql.Timestamp(zeitdaten.getT_zeit().getTime()), zeitdaten.getPersonal_i_id(),
					theClientDto);
		}
		session.close();
	}

	public void automatikbuchungenLoeschen(java.sql.Date tVon, Integer personalIId, TheClientDto theClientDto,
			java.util.Date dBis) {
		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();
		org.hibernate.Criteria autoPausen = session.createCriteria(FLRZeitdaten.class);
		autoPausen.createAlias("flrpersonal", "p");
		autoPausen.add(Restrictions.eq("p.mandant_c_nr", theClientDto.getMandant()));
		if (personalIId != null) {
			autoPausen.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalIId));
		}
		autoPausen.add(Restrictions.ge(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tVon));
		autoPausen.add(Restrictions.le(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, dBis));
		autoPausen.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_B_AUTOMATIKBUCHUNG, Helper.boolean2Short(true)));
		/*
		 * autoPausen.add(Restrictions
		 * .isNull(ZeiterfassungFac.FLR_ZEITDATEN_MASCHINE_I_ID));
		 */
		List<?> resultListAutopausen = autoPausen.list();

		Iterator<?> resultListIterator = resultListAutopausen.iterator();
		while (resultListIterator.hasNext()) {
			FLRZeitdaten zeitdaten = (FLRZeitdaten) resultListIterator.next();

			Zeitdaten toRemove = em.find(Zeitdaten.class, zeitdaten.getI_id());
			if (toRemove == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
			}
			try {
				em.remove(toRemove);
				em.flush();
			} catch (EntityExistsException er) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, er);
			}

		}
		session.close();
	}

	// PJ21325
	@TransactionAttribute(TransactionAttributeType.NEVER)
	public void negativstundenInUrlaubUmwandeln(Integer iJahr, Integer iMonat, Integer personalIId,
			TheClientDto theClientDto) {
		PersonalDto[] personalDtos = null;
		if (personalIId != null) {
			personalDtos = new PersonalDto[1];

			personalDtos[0] = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);

		} else {
			try {
				personalDtos = getPersonalFac().personalFindByMandantCNr(theClientDto.getMandant(), true);
			} catch (RemoteException e) {
				throwEJBExceptionLPRespectOld(e);
			}
		}

		Integer tagesartIId_Feiertag = getZeiterfassungFac()
				.tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
		Integer tagesartIId_Halbtag = getZeiterfassungFac()
				.tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();

		TaetigkeitDto taetigkeitDto_Urlaub = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_URLAUB, theClientDto);

		for (int i = 0; i < personalDtos.length; i++) {
			PersonalDto personalDto = personalDtos[i];

			PartnerDto partnerDto = getPartnerFac().partnerFindByPrimaryKey(personalDto.getPartnerIId(), theClientDto);
			personalDto.setPartnerDto(partnerDto);

			personalIId = personalDto.getIId();

			boolean bTageweiseBetrachtung = false;
			try {
				PersonalgehaltDto pgDto = getPersonalFac().personalgehaltFindLetztePersonalgehalt(personalDto.getIId(),
						iJahr, iMonat);
				if (pgDto != null) {
					bTageweiseBetrachtung = Helper
							.short2boolean(pgDto.getBNegativstundenInUrlaubUmwandelnTageweiseBetrachten());
				}
			} catch (RemoteException e) {
				throwEJBExceptionLPRespectOld(e);
			}
			int iTage = Helper.ermittleAnzahlTageEinesMonats(iJahr, iMonat);

			Calendar calVon = Calendar.getInstance();
			calVon.set(iJahr, iMonat, 1, 0, 0, 0);
			calVon.set(Calendar.MILLISECOND, 0);
			Timestamp tVon = new java.sql.Timestamp(calVon.getTimeInMillis());

			Calendar calBis = Calendar.getInstance();
			calBis.set(iJahr, iMonat, 1, 0, 0, 0);
			calBis.set(Calendar.MILLISECOND, 0);
			calBis.set(Calendar.DAY_OF_MONTH, calBis.getActualMaximum(calBis.DAY_OF_MONTH));
			Timestamp tBis = new java.sql.Timestamp(calBis.getTimeInMillis());

			getZeiterfassungFac().automatischeSonderzeitenEntfernen(personalIId, tVon, tBis);

			MonatsabrechnungDto moaDto = erstelleMonatsAbrechnung(personalDto.getIId(), iJahr, iMonat, true, null,
					theClientDto, false, ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_PERSONALNUMMER,
					null);

			HashMap parameter = moaDto.getParameter();

			Object[][] datenMoa = moaDto.getData();
			for (int j = 0; j < datenMoa.length; j++) {
				Object[] zeileMoa = datenMoa[j];

				String tagesart = (String) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_TAGESART];

				BigDecimal bdIst = (BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_IST];
				BigDecimal bdSoll = (BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SOLL];

				// Wenn Sollzeit

				Timestamp tDatum = (Timestamp) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_DATUM];
				SonderzeitenDto[] szDtos = sonderzeitenFindByPersonalIIdDDatum(personalIId, tDatum);

				boolean bUrlaubTageweiseOderHalbtageweiseVorhanden = false;
				for (SonderzeitenDto szDto : szDtos) {
					if (Helper.short2boolean(szDto.getBHalbtag()) == true
							|| Helper.short2boolean(szDto.getBTag()) == true) {
						if (szDto.getTaetigkeitIId().equals(taetigkeitDto_Urlaub.getIId())) {
							// Wenn an dem Tag bereits Urlaub vorhanden ist, dann FEHLER
							bUrlaubTageweiseOderHalbtageweiseVorhanden = true;

						}
					}
				}

				if (bdSoll.doubleValue() > 0 && bUrlaubTageweiseOderHalbtageweiseVorhanden == false) {

					bdSoll = Helper.rundeKaufmaennisch(bdSoll, 2);
					bdIst = Helper.rundeKaufmaennisch(bdIst, 2);

					// Wenn Sollzeit

					// PJ22087
					BigDecimal bdStundenAusSonderzeiten = BigDecimal.ZERO;
					for (SonderzeitenDto szDto : szDtos) {

						if (Helper.short2boolean(szDto.getBHalbtag()) == false
								&& Helper.short2boolean(szDto.getBTag()) == false && szDto.getUStunden() != null) {
							bdStundenAusSonderzeiten = bdStundenAusSonderzeiten
									.add(new BigDecimal(Helper.time2Double(szDto.getUStunden())));
						}
					}

					BigDecimal diff = bdSoll.subtract(bdStundenAusSonderzeiten).subtract(bdIst);

					if (bdStundenAusSonderzeiten.doubleValue() == 0 && bdIst.doubleValue() == 0) {
						// Und Keine Sonderzeiten an diesem Tag, dann URLAUB eintragen

						SonderzeitenDto szDto = new SonderzeitenDto();

						szDto.setBAutomatik(Helper.boolean2Short(true));
						szDto.setBHalbtag(Helper.boolean2Short(false));
						szDto.setBTag(Helper.boolean2Short(true));
						szDto.setPersonalIId(personalDto.getIId());
						szDto.setTDatum(Helper.cutTimestamp(tDatum));
						szDto.setBAutomatik(Helper.boolean2Short(true));
						szDto.setTaetigkeitIId(taetigkeitDto_Urlaub.getIId());
						szDto.setBAutomatik(Helper.boolean2Short(true));
						getZeiterfassungFac().createSonderzeiten(szDto, theClientDto);
					} else if (diff.doubleValue() > 0) {
						SonderzeitenDto szDto = new SonderzeitenDto();

						szDto.setBAutomatik(Helper.boolean2Short(true));
						szDto.setBHalbtag(Helper.boolean2Short(false));
						szDto.setBTag(Helper.boolean2Short(false));

						szDto.setUStunden(new Time(((long) (diff.doubleValue() * 3600000)) - 3600000));

						szDto.setPersonalIId(personalDto.getIId());
						szDto.setTDatum(Helper.cutTimestamp(tDatum));
						szDto.setBAutomatik(Helper.boolean2Short(true));
						szDto.setTaetigkeitIId(taetigkeitDto_Urlaub.getIId());
						szDto.setBAutomatik(Helper.boolean2Short(true));
						getZeiterfassungFac().createSonderzeiten(szDto, theClientDto);
					}
				}
			}

			moaDto = erstelleMonatsAbrechnung(personalDto.getIId(), iJahr, iMonat, true, null, theClientDto, false,
					ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_PERSONALNUMMER, null);

			parameter = moaDto.getParameter();

			BigDecimal bdSaldo = moaDto.getGleitzeitsaldoAbrechnungsmonatOhneVormonat();

			BigDecimal bdZuVerbrauchen = new BigDecimal(99999999.99);
			if (bTageweiseBetrachtung) {
				bdZuVerbrauchen = new BigDecimal(99999999.99);
			} else {
				if (bdSaldo.doubleValue() > 0) {
					bdZuVerbrauchen = BigDecimal.ZERO;
				} else {
					bdZuVerbrauchen = bdSaldo.negate();
				}

			}

			datenMoa = moaDto.getData();

			for (int j = datenMoa.length - 1; j >= 0; j--) {
				Object[] zeileMoa = datenMoa[j];

				String tagesart = (String) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_TAGESART];

				BigDecimal bdIst = (BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_IST];
				BigDecimal bdSoll = (BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SOLL];
				BigDecimal bdDiff = (BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_DIFF];

				if (bdSoll.doubleValue() > 0 && bdIst.doubleValue() > 0 && bdDiff.doubleValue() < 0) {
					// Wenn Sollzeit

					if (bdZuVerbrauchen.doubleValue() > 0) {

						BigDecimal bdAmTagBuchen = null;
						if (bdDiff.abs().doubleValue() >= bdZuVerbrauchen.doubleValue()) {
							bdAmTagBuchen = bdZuVerbrauchen;
							bdZuVerbrauchen = BigDecimal.ZERO;

						} else {
							bdAmTagBuchen = bdDiff.abs();
							bdZuVerbrauchen = bdZuVerbrauchen.subtract(bdDiff.abs());
						}

						Timestamp tDatum = (Timestamp) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_DATUM];

						SonderzeitenDto[] szDtos = sonderzeitenFindByPersonalIIdDDatum(personalIId, tDatum);

						if (szDtos.length == 0) {
							// Und Keine Sonderzeiten an diesem Tag, dann URLAUB eintragen

							SonderzeitenDto szDto = new SonderzeitenDto();

							szDto.setBAutomatik(Helper.boolean2Short(true));
							szDto.setBHalbtag(Helper.boolean2Short(false));
							szDto.setBTag(Helper.boolean2Short(false));

							szDto.setUStunden(new Time(((long) (bdAmTagBuchen.doubleValue() * 3600000)) - 3600000));

							szDto.setPersonalIId(personalDto.getIId());
							szDto.setTDatum(Helper.cutTimestamp(tDatum));
							szDto.setBAutomatik(Helper.boolean2Short(true));
							szDto.setTaetigkeitIId(taetigkeitDto_Urlaub.getIId());
							szDto.setBAutomatik(Helper.boolean2Short(true));
							getZeiterfassungFac().createSonderzeiten(szDto, theClientDto);
						}
					}
				}
			}

		}

	}

	public void automatischeSonderzeitenEntfernen(Integer personalIId, Timestamp tVon, Timestamp tBis) {
		Query query = em.createNamedQuery("SonderzeitenfindAlleAutomatikbuchungenEinesZeitraums");
		query.setParameter(1, personalIId);
		query.setParameter(2, Helper.cutTimestamp(tVon));
		query.setParameter(3, Helper.cutTimestamp(tBis));
		Collection<?> cl = query.getResultList();
		Iterator it = cl.iterator();
		while (it.hasNext()) {
			Sonderzeiten sz = (Sonderzeiten) it.next();
			em.remove(sz);
			em.flush();
		}
	}

	public void pruefeUndErstelleAutomatischePausen(java.sql.Timestamp tZeitpunkt, Integer personalIId,
			TheClientDto theClientDto) throws EJBExceptionLP {
		try {
			PersonalzeitmodellDto personalzeitmodellDto = getPersonalFac().personalzeitmodellFindZeitmodellZuDatum(
					personalIId, Helper.cutTimestamp(tZeitpunkt), theClientDto);
			// Wenn kein Zeitmodell zugeordnet, dann keine Pausen
			if (personalzeitmodellDto == null) {
				return;
			}

			Calendar c = Calendar.getInstance();
			c.setTimeInMillis(tZeitpunkt.getTime());
			Integer tagesartIId = null;
			try {
				Query query = em.createNamedQuery("TagesartfindByCNr");
				query.setParameter(1, Helper.holeTagbezeichnungLang(c.get(Calendar.DAY_OF_WEEK)));
				Tagesart tagesart = (Tagesart) query.getSingleResult();

				tagesartIId = tagesart.getIId();
			} catch (NoResultException ex2) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, ex2);
			}

			BetriebskalenderDto dto = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(
					Helper.cutTimestamp(tZeitpunkt), theClientDto.getMandant(), theClientDto);
			if (dto != null) {
				Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto)
						.getIId();
				Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto)
						.getIId();
				if (dto.getTagesartIId().equals(tagesartIId_Feiertag)
						|| dto.getTagesartIId().equals(tagesartIId_Halbtag)) {
					tagesartIId = dto.getTagesartIId();
				} else {
					// SP8740 Wenn Betriebsurlaub, dann kommt die Tagesart bzw. die Pausen aus dem
					// Wochentag, und nicht aus dem Betriebsurlaub
					// d.h. Wenn am Dienstag Betriebsurlaub ist, dann kommen die Pausen aus der
					// Tagesart Dienstag und nicht aus der Tagesart Betriebsurlaub
					Integer tagesartIId_Betriebsurlaub = tagesartFindByCNr(ZeiterfassungFac.TAGESART_BETRIEBSURLAUB,
							theClientDto).getIId();
					if (!dto.getTagesartIId().equals(tagesartIId_Betriebsurlaub)) {
						// Wenn kein Betriebsurlaub, dann kommt die Tagesart aus dem Betriebskalender
						tagesartIId = dto.getTagesartIId();
					}
				}
			}

			// Ist fuer die heutige Tagesart etwas definiert?
			Integer zmtagIId = null;
			// try {
			Query query1 = em.createNamedQuery("ZeitmodelltagfindByZeitmodellIIdTagesartIId");
			query1.setParameter(1, personalzeitmodellDto.getZeitmodellIId());
			query1.setParameter(2, tagesartIId);
			// @todo getSingleResult oder getResultList ?
			Zeitmodelltag zmtag = null;
			try {
				zmtag = (Zeitmodelltag) query1.getSingleResult();
			} catch (javax.persistence.NoResultException e) {
				// nix
			} catch (NonUniqueResultException e) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_NO_UNIQUE_RESULT, e);
			}
			if (zmtag != null) {
				zmtagIId = zmtag.getIId();
				// }
				// catch (NoResultException ex3) {
				// //nix
				// }
				if (zmtagIId == null) {
					// fuer heute nichts definiert
					return;
				}
			}

			// Hole Pausen
			ZeitmodelltagpauseDto[] zeitmodelltagpauseDtos = null;
			// try {
			Query query2 = em.createNamedQuery("ZeitmodelltagpausefindByZeitmodelltagIId");
			query2.setParameter(1, zmtagIId);

			Collection<?> cl = query2.getResultList();
			// if (! cl.isEmpty()) {
			zeitmodelltagpauseDtos = assembleZeitmodelltagpauseDtos(cl);
			// }
			// catch (NoResultException ex3) {
			// //nix
			// }
			if (zeitmodelltagpauseDtos == null || zeitmodelltagpauseDtos.length == 0) {
				// keine pausen definiert
				return;
			}

			// Hole Zeitdaten eines Tages
			ZeitdatenDto[] zeitdatenDtos = null;
			// try {
			Query query3 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
			query3.setParameter(1, personalIId);
			query3.setParameter(2, Helper.cutTimestamp(Helper.addiereTageZuTimestamp(tZeitpunkt, -1)));
			query3.setParameter(3, tZeitpunkt);
			Collection<?> cl1 = query3.getResultList();
			// if (! cl1.isEmpty()) {
			zeitdatenDtos = assembleZeitdatenDtosOhneBelegzeiten(cl1);
			// }
			// catch (NoResultException ex4) {
			// //nix
			// }

			if (zeitdatenDtos == null || zeitdatenDtos.length == 0) {
				// keine daten fuer heute
				return;
			}

			// Hole id der Taetigkeit KOMMT
			Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();
			// Hole id der Taetigkeit GEHT
			Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();

			java.sql.Timestamp letztesKommt = null;

			for (int i = zeitdatenDtos.length - 1; i >= 0; i--) {
				if (zeitdatenDtos[i].getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {
					letztesKommt = zeitdatenDtos[i].getTZeit();
					break;
				}
				if (zeitdatenDtos[i].getTaetigkeitIId().equals(taetigkeitIId_Geht)) {
					// wenn zuerst ein GEHT vor einem KOMMT gefunden wurde, dann
					// zurueck
					return;
				}
			}

			if (letztesKommt != null) {

				// SP8633 Wenn das letzte Kommt am Vortag ist, dann auch die Pausen fr den
				// Vortag bis um 23:59 eintragen

				java.sql.Timestamp tZeitpunktGestern23_59 = new java.sql.Timestamp(
						Helper.cutTimestamp(tZeitpunkt).getTime() - 1000);
				if (letztesKommt.before(tZeitpunktGestern23_59)) {
					pruefeUndErstelleAutomatischePausen(tZeitpunktGestern23_59, personalIId, theClientDto);
				}

				for (int k = 0; k < zeitmodelltagpauseDtos.length; k++) {
					ZeitmodelltagpauseDto zeitmodelltagpauseDto = zeitmodelltagpauseDtos[k];
					// Hole daten des tages
					Session session = FLRSessionFactory.getFactory().openSession();

					// SP7923 wg. Zeitumstellung Stunden ueber Kalender addieren
					Calendar cZeitpunktVon = Calendar.getInstance();
					cZeitpunktVon.setTimeInMillis(Helper.cutTimestamp(tZeitpunkt).getTime());

					Calendar cVon = Calendar.getInstance();
					cVon.setTimeInMillis(zeitmodelltagpauseDto.getUBeginn().getTime());

					cZeitpunktVon.set(Calendar.HOUR_OF_DAY, cVon.get(Calendar.HOUR_OF_DAY));
					cZeitpunktVon.set(Calendar.MINUTE, cVon.get(Calendar.MINUTE));

					Timestamp tVon = new Timestamp(cZeitpunktVon.getTimeInMillis());

					Calendar cZeitpunktBis = Calendar.getInstance();
					cZeitpunktBis.setTimeInMillis(Helper.cutTimestamp(tZeitpunkt).getTime());

					Calendar cBis = Calendar.getInstance();
					cBis.setTimeInMillis(zeitmodelltagpauseDto.getUEnde().getTime());

					cZeitpunktBis.set(Calendar.HOUR_OF_DAY, cBis.get(Calendar.HOUR_OF_DAY));
					cZeitpunktBis.set(Calendar.MINUTE, cBis.get(Calendar.MINUTE));

					Timestamp tBis = new Timestamp(cZeitpunktBis.getTimeInMillis());

					if (tVon.after(tZeitpunkt)) {
						continue;
					}

					if (Helper.short2boolean(personalzeitmodellDto.getZeitmodellDto().getBFixepauseTrotzkommtgeht())) {
						// PJ18888 Wenn Kommt oder Geht zwischen VON_BIS bis,
						// dann
						// muss Pause mitgemacht werden
						if (letztesKommt.after(tVon) && letztesKommt.before(tBis)) {
							tVon = new Timestamp(letztesKommt.getTime() + 10);
						}

						if (tBis.after(tZeitpunkt)) {
							tBis = new Timestamp(tZeitpunkt.getTime() - 10);
						}
					} else {
						if (tBis.after(tZeitpunkt)) {
							continue;
						}
					}

					// Wenn KOMMT vor Automatischem UNTER, sonst Naechste
					// Buchung
					if (letztesKommt.before(tVon)) {

						// SP4896 Neue Definition: Gilt fuer ALLE
						// Bestandskunden:
						// Eine Fixe Pause ist FIX, DH wenn von 12:00 bis 12:30
						// definiert, dann muss diese auch in diesem Zeitraum
						// bleiben!

						// Idealer Fall: zwischen VON und BIS gibt es keine
						// Zeitdaten: VON-BIS einfach buchen!

						// Ansonsten: Pruefen, ob

						if (istPersonAnwesend(zeitdatenDtos, taetigkeitIId_Kommt, tVon)) {

							Integer taetigkeitIId_Unter = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER,
									theClientDto).getIId();

							org.hibernate.Criteria zeitdaten = session.createCriteria(FLRZeitdaten.class);
							zeitdaten.add(Restrictions.ge(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tVon));
							zeitdaten.add(Restrictions.le(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tBis));
							zeitdaten.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalIId));
							zeitdaten.addOrder(Order.asc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));

							List resultListArtikel = zeitdaten.list();

							Iterator resultListIterator = resultListArtikel.iterator();

							ArrayList<FLRZeitdaten> alZeitdatenZwischenVonBis = new ArrayList();

							while (resultListIterator.hasNext()) {
								FLRZeitdaten zeile = (FLRZeitdaten) resultListIterator.next();

								alZeitdatenZwischenVonBis.add(zeile);

							}

							// Automatische Pause eintragen
							ZeitdatenDto autoPause = new ZeitdatenDto();
							autoPause.setPersonalIId(personalIId);
							autoPause.setTZeit(tVon);
							autoPause.setBAutomatikbuchung(Helper.boolean2Short(true));
							autoPause.setTaetigkeitIId(taetigkeitIId_Unter);

							if (alZeitdatenZwischenVonBis.isEmpty()) {

								createZeitdaten(autoPause, false, false, false, false, theClientDto);
								autoPause.setTZeit(tBis);
								createZeitdaten(autoPause, false, false, false, false, theClientDto);

								continue;
							}

							// Da die Person ja anwesend ist, muss ich vom
							// Pause-VON bis zum ersten Eintrag nach dem VON
							// eine Pause einbuchen

							boolean bVonAnlegen = true;
							if (alZeitdatenZwischenVonBis.get(0).getT_zeit().getTime() == tVon.getTime()) {
								// es gibt schon einen Eintrag zu dieser
								// Zeit
								bVonAnlegen = false;
							}

							// Automatische Pause eintragen
							if (bVonAnlegen) {
								// UNTER_BEGINN
								createZeitdaten(autoPause, false, false, false, false, theClientDto);
							}

							// UNTER-ENDE
							autoPause.setTZeit(
									new Timestamp(alZeitdatenZwischenVonBis.get(0).getT_zeit().getTime() - 10));

							createZeitdaten(autoPause, false, false, false, false, theClientDto);

							if (istPersonAnwesend(zeitdatenDtos, taetigkeitIId_Kommt, tBis)) {

								boolean bBisAnlegen = true;
								if (alZeitdatenZwischenVonBis.get(alZeitdatenZwischenVonBis.size() - 1).getT_zeit()
										.getTime() == tBis.getTime()) {
									bBisAnlegen = false;

								}

								if (bBisAnlegen == true) {
									autoPause.setTZeit(tBis);
									// UNTER_ENDE
									createZeitdaten(autoPause, false, false, false, false, theClientDto);
								}

								// UNTER_BEGINN
								autoPause.setTZeit(new Timestamp(alZeitdatenZwischenVonBis
										.get(alZeitdatenZwischenVonBis.size() - 1).getT_zeit().getTime() + 10));

								createZeitdaten(autoPause, false, false, false, false, theClientDto);

							}

						} else {
							if (Helper.short2boolean(
									personalzeitmodellDto.getZeitmodellDto().getBFixepauseTrotzkommtgeht())) {
								if (istPersonAnwesend(zeitdatenDtos, taetigkeitIId_Kommt, tBis)) {

									// Nun Pause-Ende buchen
									// Automatische Pause eintragen

									Integer taetigkeitIId_Unter = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER,
											theClientDto).getIId();

									ZeitdatenDto autoPause = new ZeitdatenDto();
									autoPause.setPersonalIId(personalIId);
									autoPause.setTZeit(tBis);
									autoPause.setBAutomatikbuchung(Helper.boolean2Short(true));
									autoPause.setTaetigkeitIId(taetigkeitIId_Unter);

									try {
										Query query = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
										query.setParameter(1, autoPause.getPersonalIId());
										query.setParameter(2, autoPause.getTZeit());
										Zeitdaten zeitdaten2 = (Zeitdaten) query.getSingleResult();
									} catch (NoResultException ex) {
										// Wenn zu dem Zeitpunkt noch keine
										// buchung
										createZeitdaten(autoPause, false, false, false, false, theClientDto);

										// Und Unter-Beginn zum Zeitpunkt der
										// lettzen Taetigkeit eintragen (+ 10ms)

										org.hibernate.Criteria zeitdaten = session.createCriteria(FLRZeitdaten.class);

										zeitdaten.add(Restrictions.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT,
												autoPause.getTZeit()));
										zeitdaten.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID,
												personalIId));
										zeitdaten.add(
												Restrictions.isNotNull(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID));
										zeitdaten.addOrder(Order.desc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));
										zeitdaten.setMaxResults(1);
										List resultListArtikel = zeitdaten.list();

										Iterator resultListIterator = resultListArtikel.iterator();

										boolean bVonAnlegen = true;
										boolean bBisAnlegen = true;

										if (resultListIterator.hasNext()) {
											FLRZeitdaten zeile = (FLRZeitdaten) resultListIterator.next();
											autoPause.setTZeit(new Timestamp(zeile.getT_zeit().getTime() + 10));

											boolean bAngelegt = false;
											while (bAngelegt == false) {

												try {
													Query query = em
															.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
													query.setParameter(1, autoPause.getPersonalIId());
													query.setParameter(2, autoPause.getTZeit());
													Zeitdaten zeitdaten2 = (Zeitdaten) query.getSingleResult();

													autoPause.setTZeit(
															new Timestamp(autoPause.getTZeit().getTime() + 10));

												} catch (NoResultException ex2) {
													bAngelegt = true;
													createZeitdaten(autoPause, false, false, false, false,
															theClientDto);

												}

											}

										}

									}

								}
							}
						}
					}
				}
			}

		} catch (RemoteException ex) {
			throwEJBExceptionLPRespectOld(ex);
		}

	}

	private boolean istPersonAnwesend(ZeitdatenDto[] zeitdatenDtos, Integer taetigkeitIId_Kommt,
			java.sql.Timestamp tsZeitpunkt) {
		Timestamp letztesKommt = null;

		boolean bAnwesend = true;
		for (int i = zeitdatenDtos.length - 1; i >= 0; i--) {
			if (zeitdatenDtos[i].getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {
				letztesKommt = zeitdatenDtos[i].getTZeit();
				break;
			}
		}

		if (letztesKommt != null) {

			Integer iLetzteTaetigkeit = null;
			int iAnzahlGleicherTaetigkeiten = 0;

			for (int i = zeitdatenDtos.length - 1; i >= 0; i--) {

				if (zeitdatenDtos[i].getTZeit().after(letztesKommt) && zeitdatenDtos[i].getTZeit().before(tsZeitpunkt)
						|| zeitdatenDtos[i].getTZeit().equals(tsZeitpunkt)) {

					if (iLetzteTaetigkeit == null) {

						iAnzahlGleicherTaetigkeiten++;
					} else {
						if (iLetzteTaetigkeit.equals(zeitdatenDtos[i].getTaetigkeitIId())) {
							iAnzahlGleicherTaetigkeiten++;
						} else {
							break;
						}
					}
					iLetzteTaetigkeit = zeitdatenDtos[i].getTaetigkeitIId();
				}

			}

			if (iAnzahlGleicherTaetigkeiten % 2 == 1) {
				bAnwesend = false;
			}
		}

		return bAnwesend;
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public void schichtzeitmodelleAufrollen(java.sql.Date tVon, java.sql.Date tBis, Integer personalIId,
			TheClientDto theClientDto) {

		Calendar c = Calendar.getInstance();
		c.setTime(tBis);
		c.set(Calendar.HOUR_OF_DAY, 23);
		c.set(Calendar.MINUTE, 59);
		c.set(Calendar.SECOND, 59);
		c.set(Calendar.MILLISECOND, 999);

		tVon = Helper.cutDate(tVon);

		java.util.Date dBis = c.getTime();

		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();
		org.hibernate.Criteria query = session.createCriteria(FLRZeitdaten.class);
		query.createAlias("flrpersonal", "p");
		query.add(Restrictions.eq("p.mandant_c_nr", theClientDto.getMandant()));
		if (personalIId != null) {
			query.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalIId));
		}
		query.add(Restrictions.ge(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tVon));

		query.add(Restrictions.le(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, dBis));
		// Hole id der Taetigkeit GEHT
		Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();

		query.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID, taetigkeitIId_Kommt));
		List<?> resultListAlleKommtimZeitraum = query.list();

		Iterator<?> resultListIterator = resultListAlleKommtimZeitraum.iterator();
		while (resultListIterator.hasNext()) {
			FLRZeitdaten zeitdaten = (FLRZeitdaten) resultListIterator.next();
			getZeiterfassungFac().schichtzeitmodellEintragen(
					zeitdatenFindByPrimaryKey(zeitdaten.getI_id(), theClientDto), theClientDto);
		}
		session.close();
	}

	public void pruefeUndErstelleAutomatischesEndeBeiGeht(java.sql.Timestamp tZeitpunktGeht, Integer personalIId,
			TheClientDto theClientDto) throws EJBExceptionLP {

		// Hole id der Taetigkeit KOMMT
		Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();
		// Hole id der Taetigkeit GEHT
		Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();

		ZeitdatenDto[] zeitdatenDtos = null;

		// try {
		// Hole Zeitdaten eines Tages
		Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
		query.setParameter(1, personalIId);
		query.setParameter(2, Helper.cutTimestamp(tZeitpunktGeht));
		query.setParameter(3, tZeitpunktGeht);
		Collection<?> cl = query.getResultList();
		// if (! cl.isEmpty()) {
		zeitdatenDtos = assembleZeitdatenDtos(query.getResultList());
		// }
		// catch (NoResultException ex) {
		// zeitdatenDtos = null;
		// }
		// Letztes KOMMT suchen
		Timestamp tLetztesKommt = null;
		ArrayList<ZeitdatenDto> alZeitdaten = new ArrayList<ZeitdatenDto>();
		for (int i = zeitdatenDtos.length - 1; i >= 0; i--) {
			ZeitdatenDto zeitdatenDto = zeitdatenDtos[i];
			alZeitdaten.add(zeitdatenDto);
			if (zeitdatenDto.getTaetigkeitIId() != null) {
				if (zeitdatenDto.getTaetigkeitIId().equals(taetigkeitIId_Geht)) {
					break;
				}
				if (zeitdatenDto.getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {
					tLetztesKommt = zeitdatenDto.getTZeit();
					// kommt wieder aus liste entfernen
					alZeitdaten.remove(alZeitdaten.size() - 1);

					break;
				}
			}
		}

		query = em.createNamedQuery("MaschinenzeitdatenfindByPersonalIIdGestartet");
		query.setParameter(1, personalIId);
		query.setParameter(2, tZeitpunktGeht);
		cl = query.getResultList();

		Iterator<?> iterator = cl.iterator();
		while (iterator.hasNext()) {
			Maschinenzeitdaten maschinenzeitdaten = (Maschinenzeitdaten) iterator.next();
			// SP1568

			LossollarbeitsplanDto lsapDto = getFertigungFac()
					.lossollarbeitsplanFindByPrimaryKey(maschinenzeitdaten.getLossollarbeitsplanIId());

			if (maschinenzeitdaten.getTBis() == null) {
				if (lsapDto.getMaschineIId() == null) {
					// SP3796
					MaschineDto mDto = getZeiterfassungFac()
							.maschineFindByPrimaryKey(maschinenzeitdaten.getMaschineIId());

					if (Helper.short2boolean(mDto.getBAutoendebeigeht()) == true) {

						maschinenzeitdaten.setTBis(tZeitpunktGeht);
						em.merge(maschinenzeitdaten);
						em.flush();
					}

				} else {

					if (Helper.short2boolean(lsapDto.getBAutoendebeigeht()) == true) {
						maschinenzeitdaten.setTBis(tZeitpunktGeht);
						em.merge(maschinenzeitdaten);
						em.flush();
					}
				}
			}

		}

	}

	public java.sql.Time getRelativeZeitFuerRelativesAendernAmClient(Integer personalIId,
			java.sql.Timestamp tBelegbuchung) {

		java.sql.Time tReturn = new java.sql.Time(-3600000);
		if (tBelegbuchung != null) {

			try {
				// Hole Zeitdaten eines Tages
				Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
				query.setParameter(1, personalIId);
				query.setParameter(2, tBelegbuchung);
				query.setParameter(3, Helper.addiereTageZuTimestamp(Helper.cutTimestamp(tBelegbuchung), 1));
				Collection<?> cl = query.getResultList();
				ZeitdatenDto[] zeitdatenDtos = null;
				// if (! cl.isEmpty()) {
				zeitdatenDtos = assembleZeitdatenDtos(cl);
				// }
				if (zeitdatenDtos.length > 1) {
					Query query1 = em.createNamedQuery("TaetigkeitfindByCNr");
					query1.setParameter(1, ZeiterfassungFac.TAETIGKEIT_ENDE);
					Integer taetigkeitIId_Ende = ((Taetigkeit) query1.getSingleResult()).getIId();
					ZeitdatenDto naechster = zeitdatenDtos[1];

					if (naechster.getIBelegartid() != null || (naechster.getTaetigkeitIId() != null
							&& naechster.getTaetigkeitIId().equals(taetigkeitIId_Ende))) {

						long diff = naechster.getTZeit().getTime() - zeitdatenDtos[0].getTZeit().getTime();
						tReturn = new java.sql.Time(-3600000 + diff + 10);

					}

				}
			} catch (NoResultException ex) {
				// Keine Zeitdaten vorhanden
			}
		}

		return tReturn;
	}

	public void aendereZeitRelativ(ZeitdatenDto zeitdatenDto, java.sql.Time tZeitRelativ, TheClientDto theClientDto) {
		if (zeitdatenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitdatenDto == null"));
		}

		try {
			Zeitdaten zeitdaten1 = em.find(Zeitdaten.class, zeitdatenDto.getIId());
			if (zeitdaten1 != null) {
				java.sql.Timestamp tSucheZeitdatenVon = zeitdaten1.getTZeit();

				// Hole Zeitdaten eines Tages
				Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
				query.setParameter(1, zeitdatenDto.getPersonalIId());
				query.setParameter(2, tSucheZeitdatenVon);
				query.setParameter(3, Helper.addiereTageZuTimestamp(Helper.cutTimestamp(zeitdatenDto.getTZeit()), 1));

				ZeitdatenDto[] zeitdatenDtos = assembleZeitdatenDtos(query.getResultList());

				Query query1 = em.createNamedQuery("TaetigkeitfindByCNr");
				query1.setParameter(1, ZeiterfassungFac.TAETIGKEIT_ENDE);
				Integer taetigkeitIId_Ende = ((Taetigkeit) query1.getSingleResult()).getIId();
				query1 = em.createNamedQuery("TaetigkeitfindByCNr");
				query1.setParameter(1, ZeiterfassungFac.TAETIGKEIT_KOMMT);
				Integer taetigkeitIId_Kommt = ((Taetigkeit) query1.getSingleResult()).getIId();
				query1 = em.createNamedQuery("TaetigkeitfindByCNr");
				query1.setParameter(1, ZeiterfassungFac.TAETIGKEIT_GEHT);
				Integer taetigkeitIId_Geht = ((Taetigkeit) query1.getSingleResult()).getIId();

				// Wenn Sondertaetigkeiten vorhanden, dann Fehler ausgeben
				for (int i = 0; i < zeitdatenDtos.length; i++) {
					ZeitdatenDto dto = zeitdatenDtos[i];
					if (dto.getTaetigkeitIId() != null) {
						if (!dto.getTaetigkeitIId().equals(taetigkeitIId_Kommt)
								&& !dto.getTaetigkeitIId().equals(taetigkeitIId_Geht)
								&& !dto.getTaetigkeitIId().equals(taetigkeitIId_Ende)) {
							throw new EJBExceptionLP(
									EJBExceptionLP.FEHLER_RELATIVES_AENDERN_MIT_SONDERTAETIGKEITEN_NICHT_MOEGLICH,
									new Exception(""));
						}
					}
				}

				// Eigentlich duerften ab hier nur mehr Auftraege/ENDE und GEHT
				// vorhanden sein

				if (zeitdatenDtos.length > 1) {
					// Naeachste Buchung ist das Auftragsende
					ZeitdatenDto endeDesAuftrages = zeitdatenDtos[1];

					java.sql.Time tAuftragVon = new java.sql.Time(tSucheZeitdatenVon.getTime());
					java.sql.Time tAuftragBis = new java.sql.Time(endeDesAuftrages.getTZeit().getTime());

					long lDifferenz = (tZeitRelativ.getTime() + 3600000)
							- ((tAuftragBis.getTime() + 3600000) - (tAuftragVon.getTime() + 3600000));

					for (int i = 1; i < zeitdatenDtos.length; i++) {
						ZeitdatenDto dto = zeitdatenDtos[i];

						if (dto.getTaetigkeitIId() == null || !dto.getTaetigkeitIId().equals(taetigkeitIId_Geht)) {

							Zeitdaten zeitdaten = em.find(Zeitdaten.class, dto.getIId());

							Timestamp neueZeit = new Timestamp(zeitdaten.getTZeit().getTime() + lDifferenz);

							zeitdaten.setTZeit(neueZeit);

							// WENNS ein ENDE ist, dann dieses noch aendern und
							// aufhoeren
							if (dto.getTaetigkeitIId() != null && dto.getTaetigkeitIId().equals(taetigkeitIId_Ende)) {
								// wenn nachher ein geht ist, pruefen ob es
								// nicth
								// spaeter als das geth wird
								if (zeitdatenDtos.length > i + 1) {
									ZeitdatenDto dtoNaechstes = zeitdatenDtos[i + 1];
									if (dtoNaechstes.getTaetigkeitIId() != null
											&& dtoNaechstes.getTaetigkeitIId().equals(taetigkeitIId_Geht)) {
										if (neueZeit.after(dtoNaechstes.getTZeit())) {
											throw new EJBExceptionLP(
													EJBExceptionLP.FEHLER_RELATIVES_AENDERN_ZUWENIG_ZEIT,
													new Exception(""));
										} else {
											return;
										}
									} else {
										return;
									}
								} else {
									return;
								}

							}
						} else {
							if (lDifferenz > 0) {
								throw new EJBExceptionLP(EJBExceptionLP.FEHLER_RELATIVES_AENDERN_ZUWENIG_ZEIT,
										new Exception(""));
							} else {
								// ENDE einbuchen
								dto.setTZeit(new Timestamp(dto.getTZeit().getTime() + lDifferenz));
								dto.setTaetigkeitIId(taetigkeitIId_Ende);
								createZeitdaten(dto, false, false, false, false, theClientDto);
							}
							return;
						}

						// Nun alle nachfolgenden Buchungen (ausser GEHT)
						// verschieben

					}
				}
			}
		} catch (NoResultException ex) {
			// Keine Zeitdaten vorhanden
		}

	}

	public Integer bucheZeitRelativ(ZeitdatenDto zeitdatenDto, Timestamp tsAbDieserZeit, Boolean bAuchWennZuWenigZeit,
			boolean bIgnoriereFehler, TheClientDto theClientDto) {
		return bucheZeitRelativ(zeitdatenDto, tsAbDieserZeit, null, bAuchWennZuWenigZeit, bIgnoriereFehler,
				theClientDto);
	}

	public Integer bucheZeitRelativ(ZeitdatenDto zeitdatenDto, Timestamp tsAbDieserZeit, Timestamp tsEndeGeht,
			Boolean bAuchWennZuWenigZeit, boolean bIgnoriereFehler, TheClientDto theClientDto) {

		if (zeitdatenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitdatenDto == null"));
		}
		if (bAuchWennZuWenigZeit == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("bAuchWennZuWenigZeit == null"));
		}
		if (zeitdatenDto.getPersonalIId() == null || zeitdatenDto.getTZeit() == null
				|| zeitdatenDto.getArtikelIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception(
					"zeitdatenDto.getPersonalIId() == null || zeitdatenDto.getTZeit() == null || zeitdatenDto.getArtikelIId() == null"));
		}
		Integer id = null;
		Integer iIdEnde = null;
		// try {
		// Hole Zeitdaten eines Tages
		Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
		query.setParameter(1, zeitdatenDto.getPersonalIId());
		if (tsAbDieserZeit != null) {
			query.setParameter(2, new Timestamp(tsAbDieserZeit.getTime() + 10));
		} else {
			query.setParameter(2, Helper.cutTimestamp(zeitdatenDto.getTZeit()));
		}

		Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();

		if (tsEndeGeht != null) {
			query.setParameter(3, tsEndeGeht);
		} else {
			query.setParameter(3, Helper.addiereTageZuTimestamp(Helper.cutTimestamp(zeitdatenDto.getTZeit()), 1));
		}
		Collection<?> cl = query.getResultList();
		// if (! cl.isEmpty()) {
		ZeitdatenDto[] zeitdatenDtos = assembleZeitdatenDtos(query.getResultList());

		Query query1 = em.createNamedQuery("TaetigkeitfindByCNr");
		query1.setParameter(1, ZeiterfassungFac.TAETIGKEIT_ENDE);
		Integer taetigkeitIId_Ende = ((Taetigkeit) query1.getSingleResult()).getIId();
		query1 = em.createNamedQuery("TaetigkeitfindByCNr");
		query1.setParameter(1, ZeiterfassungFac.TAETIGKEIT_KOMMT);
		Integer taetigkeitIId_Kommt = ((Taetigkeit) query1.getSingleResult()).getIId();

		Timestamp tsAbDaFrei = null;
		if (tsAbDieserZeit != null) {
			tsAbDaFrei = tsAbDieserZeit;
		}

		boolean bLetzterEintragIstEnde = false;

		if (bIgnoriereFehler == false) {
			if (zeitdatenDtos != null && zeitdatenDtos.length == 0) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_RELATIVE_BUCHUNG_OHNE_KOMMT,
						new Exception("FEHLER_RELATIVE_BUCHUNG_OHNE_KOMMT"));

			}

			if (zeitdatenDtos != null && zeitdatenDtos.length > 0) {
				ZeitdatenDto dto = zeitdatenDtos[0];
				if (dto.getTaetigkeitIId() == null) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_RELATIVE_BUCHUNG_OHNE_KOMMT,
							new Exception("FEHLER_RELATIVE_BUCHUNG_OHNE_KOMMT"));

				} else if (dto.getTaetigkeitIId() != null && !dto.getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_RELATIVE_BUCHUNG_OHNE_KOMMT,
							new Exception("FEHLER_RELATIVE_BUCHUNG_OHNE_KOMMT"));
				}

			}
		}

		Timestamp tsLetzterAuftrag = null;
		for (int i = zeitdatenDtos.length; i > 0; i--) {
			ZeitdatenDto dto = zeitdatenDtos[i - 1];
			if (dto.getArtikelIId() != null) {
				tsLetzterAuftrag = dto.getTZeit();
				// Wenn nach dem letzten Auftrag ein Geht, jedoch kein Ende
				// gebucht wurde, dann ist die komplette zeit verbraucht worden
				for (int z = 0; z < zeitdatenDtos.length; z++) {
					if (zeitdatenDtos[z].getTZeit().after(tsLetzterAuftrag)) {
						if (zeitdatenDtos[z].getTaetigkeitIId() != null) {
							if (taetigkeitIId_Geht.equals(zeitdatenDtos[z].getTaetigkeitIId())) {
								throw new EJBExceptionLP(EJBExceptionLP.FEHLER_RELATIVE_BUCHUNG_GESAMTE_ZEIT_VERBUCHT,
										new Exception("FEHLER_RELATIVE_BUCHUNG_GESAMTE_ZEIT_VERBUCHT"));
							} else {
								break;
							}
						}
					}
				}
				break;
			}
		}

		for (int i = zeitdatenDtos.length; i > 0; i--) {
			ZeitdatenDto dto = zeitdatenDtos[i - 1];
			if (dto.getTaetigkeitIId() != null && dto.getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {
				tsAbDaFrei = new Timestamp(dto.getTZeit().getTime() + 10);
				break;
			} else if (dto.getTaetigkeitIId() != null && dto.getTaetigkeitIId().equals(taetigkeitIId_Ende)) {
				bLetzterEintragIstEnde = true;
				tsAbDaFrei = new Timestamp(dto.getTZeit().getTime());
				iIdEnde = dto.getIId();
				break;
			}
		}

		if (tsAbDaFrei != null) {

			if (tsLetzterAuftrag != null
					&& (tsLetzterAuftrag.after(tsAbDaFrei) || tsLetzterAuftrag.equals(tsAbDaFrei))) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_RELATIVE_BUCHUNG_ENDE_FEHLT,
						new Exception("FEHLER_RELATIVE_BUCHUNG_ENDE_FEHLT"));
			}

			java.sql.Time tZeitRelativ = new java.sql.Time(zeitdatenDto.getTZeit().getTime());
			ZeitdatenDto dto = zeitdatenDto;

			if (bLetzterEintragIstEnde) {
				// Letzten Ende-Eintrag updaten

				dto.setIId(iIdEnde);
				dto.setTZeit(tsAbDaFrei);
				updateZeitdaten(dto, theClientDto);
				id = iIdEnde;
			} else {

				// Beginneintrag des Auftrages erstellen, wenn Kommt
				dto.setTZeit(tsAbDaFrei);
				id = createZeitdaten(dto, false, false, false, false, theClientDto);
			}
			// Ende-Eintrag erstellen
			dto = new ZeitdatenDto();
			dto.setPersonalIId(zeitdatenDto.getPersonalIId());
			dto.setTaetigkeitIId(taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId());

			Calendar c = Calendar.getInstance();
			c.setTimeInMillis(tZeitRelativ.getTime());
			int stunde = c.get(Calendar.HOUR_OF_DAY);
			int minute = c.get(Calendar.MINUTE);
			int sekunde = c.get(Calendar.SECOND);

			long tZeit = stunde * 3600000 + minute * 60000 + sekunde * 1000;

			try {
				dto.setTZeit(sucheEndeZeitFuerRelativeZeitbuchung(tsAbDaFrei, zeitdatenDto.getPersonalIId(), tZeit,
						bIgnoriereFehler, theClientDto));

				// Millisekunden abschneiden
				c.setTimeInMillis(dto.getTZeit().getTime());
				c.set(Calendar.MILLISECOND, 0);
				dto.setTZeit(new Timestamp(c.getTimeInMillis()));
				boolean bGespeichert = false;
				while (bGespeichert == false) {
					try {
						createZeitdaten(dto, false, false, false, false, theClientDto);
						bGespeichert = true;
					} catch (EJBExceptionLP ex1) {
						if (ex1.getCode() == EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE
								|| ex1.getCode() == EJBExceptionLP.FEHLER_BUCHUNG_BEREITS_VORHANDEN) {
							dto.setTZeit(new Timestamp(dto.getTZeit().getTime() + 10));
						} else {
							throw ex1;
						}
					}
				}
			} catch (EJBExceptionLP ex2) {
				if (ex2.getCode() == EJBExceptionLP.FEHLER_GEHT_VOR_ENDE) {
					if (bAuchWennZuWenigZeit.booleanValue() == false) {
						throw new EJBExceptionLP(ex2.getCode(), ex2);
					} else {
						return id;
					}
				} else {
					throw new EJBExceptionLP(ex2.getCode(), ex2);
				}

			}

		}

		return id;
	}

	public void speichereZeidatenVonZEStift(ZeitdatenDto[] zeitdatenDtos, TheClientDto theClientDto)
			throws EJBExceptionLP {

		if (zeitdatenDtos == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitdatenDto == null"));
		}

		int abstand = 10000;
		ParametermandantDto parameter = null;
		try {
			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_ZESTIFT_ABSTAND_BUCHUNGEN);
		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		java.sql.Timestamp tLetztesDatum = new Timestamp(System.currentTimeMillis());
		HashMap<Object, Object> hmPersonen = new HashMap<Object, Object>();

		abstand = ((Integer) parameter.getCWertAsObject()).intValue() * 1000;

		for (int i = 0; i < zeitdatenDtos.length; i++) {
			ZeitdatenDto zeitdatenDto = zeitdatenDtos[i];

			if (tLetztesDatum.after(zeitdatenDto.getTZeit())) {
				tLetztesDatum = zeitdatenDto.getTZeit();
			}
			if (!hmPersonen.containsKey(zeitdatenDto.getPersonalIId())) {
				hmPersonen.put(zeitdatenDto.getPersonalIId(), "");
			}

			boolean bGespeichert = false;

			while (bGespeichert == false) {
				try {

					if (zeitdatenDto.bFertigFuerLossollarbeitsplan == false) {

						createZeitdaten(zeitdatenDto, true, true, true, false, theClientDto);

					} else {
						try {
							com.lp.server.fertigung.service.LossollarbeitsplanDto[] dtos = getFertigungFac()
									.lossollarbeitsplanFindByLosIIdArtikelIIdTaetigkeit(zeitdatenDto.getIBelegartid(),
											zeitdatenDto.getArtikelIId());

							// PJ 15388

							if (dtos != null && dtos.length > 0) {

								LossollarbeitsplanDto dto = dtos[0];
								dto.setBFertig(Helper.boolean2Short(true));

								getFertigungFac().updateLossollarbeitsplan(dto, theClientDto);

							}

						} catch (RemoteException ex) {
							throwEJBExceptionLPRespectOld(ex);
						}

					}
					bGespeichert = true;
				} catch (EJBExceptionLP ex) {
					// Wenn 2 Buchungen in der selben Sekunde gemacht werden,
					// wird bei der naechsten 100 Millisekunden hinzugefuegt
					if (ex.getCode() == EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE) {
						bGespeichert = false;
						zeitdatenDto.setTZeit(new Timestamp(zeitdatenDto.getTZeit().getTime() + 100));
					} else {
						throw ex;
					}
				}
			}

			// Wenn 2 Taetigkeiten innerhalb eines best. Zeitraums sind und
			// gleich sind, dann werden sie verworfen
			// ausser es betrifft verschiedene Personen
			if (i < zeitdatenDtos.length - 1) {

				ZeitdatenDto zeitdatenDto_Next = zeitdatenDtos[i + 1];
				Timestamp tZeitNext = zeitdatenDto_Next.getTZeit();
				Timestamp tZeitAkt = zeitdatenDto.getTZeit();

				if (zeitdatenDto.getPersonalIId().equals(zeitdatenDto_Next.getPersonalIId())) {

					if (tZeitNext.getTime() - tZeitAkt.getTime() < abstand) {

						Integer artikelIdNext = zeitdatenDto_Next.getArtikelIId();
						Integer artikelIdAKt = zeitdatenDto.getArtikelIId();

						Integer taetigkeitIdNext = zeitdatenDto_Next.getTaetigkeitIId();
						Integer taetigkeitIdAKt = zeitdatenDto.getTaetigkeitIId();

						if (artikelIdNext != null && artikelIdAKt != null) {
							if (artikelIdNext.equals(artikelIdAKt)) {

								Integer belegartIdIdNext = zeitdatenDto_Next.getIBelegartid();
								Integer belegartIdAKt = zeitdatenDto.getIBelegartid();

								if (belegartIdIdNext.equals(belegartIdAKt)) {
									myLogger.logKritisch(
											"Folgende Zeitdaten wurden aufgrund PARAMETER_ZESTIFT_ABSTAND_BUCHUNGEN verworfen: "
													+ zeitdatenDto_Next.toString());
									i++;
								}
							}
						} else if (taetigkeitIdNext != null && taetigkeitIdAKt != null) {
							if (taetigkeitIdNext.equals(taetigkeitIdAKt)) {
								myLogger.logKritisch(
										"Folgende Zeitdaten wurden aufgrund PARAMETER_ZESTIFT_ABSTAND_BUCHUNGEN verworfen: "
												+ zeitdatenDto_Next.toString());
								i++;
							}
						}
					}
				}
			}
		}

		// Zum Abschluss Automatikbuchungen ueberpruefen
		if (tLetztesDatum != null && hmPersonen.size() > 0) {

			Iterator<?> it = hmPersonen.keySet().iterator();
			while (it.hasNext()) {
				Integer key = (Integer) it.next();
				automatikbuchungenAufrollen(new java.sql.Date(tLetztesDatum.getTime()),
						new java.sql.Date(System.currentTimeMillis()), key, theClientDto, true);
			}
		}
	}

	public BigDecimal getMengeGutSchlechtEinesLosSollarbeitsplanes(Integer lossollarbeitsplanIId,
			TheClientDto theClientDto, Boolean bGut) {
		if (lossollarbeitsplanIId == null || bGut == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("lossollarbeitsplanIId == null || bGut == null"));
		}

		String sQuery = "";

		if (bGut.booleanValue() == true) {
			sQuery = "select sum(zeitdaten.n_gut) from FLRLosgutschlecht zeitdaten WHERE zeitdaten.lossollarbeitsplan_i_id="
					+ lossollarbeitsplanIId;
		} else {
			sQuery = "select sum(zeitdaten.n_schlecht) from FLRLosgutschlecht zeitdaten WHERE zeitdaten.lossollarbeitsplan_i_id="
					+ lossollarbeitsplanIId;

		}
		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();

		org.hibernate.Query summe = session.createQuery(sQuery);
		List<?> resultList = summe.list();
		Iterator<?> resultListIterator = resultList.iterator();
		BigDecimal menge = (BigDecimal) resultListIterator.next();

		if (menge == null) {
			menge = new BigDecimal(0);
		}

		return menge;
	}

	public Integer createZeitdaten(ZeitdatenDto zeitdatenDto, boolean bBucheAutoPausen,
			boolean bBucheMitternachtssprung, boolean bZeitverteilen, boolean bLospruefungAufFertig,
			TheClientDto theClientDto, ArrayList<ZeitverteilenGutSchlechtDto> alGutSchlecht) throws EJBExceptionLP {
		return createZeitdaten(zeitdatenDto, bBucheAutoPausen, bBucheMitternachtssprung, bZeitverteilen,
				bLospruefungAufFertig, theClientDto, false, alGutSchlecht);
	}

	public Integer createZeitdaten(ZeitdatenDto zeitdatenDto, boolean bBucheAutoPausen,
			boolean bBucheMitternachtssprung, boolean bZeitverteilen, boolean bLospruefungAufFertig,
			TheClientDto theClientDto) throws EJBExceptionLP {
		return createZeitdaten(zeitdatenDto, bBucheAutoPausen, bBucheMitternachtssprung, bZeitverteilen,
				bLospruefungAufFertig, theClientDto, false, null);
	}

	private Integer binIchZwischenEinerVonBisBuchung(Integer personalIId, Timestamp tZeit, TheClientDto theclientDto) {

		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();

		org.hibernate.Criteria letztesKommtOderGeht = session.createCriteria(FLRZeitdaten.class);

		letztesKommtOderGeht.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalIId));
		letztesKommtOderGeht.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tZeit));
		letztesKommtOderGeht.setMaxResults(1);
		letztesKommtOderGeht.addOrder(Order.desc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));

		List<?> resultLetztesKommtOderGeht = letztesKommtOderGeht.list();
		Iterator it = resultLetztesKommtOderGeht.iterator();

		if (it.hasNext()) {
			FLRZeitdaten z = (FLRZeitdaten) it.next();
			// Wenn vorher beleg dann bin ich dazwischen
			if (z.getI_belegartid() != null) {
				return z.getI_id();
			}
		}
		session.close();
		return null;
	}

	private EJBExceptionLP getExceptionData(ZeitdatenDto zeitdatenDto, int errorCode, String errorText,
			TheClientDto theClientDto) {
		Personal personal = em.find(Personal.class, zeitdatenDto.getPersonalIId());
		String dateTimeString = Helper.formatTimestamp(zeitdatenDto.getTZeit(), theClientDto.getLocUi());
		return new EJBExceptionLP(errorCode, errorText, personal.getCPersonalnr(), dateTimeString);
	}

	private Integer createZeitdaten(ZeitdatenDto zeitdatenDto, boolean bBucheAutoPausen,
			boolean bBucheMitternachtssprung, boolean bZeitverteilen, boolean bLospruefungAufFertig,
			TheClientDto theClientDto, boolean bRekursiv, ArrayList<ZeitverteilenGutSchlechtDto> alGutSchlecht)
			throws EJBExceptionLP {

		// PJ18356

		boolean bVonBisErfassung = false;

		try {

			if (zeitdatenDto.getCBelegartnr() != null && zeitdatenDto.getCBelegartnr().equals(LocaleFac.BELEGART_LOS)
					&& zeitdatenDto.getIBelegartid() != null) {
				// PJ21348
				ParametermandantDto parameterBeiErstemAGMaterialNachbuchen = (ParametermandantDto) getParameterFac()
						.getMandantparameter(theClientDto.getMandant(), ParameterFac.KATEGORIE_FERTIGUNG,
								ParameterFac.PARAMETER_MATERIAL_BEI_ERSTEM_AG_NACHBUCHEN);

				boolean bBeiErstemAGMaterialNachbuchen = ((Boolean) parameterBeiErstemAGMaterialNachbuchen
						.getCWertAsObject());
				if (bBeiErstemAGMaterialNachbuchen) {

					LosDto losDto = getFertigungFac().losFindByPrimaryKeyOhneExc(zeitdatenDto.getIBelegartid());
					if (losDto != null && losDto.getStatusCNr().equals(FertigungFac.STATUS_IN_PRODUKTION)) {

						SessionFactory factory = FLRSessionFactory.getFactory();
						Session session = factory.openSession();

						org.hibernate.Criteria critBuchungenAufLos = session.createCriteria(FLRZeitdaten.class);

						critBuchungenAufLos.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_I_BELEGARTID,
								zeitdatenDto.getIBelegartid()));
						critBuchungenAufLos.add(
								Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_C_BELEGARTNR, LocaleFac.BELEGART_LOS));

						critBuchungenAufLos.setMaxResults(1);

						List<?> resultBuchungenAufLos = critBuchungenAufLos.list();

						if (resultBuchungenAufLos.size() == 0) {
							// Bei der ersten Buchung Material buchen

							boolean bUnterstklAusgeben = false;
							if (losDto.getStuecklisteIId() != null) {
								StuecklisteDto stklDto = getStuecklisteFac()
										.stuecklisteFindByPrimaryKey(losDto.getStuecklisteIId(), theClientDto);
								bUnterstklAusgeben = Helper.short2boolean(stklDto.getBAusgabeunterstueckliste());
							}

							getFertigungFac().bucheMaterialAufLos(losDto, null, false, false, bUnterstklAusgeben,
									theClientDto, null, false);
						}
					}
				}

			}

			if (zeitdatenDto.getCBelegartnr() != null && zeitdatenDto.getCBelegartnr().equals(LocaleFac.BELEGART_LOS)
					&& zeitdatenDto.getIBelegartid() != null && zeitdatenDto.getIBelegartpositionid() != null) {
				// PJ21348
				ParametermandantDto parameterBeiErsterZeitbuchung = (ParametermandantDto) getParameterFac()
						.getMandantparameter(theClientDto.getMandant(), ParameterFac.KATEGORIE_FERTIGUNG,
								ParameterFac.PARAMETER_MATERIAL_ANHAND_GLEICHER_ARTIKELGRUPPE_BUCHEN);

				boolean bBeiErsterZeitbuchung = ((Boolean) parameterBeiErsterZeitbuchung.getCWertAsObject());
				if (bBeiErsterZeitbuchung) {

					LosDto losDto = getFertigungFac().losFindByPrimaryKeyOhneExc(zeitdatenDto.getIBelegartid());
					if (losDto != null && losDto.getStatusCNr().equals(FertigungFac.STATUS_IN_PRODUKTION)) {

						SessionFactory factory = FLRSessionFactory.getFactory();
						Session session = factory.openSession();

						org.hibernate.Criteria critBuchungenAufLos = session.createCriteria(FLRZeitdaten.class);

						critBuchungenAufLos.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_I_BELEGARTID,
								zeitdatenDto.getIBelegartid()));
						critBuchungenAufLos.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_I_BELEGARTPOSITIONID,
								zeitdatenDto.getIBelegartpositionid()));
						critBuchungenAufLos.add(
								Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_C_BELEGARTNR, LocaleFac.BELEGART_LOS));

						critBuchungenAufLos.setMaxResults(1);

						List<?> resultBuchungenAufLos = critBuchungenAufLos.list();

						if (resultBuchungenAufLos.size() == 0) {
							// Bei der ersten Buchung Material der gleichen Artikelgruppe buchen buchen

							LossollarbeitsplanDto saDto = getFertigungFac()
									.lossollarbeitsplanFindByPrimaryKeyOhneExc(zeitdatenDto.getIBelegartpositionid());

							if (saDto != null) {

								ArtikelDto aDtoAZ = getArtikelFac()
										.artikelFindByPrimaryKeySmall(saDto.getArtikelIIdTaetigkeit(), theClientDto);
								if (aDtoAZ.getArtgruIId() != null) {

									ArrayList<LossollmaterialDto> listSollmat = new ArrayList<LossollmaterialDto>();

									Session sessionMaterial = factory.openSession();

									String sQuery = "select sm FROM FLRLossollmaterial sm WHERE sm.los_i_id="
											+ saDto.getLosIId()
											+ " AND sm.flrartikel.b_seriennrtragend=0 AND sm.flrartikel.b_chargennrtragend=0 AND sm.flrartikel.flrartikelgruppe.b_bei_erster_zeitbuchung_abbuchen = 1 AND sm.flrartikel.flrartikelgruppe.i_id="
											+ aDtoAZ.getArtgruIId();

									org.hibernate.Query queryMaterial = sessionMaterial.createQuery(sQuery);

									List<?> resultMaterial = queryMaterial.list();
									Iterator itMaterial = resultMaterial.iterator();
									while (itMaterial.hasNext()) {
										FLRLossollmaterial sm = (FLRLossollmaterial) itMaterial.next();
										if (sm.getN_menge().doubleValue() >= 0) {

											BigDecimal bdAusgegeben = getFertigungFac()
													.getAusgegebeneMenge(sm.getI_id(), null, theClientDto);

											BigDecimal offen = sm.getN_menge().subtract(bdAusgegeben);
											if (offen.doubleValue() > 0) {
												listSollmat.add(getFertigungFac()
														.lossollmaterialFindByPrimaryKey(sm.getI_id()));
											}

										}

									}

									if (listSollmat.size() > 0) {
										LossollmaterialDto[] sollmat = new LossollmaterialDto[listSollmat.size()];
										sollmat = (LossollmaterialDto[]) listSollmat.toArray(sollmat);
										getFertigungFac().bucheMaterialAufLos(losDto, sollmat, null, false, false,
												false, theClientDto, null, false);
									}
								}
							}
						}
					}
				}

			}

			ParametermandantDto parameterVonBis = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_VON_BIS_ERFASSUNG);

			bVonBisErfassung = ((Boolean) parameterVonBis.getCWertAsObject());

			// Wenn von-bis erfassung, dann darf zwischen von-bis keine
			// Zeitbuchung
			// vorhanden sein

			if (bVonBisErfassung && zeitdatenDto.getTaetigkeitIId() != null) {

				Integer tetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto)
						.getIId();
				Integer tetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto)
						.getIId();

				if (zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_Kommt)
						|| zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_Geht)) {

					zeitdatenDto.settZeit_Bis(null);
				}
			}

			if (bVonBisErfassung && zeitdatenDto.gettZeit_Bis() != null) {
				ZeitdatenDto[] dtos = getZeiterfassungFac().zeitdatenFindZeitdatenEinesTagesUndEinerPerson(
						zeitdatenDto.getPersonalIId(), zeitdatenDto.getTZeit(),
						new Timestamp(zeitdatenDto.gettZeit_Bis().getTime()));
				if (dtos.length > 0) {
					throw getExceptionData(zeitdatenDto, EJBExceptionLP.FEHLER_BUCHUNG_ZWISCHEN_VON_BIS,
							"EJBExceptionLP.FEHLER_BUCHUNG_ZWISCHEN_VON_BIS", theClientDto);
					// throw new EJBExceptionLP(
					// EJBExceptionLP.FEHLER_BUCHUNG_ZWISCHEN_VON_BIS,
					// new Exception(
					// "EJBExceptionLP.FEHLER_BUCHUNG_ZWISCHEN_VON_BIS"));
				}
			}

			if (bVonBisErfassung == true) {

				Integer tetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto)
						.getIId();

				if (zeitdatenDto.getTaetigkeitIId() != null
						&& zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_Ende)) {

				} else {
					Integer zeitdatenIId = binIchZwischenEinerVonBisBuchung(zeitdatenDto.getPersonalIId(),
							zeitdatenDto.getTZeit(), theClientDto);
					if (zeitdatenIId != null && zeitdatenDto.gettZeit_Bis() != null) {
						// SP4141 Pausenbuchung darf bei neu dazwischen
						// eingefuegt werden

						Integer tetigkeitIId_Unter = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER,
								theClientDto).getIId();

						if (zeitdatenDto.getTaetigkeitIId() != null
								&& zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_Unter)) {

							// 1. Beleg-Beginn nach Pausen-Ende einfuegen
							ZeitdatenDto zDtoBisherigerBeginn = zeitdatenFindByPrimaryKey(zeitdatenIId, theClientDto);
							zDtoBisherigerBeginn.setIId(null);

							Calendar cBis = Calendar.getInstance();
							cBis.setTimeInMillis(zeitdatenDto.gettZeit_Bis().getTime());
							cBis.set(Calendar.MILLISECOND, 0);
							cBis.setTimeInMillis(cBis.getTimeInMillis() + 10);

							zDtoBisherigerBeginn.setTZeit(new Timestamp(cBis.getTimeInMillis()));
							zDtoBisherigerBeginn.settZeit_Bis(null);

							createZeitdaten(zDtoBisherigerBeginn, false, false, false, false, theClientDto, true,
									alGutSchlecht);

							// 2. Ende vor Pausenbeginn einfuegen

							zDtoBisherigerBeginn.setTaetigkeitIId(tetigkeitIId_Ende);
							zDtoBisherigerBeginn.setIBelegartid(null);
							zDtoBisherigerBeginn.setCBelegartnr(null);
							zDtoBisherigerBeginn.setIBelegartpositionid(null);

							Calendar cVon = Calendar.getInstance();
							cVon.setTimeInMillis(zeitdatenDto.getTZeit().getTime());
							cVon.set(Calendar.MILLISECOND, 0);
							zDtoBisherigerBeginn.setTZeit(new Timestamp(cVon.getTimeInMillis()));

							createZeitdaten(zDtoBisherigerBeginn, false, false, false, false, theClientDto, true,
									alGutSchlecht);

							// zeitdatenDto.gettZeit_Bis()

						} else {

							throw getExceptionData(zeitdatenDto,
									EJBExceptionLP.FEHLER_BUCHUNG_EINFUEGEN_ZWISCHEN_VON_BIS_NICHT_ERLAUBT,
									"EJBExceptionLP.FEHLER_BUCHUNG_EINFUEGEN_ZWISCHEN_VON_BIS_NICHT_ERLAUBT",
									theClientDto);
						}

					}
				}

			}

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		boolean bNurWarnung = false;
		ParametermandantDto parameterNurMarnung = null;
		try {
			parameterNurMarnung = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_AUTOMATISCHE_PAUSEN_NUR_WARNUNG);

			bNurWarnung = (Boolean) parameterNurMarnung.getCWertAsObject();

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		if (zeitdatenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitdatenDto == null"));
		} else if (zeitdatenDto.getPersonalIId() == null || zeitdatenDto.getTZeit() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("zeitdatenDto.getPersonalIId() == null || zeitdatenDto.getTZeit() == null"));
		} else if (zeitdatenDto.getTaetigkeitIId() == null && zeitdatenDto.getArtikelIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("zeitdatenDto.getTaetigkeitIId() == null && zeitdatenDto.getArtikelIId() == null"));
		}

		if (zeitdatenDto.getTaetigkeitIId() != null) {
			zeitdatenDto.setCBelegartnr(null);
			zeitdatenDto.setArtikelIId(null);
			zeitdatenDto.setIBelegartid(null);
			zeitdatenDto.setIBelegartpositionid(null);
			zeitdatenDto.setIBelegartpositionid(null);

			if (zeitdatenDto.getCBemerkungZuBelegart() != null
					&& zeitdatenDto.getCBemerkungZuBelegart().length() > 79) {
				zeitdatenDto.setCBemerkungZuBelegart(zeitdatenDto.getCBemerkungZuBelegart().substring(0, 79));
			}

		}

		// SP3289
		bringeFehlerWennZeitabschlussvorhanden(zeitdatenDto.getPersonalIId(), zeitdatenDto.getTZeit(), theClientDto);

		if (zeitdatenDto.getBAutomatikbuchung() == null) {
			zeitdatenDto.setBAutomatikbuchung(Helper.boolean2Short(false));
		}

		if (zeitdatenDto.getCWowurdegebucht() != null && zeitdatenDto.getCWowurdegebucht().length() > 40) {
			zeitdatenDto.setCWowurdegebucht(zeitdatenDto.getCWowurdegebucht().substring(0, 39));
		}

		// PJ19158
		if (zeitdatenDto.getCWowurdegebucht() != null) {
			KeyvaluePK keyvaluePK = new KeyvaluePK(SystemServicesFac.KEYVALUE_ZEITDATEN_QUELLE,
					zeitdatenDto.getCWowurdegebucht());
			Keyvalue keyvalue = em.find(Keyvalue.class, keyvaluePK);
			if (keyvalue != null) {
				zeitdatenDto.setCWowurdegebucht(keyvalue.getCValue());
			}
		}

		ParametermandantDto parameterNachher = null;
		try {
			parameterNachher = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_BUCHUNG_IMMER_NACHHER_EINFUEGEN);
		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		if (bBucheAutoPausen) {
			if (bNurWarnung == false) {
				pruefeUndErstelleAutomatischePausen(zeitdatenDto.getTZeit(), zeitdatenDto.getPersonalIId(),
						theClientDto);
			}
		}

		// PJ 17048
		boolean bNachherEinfuegen = ((Boolean) parameterNachher.getCWertAsObject()).booleanValue();

		if (bNachherEinfuegen == true) {
			boolean bHatPlatz = false;

			while (bHatPlatz == false) {
				try {
					Query query = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
					query.setParameter(1, zeitdatenDto.getPersonalIId());
					query.setParameter(2, zeitdatenDto.getTZeit());
					Zeitdaten doppelt = (Zeitdaten) query.getSingleResult();
					zeitdatenDto.setTZeit(new Timestamp(zeitdatenDto.getTZeit().getTime() + 30));
				} catch (NoResultException ex) {
					bHatPlatz = true;
				}
			}

		} else {
			try {
				Query query = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
				query.setParameter(1, zeitdatenDto.getPersonalIId());
				query.setParameter(2, zeitdatenDto.getTZeit());
				Zeitdaten doppelt = (Zeitdaten) query.getSingleResult();
				throw getExceptionData(zeitdatenDto, EJBExceptionLP.FEHLER_BUCHUNG_BEREITS_VORHANDEN,
						"PERS_ZEITDATEN.UK", theClientDto);
				// throw new EJBExceptionLP(
				// EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception(
				// "PERS_ZEITDATEN.UK"));
			} catch (NoResultException ex) {
				// //
			}
		}

		ZeitdatenDto[] letzeBuchungen = null;
		Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();
		Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();
		// try {
		Query query3 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
		query3.setParameter(1, zeitdatenDto.getPersonalIId());
		query3.setParameter(2, Helper.cutTimestamp(zeitdatenDto.getTZeit()));
		query3.setParameter(3, zeitdatenDto.getTZeit());
		Collection<?> cl = query3.getResultList();
		// if (!cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, null);
		// }
		letzeBuchungen = assembleZeitdatenDtosOhneBelegzeiten(query3.getResultList());
		ZeitdatenDto[] letzeBuchungenMitBelegen = assembleZeitdatenDtos(query3.getResultList());

		ZeitdatenDto[] letzeBuchungenMitBelegzeiten = assembleZeitdatenDtos(query3.getResultList());

		// WH: 13.02.2008: Wenn zuletzt ein GEHT gebucht wurde, und wieder ein
		// GEHT gebucht wird, wir dieses 'verschmissen'
		// WH: 23.08.2011: Wieder auskommentieren, da wir den Sinn von nicht
		// mher wussten
		/*
		 * if (letzeBuchungen.length > 0) { if (taetigkeitIId_Geht
		 * .equals(letzeBuchungen[letzeBuchungen.length - 1] .getTaetigkeitIId()) &&
		 * taetigkeitIId_Geht.equals(zeitdatenDto .getTaetigkeitIId())) { return
		 * letzeBuchungen[letzeBuchungen.length - 1].getIId(); } }
		 */

		// }
		// catch (NoResultException ex3) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, ex3);
		// }
		try {
			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_ZEITDATEN);
			zeitdatenDto.setIId(pk);

			zeitdatenDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
			zeitdatenDto.setPersonalIIdAnlegen(theClientDto.getIDPersonal());

			zeitdatenDto.setTAnlegen(new java.sql.Timestamp(System.currentTimeMillis()));
			if (zeitdatenDto.getTAendern() == null) {
				zeitdatenDto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));
			}
			zeitdatenDto.setBTaetigkeitgeaendert(Helper.boolean2Short(false));

			// WENN ENDE dann auch zeitverteilen jedoch darf dann das ENDE nich
			// gebucht werden
			Integer tetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();

			Integer tetigkeitIId_geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();

			Integer tetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();

			Integer taetigkeitIId_Unter = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER, theClientDto).getIId();

			// ZEITVERTILUNG AUF LOSE

			boolean bVorherEndeEinbuchen = false;
			if (letzeBuchungenMitBelegzeiten.length > 0) {
				if (letzeBuchungenMitBelegzeiten[letzeBuchungenMitBelegzeiten.length - 1].getCBelegartnr() != null) {
					bVorherEndeEinbuchen = true;
				}
			}

			boolean bZeitenverteilt = false;
			if (bZeitverteilen == true && zeitdatenDto.getTaetigkeitIId() != null
					&& zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_Ende)) {
				// NUN ZEITVERTEILEN PJ 5589
				bZeitenverteilt = zeitAufLoseVerteilen(zeitdatenDto.getPersonalIId(), zeitdatenDto.getTZeit(),
						bVorherEndeEinbuchen, alGutSchlecht, theClientDto);
			}

			if (bZeitverteilen == true && zeitdatenDto.getTaetigkeitIId() != null
					&& zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_geht)) {
				zeitAufLoseVerteilen(zeitdatenDto.getPersonalIId(), zeitdatenDto.getTZeit(), bVorherEndeEinbuchen,
						alGutSchlecht, theClientDto);
			}

			if (bZeitverteilen == true && zeitdatenDto.getCBelegartnr() != null
					&& zeitdatenDto.getIBelegartid() != null) {
				// NUN ZEITVERTEILEN PJ 5589
				zeitAufLoseVerteilen(zeitdatenDto.getPersonalIId(), zeitdatenDto.getTZeit(), bVorherEndeEinbuchen,
						alGutSchlecht, theClientDto);
			}

			if (bZeitenverteilt == false) {

				Zeitdaten zeitdaten = new Zeitdaten(zeitdatenDto.getIId(), zeitdatenDto.getPersonalIId(),
						zeitdatenDto.getTZeit(), zeitdatenDto.getBTaetigkeitgeaendert(),
						zeitdatenDto.getPersonalIIdAnlegen(), zeitdatenDto.getPersonalIIdAendern(),
						zeitdatenDto.getBAutomatikbuchung());
				em.persist(zeitdaten);
				em.flush();
				setZeitdatenFromZeitdatenDto(zeitdaten, zeitdatenDto);
			} else {
				// SP6200 letztes Ende holen, da wenn die Zeiten verteilt
				// werden, implizit ein ENDE gebucht wird und das ENDE selbst
				// ausgelassen wird

				SessionFactory factory = FLRSessionFactory.getFactory();
				Session session = factory.openSession();

				org.hibernate.Criteria letztesEnde = session.createCriteria(FLRZeitdaten.class);

				letztesEnde.add(
						Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, zeitdatenDto.getPersonalIId()));
				letztesEnde.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID, tetigkeitIId_Ende));
				letztesEnde.add(Expression.gt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT,
						Helper.cutTimestamp(zeitdatenDto.getTZeit())));
				letztesEnde.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, zeitdatenDto.getTZeit()));
				letztesEnde.setMaxResults(1);
				letztesEnde.addOrder(Order.desc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));

				List<?> resultLetztesKommtOderGeht = letztesEnde.list();

				if (resultLetztesKommtOderGeht.size() > 0) {
					FLRZeitdaten zeitdaten = (FLRZeitdaten) resultLetztesKommtOderGeht.iterator().next();

					zeitdatenDto = assembleZeitdatenDto(em.find(Zeitdaten.class, zeitdaten.getI_id()));

				}

			}

			if (bRekursiv == false && !taetigkeitIId_Kommt.equals(zeitdatenDto.getTaetigkeitIId())) {

				pruefeUndBucheAutoKommt(zeitdatenDto, theClientDto, taetigkeitIId_Geht, taetigkeitIId_Kommt,
						taetigkeitIId_Unter);
			}

			if (zeitdatenDto.getTaetigkeitIId() != null && zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_geht)) {

				if (Helper.short2boolean(zeitdatenDto.getBAutomatikbuchung()) == false) {
					pruefeUndErstelleAutomatischesEndeBeiGeht(zeitdatenDto.getTZeit(), zeitdatenDto.getPersonalIId(),
							theClientDto);
				}

				// PJ210712
				erstelleAutomatischePauseBeiUnproduktiverZeit(zeitdatenDto.getTZeit(), zeitdatenDto.getPersonalIId(),
						theClientDto);

				// automatische Mindestpause
				// PJ18736
				if (bNurWarnung == false) {

					erstelleAutomatischeMindestpause(zeitdatenDto.getTZeit(), zeitdatenDto.getPersonalIId(),
							theClientDto);
				}

			}

			// PJ 16849
			if (zeitdatenDto.getTaetigkeitIId() != null && zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_Kommt)) {

				schichtzeitmodellEintragen(zeitdatenDto, theClientDto);

			}

			boolean bAufAngelegteLoseBuchenMoeglich = false;
			boolean bAufErledigteLoseAuftraegeBuchenMoeglich = false;
			try {
				ParametermandantDto parameterint = (ParametermandantDto) getParameterFac().getMandantparameter(
						theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
						ParameterFac.PARAMETER_ZEITBUCHUNG_AUF_ANGELEGTE_LOSE_MOEGLICH);

				bAufAngelegteLoseBuchenMoeglich = ((Boolean) parameterint.getCWertAsObject());
				parameterint = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
						ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_ZEITBUCHUNG_AUF_ERLEDIGTE_MOEGLICH);

				bAufErledigteLoseAuftraegeBuchenMoeglich = ((Boolean) parameterint.getCWertAsObject());

			} catch (RemoteException e) {
				throwEJBExceptionLPRespectOld(e);
			}

			if (zeitdatenDto.getCBelegartnr() != null
					&& zeitdatenDto.getCBelegartnr().equals(LocaleFac.BELEGART_ANGEBOT)) {
				if (zeitdatenDto.getIBelegartid() != null) {
					AngebotDto angebotDto = getAngebotFac()
							.angebotFindByPrimaryKeyOhneExec(zeitdatenDto.getIBelegartid());
					if (angebotDto != null) {
						if (angebotDto.getStatusCNr().equals(LocaleFac.STATUS_ERLEDIGT)) {
							throw new EJBExceptionLP(
									EJBExceptionLP.FEHLER_ZEITBUCHUNG_ERLEDIGTES_ANGEBOT_NICHT_MOEGLICH, "");
						}
						if (angebotDto.getStatusCNr().equals(LocaleFac.STATUS_STORNIERT)) {
							throw new EJBExceptionLP(
									EJBExceptionLP.FEHLER_ZEITBUCHUNG_STORNIERTES_ANGEBOT_NICHT_MOEGLICH, "");
						}
					}

				}
			}

			if (zeitdatenDto.getCBelegartnr() != null
					&& zeitdatenDto.getCBelegartnr().equals(LocaleFac.BELEGART_AUFTRAG)) {
				if (zeitdatenDto.getIBelegartid() != null) {
					AuftragDto auftragDto = getAuftragFac()
							.auftragFindByPrimaryKeyOhneExc(zeitdatenDto.getIBelegartid());
					if (auftragDto.getStatusCNr().equals(LocaleFac.STATUS_ERLEDIGT)
							&& bAufErledigteLoseAuftraegeBuchenMoeglich == false) {
						throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITBUCHUNG_ERLEDIGTER_AUFTRAG_NICHT_MOEGLICH,
								"");
					}
					if (auftragDto.getStatusCNr().equals(LocaleFac.STATUS_STORNIERT)
							&& bAufErledigteLoseAuftraegeBuchenMoeglich == false) {
						throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITBUCHUNG_STORNIERTER_AUFTRAG_NICHT_MOEGLICH,
								"");
					}

					// PJ20739
					if (zeitdatenDto.getFVerrechenbar() == null) {
						zeitdatenDto.setFVerrechenbar(100D);
						if (zeitdatenDto.getIBelegartpositionid() != null) {
							AuftragpositionDto apDto = getAuftragpositionFac()
									.auftragpositionFindByPrimaryKeyOhneExc(zeitdatenDto.getIBelegartpositionid());
							if (apDto != null && Helper.short2boolean(apDto.getBPauschal())) {
								zeitdatenDto.setFVerrechenbar(0D);
							}
						}

					}

				}
			}

			// Losablieferungen auf "Neu Berechnen" setzen
			if (zeitdatenDto.getCBelegartnr() != null && zeitdatenDto.getCBelegartnr().equals(LocaleFac.BELEGART_LOS)) {

				try {
					if (zeitdatenDto.getIBelegartid() != null) {

						LosDto losDto = getFertigungFac().losFindByPrimaryKeyOhneExc(zeitdatenDto.getIBelegartid());

						if (losDto.getStatusCNr().equals(LocaleFac.STATUS_ERLEDIGT)
								&& bAufErledigteLoseAuftraegeBuchenMoeglich == false) {
							throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITBUCHUNG_ERLEDIGTES_LOS_NICHT_MOEGLICH,
									"");
						}
						if (losDto.getStatusCNr().equals(LocaleFac.STATUS_ANGELEGT)
								&& bAufAngelegteLoseBuchenMoeglich == false) {
							throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITBUCHUNG_ANGELEGTES_LOS_NICHT_MOEGLICH,
									"");
						}

						if (losDto.getStatusCNr().equals(LocaleFac.STATUS_GESTOPPT)) {
							throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITBUCHUNG_GESTOPPTES_LOS_NICHT_MOEGLICH,
									"");
						}
						if (losDto.getStatusCNr().equals(LocaleFac.STATUS_STORNIERT)) {
							throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITBUCHUNG_STORNIERTES_LOS_NICHT_MOEGLICH,
									"");
						}

						getFertigungFac().setzeLosablieferungenAufNeuBerechnen(zeitdatenDto.getIBelegartid(),
								theClientDto);

						// PJ20739
						if (losDto.getAuftragIId() != null) {
							if (zeitdatenDto.getFVerrechenbar() == null) {

								zeitdatenDto.setFVerrechenbar(100D);
								if (losDto.getAuftragpositionIId() != null) {
									AuftragpositionDto apDto = getAuftragpositionFac()
											.auftragpositionFindByPrimaryKeyOhneExc(losDto.getAuftragpositionIId());
									if (apDto != null && Helper.short2boolean(apDto.getBPauschal())) {
										zeitdatenDto.setFVerrechenbar(0D);
									}
								}
							}
						}
					}

					if (zeitdatenDto.getIBelegartpositionid() != null && bLospruefungAufFertig == true) {
						LossollarbeitsplanDto sollaDto = getFertigungFac()
								.lossollarbeitsplanFindByPrimaryKeyOhneExc(zeitdatenDto.getIBelegartpositionid());

						if (sollaDto != null && Helper.short2boolean(sollaDto.getBFertig())) {
							// SP2410

							LosDto losDto = getFertigungFac().losFindByPrimaryKeyOhneExc(zeitdatenDto.getIBelegartid());

							ArrayList errorInfo = new ArrayList();

							errorInfo.add(losDto.getCNr());

							String arbeitsgang = sollaDto.getIArbeitsgangnummer() + "";
							if (sollaDto.getIUnterarbeitsgang() != null) {
								arbeitsgang += "/" + sollaDto.getIUnterarbeitsgang();
							}

							errorInfo.add(arbeitsgang);

							throw new EJBExceptionLP(
									EJBExceptionLP.FEHLER_ZEITBUCHUNG_AUF_FERTIGEN_ARBEITSGANG_NICHT_MOEGLICH,
									errorInfo,
									new Exception("FEHLER_ZEITBUCHUNG_AUF_FERTIGEN_ARBEITSGANG_NICHT_MOEGLICH"));

						}

					}

				} catch (RemoteException ex2) {
					throwEJBExceptionLPRespectOld(ex2);
				}

				try {
					// PJ21873 Zusaetliche AGs nur bei THEORETISCHE_IST_ZEIT_RECHNUNG anstempeln
					boolean bTheoretischeIstZeit = false;

					try {
						ParametermandantDto parameterIstZeit = (ParametermandantDto) getParameterFac()
								.getMandantparameter(theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
										ParameterFac.PARAMETER_THEORETISCHE_IST_ZEIT_RECHNUNG);

						bTheoretischeIstZeit = ((Boolean) parameterIstZeit.getCWertAsObject());

					} catch (RemoteException ex5) {
						throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
					}

					if (bTheoretischeIstZeit) {

						LossollarbeitsplanDto[] dtos = getFertigungFac()
								.lossollarbeitsplanFindByLosIIdArtikelIIdTaetigkeit(zeitdatenDto.getIBelegartid(),
										zeitdatenDto.getArtikelIId());

						if (dtos != null && dtos.length > 0) {
							LossollarbeitsplanDto[] zusDtos = getFertigungFac()
									.getAlleZusatzlichZuBuchuchendenArbeitsgaenge(dtos[0].getIId(), theClientDto);

							for (int i = 0; i < zusDtos.length; i++) {
								if (Helper.short2boolean(zusDtos[i].getBNurmaschinenzeit()) == false) {
									pk = pkGen.getNextPrimaryKey(PKConst.PK_ZEITDATEN);
									zeitdatenDto.setIId(pk);
									zeitdatenDto.setArtikelIId(zusDtos[i].getArtikelIIdTaetigkeit());
									zeitdatenDto.setIBelegartpositionid(zusDtos[i].getIId());
									zeitdatenDto.setTZeit(new Timestamp(zeitdatenDto.getTZeit().getTime() + 200));
									Zeitdaten zeitdaten = new Zeitdaten(zeitdatenDto.getIId(),
											zeitdatenDto.getPersonalIId(), zeitdatenDto.getTZeit(),
											zeitdatenDto.getBTaetigkeitgeaendert(),
											zeitdatenDto.getPersonalIIdAnlegen(), zeitdatenDto.getPersonalIIdAendern(),
											zeitdatenDto.getBAutomatikbuchung());

									setZeitdatenFromZeitdatenDto(zeitdaten, zeitdatenDto);
								}
							}

						}
					}

				} catch (RemoteException e) {
					throwEJBExceptionLPRespectOld(e);
				}

			}

			if (zeitdatenDto.getCBelegartnr() != null
					&& zeitdatenDto.getCBelegartnr().equals(LocaleFac.BELEGART_PROJEKT)) {
				// PJ18156

				ProjektDto pjDto = getProjektFac().projektFindByPrimaryKeyOhneExc(zeitdatenDto.getIBelegartid());

				if (pjDto.getStatusCNr().equals(ProjektServiceFac.PROJEKT_STATUS_STORNIERT)) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITBUCHUNG_STORNIERTES_PROJEKT_NICHT_MOEGLICH, "");

				}
				if (pjDto.getStatusCNr().equals(ProjektServiceFac.PROJEKT_STATUS_ERLEDIGT)) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITBUCHUNG_ERLEDIGTES_PROJEKT_NICHT_MOEGLICH, "");

				}

				if (pjDto.getTInternerledigt() != null) {

					try {
						ParametermandantDto parameterint = (ParametermandantDto) getParameterFac().getMandantparameter(
								theClientDto.getMandant(), ParameterFac.KATEGORIE_PROJEKT,
								ParameterFac.PARAMETER_INTERN_ERLEDIGT_BEBUCHBAR);

						boolean bInterErledigteBebuchbar = ((Boolean) parameterint.getCWertAsObject());

						if (bInterErledigteBebuchbar == false) {
							throw new EJBExceptionLP(
									EJBExceptionLP.FEHLER_ZEITBUCHUNG_INTERN_ERLEDIGTES_PROJEKT_NICHT_MOEGLICH, "");
						}

					} catch (RemoteException e) {
						throwEJBExceptionLPRespectOld(e);
					}

				}

				try {
					// PJ18534
					ParametermandantDto parameterint = (ParametermandantDto) getParameterFac().getMandantparameter(
							theClientDto.getMandant(), ParameterFac.KATEGORIE_PROJEKT,
							ParameterFac.PARAMETER_PROJEKT_MIT_TAETIGKEIT);

					boolean bProjektMitTaetigkeit = ((Boolean) parameterint.getCWertAsObject());

					if (bProjektMitTaetigkeit == true) {

						boolean bHinterlegt = getProjektServiceFac().istTaetigkeitBeiProjekthinterlegt(
								zeitdatenDto.getIBelegartid(), zeitdatenDto.getArtikelIId());

						if (bHinterlegt == false) {
							// Exception
							throw new EJBExceptionLP(
									EJBExceptionLP.FEHLER_ZEITBUCHUNG_TAETIGKEIT_AUF_PROJEKT_NICHT_MOEGLICH,
									"FEHLER_ZEITBUCHUNG_TAETIGKEIT_AUF_PROJEKT_NICHT_MOEGLICH" + pjDto.getCNr());
						}

					}

				} catch (RemoteException e) {
					throwEJBExceptionLPRespectOld(e);
				}

			}

			if ((zeitdatenDto.getTaetigkeitIId() != null && zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_Ende))
					|| (zeitdatenDto.getTaetigkeitIId() != null
							&& zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_geht))
					|| zeitdatenDto.getCBelegartnr() != null) {

				// Hole letzte Beleg-Buchung und pruefe deren Sollzeit
				// Sollzeitueberschreitung pruefen

				for (int i = letzeBuchungenMitBelegen.length - 1; i >= 0; i--) {
					if (letzeBuchungenMitBelegen[i].getCBelegartnr() != null) {

						boolean bKommtVonTerminal = false;
						if (zeitdatenDto.getCWowurdegebucht() != null) {

							if (zeitdatenDto.getCWowurdegebucht().startsWith("ZT")
									|| zeitdatenDto.getCWowurdegebucht().startsWith("F630")
									|| zeitdatenDto.getCWowurdegebucht().startsWith("Quick-ZE")
									|| zeitdatenDto.getCWowurdegebucht().startsWith("KDC100")) {
								bKommtVonTerminal = true;
							}
						}

						if (letzeBuchungenMitBelegen[i].getCBelegartnr().equals(LocaleFac.BELEGART_LOS)) {

							pruefeObSollzeitenUeberschritten(letzeBuchungenMitBelegen[i].getIBelegartid(),
									letzeBuchungenMitBelegen[i].getArtikelIId(),
									letzeBuchungenMitBelegen[i].getPersonalIId(), bKommtVonTerminal, theClientDto);
							break;
						}

						if (letzeBuchungenMitBelegen[i].getCBelegartnr().equals(LocaleFac.BELEGART_PROJEKT)) {
							pruefeObProjektSollzeitenUeberschritten(letzeBuchungenMitBelegen[i].getIBelegartid(),
									bKommtVonTerminal, theClientDto);
							break;
						}

					}
				}
			}

			// PJ21742

			if (zeitdatenDto.getCWowurdegebucht() != null) {

				if (zeitdatenDto.getCWowurdegebucht().startsWith("ZT")
						|| zeitdatenDto.getCWowurdegebucht().startsWith("Quick-ZE")) {

					if (letzeBuchungen.length > 0 && bRekursiv == false && zeitdatenDto.getTaetigkeitIId() != null
							&& (zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_Kommt)
									|| zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_geht)
									|| zeitdatenDto.getTaetigkeitIId().equals(taetigkeitIId_Unter))) {
						try {
							ParametermandantDto parameterSekunden = (ParametermandantDto) getParameterFac()
									.getMandantparameter(theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
											ParameterFac.PARAMETER_VORHERIGE_ZEITBUCHUNG_LOESCHEN);

							Integer iSekunden = ((Integer) parameterSekunden.getCWertAsObject());

							if (iSekunden > 0) {

								ZeitdatenDto letzteBuchung = letzeBuchungen[letzeBuchungen.length - 1];

								Timestamp buchungZeitMinusSekunden = new Timestamp(
										zeitdatenDto.getTZeit().getTime() - (iSekunden * 1000));

								if (letzteBuchung.getTaetigkeitIId() != null
										&& letzteBuchung.getTZeit().after(buchungZeitMinusSekunden)) {
									if (letzteBuchung.getTaetigkeitIId().equals(tetigkeitIId_Kommt)
											|| letzteBuchung.getTaetigkeitIId().equals(tetigkeitIId_geht)
											|| letzteBuchung.getTaetigkeitIId().equals(taetigkeitIId_Unter)) {
										removeZeitdaten(letzteBuchung, theClientDto);

										// SP8965 Wenn die letzte Buchung ein KOMMT war und geloescht wurde, dann
										// Schichtzeitmodell entfernen, wenn vorhanden, da dies durch die KOMMT -Buchung
										// irrtuermlich eingetragen worden ist
										if (letzteBuchung.getTaetigkeitIId().equals(tetigkeitIId_Kommt)
												&& zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_geht)) {
											Query query6 = em
													.createNamedQuery("PersonalzeitmodellfindByPersonalIIdTDatum");
											query6.setParameter(1, zeitdatenDto.getPersonalIId());
											query6.setParameter(2, Helper.cutTimestamp(letzteBuchung.getTZeit()));
											Personalzeitmodell personalzeitmodell = null;
											try {
												personalzeitmodell = (Personalzeitmodell) query6.getSingleResult();
												em.remove(personalzeitmodell);
											} catch (NoResultException e) {
												//
											}
										}

									}

								}

							}

						} catch (RemoteException e) {
							throwEJBExceptionLPRespectOld(e);
						}

					}
				}
			}

			// PJ 16393 Bei ENDE Maschine stoppen
			if (zeitdatenDto.getTaetigkeitIId() != null && zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_Ende)) {
				boolean bTheoretischeIstZeit = false;

				try {
					ParametermandantDto parameterIstZeit = (ParametermandantDto) getParameterFac().getMandantparameter(
							theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
							ParameterFac.PARAMETER_THEORETISCHE_IST_ZEIT_RECHNUNG);

					bTheoretischeIstZeit = ((Boolean) parameterIstZeit.getCWertAsObject());

					if (bTheoretischeIstZeit == true) {
						// Hole letzte offen Maschinenzeit deren Sollarbeitsplan
						// Ruesten (AGART=NULL) ist
						Session session = FLRSessionFactory.getFactory().openSession();
						org.hibernate.Criteria letztesKommtOderGeht = session.createCriteria(FLRZeitdaten.class);

						letztesKommtOderGeht.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID,
								zeitdatenDto.getPersonalIId()));
						letztesKommtOderGeht.add(
								Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID, taetigkeitIId_Kommt));
						letztesKommtOderGeht
								.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, zeitdatenDto.getTZeit()));
						letztesKommtOderGeht.setMaxResults(1);
						letztesKommtOderGeht.addOrder(Order.desc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));

						List<?> resultLetztesKommt = letztesKommtOderGeht.list();

						if (resultLetztesKommt.size() > 0) {

							FLRZeitdaten lKommt = (FLRZeitdaten) resultLetztesKommt.iterator().next();
							// auch alle Maschinen der Person mit autoende
							// stoppen
							String sQuery = "select zeitdaten FROM FLRMaschinenzeitdaten zeitdaten WHERE zeitdaten.t_von>'"
									+ Helper.formatTimestampWithSlashes(new Timestamp(lKommt.getT_zeit().getTime()))
									+ "' AND zeitdaten.personal_i_id_gestartet=" + zeitdatenDto.getPersonalIId()
									+ " AND zeitdaten.t_bis IS NULL "
									+ " AND (zeitdaten.flrlossollarbeitsplan.agart_c_nr IS NULL OR zeitdaten.flrlossollarbeitsplan.b_autoendebeigeht = 1)"
									+ " ORDER BY zeitdaten.t_von DESC";

							Session session2 = FLRSessionFactory.getFactory().openSession();

							org.hibernate.Query letzteOffeneMaschine = session2.createQuery(sQuery);
							// jetzt alle stoppen!!
							// letzteOffeneMaschine.setMaxResults(1);

							List<?> resultList = letzteOffeneMaschine.list();

							Iterator<?> resultListIterator = resultList.iterator();

							while (resultListIterator.hasNext()) {

								FLRMaschinenzeitdaten mz = (FLRMaschinenzeitdaten) resultListIterator.next();
								Maschinenzeitdaten maschinenzeitdaten = em.find(Maschinenzeitdaten.class, mz.getI_id());
								maschinenzeitdaten.setTBis(zeitdatenDto.getTZeit());
								em.merge(maschinenzeitdaten);
								em.flush();

							}
							session.close();
							session2.close();

						}

					}

				} catch (RemoteException ex5) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
				}
			}

		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);

		}

		if (bVonBisErfassung && zeitdatenDto.gettZeit_Bis() != null) {
			ZeitdatenDto zDtoBis = new ZeitdatenDto();

			zDtoBis.setPersonalIId(zeitdatenDto.getPersonalIId());
			zDtoBis.setTZeit(zeitdatenDto.gettZeit_Bis());

			if (zeitdatenDto.getCBelegartnr() != null) {
				zDtoBis.setTaetigkeitIId(taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId());
			} else {
				zDtoBis.setTaetigkeitIId(zeitdatenDto.getTaetigkeitIId());
			}

			zDtoBis.setCWowurdegebucht(zeitdatenDto.getCWowurdegebucht());
			zDtoBis.setPersonalIId(zeitdatenDto.getPersonalIId());
			createZeitdaten(zDtoBis, false, false, false, false, theClientDto, true, alGutSchlecht);

		}

		HvDtoLogger<ZeitdatenDto> zeitdatenLogger = new HvDtoLogger<ZeitdatenDto>(em, zeitdatenDto.getPersonalIId(),
				theClientDto);
		zeitdatenLogger.logInsert(zeitdatenDto);

		myLogger.info("ZEITDATEN_I_ID=" + zeitdatenDto.getIId());

		return zeitdatenDto.getIId();
	}

	private void pruefeUndBucheAutoKommt(ZeitdatenDto zeitdatenDto, TheClientDto theClientDto,
			Integer taetigkeitIId_Geht, Integer taetigkeitIId_Kommt, Integer taetigkeitIId_Unter) {
		// Auto-Kommt/Unter
		ParametermandantDto parameter = null;
		try {
			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_AUTOMATISCHES_KOMMT);
		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		int bAutoKommt = ((Integer) parameter.getCWertAsObject());

		if (bAutoKommt > 0) {

			// Bei KOMMT nichts tun

			SessionFactory factory = FLRSessionFactory.getFactory();
			Session session = factory.openSession();

			org.hibernate.Criteria letztesKommtOderGeht = session.createCriteria(FLRZeitdaten.class);

			letztesKommtOderGeht
					.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, zeitdatenDto.getPersonalIId()));
			letztesKommtOderGeht.add(
					Restrictions.or(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID, taetigkeitIId_Geht),
							Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID, taetigkeitIId_Kommt)));
			letztesKommtOderGeht.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, zeitdatenDto.getTZeit()));
			letztesKommtOderGeht.setMaxResults(1);
			letztesKommtOderGeht.addOrder(Order.desc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));

			List<?> resultLetztesKommtOderGeht = letztesKommtOderGeht.list();

			if (resultLetztesKommtOderGeht.size() == 0) {
				if (zeitdatenDto.getArtikelIId() != null || (zeitdatenDto.getTaetigkeitIId() != null
						&& !zeitdatenDto.getTaetigkeitIId().equals(taetigkeitIId_Kommt))) {

					ZeitdatenDto dtoKommt = new ZeitdatenDto();
					dtoKommt.setTaetigkeitIId(taetigkeitIId_Kommt);
					dtoKommt.setPersonalIId(zeitdatenDto.getPersonalIId());
					dtoKommt.setCWowurdegebucht(zeitdatenDto.getCWowurdegebucht());
					dtoKommt.setCBemerkungZuBelegart("Folgebuchung AUTOMATISCHES_KOMMT");
					// Zeit 140 MS vorher
					dtoKommt.setTZeit(new Timestamp(zeitdatenDto.getTZeit().getTime() - 140));
					createZeitdaten(dtoKommt, false, false, false, false, theClientDto, true, null);
				}
			} else {
				// Wenn zuletzt Geht, dann vorher Kommt buchen

				FLRZeitdaten flrZeitdaten = (FLRZeitdaten) resultLetztesKommtOderGeht.iterator().next();

				if (flrZeitdaten.getTaetigkeit_i_id().equals(taetigkeitIId_Kommt)) {
					Query queryAutoKommt = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
					queryAutoKommt.setParameter(1, zeitdatenDto.getPersonalIId());
					queryAutoKommt.setParameter(2, flrZeitdaten.getT_zeit());
					queryAutoKommt.setParameter(3, zeitdatenDto.getTZeit());

					ZeitdatenDto[] letzeBuchungenFuerAutoKommt = assembleZeitdatenDtosOhneBelegzeiten(
							queryAutoKommt.getResultList());
					if (letzeBuchungenFuerAutoKommt.length == 0 && zeitdatenDto.getTaetigkeitIId() == null) {
						// Vorher Kommt buchen
						ZeitdatenDto dtoKommt = new ZeitdatenDto();
						dtoKommt.setTaetigkeitIId(
								taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId());
						dtoKommt.setPersonalIId(zeitdatenDto.getPersonalIId());
						dtoKommt.setCWowurdegebucht(zeitdatenDto.getCWowurdegebucht());
						dtoKommt.setCBemerkungZuBelegart("Folgebuchung AUTOMATISCHES_KOMMT");
						// Zeit 140 MS vorher
						dtoKommt.setTZeit(new Timestamp(zeitdatenDto.getTZeit().getTime() - 140));
						createZeitdaten(dtoKommt, false, false, false, false, theClientDto, true, null);

					} else {
						if (letzeBuchungenFuerAutoKommt.length >= 1) {

							// Wenn die letzte Taetigkeit ein Geht war,
							// dann
							// vorher
							// Kommt buchen
							if (taetigkeitIId_Geht
									.equals(letzeBuchungenFuerAutoKommt[letzeBuchungenFuerAutoKommt.length - 1]
											.getTaetigkeitIId())) {
								// Vorher Kommt buchen
								ZeitdatenDto dtoKommt = new ZeitdatenDto();
								dtoKommt.setTaetigkeitIId(
										taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId());
								dtoKommt.setPersonalIId(zeitdatenDto.getPersonalIId());
								dtoKommt.setCWowurdegebucht(zeitdatenDto.getCWowurdegebucht());
								dtoKommt.setCBemerkungZuBelegart("Folgebuchung AUTOMATISCHES_KOMMT");
								// Zeit 140 MS vorher
								dtoKommt.setTZeit(new Timestamp(zeitdatenDto.getTZeit().getTime() - 140));
								createZeitdaten(dtoKommt, false, false, false, false, theClientDto, true, null);

							} else {

								int iAnzahlUnterHintereinander = 0;
								for (int i = letzeBuchungenFuerAutoKommt.length - 1; i > 0; i--) {
									ZeitdatenDto dto = letzeBuchungenFuerAutoKommt[i];
									if (taetigkeitIId_Unter.equals(dto.getTaetigkeitIId())) {
										iAnzahlUnterHintereinander++;
									} else {
										break;
									}
								}

								if (iAnzahlUnterHintereinander % 2 == 1
										&& !taetigkeitIId_Unter.equals(zeitdatenDto.getTaetigkeitIId())) {
									// PJ17898
									if (bAutoKommt == 1) {
										// UNTER Ende Buchen
										ZeitdatenDto dtoUnter = new ZeitdatenDto();
										dtoUnter.setTaetigkeitIId(
												taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER, theClientDto)
														.getIId());
										dtoUnter.setPersonalIId(zeitdatenDto.getPersonalIId());
										dtoUnter.setCWowurdegebucht(zeitdatenDto.getCWowurdegebucht());
										dtoUnter.setCBemerkungZuBelegart("Folgebuchung AUTOMATISCHES_KOMMT");
										// Zeit 140 MS vorher
										dtoUnter.setTZeit(new Timestamp(zeitdatenDto.getTZeit().getTime() - 140));
										createZeitdaten(dtoUnter, false, false, false, false, theClientDto, true, null);
									}
								}
							}
						}

					}
				} else {
					ZeitdatenDto dtoKommt = new ZeitdatenDto();
					dtoKommt.setTaetigkeitIId(taetigkeitIId_Kommt);
					dtoKommt.setPersonalIId(zeitdatenDto.getPersonalIId());
					dtoKommt.setCWowurdegebucht(zeitdatenDto.getCWowurdegebucht());
					dtoKommt.setCBemerkungZuBelegart("Folgebuchung AUTOMATISCHES_KOMMT");
					// Zeit 140 MS vorher
					dtoKommt.setTZeit(new Timestamp(zeitdatenDto.getTZeit().getTime() - 140));
					createZeitdaten(dtoKommt, false, false, false, false, theClientDto, true, null);
				}

			}

		}
	}

	public void schichtzeitmodellEintragen(ZeitdatenDto zeitdatenDto, TheClientDto theClientDto) {
		Integer zeiltmodellIId = null;
		java.sql.Time tKommt = new java.sql.Time(
				zeitdatenDto.getTZeit().getTime() % (24 * 3600000) + Calendar.getInstance().get(Calendar.DST_OFFSET));

		double dKommt = Helper.time2Double(tKommt);

		double dKleinsterAbstand = 999;

		Query query = em.createNamedQuery("SchichtzeitmodellfindByPersonalIId");
		query.setParameter(1, zeitdatenDto.getPersonalIId());
		Collection c = query.getResultList();
		HashSet<Integer> hsSchichtzeitmodelleDerPerson = new HashSet<Integer>();
		Iterator it = c.iterator();
		while (it.hasNext()) {
			Schichtzeitmodell sz = (Schichtzeitmodell) it.next();

			hsSchichtzeitmodelleDerPerson.add(sz.getZeitmodellIId());
		}
		it = c.iterator();
		while (it.hasNext()) {
			Schichtzeitmodell sz = (Schichtzeitmodell) it.next();

			ZeitmodellDto zmDto = zeitmodellFindByPrimaryKey(sz.getZeitmodellIId(), theClientDto);

			Calendar cKommt = Calendar.getInstance();
			cKommt.setTime(zeitdatenDto.getTZeit());
			Integer tagesartIId = null;

			Query queryTa = em.createNamedQuery("TagesartfindByCNr");
			queryTa.setParameter(1, Helper.holeTagbezeichnungLang(cKommt.get(Calendar.DAY_OF_WEEK)));
			Tagesart tagesart = (Tagesart) queryTa.getSingleResult();
			tagesartIId = tagesart.getIId();

			if (tagesartIId != null) {

				try {
					Query query2 = em.createNamedQuery("ZeitmodelltagfindSollzeitZuTagesart");
					query2.setParameter(1, zmDto.getIId());
					query2.setParameter(2, tagesartIId);
					Zeitmodelltag zmTag = (Zeitmodelltag) query2.getSingleResult();

					java.sql.Time tSchichterkennungszeitpunkt = zmTag.getUSchichterkennung();

					if (tSchichterkennungszeitpunkt != null && tSchichterkennungszeitpunkt.getTime() > -3600000) {

						double dSchichterkennungszeitpunkt = Helper.time2Double(tSchichterkennungszeitpunkt);

						double dDiff = Math.abs(dSchichterkennungszeitpunkt - dKommt);

						if (dDiff < dKleinsterAbstand) {
							zeiltmodellIId = zmDto.getIId();
							dKleinsterAbstand = dDiff;
						}

					}

				} catch (NoResultException e) {
					// dann nix
				}

			}

		}

		// Nun das Zeitmodell eintragen, wenn
		if (zeiltmodellIId != null) {

			PersonalzeitmodellDto personalzeitmodellDto = null;
			try {
				personalzeitmodellDto = getPersonalFac().personalzeitmodellFindZeitmodellZuDatum(
						zeitdatenDto.getPersonalIId(), zeitdatenDto.getTZeit(), theClientDto);

				if (personalzeitmodellDto == null || (personalzeitmodellDto != null
						&& !personalzeitmodellDto.getZeitmodellIId().equals(zeiltmodellIId))) {
					// Zeitmodell ungleich, dann eintragen

					Timestamp tHeute = Helper.cutTimestamp(zeitdatenDto.getTZeit());

					Query query2 = em.createNamedQuery("PersonalzeitmodellfindByPersonalIIdTDatum");
					query2.setParameter(1, zeitdatenDto.getPersonalIId());
					query2.setParameter(2, tHeute);
					Personalzeitmodell personalzeitmodell = null;
					try {
						personalzeitmodell = (Personalzeitmodell) query2.getSingleResult();

						// PJ22086
						if (hsSchichtzeitmodelleDerPerson.contains(personalzeitmodell.getZeitmodellIId())) {
							personalzeitmodell.setZeitmodellIId(zeiltmodellIId);
							em.merge(personalzeitmodell);
							em.flush();
						}

					} catch (NoResultException e) {
						PKGeneratorObj pkPz = new PKGeneratorObj();
						Integer pkIPz = pkPz.getNextPrimaryKey(PKConst.PK_PERSONALZEITMODELL);

						personalzeitmodell = new Personalzeitmodell(pkIPz, zeitdatenDto.getPersonalIId(),
								zeiltmodellIId, tHeute);
						em.merge(personalzeitmodell);
						em.flush();
					}

				}

			} catch (RemoteException ex) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
			}
		}
	}

	@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
	public void pruefeObSollzeitenUeberschritten(Integer losIId, Integer arikelIId, Integer personalIId,
			boolean bKommtVonTerminal, TheClientDto theClientDto) {

		try {
			LossollarbeitsplanDto[] sollDtos = getFertigungFac()
					.lossollarbeitsplanFindByLosIIdArtikelIIdTaetigkeit(losIId, arikelIId);

			if (sollDtos.length > 0) {

				double dSoll = 0;

				{

					if (sollDtos[0].getLRuestzeit().doubleValue() > 0) {
						if (sollDtos[0].getNGesamtzeit() != null) {
							dSoll = dSoll + sollDtos[0].getNGesamtzeit().doubleValue();
						}
					} else {
						return;
					}

				}

				if (!sindZuvieleZeitdatenEinesBelegesVorhanden(LocaleFac.BELEGART_LOS, losIId, theClientDto)) {

					AuftragzeitenDto[] dtos = null;

					try {
						dtos = getAllZeitenEinesBeleges(LocaleFac.BELEGART_LOS, losIId, null, null, null, null,
								SORTIERUNG_ZEITDATEN_ARTIKEL, theClientDto);
					} catch (EJBExceptionLP e) {

						if (bKommtVonTerminal == true) {
							String nachricht = " Fehler in Zeitdaten bei R\u00FCstzeit\u00FCberschreitungspr\u00FCfung: ";

							List<?> al = e.getAlInfoForTheClient();
							String s = "";
							if (al != null && al.size() > 1) {
								if (al.get(0) instanceof Integer) {
									PersonalDto personalDto = getPersonalFac()
											.personalFindByPrimaryKey((Integer) al.get(0), theClientDto);
									s += " (" + personalDto.getCPersonalnr() + " "
											+ personalDto.getPartnerDto().formatFixName2Name1();
								}
								if (al.get(1) instanceof java.sql.Timestamp) {
									s += ", " + Helper.formatDatum((java.sql.Timestamp) al.get(1),
											theClientDto.getLocUi()) + ")";
								}

							}
							nachricht += s;

							getBenutzerFac().sendJmsMessageMitArchiveintrag(BenutzerFac.NA_RUESTZEIT_UEBERSCHRITTEN,
									nachricht, theClientDto);
							return;
						} else {
							throw e;
						}

					}

					double zeiten = 0;
					for (int i = 0; i < dtos.length; i++) {
						if (dtos[i] != null && dtos[i].getDdDauer() != null
								&& dtos[i].getArtikelIId().equals(arikelIId)) {
							zeiten = zeiten + dtos[i].getDdDauer().doubleValue();
						}
					}

					if (zeiten > dSoll) {
						LosDto losDto = getFertigungFac().losFindByPrimaryKey(losIId);

						ArtikelDto artikelDto = getArtikelFac()
								.artikelFindByPrimaryKeySmall(sollDtos[0].getArtikelIIdTaetigkeit(), theClientDto);

						PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);

						String nachricht = " R\u00FCstzeit \u00FCberschritten bei Losnummer: " + losDto.getCNr()
								+ " T\u00E4tigkeit: " + artikelDto.formatArtikelbezeichnung() + " Person: "
								+ personalDto.getPartnerDto().formatAnrede();
						getBenutzerFac().sendJmsMessageMitArchiveintrag(BenutzerFac.NA_RUESTZEIT_UEBERSCHRITTEN,
								nachricht, theClientDto);

					}

				}
			}

		} catch (RemoteException e) {
			return;
		}

	}

	@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
	public void pruefeObProjektSollzeitenUeberschritten(Integer projektIId, boolean bKommtVonTerminal,
			TheClientDto theClientDto) {

		try {
			ProjektDto projektDto = getProjektFac().projektFindByPrimaryKey(projektIId);

			if (projektDto.getDDauer() != null && projektDto.getDDauer() > 0
					&& projektDto.getIVerrechenbar() == ProjektServiceFac.PROJEKT_VERRECHENBAR_VERRECHENBAR) {

				double dSoll = projektDto.getDDauer();
				if (!sindZuvieleZeitdatenEinesBelegesVorhanden(LocaleFac.BELEGART_PROJEKT, projektIId, theClientDto)) {
					Double dSummeIst = null;
					try {
						dSummeIst = getSummeZeitenEinesBeleges(LocaleFac.BELEGART_PROJEKT, projektIId, null, null, null,
								null, theClientDto);
					} catch (EJBExceptionLP e) {
						if (bKommtVonTerminal == true) {
							return;
						} else {
							throw e;
						}
					}
					if (dSummeIst > dSoll) {
						getNachrichtenFac().nachrichtProjektzeitenUeberschritten(projektDto, dSummeIst, theClientDto);

					}
				}
			}
		} catch (RemoteException e) {
			return;
		}

	}

	private long getVerfuegbareZeitImZeitraumOhneSondertaetigkeiten(Integer personalIId, Timestamp tZeitVon,
			Timestamp tZeitBis) {
		// Hole Zeitdaten eines Tages
		Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
		query.setParameter(1, personalIId);
		query.setParameter(2, tZeitVon);
		query.setParameter(3, tZeitBis);
		Collection<?> cl = query.getResultList();

		ZeitdatenDto[] dtos = assembleZeitdatenDtosOhneBelegzeiten(query.getResultList());

		long lZeitgesamt = tZeitBis.getTime() - tZeitVon.getTime();

		// Paarweise Sondertaetigkeiten abziehen
		Query query2 = em.createNamedQuery("TaetigkeitfindAll");

		TaetigkeitDto[] tDtos = assembleTaetigkeitDtos(query2.getResultList());

		for (int i = 0; i < tDtos.length; i++) {
			try {
				double d = berechnePaarweiserSondertaetigkeiten(dtos, false, tDtos[i].getIId());

				lZeitgesamt -= d * 3600000;

			} catch (Exception e) {
				// Wenn Felher, dann wird das ignoriert
			}
		}

		return lZeitgesamt;

	}

	public boolean zeitAufLoseVerteilen(Integer personalIId, Timestamp tZeitBis, boolean bVorherEndeEinbuchen,
			ArrayList<ZeitverteilenGutSchlechtDto> alGutSchlecht, TheClientDto theClientDto) {

		int iZeitverteilungTyp = 0;
		try {
			ParametermandantDto parameter = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_ZEITVERTEILUNG_TYP);

			iZeitverteilungTyp = (Integer) parameter.getCWertAsObject();

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		// Zuerst alle mit artikel_i_id=NULL loeschen, da hier anscheinend keine
		// Abschlussbuchung durchgefuehrt wurde
		ZeitverteilungDto[] zeitverteilungDtos = zeitverteilungFindByPersonalIIdUndTag(personalIId, tZeitBis);
		for (int i = 0; i < zeitverteilungDtos.length; i++) {
			if (zeitverteilungDtos[i].getArtikelIId() == null) {
				Zeitverteilung zeitverteilung = em.find(Zeitverteilung.class, zeitverteilungDtos[i].getIId());
				em.remove(zeitverteilung);
				em.flush();
			}
		}

		zeitverteilungDtos = zeitverteilungFindByPersonalIIdUndTag(personalIId, tZeitBis);
		if (zeitverteilungDtos.length > 0 && zeitverteilungDtos[0].getArtikelIId() != null) {

			if (iZeitverteilungTyp == 0) {
				return zeitAufLoseVerteilen_TYP0(personalIId, tZeitBis, bVorherEndeEinbuchen, zeitverteilungDtos,
						theClientDto);
			} else if (iZeitverteilungTyp == 1) {

				return zeitAufLoseVerteilen_TYP1und2(personalIId, tZeitBis, bVorherEndeEinbuchen, zeitverteilungDtos,
						alGutSchlecht, iZeitverteilungTyp, theClientDto);
			} else if (iZeitverteilungTyp == 2) {

				// PJ21873
				boolean bRuestenVorhanden = false;
				for (int i = 0; i < zeitverteilungDtos.length; i++) {
					if (zeitverteilungDtos[i].getLossollarbeitsplanIId() != null) {

						LossollarbeitsplanDto saDto = getFertigungFac()
								.lossollarbeitsplanFindByPrimaryKey(zeitverteilungDtos[i].getLossollarbeitsplanIId());

						LossollarbeitsplanDto[] soaDtos = getFertigungFac()
								.getAlleZusatzlichZuBuchuchendenArbeitsgaenge(
										zeitverteilungDtos[i].getLossollarbeitsplanIId(), theClientDto);
						zeitverteilungDtos[i].setZusaetzlicheAGs_NOT_IN_DB(soaDtos);

						if (saDto.getAgartCNr() == null) {
							bRuestenVorhanden = true;
						}

						for (int j = 0; j < soaDtos.length; j++) {

							LossollarbeitsplanDto zusDto = soaDtos[j];
							if (zusDto.getAgartCNr() == null) {
								bRuestenVorhanden = true;
							}
						}

					}
				}

				if (bRuestenVorhanden == true) {
					return zeitAufLoseVerteilen_TYP1und2(personalIId, tZeitBis, bVorherEndeEinbuchen,
							zeitverteilungDtos, alGutSchlecht, 2, theClientDto);
				} else {
					return zeitAufLoseVerteilen_TYP1und2(personalIId, tZeitBis, bVorherEndeEinbuchen,
							zeitverteilungDtos, alGutSchlecht, 1, theClientDto);
				}

			}
		}
		return false;
	}

	private boolean zeitAufLoseVerteilen_TYP0(Integer personalIId, Timestamp tZeitBis, boolean bVorherEndeEinbuchen,
			ZeitverteilungDto[] zeitverteilungDtos, TheClientDto theClientDto) {
		// Wenn Taetigkeit GEHT/ENDE oder eine Fortsetzung eines Loses gebucht
		// wird, dann Zeiten verteilen

		ZeitdatenDto zeitdatenDto = new ZeitdatenDto();

		zeitdatenDto.setPersonalIId(personalIId);
		zeitdatenDto.setTaetigkeitIId(taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId());
		zeitdatenDto.setTZeit(zeitverteilungDtos[0].getTZeit());

		// PJ18152 Wenn Beginnzeiten waehrend einer Pause gestempelt
		// wutrden, dann muss die naechste Sondertaetigkeit verwendet werden
		ZeitdatenDto[] zeitdatenDtos = null;
		// try {
		Query query3 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
		query3.setParameter(1, personalIId);
		query3.setParameter(2, Helper.cutTimestamp(zeitverteilungDtos[0].getTZeit()));
		query3.setParameter(3, zeitverteilungDtos[0].getTZeit());
		Collection<?> cl1 = query3.getResultList();
		// if (! cl1.isEmpty()) {
		zeitdatenDtos = assembleZeitdatenDtosOhneBelegzeiten(cl1);

		boolean b = istPersonAnwesend(zeitdatenDtos,
				taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId(),
				zeitverteilungDtos[0].getTZeit());

		HashSet hsMaschinebereitsGebucht = new HashSet();

		if (b == false) {

			String sQuery = "select zeitdaten FROM FLRZeitdaten zeitdaten WHERE zeitdaten.t_zeit>'"
					+ Helper.formatTimestampWithSlashes(zeitverteilungDtos[0].getTZeit())
					+ "' AND zeitdaten.personal_i_id=" + personalIId
					+ " AND zeitdaten.taetigkeit_i_id is not null) ORDER BY zeitdaten.t_zeit ASC";

			Session session = FLRSessionFactory.getFactory().openSession();

			org.hibernate.Query naechsteSondertaetigkeit = session.createQuery(sQuery);
			naechsteSondertaetigkeit.setMaxResults(1);

			List<?> resultNaechsteSondertaetigkeit = naechsteSondertaetigkeit.list();

			if (resultNaechsteSondertaetigkeit.size() > 0) {
				FLRZeitdaten flr = (FLRZeitdaten) resultNaechsteSondertaetigkeit.iterator().next();
				zeitdatenDto.setTZeit(new Timestamp(flr.getT_zeit().getTime() + 10));
			}
			session.close();

		}

		// SP8732 Vorher pruefen, ob noch nicht vorhanden
		Query query4 = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
		query4.setParameter(1, personalIId);
		query4.setParameter(2, zeitdatenDto.getTZeit());

		Collection<?> clVorhanden = query4.getResultList();

		if (clVorhanden.size() == 0) {
			createZeitdaten(zeitdatenDto, false, false, false, false, theClientDto);
		}

		// Hole alle Zeitdaten im Bereich

		long lVerfuegbar = getVerfuegbareZeitImZeitraumOhneSondertaetigkeiten(personalIId, zeitdatenDto.getTZeit(),
				tZeitBis);

		// SP6301
		lVerfuegbar = lVerfuegbar - 100;

		long lVerfuegbarFuerMaschinenzeit = tZeitBis.getTime() - zeitverteilungDtos[0].getTZeit().getTime();
		// PJ18956
		BigDecimal bdGesamtLosgroesse = BigDecimal.ZERO;
		for (int i = 0; i < zeitverteilungDtos.length; i++) {
			try {
				bdGesamtLosgroesse = bdGesamtLosgroesse
						.add(getFertigungFac().losFindByPrimaryKey(zeitverteilungDtos[i].getLosIId()).getNLosgroesse());
			} catch (RemoteException e) {
				throwEJBExceptionLPRespectOld(e);
			}
		}

		long zeitProEinheit = lVerfuegbar;
		long zeitProEinheitFuerMaschinenzeit = lVerfuegbarFuerMaschinenzeit;

		if (bdGesamtLosgroesse.doubleValue() != 0) {
			zeitProEinheit = lVerfuegbar / bdGesamtLosgroesse.intValue();
			zeitProEinheitFuerMaschinenzeit = lVerfuegbarFuerMaschinenzeit / bdGesamtLosgroesse.intValue();
		}

		Integer iId_Zeitdaten = null;
		Timestamp tBeginnFuerMasschinenzeit = zeitverteilungDtos[0].getTZeit();
		for (int i = 0; i < zeitverteilungDtos.length; i++) {

			MaschineDto mDto = null;

			if (zeitverteilungDtos[i].getMaschineIId() != null) {

				mDto = getZeiterfassungFac().maschineFindByPrimaryKey(zeitverteilungDtos[i].getMaschineIId());
			}

			ZeitdatenDto dto = new ZeitdatenDto();
			dto.setPersonalIId(personalIId);
			dto.setCBelegartnr(LocaleFac.BELEGART_LOS);
			dto.setIBelegartid(zeitverteilungDtos[i].getLosIId());
			dto.setArtikelIId(zeitverteilungDtos[i].getArtikelIId());

			if (mDto != null && Helper.short2boolean(mDto.getBManuelleBedienung())) {
				dto.setMaschineIId(mDto.getIId());
			}

			long lZeitProLos = 0;
			long lZeitProLosFuerMaschinenzeit = 0;
			try {

				BigDecimal bdLosgroesse = getFertigungFac().losFindByPrimaryKey(zeitverteilungDtos[i].getLosIId())
						.getNLosgroesse();

				// PJ18956
				lZeitProLos = zeitProEinheit * bdLosgroesse.intValue();
				lZeitProLosFuerMaschinenzeit = zeitProEinheitFuerMaschinenzeit * bdLosgroesse.intValue();

				zeitverteilungDtos[i].setlZeitproLos_notInDB(lZeitProLosFuerMaschinenzeit);

				// PJ19451
				if (zeitverteilungDtos[i].getLossollarbeitsplanIId() != null) {
					dto.setIBelegartpositionid(zeitverteilungDtos[i].getLossollarbeitsplanIId());
				} else {
					// Auf Taetigkeit buchen, wenn nicht vorhanden auf die
					// erste Position
					com.lp.server.fertigung.service.LossollarbeitsplanDto[] dtos = getFertigungFac()
							.lossollarbeitsplanFindByLosIIdArtikelIIdTaetigkeit(zeitverteilungDtos[i].getLosIId(),
									zeitverteilungDtos[i].getArtikelIId());

					if (dtos != null && dtos.length > 0) {
						dto.setIBelegartpositionid(dtos[0].getIId());
					} else {
						com.lp.server.fertigung.service.LossollarbeitsplanDto[] dtosErstePosition = getFertigungFac()
								.lossollarbeitsplanFindByLosIId(zeitverteilungDtos[i].getLosIId());
						if (dtosErstePosition != null && dtosErstePosition.length > 0) {
							dto.setIBelegartpositionid(dtosErstePosition[0].getIId());

						}
					}
				}
			} catch (RemoteException e) {
				throwEJBExceptionLPRespectOld(e);
			}

			dto.setTZeit(new Timestamp(Helper.cutTimestamp(tZeitBis).getTime() + lZeitProLos));

			if (lZeitProLos < 1000) {
				continue;
			}

			if (iId_Zeitdaten == null) {
				iId_Zeitdaten = bucheZeitRelativ(dto, null, true, true, theClientDto);
			} else {
				ZeitdatenDto temp = zeitdatenFindByPrimaryKey(iId_Zeitdaten, theClientDto);
				iId_Zeitdaten = bucheZeitRelativ(dto, temp.getTZeit(), true, true, theClientDto);
			}

			// PJ20641
			Zeitverteilung zeitverteilung = em.find(Zeitverteilung.class, zeitverteilungDtos[i].getIId());
			zeitverteilung.setBVerteilt(Helper.boolean2Short(true));
			zeitverteilung.setIIdBlock(zeitverteilungDtos[0].getIId());
			zeitverteilung.setZeitdatenIIdUmgewandelt(iId_Zeitdaten);
			em.merge(zeitverteilung);
			em.flush();

			// PJ20756

			if (mDto != null && Helper.short2boolean(mDto.getBManuelleBedienung()) == false) {

				if (!hsMaschinebereitsGebucht.contains(zeitverteilungDtos[i].getMaschineIId())) {

					MaschinenzeitdatenDto mzDto = new MaschinenzeitdatenDto();
					mzDto.setMaschineIId(zeitverteilungDtos[i].getMaschineIId());
					mzDto.setLossollarbeitsplanIId(zeitverteilungDtos[i].getLossollarbeitsplanIId());
					mzDto.setPersonalIIdGestartet(zeitverteilungDtos[i].getPersonalIId());
					mzDto.setTVon(tBeginnFuerMasschinenzeit);

					// Timestamp tEnde = new Timestamp(
					// tBeginnFuerMasschinenzeit.getTime() +
					// zeitverteilungDtos[i].getlZeitproLos_notInDB());

					// mzDto.setTBis(tEnde);

					// SP9740
					mzDto.setTBis(tZeitBis);

					maschinenzeitenVorZeitverteilungVerschieben(tBeginnFuerMasschinenzeit, tZeitBis,
							zeitverteilungDtos[i].getMaschineIId(), theClientDto);

					// Beim letzten auf tatsaechliche Bis-Zeit setzten
					if (i == zeitverteilungDtos.length - 1) {
						mzDto.setTBis(tZeitBis);
					}

					mzDto.setCBemerkung("Zeitverteilung");

					createMaschinenzeitdaten(mzDto, false, theClientDto);

				}
				hsMaschinebereitsGebucht.add(zeitverteilungDtos[i].getMaschineIId());
			}

		}
		return true;
	}

	private boolean zeitAufLoseVerteilen_TYP1und2(Integer personalIId, Timestamp tZeitBis, boolean bVorherEndeEinbuchen,
			ZeitverteilungDto[] zeitverteilungDtos, ArrayList<ZeitverteilenGutSchlechtDto> alGutSchlecht,
			int iZeitverteilungTyp, TheClientDto theClientDto) {
		// Wenn Taetigkeit GEHT/ENDE oder eine Fortsetzung eines Loses gebucht
		// wird, dann Zeiten verteilen

		Integer taetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();
		Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();

		ZeitdatenDto zeitdatenDto = new ZeitdatenDto();

		zeitdatenDto.setPersonalIId(personalIId);
		zeitdatenDto.setTaetigkeitIId(taetigkeitIId_Ende);
		zeitdatenDto.setTZeit(zeitverteilungDtos[0].getTZeit());

		// PJ18152 Wenn Beginnzeiten waehrend einer Pause gestempelt
		// wutrden, dann muss die naechste Sondertaetigkeit verwendet werden
		ZeitdatenDto[] zeitdatenDtos = null;
		// try {
		Query query3 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
		query3.setParameter(1, personalIId);
		query3.setParameter(2, Helper.cutTimestamp(zeitverteilungDtos[0].getTZeit()));
		query3.setParameter(3, zeitverteilungDtos[0].getTZeit());
		Collection<?> cl1 = query3.getResultList();
		// if (! cl1.isEmpty()) {
		zeitdatenDtos = assembleZeitdatenDtosOhneBelegzeiten(cl1);

		boolean b = istPersonAnwesend(zeitdatenDtos, taetigkeitIId_Kommt, zeitverteilungDtos[0].getTZeit());

		if (b == false) {

			String sQuery = "select zeitdaten FROM FLRZeitdaten zeitdaten WHERE zeitdaten.t_zeit>'"
					+ Helper.formatTimestampWithSlashes(zeitverteilungDtos[0].getTZeit())
					+ "' AND zeitdaten.personal_i_id=" + personalIId
					+ " AND zeitdaten.taetigkeit_i_id is not null) ORDER BY zeitdaten.t_zeit ASC";

			Session session = FLRSessionFactory.getFactory().openSession();

			org.hibernate.Query naechsteSondertaetigkeit = session.createQuery(sQuery);
			naechsteSondertaetigkeit.setMaxResults(1);

			List<?> resultNaechsteSondertaetigkeit = naechsteSondertaetigkeit.list();

			if (resultNaechsteSondertaetigkeit.size() > 0) {
				FLRZeitdaten flr = (FLRZeitdaten) resultNaechsteSondertaetigkeit.iterator().next();
				zeitdatenDto.setTZeit(new Timestamp(flr.getT_zeit().getTime() + 10));
			}
			session.close();

		}

		// SP8732 Vorher pruefen, ob noch nicht vorhanden
		Query query4 = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
		query4.setParameter(1, personalIId);
		query4.setParameter(2, zeitdatenDto.getTZeit());

		Collection<?> clVorhanden = query4.getResultList();

		if (clVorhanden.size() == 0) {
			createZeitdaten(zeitdatenDto, false, false, false, false, theClientDto);
		}

		// Hole alle Zeitdaten im Bereich

		long lVerfuegbar = getVerfuegbareZeitImZeitraumOhneSondertaetigkeiten(personalIId, zeitdatenDto.getTZeit(),
				tZeitBis);

		// SP6301
		lVerfuegbar = lVerfuegbar - 100;

		// SP8716 Bei Typ 1 wird die Zeit anhand der Stueckzeit x (Gut+Schlechtstuek)
		// berechnet, d.h. zuerst Gesamt-Stueck berechnen

		int iSollzeitWenn0 = 60;

		try {
			ParametermandantDto parameter = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_ZEITVERTEILUNG_SOLLZEIT_WENN_0);

			iSollzeitWenn0 = (Integer) parameter.getCWertAsObject();

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		long lGesamtzeitBerechnet = 0;

		/*
		 * TEST alGutSchlecht=new ArrayList<ZeitverteilenGutSchlechtDto>();
		 * alGutSchlecht.add(new
		 * ZeitverteilenGutSchlechtDto(1030589,BigDecimal.ONE,BigDecimal.ONE));
		 * alGutSchlecht.add(new
		 * ZeitverteilenGutSchlechtDto(1030597,BigDecimal.ONE,BigDecimal.ONE));
		 * alGutSchlecht.add(new
		 * ZeitverteilenGutSchlechtDto(1030599,BigDecimal.ONE,BigDecimal.ONE));
		 */

		ArrayList<ZeitverteilungDto> alZeitvertweilungDtosZusaetzlich = new ArrayList<ZeitverteilungDto>();

		for (int i = 0; i < zeitverteilungDtos.length; i++) {

			if (zeitverteilungDtos[i].getLossollarbeitsplanIId() != null) {

				LossollarbeitsplanDto saDto = getFertigungFac()
						.lossollarbeitsplanFindByPrimaryKey(zeitverteilungDtos[i].getLossollarbeitsplanIId());

				double dStueckzeit = new BigDecimal(saDto.getLStueckzeit())
						.divide(new BigDecimal(3600000), 5, BigDecimal.ROUND_HALF_EVEN).doubleValue();

				// GutSchlechtStuck finden
				BigDecimal bdGutSchlechStueck = BigDecimal.ONE;
				if (alGutSchlecht != null) {
					Iterator it = alGutSchlecht.iterator();
					while (it.hasNext()) {
						ZeitverteilenGutSchlechtDto zvDto = (ZeitverteilenGutSchlechtDto) it.next();

						if (zvDto.getLossollarbeitsplanIId() != null && zvDto.getLossollarbeitsplanIId()
								.equals(zeitverteilungDtos[i].getLossollarbeitsplanIId())) {

							if (zvDto.getGutStueck() != null || zvDto.getSchlechtStueck() != null) {
								bdGutSchlechStueck = BigDecimal.ZERO;

								if (zvDto.getGutStueck() != null) {
									bdGutSchlechStueck = bdGutSchlechStueck.add(zvDto.getGutStueck());
								}
								if (zvDto.getSchlechtStueck() != null) {
									bdGutSchlechStueck = bdGutSchlechStueck.add(zvDto.getSchlechtStueck());
								}
							}
						}
					}
				}

				zeitverteilungDtos[i].setBdSummeGutSchlecht_NOT_IN_DB(bdGutSchlechStueck);

				if (dStueckzeit == 0) {
					dStueckzeit = ((double) iSollzeitWenn0) / 60;
				}

				BigDecimal bdStueckzeitGesamt = Helper.rundeKaufmaennisch(new BigDecimal(dStueckzeit), 5)
						.multiply(bdGutSchlechStueck);

				zeitverteilungDtos[i]
						.setlZeitproLos_notInDB((long) (bdStueckzeitGesamt.doubleValue() * 60 * 60 * 1000));

				lGesamtzeitBerechnet = lGesamtzeitBerechnet + zeitverteilungDtos[i].getlZeitproLos_notInDB();

				// PJ21873 Zusaetzliche AGS beruecksichtigen
				if (iZeitverteilungTyp == 2) {
					if (saDto.getAgartCNr() == null) {
						zeitverteilungDtos[i].setBRuesten(true);
					}
					if (zeitverteilungDtos[i].getZusaetzlicheAGs_NOT_IN_DB() != null) {

						for (int j = 0; j < zeitverteilungDtos[i].getZusaetzlicheAGs_NOT_IN_DB().length; j++) {
							LossollarbeitsplanDto saDoZusaetzlich = zeitverteilungDtos[i]
									.getZusaetzlicheAGs_NOT_IN_DB()[j];

							ZeitverteilungDto zusDto = ZeitverteilungDto.clone(zeitverteilungDtos[i]);
							zusDto.setMaschineIId(saDoZusaetzlich.getMaschineIId());
							zusDto.setLossollarbeitsplanIId(saDoZusaetzlich.getIId());
							if (saDoZusaetzlich.getAgartCNr() == null) {
								zusDto.setBRuesten(true);
							} else {
								zusDto.setBRuesten(false);
							}
							zusDto.setLosIId(saDoZusaetzlich.getLosIId());
							zusDto.setZusaetzlicheAGs_NOT_IN_DB(null);

							// Zeit berechnen

							dStueckzeit = new BigDecimal(saDoZusaetzlich.getLStueckzeit())
									.divide(new BigDecimal(3600000), 5, BigDecimal.ROUND_HALF_EVEN).doubleValue();
							if (dStueckzeit == 0) {
								dStueckzeit = ((double) iSollzeitWenn0) / 60;
							}
							bdStueckzeitGesamt = Helper.rundeKaufmaennisch(new BigDecimal(dStueckzeit), 5)
									.multiply(bdGutSchlechStueck);

							zusDto.setlZeitproLos_notInDB((long) (bdStueckzeitGesamt.doubleValue() * 60 * 60 * 1000));

							lGesamtzeitBerechnet = lGesamtzeitBerechnet + zusDto.getlZeitproLos_notInDB();

							alZeitvertweilungDtosZusaetzlich.add(zusDto);

						}

					}

				}

			} else {

				zeitverteilungDtos[i].setlZeitproLos_notInDB(
						(long) (new BigDecimal(((double) iSollzeitWenn0) / 60).doubleValue() * 60 * 60 * 1000));
				lGesamtzeitBerechnet = lGesamtzeitBerechnet + zeitverteilungDtos[i].getlZeitproLos_notInDB();
			}

		}

		if (iZeitverteilungTyp == 2) {

			ZeitverteilungDto[] zeitverteilungDtosTemp = new ZeitverteilungDto[zeitverteilungDtos.length
					+ alZeitvertweilungDtosZusaetzlich.size()];
			int j = 0;
			for (int i = 0; i < zeitverteilungDtos.length; i++) {
				zeitverteilungDtosTemp[i] = zeitverteilungDtos[i];
				j++;
			}

			for (int i = 0; i < alZeitvertweilungDtosZusaetzlich.size(); i++) {
				zeitverteilungDtosTemp[j] = alZeitvertweilungDtosZusaetzlich.get(i);
				j++;
			}

			zeitverteilungDtos = zeitverteilungDtosTemp;

			// Wenn die verfuegbare Zeit < als die errechnete ist, dann werden fuer die
			// Ruestzeiten 1 Minute angenommen

			if (lVerfuegbar < lGesamtzeitBerechnet) {
				for (int i = 0; i < zeitverteilungDtos.length; i++) {
					if (zeitverteilungDtos[i].isbRuesten() && zeitverteilungDtos[i].getlZeitproLos_notInDB() > 60000) {

						lGesamtzeitBerechnet = lGesamtzeitBerechnet
								- (zeitverteilungDtos[i].getlZeitproLos_notInDB() - 60000);
						zeitverteilungDtos[i].setlZeitproLos_notInDB(60000);
					}
				}
			}
		}

		// Faktor berechnen
		double dFaktor = 1;
		if (lGesamtzeitBerechnet != 0) {
			dFaktor = ((double) lVerfuegbar) / ((double) lGesamtzeitBerechnet);
		}

		// Zeit um Faktor korrigieren

		for (int i = 0; i < zeitverteilungDtos.length; i++) {
			zeitverteilungDtos[i]
					.setlZeitproLos_notInDB((long) ((double) zeitverteilungDtos[i].getlZeitproLos_notInDB() * dFaktor));
		}

		Integer iId_Zeitdaten = null;

		for (int i = 0; i < zeitverteilungDtos.length; i++) {

			ZeitdatenDto dto = new ZeitdatenDto();
			dto.setPersonalIId(personalIId);
			dto.setCBelegartnr(LocaleFac.BELEGART_LOS);
			dto.setIBelegartid(zeitverteilungDtos[i].getLosIId());
			dto.setArtikelIId(zeitverteilungDtos[i].getArtikelIId());

			MaschineDto mDto = null;

			if (zeitverteilungDtos[i].getMaschineIId() != null) {

				mDto = getZeiterfassungFac().maschineFindByPrimaryKey(zeitverteilungDtos[i].getMaschineIId());
			}

			if (mDto != null && Helper.short2boolean(mDto.getBManuelleBedienung())) {
				dto.setMaschineIId(mDto.getIId());
			}

			long lZeitProLos = 0;
			long lZeitProLosFuerMaschinenzeit = 0;
			try {

				// PJ18956
				lZeitProLos = zeitverteilungDtos[i].getlZeitproLos_notInDB();

				// PJ19451
				if (zeitverteilungDtos[i].getLossollarbeitsplanIId() != null) {
					dto.setIBelegartpositionid(zeitverteilungDtos[i].getLossollarbeitsplanIId());
					dto.setArtikelIId(getFertigungFac()
							.lossollarbeitsplanFindByPrimaryKey(zeitverteilungDtos[i].getLossollarbeitsplanIId())
							.getArtikelIIdTaetigkeit());
				} else {
					// Auf Taetigkeit buchen, wenn nicht vorhanden auf die
					// erste Position
					com.lp.server.fertigung.service.LossollarbeitsplanDto[] dtos = getFertigungFac()
							.lossollarbeitsplanFindByLosIIdArtikelIIdTaetigkeit(zeitverteilungDtos[i].getLosIId(),
									zeitverteilungDtos[i].getArtikelIId());

					if (dtos != null && dtos.length > 0) {
						dto.setIBelegartpositionid(dtos[0].getIId());
					} else {
						com.lp.server.fertigung.service.LossollarbeitsplanDto[] dtosErstePosition = getFertigungFac()
								.lossollarbeitsplanFindByLosIId(zeitverteilungDtos[i].getLosIId());
						if (dtosErstePosition != null && dtosErstePosition.length > 0) {
							dto.setIBelegartpositionid(dtosErstePosition[0].getIId());

						}
					}
				}
			} catch (RemoteException e) {
				throwEJBExceptionLPRespectOld(e);
			}

			dto.setTZeit(new Timestamp(Helper.cutTimestamp(zeitverteilungDtos[0].getTZeit()).getTime() + lZeitProLos));

			// PJ20641
			if (zeitverteilungDtos[i].getIId() != null) {
				Zeitverteilung zeitverteilung = em.find(Zeitverteilung.class, zeitverteilungDtos[i].getIId());
				zeitverteilung.setBVerteilt(Helper.boolean2Short(true));
				zeitverteilung.setIIdBlock(zeitverteilungDtos[0].getIId());
				zeitverteilung.setZeitdatenIIdUmgewandelt(iId_Zeitdaten);
				em.merge(zeitverteilung);
				em.flush();
			}

			if (lZeitProLos < 1000) {
				continue;
			}

			if (iId_Zeitdaten == null) {
				iId_Zeitdaten = bucheZeitRelativ(dto, new java.sql.Timestamp(zeitdatenDto.getTZeit().getTime() - 1000),
						tZeitBis, true, true, theClientDto);
			} else {
				ZeitdatenDto temp = zeitdatenFindByPrimaryKey(iId_Zeitdaten, theClientDto);
				dto.setTZeit(new Timestamp(Helper.cutTimestamp(temp.getTZeit()).getTime() + lZeitProLos));
				iId_Zeitdaten = bucheZeitRelativ(dto, new java.sql.Timestamp(zeitdatenDto.getTZeit().getTime() - 1000),
						tZeitBis, true, true, theClientDto);
			}

		}

		// Nach Maschinen auftrennen
		HashMap<Integer, ArrayList<ZeitverteilungDto>> hmMaschinen = new HashMap<Integer, ArrayList<ZeitverteilungDto>>();

		HashMap<Integer, BigDecimal> hmGesamtSollJeMaschine = new HashMap<Integer, BigDecimal>();

		for (int i = 0; i < zeitverteilungDtos.length; i++) {

			MaschineDto mDto = null;

			if (zeitverteilungDtos[i].getMaschineIId() != null) {
				Integer maschineIId = zeitverteilungDtos[i].getMaschineIId();

				ArrayList<ZeitverteilungDto> zvDtos = null;

				if (hmMaschinen.containsKey(maschineIId)) {
					zvDtos = hmMaschinen.get(maschineIId);
				} else {
					zvDtos = new ArrayList<ZeitverteilungDto>();
				}

				zvDtos.add(zeitverteilungDtos[i]);

				hmMaschinen.put(maschineIId, zvDtos);

				BigDecimal bdGesamtSoll = null;

				if (hmGesamtSollJeMaschine.containsKey(maschineIId)) {
					bdGesamtSoll = hmGesamtSollJeMaschine.get(maschineIId);
				} else {
					bdGesamtSoll = BigDecimal.ZERO;
				}

				if (zeitverteilungDtos[i].getLossollarbeitsplanIId() != null) {

					LossollarbeitsplanDto lossollarbeitsplanDto = getFertigungFac()
							.lossollarbeitsplanFindByPrimaryKey(zeitverteilungDtos[i].getLossollarbeitsplanIId());
					
					BigDecimal 	dStueckzeit = new BigDecimal(lossollarbeitsplanDto.getLStueckzeit())
							.divide(new BigDecimal(3600000), 5, BigDecimal.ROUND_HALF_EVEN);
					
					BigDecimal dRuestzeit = new BigDecimal(lossollarbeitsplanDto.getLRuestzeit())
							.divide(new BigDecimal(3600000), 5, BigDecimal.ROUND_HALF_EVEN);
					
					
					if (dRuestzeit.doubleValue() > 0 && dStueckzeit.doubleValue() == 0) {
						bdGesamtSoll = bdGesamtSoll.add(new BigDecimal(lossollarbeitsplanDto.getLRuestzeit())
								.divide(new BigDecimal(3600000), 4, BigDecimal.ROUND_HALF_EVEN));
					}else {
						bdGesamtSoll = bdGesamtSoll.add(new BigDecimal(lossollarbeitsplanDto.getLStueckzeit())
								.divide(new BigDecimal(3600000), 4, BigDecimal.ROUND_HALF_EVEN));
					}
					
					
				}

				hmGesamtSollJeMaschine.put(maschineIId, bdGesamtSoll);

			}
		}

		BigDecimal bdZuVerteilen = new BigDecimal(
				Helper.timeInMillis2Double(tZeitBis.getTime() - zeitverteilungDtos[0].getTZeit().getTime()));

		Iterator it = hmMaschinen.keySet().iterator();
		while (it.hasNext()) {

			Integer maschineIId = (Integer) it.next();

			ArrayList<ZeitverteilungDto> alZeitverteilungDtos = hmMaschinen.get(maschineIId);

			Timestamp tMaschineBeginnAktuell = zeitverteilungDtos[0].getTZeit();

			BigDecimal bdGesamtSoll = hmGesamtSollJeMaschine.get(maschineIId);
			MaschineDto mDto = getZeiterfassungFac().maschineFindByPrimaryKey(maschineIId);

			if (Helper.short2boolean(mDto.getBManuelleBedienung()) == false) {

				if (bdGesamtSoll.doubleValue() != 0) {

					for (int x = 0; x < alZeitverteilungDtos.size(); x++) {

						BigDecimal dStueckzeit = BigDecimal.ZERO;

						if (alZeitverteilungDtos.get(x).getLossollarbeitsplanIId() != null) {

							LossollarbeitsplanDto lossollarbeitsplanDto = getFertigungFac()
									.lossollarbeitsplanFindByPrimaryKey(
											alZeitverteilungDtos.get(x).getLossollarbeitsplanIId());
							dStueckzeit = new BigDecimal(lossollarbeitsplanDto.getLStueckzeit())
									.divide(new BigDecimal(3600000), 5, BigDecimal.ROUND_HALF_EVEN);

							BigDecimal dRuestzeit = new BigDecimal(lossollarbeitsplanDto.getLRuestzeit())
									.divide(new BigDecimal(3600000), 5, BigDecimal.ROUND_HALF_EVEN);

							if (dRuestzeit.doubleValue() > 0 && dStueckzeit.doubleValue() > 0) {
								try {
									LosDto losDto = getFertigungFac()
											.losFindByPrimaryKey(lossollarbeitsplanDto.getLosIId());

									myLogger.logKritisch("Zeitverteilung fuer Los " + losDto.getCNr() + ": Beim AG "
											+ lossollarbeitsplanDto.getIArbeitsgangnummer() + "UAG: "
											+ lossollarbeitsplanDto.getIUnterarbeitsgang()
											+ " sind sowohl Ruestzeit als auch Stueckzeit definiert. Es wird nur die Stueckzeit verwendet.");

								} catch (RemoteException e) {
									throwEJBExceptionLPRespectOld(e);
								}

							}

							if (dRuestzeit.doubleValue() > 0 && dStueckzeit.doubleValue() == 0) {
								dStueckzeit = dRuestzeit;
							}

						}

						if (dStueckzeit.doubleValue() == 0) {
							dStueckzeit = new BigDecimal(((double) iSollzeitWenn0) / 60);
						}

						BigDecimal bdFaktor = bdZuVerteilen.divide(bdGesamtSoll, 5, BigDecimal.ROUND_HALF_EVEN);

						BigDecimal bdIstZeit = dStueckzeit.multiply(bdFaktor);

						long lZeitProAG = (long) (bdIstZeit.doubleValue() * 60 * 60 * 1000);

						Timestamp tMaschineEndeAktuell = new java.sql.Timestamp(
								tMaschineBeginnAktuell.getTime() + lZeitProAG);

						MaschinenzeitdatenDto mzDto = new MaschinenzeitdatenDto();
						mzDto.setMaschineIId(alZeitverteilungDtos.get(x).getMaschineIId());
						mzDto.setLossollarbeitsplanIId(alZeitverteilungDtos.get(x).getLossollarbeitsplanIId());
						mzDto.setPersonalIIdGestartet(alZeitverteilungDtos.get(x).getPersonalIId());
						mzDto.setTVon(tMaschineBeginnAktuell);
						mzDto.setTBis(tMaschineEndeAktuell);

						// NUR Beim ersten die Zeit verschieben
						if (x == 0) {
							maschinenzeitenVorZeitverteilungVerschieben(zeitverteilungDtos[0].getTZeit(), tZeitBis,
									alZeitverteilungDtos.get(x).getMaschineIId(), theClientDto);
						}

						// Beim letzten auf tatsaechliche Bis-Zeit setzten
						if (x == zeitverteilungDtos.length - 1) {
							mzDto.setTBis(tZeitBis);
						}

						mzDto.setCBemerkung("Zeitverteilung");

						createMaschinenzeitdaten(mzDto, false, theClientDto);

						tMaschineBeginnAktuell = tMaschineEndeAktuell;

					}

				}
			}

		}

		return true;

	}

	private void maschinenzeitenVorZeitverteilungVerschieben(Timestamp tBeginn, Timestamp tEnde, Integer maschineIId,
			TheClientDto theClientDto) {
		String sQuery = "select zeitdaten FROM FLRMaschinenzeitdaten zeitdaten WHERE zeitdaten.t_von>='"
				+ Helper.formatTimestampWithSlashes(tBeginn) + "' AND (zeitdaten.t_bis<'"
				+ Helper.formatTimestampWithSlashes(tEnde)
				+ "' OR zeitdaten.t_bis IS NULL ) AND zeitdaten.maschine_i_id=" + maschineIId
				+ "  ORDER BY zeitdaten.t_von ASC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query nachHintenSchieben = session.createQuery(sQuery);

		List<?> resultList = nachHintenSchieben.list();

		Iterator<?> resultListIterator = resultList.iterator();

		while (resultListIterator.hasNext()) {

			// VON UND BIS nach hinten schieben

			FLRMaschinenzeitdaten m = (FLRMaschinenzeitdaten) resultListIterator.next();

			MaschinenzeitdatenDto mzDto = getZeiterfassungFac().maschinenzeitdatenFindByPrimaryKey(m.getI_id());
			mzDto.setTVon(tEnde);
			if (mzDto.getTBis() == null || mzDto.getTBis().before(tEnde)) {
				mzDto.setTBis(tEnde);
			}
			getZeiterfassungFac().updateMaschinenzeitdaten(mzDto, theClientDto);

		}
		session.close();
		session = FLRSessionFactory.getFactory().openSession();

		sQuery = "select zeitdaten FROM FLRMaschinenzeitdaten zeitdaten WHERE zeitdaten.t_von<'"
				+ Helper.formatTimestampWithSlashes(tBeginn) + "' AND (zeitdaten.t_bis>'"
				+ Helper.formatTimestampWithSlashes(tBeginn)
				+ "' OR zeitdaten.t_bis IS NULL ) AND zeitdaten.maschine_i_id=" + maschineIId
				+ "  ORDER BY zeitdaten.t_von ASC";

		org.hibernate.Query nachVorneSchieben = session.createQuery(sQuery);

		resultList = nachVorneSchieben.list();

		resultListIterator = resultList.iterator();

		while (resultListIterator.hasNext()) {
			FLRMaschinenzeitdaten m = (FLRMaschinenzeitdaten) resultListIterator.next();
			// VON UND BIS nach vorher schieben
			MaschinenzeitdatenDto mzDto = getZeiterfassungFac().maschinenzeitdatenFindByPrimaryKey(m.getI_id());
			mzDto.setTBis(tBeginn);
			getZeiterfassungFac().updateMaschinenzeitdaten(mzDto, theClientDto);

		}

	}

	public ZeitdatenDto pruefeObMaschineBelegt(Integer personalIId, Integer maschineIId, java.sql.Timestamp tZeitpunkt,
			TheClientDto theClientDto) {

		String sQuery = "select zeitdaten FROM FLRZeitdaten zeitdaten WHERE zeitdaten.t_zeit<'"
				+ Helper.formatTimestampWithSlashes(tZeitpunkt) + "' AND zeitdaten.personal_i_id<>" + personalIId
				+ " AND zeitdaten.flrmaschine.i_id=" + maschineIId + " ORDER BY zeitdaten.t_zeit DESC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query letzteKommtGeht = session.createQuery(sQuery);
		letzteKommtGeht.setMaxResults(1);

		List<?> resultList = letzteKommtGeht.list();

		Iterator<?> resultListIterator = resultList.iterator();

		if (resultListIterator.hasNext()) {
			FLRZeitdaten l = (FLRZeitdaten) resultListIterator.next();

			/// Nun sehen, ob diese beendet worden ist
			Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();
			Integer taetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();

			String sQuery2 = "select zeitdaten FROM FLRZeitdaten zeitdaten WHERE zeitdaten.t_zeit>'"
					+ Helper.formatTimestampWithSlashes(new Timestamp(l.getT_zeit().getTime()))
					+ "' AND zeitdaten.personal_i_id=" + l.getPersonal_i_id() + " AND (zeitdaten.taetigkeit_i_id="
					+ taetigkeitIId_Geht + " OR zeitdaten.taetigkeit_i_id=" + taetigkeitIId_Ende
					+ "  OR zeitdaten.i_belegartid IS NOT NULL ) ORDER BY zeitdaten.t_zeit ASC";

			Session session2 = FLRSessionFactory.getFactory().openSession();

			org.hibernate.Query beendet = session.createQuery(sQuery2);
			beendet.setMaxResults(1);

			List<?> resultList2 = beendet.list();

			Iterator<?> resultListIterator2 = resultList2.iterator();
			if (resultListIterator2.hasNext()) {
				FLRZeitdaten lEnde = (FLRZeitdaten) resultListIterator2.next();
				if (lEnde.getT_zeit().after(tZeitpunkt)) {
					return zeitdatenFindByPrimaryKey(l.getI_id(), theClientDto);
				}
			} else {
				return zeitdatenFindByPrimaryKey(l.getI_id(), theClientDto);
			}

		}

		return null;
	}

	public String pruefeObWiederholendePauseVorhanden(java.sql.Timestamp tDatum, Integer personalIId,
			TheClientDto theClientDto) {

		String sWarnung = null;

		Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
		Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();
		// Berechnungsdatum abschneiden, damit nur mehr JJJJ.MM.TT ueberbleibt

		// Heutiges Datum herausfinden und abschneiden, damit nur mehr
		// JJJJ.MM.TT ueberbleibt
		ZeitmodelltagDto zeitmodelltagDto = getZeitmodelltagZuDatum(personalIId, Helper.cutTimestamp(tDatum),
				tagesartIId_Feiertag, tagesartIId_Halbtag, false, theClientDto);

		if (zeitmodelltagDto != null && zeitmodelltagDto.getZeitmodellIId() != null) {

			ZeitmodellDto zmDto = zeitmodellFindByPrimaryKey(zeitmodelltagDto.getZeitmodellIId(), theClientDto);

			// PAUSE1

			java.sql.Time pausenZeit = zeitmodelltagDto.getUMindestpause();

			Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();
			// Hole id der Taetigkeit GEHT
			Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();
			// Hole id der Taetigkeit UNTER
			Integer taetigkeitIId_Unter = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER, theClientDto).getIId();

			if (zeitmodelltagDto.getUAutopauseab() != null && pausenZeit != null) {
				if ((zeitmodelltagDto.getUAutopauseab().getTime() != -3600000 && pausenZeit.getTime() != -3600000)) {
					try {

						Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
						query.setParameter(1, personalIId);
						query.setParameter(2, Helper.cutTimestamp(tDatum));
						query.setParameter(3, Helper.cutTimestamp(Helper.addiereTageZuTimestamp(tDatum, 1)));
						Collection<?> cl = query.getResultList();
						// if (! cl.isEmpty()) {
						ZeitdatenDto[] zeitdatenDtos = assembleZeitdatenDtosOhneBelegzeiten(cl);

						ArrayList<ZeitdatenDto> alZeitdaten = new ArrayList<ZeitdatenDto>();
						for (int i = 0; i < zeitdatenDtos.length; i++) {
							alZeitdaten.add(zeitdatenDtos[i]);
						}

						if (alZeitdaten.size() > 0) {

							ArrayList<ZeitdatenDto> alUnter = new ArrayList<ZeitdatenDto>();
							for (int i = 0; i < alZeitdaten.size(); i++) {
								ZeitdatenDto zeitdatenDto = alZeitdaten.get(i);
								if (zeitdatenDto.getTaetigkeitIId() != null
										&& zeitdatenDto.getTaetigkeitIId().equals(taetigkeitIId_Unter)) {
									alUnter.add(zeitdatenDto);
								}
							}

							// Wenn Pausenanzahl gerade

							// SP3037 Wenn am heutigen Tag ungerade Pausen, dann
							// wird noch nicht fertig gebucht sein
							if (alUnter.size() % 2 != 0 && alUnter.size() > 0) {

								if (Helper.cutTimestamp(tDatum).getTime() == Helper
										.cutTimestamp(new Timestamp(System.currentTimeMillis())).getTime()) {
									alUnter.remove(alUnter.size() - 1);
								}

							}

							if (zeitdatenDtos[zeitdatenDtos.length - 1].getTaetigkeitIId() != null
									&& !zeitdatenDtos[zeitdatenDtos.length - 1].getTaetigkeitIId()
											.equals(taetigkeitIId_Geht)) {
								// Wenn Heute und der letzte eintrag ist kein
								// Geht,
								// dann GEHT=JETZT simulieren
								if (Helper.cutTimestamp(tDatum).getTime() == Helper
										.cutTimestamp(new Timestamp(System.currentTimeMillis())).getTime()) {
									ZeitdatenDto zDto_geht = ZeitdatenDto.clone(zeitdatenDtos[0]);
									zDto_geht.setTaetigkeitIId(taetigkeitIId_Geht);
									zDto_geht.setTZeit(new Timestamp(System.currentTimeMillis()));
									alZeitdaten.add(zDto_geht);

								}

							}

							Timestamp tLetztePauseVollstaendig = alZeitdaten.get(0).getTZeit();

							if (alUnter.size() % 2 == 0) {
								for (int i = 0; i < alUnter.size(); i++) {
									if (i % 2 == 0) {
										ZeitdatenDto dto1 = (ZeitdatenDto) alUnter.get(i);
										ZeitdatenDto dto2 = (ZeitdatenDto) alUnter.get(i + 1);
										long lDauerPause = dto2.getTZeit().getTime() - dto1.getTZeit().getTime();
										// Nur Pausen beruecksichtigen, die
										// groesser als die Mindestzeit sind

										if (lDauerPause >= (pausenZeit.getTime() + 3600000)) {

											// Ist die Differenz zwischend er
											// letzten Vollstaendigen Pause und
											// dem Pausenbginn klsiner als
											// vorgegeben, dann Fehler

											long ldiff = dto1.getTZeit().getTime() - tLetztePauseVollstaendig.getTime();

											if (ldiff > zeitmodelltagDto.getUAutopauseab().getTime() + 3600000) {
												// FEHLER zuwenig pause

												return meldungFuerFehlendeMindespauseErzeugen(
														pausenZeit.getTime() + 3600000,
														new Timestamp(tLetztePauseVollstaendig.getTime()
																+ (zeitmodelltagDto.getUAutopauseab().getTime()
																		+ 3600000)),
														theClientDto);

											} else {
												tLetztePauseVollstaendig = dto2.getTZeit();
											}

										}

									}
								}
							}

							// Nun noch Zeit wzischen der letzen Pause und Geht
							// pruefen

							long diffDerLetztenPauseUndeGeht = alZeitdaten.get(alZeitdaten.size() - 1).getTZeit()
									.getTime() - tLetztePauseVollstaendig.getTime();

							if (diffDerLetztenPauseUndeGeht > (zeitmodelltagDto.getUAutopauseab().getTime()
									+ 3600000)) {
								return meldungFuerFehlendeMindespauseErzeugen(pausenZeit.getTime() + 3600000,
										new Timestamp(tLetztePauseVollstaendig.getTime()
												+ (zeitmodelltagDto.getUAutopauseab().getTime() + 3600000)),
										theClientDto);
							}

						}

					} catch (EJBExceptionLP ex1) {
						// Mindestpause eintragen nicht moeglich

					}

				}
			}

			if (sWarnung != null) {
				return sWarnung;
			}

		}
		return sWarnung;
	}

	public String erstelleAutomatischeMindestpause(java.sql.Timestamp tGeht, Integer personalIId,
			TheClientDto theClientDto) {

		ParametermandantDto parameter = null;
		try {
			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_AUTOMATISCHE_PAUSEN_NUR_WARNUNG);

			boolean bNurWarnung = (Boolean) parameter.getCWertAsObject();

			// PJ18774
			if (bNurWarnung == true) {
				return pruefeObWiederholendePauseVorhanden(tGeht, personalIId, theClientDto);
			}

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
		Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();
		// Berechnungsdatum abschneiden, damit nur mehr JJJJ.MM.TT ueberbleibt

		// Heutiges Datum herausfinden und abschneiden, damit nur mehr
		// JJJJ.MM.TT ueberbleibt
		ZeitmodelltagDto zeitmodelltagDto = getZeitmodelltagZuDatum(personalIId, Helper.cutTimestamp(tGeht),
				tagesartIId_Feiertag, tagesartIId_Halbtag, false, theClientDto);

		if (zeitmodelltagDto != null && zeitmodelltagDto.getZeitmodellIId() != null) {

			ZeitmodellDto zmDto = zeitmodellFindByPrimaryKey(zeitmodelltagDto.getZeitmodellIId(), theClientDto);

			// PAUSE1

			java.sql.Time pausenZeit = zeitmodelltagDto.getUMindestpause();
			mindestpauseBuchen(tGeht, personalIId, zeitmodelltagDto.getUAutopauseab(), pausenZeit,
					zeitmodelltagDto.getUBeginn(), Helper.short2boolean(zmDto.getBDynamisch()), theClientDto);

			// PAUSE2
			if (pausenZeit != null && zeitmodelltagDto.getUMindestpause2() != null
					&& zeitmodelltagDto.getUAutopauseab2().getTime() != -3600000) {
				pausenZeit = new Time(zeitmodelltagDto.getUMindestpause2().getTime());

				mindestpauseBuchen(tGeht, personalIId, zeitmodelltagDto.getUAutopauseab2(), pausenZeit,
						zeitmodelltagDto.getUBeginn(), Helper.short2boolean(zmDto.getBDynamisch()), theClientDto);

				// PAUSE3
				if (zeitmodelltagDto.getUMindestpause3() != null
						&& zeitmodelltagDto.getUAutopauseab3().getTime() != -3600000) {
					pausenZeit = new Time(zeitmodelltagDto.getUMindestpause3().getTime());
					mindestpauseBuchen(tGeht, personalIId, zeitmodelltagDto.getUAutopauseab3(), pausenZeit,
							zeitmodelltagDto.getUBeginn(), Helper.short2boolean(zmDto.getBDynamisch()), theClientDto);

				}

			}
		}
		return null;
	}

	public void erstelleAutomatischePauseBeiUnproduktiverZeit(java.sql.Timestamp tGeht, Integer personalIId,
			TheClientDto theClientDto) {

		Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
		Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();
		// Berechnungsdatum abschneiden, damit nur mehr JJJJ.MM.TT ueberbleibt

		// Heutiges Datum herausfinden und abschneiden, damit nur mehr
		// JJJJ.MM.TT ueberbleibt
		ZeitmodelltagDto zeitmodelltagDto = getZeitmodelltagZuDatum(personalIId, Helper.cutTimestamp(tGeht),
				tagesartIId_Feiertag, tagesartIId_Halbtag, false, theClientDto);

		if (zeitmodelltagDto != null && zeitmodelltagDto.getZeitmodellIId() != null) {

			ZeitmodellDto zmDto = zeitmodellFindByPrimaryKey(zeitmodelltagDto.getZeitmodellIId(), theClientDto);

			if (Helper.short2boolean(zmDto.getBUnproduktivAlsPause())) {

				Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto)
						.getIId();
				// Hole id der Taetigkeit GEHT
				Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto)
						.getIId();
				// Hole id der Taetigkeit UNTER
				Integer taetigkeitIId_Unter = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER, theClientDto)
						.getIId();

				// Hole id der Taetigkeit ENDE
				Integer taetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto)
						.getIId();

				String sQuery = "select zeitdaten FROM FLRZeitdaten zeitdaten WHERE zeitdaten.t_zeit<'"
						+ Helper.formatTimestampWithSlashes(tGeht) + "' AND zeitdaten.personal_i_id=" + personalIId
						+ " AND zeitdaten.taetigkeit_i_id=" + taetigkeitIId_Kommt + " ORDER BY zeitdaten.t_zeit DESC";

				Session session = FLRSessionFactory.getFactory().openSession();

				org.hibernate.Query letzteKommtGeht = session.createQuery(sQuery);
				letzteKommtGeht.setMaxResults(1);

				List<?> resultList = letzteKommtGeht.list();

				Iterator<?> resultListIterator = resultList.iterator();

				if (resultListIterator.hasNext()) {
					FLRZeitdaten l = (FLRZeitdaten) resultListIterator.next();
					java.sql.Timestamp letztesKommt = new Timestamp(l.getT_zeit().getTime());

					ZeitdatenDto zeitdatenDtoPause = new ZeitdatenDto();
					zeitdatenDtoPause.setPersonalIId(personalIId);
					zeitdatenDtoPause.setTaetigkeitIId(taetigkeitIId_Unter);
					zeitdatenDtoPause.setBAutomatikbuchung(Helper.boolean2Short(true));

					// Hole Zeitdaten eines Tages
					ZeitdatenDto[] zeitdatenDtos = null;
					// try {
					Query query3 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
					query3.setParameter(1, personalIId);
					query3.setParameter(2, letztesKommt);
					query3.setParameter(3, tGeht);
					Collection<?> cl1 = query3.getResultList();
					// if (! cl1.isEmpty()) {
					zeitdatenDtos = assembleZeitdatenDtos(cl1);

					for (int i = 0; i < zeitdatenDtos.length; i++) {
						if (zeitdatenDtos[i].getTaetigkeitIId() != null
								&& zeitdatenDtos[i].getTaetigkeitIId().equals(taetigkeitIId_Ende)) {

							if (i < zeitdatenDtos.length - 1) {

								ZeitdatenDto zeitdatenDtosNaechste = zeitdatenDtos[i + 1];

								long diff = zeitdatenDtosNaechste.getTZeit().getTime()
										- zeitdatenDtos[i].getTZeit().getTime();

								boolean dDiffGroesserEineMinute = false;
								if (diff > 60000) {
									dDiffGroesserEineMinute = true;
								}

								// Wenn die naechste Buchung ein BELEG oder GEHT oder UNTER ist
								if (diff > 60000 && (zeitdatenDtosNaechste.getCBelegartnr() != null
										|| zeitdatenDtosNaechste.getTaetigkeitIId() == taetigkeitIId_Geht
										|| zeitdatenDtosNaechste.getTaetigkeitIId() == taetigkeitIId_Unter)) {
									try {
										zeitdatenDtoPause
												.setTZeit(new Timestamp(zeitdatenDtos[i].getTZeit().getTime() + 100));
										createZeitdaten(zeitdatenDtoPause, false, false, false, false, theClientDto);

										zeitdatenDtoPause.setTZeit(
												new Timestamp(zeitdatenDtosNaechste.getTZeit().getTime() - 100));
										createZeitdaten(zeitdatenDtoPause, false, false, false, false, theClientDto);
									} catch (EJBExceptionLP e) {
										// Pasiert, wenn 2x Geht gebucht
									}
								}

								if (zeitdatenDtosNaechste.getTaetigkeitIId() != null
										&& zeitdatenDtosNaechste.getTaetigkeitIId() == taetigkeitIId_Unter) {
									// Solange bis Geht /Ende oder Beleg-Beginn

									for (int j = i + 2; j < zeitdatenDtos.length; j++) {
										ZeitdatenDto naechsteUnterEnde = zeitdatenDtos[j];

										if (naechsteUnterEnde.getTaetigkeitIId() != null
												&& naechsteUnterEnde.getTaetigkeitIId() == taetigkeitIId_Ende) {
											break;
										}

										if (naechsteUnterEnde.getTaetigkeitIId() != null
												&& naechsteUnterEnde.getTaetigkeitIId() == taetigkeitIId_Unter) {

											try {
												if (j < zeitdatenDtos.length - 1) {

													ZeitdatenDto nachNaechsteUnterEnde = zeitdatenDtos[j + 1];

													diff = nachNaechsteUnterEnde.getTZeit().getTime()
															- naechsteUnterEnde.getTZeit().getTime();

													if (diff > 60000) {
														zeitdatenDtoPause.setTZeit(new Timestamp(
																naechsteUnterEnde.getTZeit().getTime() + 100));
														createZeitdaten(zeitdatenDtoPause, false, false, false, false,
																theClientDto);

														zeitdatenDtoPause.setTZeit(new Timestamp(
																nachNaechsteUnterEnde.getTZeit().getTime() - 100));
														createZeitdaten(zeitdatenDtoPause, false, false, false, false,
																theClientDto);
													}

												} else {

													diff = tGeht.getTime() - naechsteUnterEnde.getTZeit().getTime();

													if (diff > 60000) {

														zeitdatenDtoPause.setTZeit(new Timestamp(
																naechsteUnterEnde.getTZeit().getTime() + 100));
														createZeitdaten(zeitdatenDtoPause, false, false, false, false,
																theClientDto);

														zeitdatenDtoPause
																.setTZeit(new Timestamp(tGeht.getTime() - 100));
														createZeitdaten(zeitdatenDtoPause, false, false, false, false,
																theClientDto);
													}
												}
											} catch (EJBExceptionLP e) {
												// Pasiert, wenn 2x Geht gebucht
											}
										}

										j++;
									}

								}

							} else {
								try {
									long diff = tGeht.getTime() - zeitdatenDtos[i].getTZeit().getTime();

									if (diff > 60000) {

										zeitdatenDtoPause
												.setTZeit(new Timestamp(zeitdatenDtos[i].getTZeit().getTime() + 100));
										createZeitdaten(zeitdatenDtoPause, false, false, false, false, theClientDto);

										zeitdatenDtoPause.setTZeit(new Timestamp(tGeht.getTime() - 100));
										createZeitdaten(zeitdatenDtoPause, false, false, false, false, theClientDto);
									}
								} catch (EJBExceptionLP e) {
									// Pasiert, wenn 2x Geht gebucht
								}

							}

						}
					}

				}

			}
		}

	}

	private String meldungFuerFehlendeMindespauseErzeugen(long lPausenzeit, Timestamp tBis, TheClientDto theClientDto) {

		MessageFormat mf = new MessageFormat(getTextRespectUISpr("pers.warning.fehlende.mindestpause",
				theClientDto.getMandant(), theClientDto.getLocUi()));
		mf.setLocale(theClientDto.getLocUi());
		Object pattern[] = {

				Helper.formatZahl(lPausenzeit / (1000 * 60), 0, theClientDto.getLocUi()),

				Helper.formatTime(tBis, theClientDto.getLocUi()) };
		return mf.format(pattern);

	}

	private void mindestpauseBuchen(java.sql.Timestamp tGeht, Integer personalIId, java.sql.Time uAutopauseAb,
			java.sql.Time uMindestpause, java.sql.Time uBeginn, boolean bDynamisch, TheClientDto theClientDto) {
		// Hole id der Taetigkeit KOMMT
		Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();
		// Hole id der Taetigkeit GEHT
		Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();
		// Hole id der Taetigkeit UNTER
		Integer taetigkeitIId_Unter = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER, theClientDto).getIId();

		if (uAutopauseAb != null && uMindestpause != null) {
			if ((uAutopauseAb.getTime() != -3600000 && uMindestpause.getTime() != -3600000)) {
				try {

					java.sql.Timestamp letztesKommt = null;

					String sQuery = "select zeitdaten FROM FLRZeitdaten zeitdaten WHERE zeitdaten.t_zeit<'"
							+ Helper.formatTimestampWithSlashes(tGeht) + "' AND zeitdaten.personal_i_id=" + personalIId
							+ " AND (zeitdaten.taetigkeit_i_id=" + taetigkeitIId_Kommt
							+ " OR zeitdaten.taetigkeit_i_id=" + taetigkeitIId_Geht
							+ ") ORDER BY zeitdaten.t_zeit DESC";

					Session session = FLRSessionFactory.getFactory().openSession();

					org.hibernate.Query letzteKommtGeht = session.createQuery(sQuery);
					letzteKommtGeht.setMaxResults(1);

					List<?> resultList = letzteKommtGeht.list();

					Iterator<?> resultListIterator = resultList.iterator();

					if (resultListIterator.hasNext()) {
						FLRZeitdaten l = (FLRZeitdaten) resultListIterator.next();
						// Wenn zuletzt ein Kommt gebucht wurde, dann OK

						if (l.getTaetigkeit_i_id().equals(taetigkeitIId_Kommt)) {
							letztesKommt = new Timestamp(l.getT_zeit().getTime());
						}
					}

					// PJ 17467
					ParametermandantDto parameter = null;
					try {
						parameter = (ParametermandantDto) getParameterFac().getMandantparameter(
								theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
								ParameterFac.PARAMETER_AUTOMATISCHE_PAUSEN_AB_ERLAUBTEM_KOMMT);
					} catch (RemoteException ex5) {
						throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
					}

					if (letztesKommt == null) {
						return;
					}

					boolean bAutopausenAbErlaubtemKommt = ((Boolean) parameter.getCWertAsObject());

					if (bAutopausenAbErlaubtemKommt) {
						if (uBeginn != null && uBeginn.getTime() != -3600000) {

							// Das ist so eigentlich falsch. Die Zeitzone
							// (TimeZone) muss zum
							// Client passen der die Zeiten erfasst hat.
							Calendar c = GregorianCalendar.getInstance();
							c.setTimeInMillis(letztesKommt.getTime());

							long l = letztesKommt.getTime() % (24 * 3600000);

							// if (l < (zeitmodelltagDto.getUBeginn().getTime()
							// - 3600000)) {

							// TODO: Quickhack, damit Fr. Krautenbacher ihre
							// Abrechnungen machen kann.
							// Die Normalisierung des Kommt muss abhaengig
							// von der aktuellen
							// Sommerzeit/Normalzeitverschiebung erfolgen
							// Ich verstehe nicht, was die ganzen +/-
							// 3.600.000ms zu sagen haben?
							if (l < (uBeginn.getTime() - c.get(Calendar.DST_OFFSET))) {
								letztesKommt = new Timestamp(
										Helper.cutTimestamp(letztesKommt).getTime() + (uBeginn.getTime() + 3600000));
							}

						}
					}

					// try {
					// Hole Zeitdaten eines Tages
					Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
					query.setParameter(1, personalIId);
					query.setParameter(2, letztesKommt);
					query.setParameter(3, tGeht);
					Collection<?> cl = query.getResultList();
					// if (! cl.isEmpty()) {
					ZeitdatenDto[] zeitdatenDtos = assembleZeitdatenDtosOhneBelegzeiten(cl);

					if (bDynamisch == true) {
						// ////////////

						// PJ 16676
						java.sql.Timestamp tAb = null;
						long lPausenzeit = 0;

						if (uAutopauseAb != null && uMindestpause != null && uAutopauseAb.getTime() != -3600000
								&& uMindestpause.getTime() != -3600000) {
							long zeit = letztesKommt.getTime() + uAutopauseAb.getTime() + 3600000;
							if (zeit >= tGeht.getTime()) {
								return;
							} else {
								tAb = new java.sql.Timestamp(zeit);
								lPausenzeit = uMindestpause.getTime() + 3600000;
							}
						} else {
							return;
						}

						// Hole Zeitdaten von Kommt bis Kommt + autopauseab
						Query query2 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
						query2.setParameter(1, personalIId);
						query2.setParameter(2, letztesKommt);
						query2.setParameter(3, tGeht);

						zeitdatenDtos = assembleZeitdatenDtosOhneBelegzeiten(query2.getResultList());

						ZeitdatenDto[] zeitdatenDtosMitBelegzeiten = assembleZeitdatenDtos(query2.getResultList());

						// Zeitdatenbuchung vorbereiten
						ZeitdatenDto zeitdatenDtoPause = new ZeitdatenDto();
						zeitdatenDtoPause.setPersonalIId(personalIId);
						zeitdatenDtoPause.setTaetigkeitIId(taetigkeitIId_Unter);
						zeitdatenDtoPause.setBAutomatikbuchung(Helper.boolean2Short(true));

						// UNTER MIT Autopausenzeit + GEHT oder Autopausenzeit +
						// Dauer einbuchen

						ArrayList<ZeitdatenDto> alUnter = new ArrayList<ZeitdatenDto>();
						for (int i = 0; i < zeitdatenDtos.length; i++) {
							ZeitdatenDto zeitdatenDto = zeitdatenDtos[i];
							if (zeitdatenDto.getTaetigkeitIId() != null
									&& zeitdatenDto.getTaetigkeitIId().equals(taetigkeitIId_Unter)) {
								alUnter.add(zeitdatenDto);
							}
						}

						long lRestPause = 0;
						// Wenn Pausenanzahl gerade

						// SP3037 Wenn am heutigen Tag ungerade Pausen, dann
						// wird noch nicht fertig gebucht sein
						if (alUnter.size() % 2 != 0 && alUnter.size() > 0) {

							if (Helper.cutTimestamp(tGeht).getTime() == Helper
									.cutTimestamp(new Timestamp(System.currentTimeMillis())).getTime()) {
								alUnter.remove(alUnter.size() - 1);
							}

						}

						if (alUnter.size() % 2 == 0) {
							for (int i = 0; i < alUnter.size(); i++) {
								if (i % 2 == 0) {
									ZeitdatenDto dto1 = (ZeitdatenDto) alUnter.get(i);
									ZeitdatenDto dto2 = (ZeitdatenDto) alUnter.get(i + 1);
									lRestPause += dto2.getTZeit().getTime() - dto1.getTZeit().getTime();
								}
							}
						}

						long lNochZuVerbuchen = lPausenzeit - lRestPause;

						if (lNochZuVerbuchen < 1) {
							return;
						}

						belegezeitenvorAutomatischeMindestpauseVerschieben(tAb,
								new java.sql.Timestamp(tAb.getTime() + lNochZuVerbuchen), zeitdatenDtosMitBelegzeiten,
								theClientDto);

						zeitdatenDtoPause.setTZeit(new java.sql.Timestamp(tAb.getTime()));
						createZeitdaten(zeitdatenDtoPause, false, false, false, false, theClientDto);

						java.sql.Timestamp tBis = new java.sql.Timestamp(tAb.getTime() + lNochZuVerbuchen);

						if (tBis.after(tGeht)) {
							zeitdatenDtoPause.setTZeit(new java.sql.Timestamp(tGeht.getTime() - 5));
						} else {
							zeitdatenDtoPause.setTZeit(new java.sql.Timestamp(tAb.getTime() + lNochZuVerbuchen));
						}

						createZeitdaten(zeitdatenDtoPause, false, false, false, false, theClientDto);
						// erledigt
						return;

						// /////////
					} else {
						// PJ 16676
						java.sql.Timestamp tBis = null;
						long lPausenzeit = 0;

						if (uAutopauseAb != null && uMindestpause != null && uAutopauseAb.getTime() != -3600000
								&& uMindestpause.getTime() != -3600000) {

							long zeit = letztesKommt.getTime() + uAutopauseAb.getTime() + 3600000;

							if (zeit >= tGeht.getTime()) {
								// Wenn die Zeit zwischen Kommt und Geht
								// kleiner
								// als die Zeit der automatischen
								// Mindestpause
								// ist,
								// dann
								// ist nichts zu tun
								return;
							} else {
								tBis = new java.sql.Timestamp(zeit);
								lPausenzeit = uMindestpause.getTime() + 3600000;

							}

						}

						// Hole Zeitdaten von Kommt bis Kommt + autopauseab
						Query query2 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
						query2.setParameter(1, personalIId);
						query2.setParameter(2, letztesKommt);
						query2.setParameter(3, new Timestamp(tBis.getTime() + lPausenzeit));

						zeitdatenDtos = assembleZeitdatenDtosOhneBelegzeiten(query2.getResultList());

						ZeitdatenDto[] zeitdatenDtosMitBelegzeiten = assembleZeitdatenDtos(query2.getResultList());

						// Zeitdatenbuchung vorbereiten
						ZeitdatenDto zeitdatenDtoPause = new ZeitdatenDto();
						zeitdatenDtoPause.setPersonalIId(personalIId);
						zeitdatenDtoPause.setTaetigkeitIId(taetigkeitIId_Unter);
						zeitdatenDtoPause.setBAutomatikbuchung(Helper.boolean2Short(true));

						// Keine Buchung dazwischen, dann xx-minuten pause
						// buchen
						if (zeitdatenDtos.length == 1) {

							belegezeitenvorAutomatischeMindestpauseVerschieben(
									new java.sql.Timestamp(tBis.getTime() - lPausenzeit), tBis,
									zeitdatenDtosMitBelegzeiten, theClientDto);

							zeitdatenDtoPause.setTZeit(new java.sql.Timestamp(tBis.getTime() - lPausenzeit));
							createZeitdaten(zeitdatenDtoPause, false, false, false, false, theClientDto);
							zeitdatenDtoPause.setTZeit(tBis);
							createZeitdaten(zeitdatenDtoPause, false, false, false, false, theClientDto);
							// erledigt
							return;

						}

						// Wenn 2 Buchungen und nur KOMMT + GEHT, dann nichts
						if (zeitdatenDtos.length == 2) {
							ZeitdatenDto dto1 = zeitdatenDtos[0];
							ZeitdatenDto dto2 = zeitdatenDtos[1];
							if (dto1.getTaetigkeitIId() != null
									&& dto1.getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {
								if (dto2.getTaetigkeitIId() != null
										&& dto2.getTaetigkeitIId().equals(taetigkeitIId_Geht)
										&& dto2.getTZeit().before(tBis)) {
									return;
								}
							}
						}

						ArrayList<ZeitdatenDto> alUnter = new ArrayList<ZeitdatenDto>();
						for (int i = 0; i < zeitdatenDtos.length; i++) {
							ZeitdatenDto zeitdatenDto = zeitdatenDtos[i];
							if (zeitdatenDto.getTaetigkeitIId() != null
									&& zeitdatenDto.getTaetigkeitIId().equals(taetigkeitIId_Unter)) {
								alUnter.add(zeitdatenDto);
							}
						}
						// Wenn mehr als eine Buchung, jedoch keine UNTER
						// Buchung, dann Pause Buchen
						if (alUnter.size() == 0) {

							zeitdatenDtoPause.setTZeit(new java.sql.Timestamp(tBis.getTime() - lPausenzeit));
							bucheAutomatischeMindestpause(personalIId, letztesKommt,
									new java.sql.Timestamp(tBis.getTime() - lPausenzeit), tBis, theClientDto);
							// erledigt
							return;

						}

						long lRestPause = 0;

						// Wenn Pausenazahl ungerade
						if (alUnter.size() % 2 == 1) {

							ZeitdatenDto dtoTemp = (ZeitdatenDto) alUnter.get(alUnter.size() - 1);

							// SP8804
							if (tBis.after(dtoTemp.getTZeit())) {
								lRestPause = tBis.getTime() - dtoTemp.getTZeit().getTime();
								tBis = new Timestamp(dtoTemp.getTZeit().getTime() - 10);
							}
							alUnter.remove(alUnter.size() - 1);

						}

						if (lRestPause > lPausenzeit) {
							return;
						}

						// Nur eine Pausenbeginn vor Ablauf der Autopausenzeit
						if (alUnter.size() == 0) {

							belegezeitenvorAutomatischeMindestpauseVerschieben(
									new java.sql.Timestamp(tBis.getTime() - (lPausenzeit - lRestPause)), tBis,
									zeitdatenDtosMitBelegzeiten, theClientDto);

							zeitdatenDtoPause
									.setTZeit(new java.sql.Timestamp(tBis.getTime() - (lPausenzeit - lRestPause)));
							createZeitdaten(zeitdatenDtoPause, false, false, false, false, theClientDto);
							zeitdatenDtoPause.setTZeit(tBis);
							createZeitdaten(zeitdatenDtoPause, false, false, false, false, theClientDto);
							// erledigt
							return;

						}

						// Wenn Pausenanzahl gerade
						if (alUnter.size() % 2 == 0) {
							for (int i = 0; i < alUnter.size(); i++) {
								if (i % 2 == 0) {
									ZeitdatenDto dto1 = (ZeitdatenDto) alUnter.get(i);
									ZeitdatenDto dto2 = (ZeitdatenDto) alUnter.get(i + 1);
									lRestPause += dto2.getTZeit().getTime() - dto1.getTZeit().getTime();
								}
							}

							ZeitdatenDto dtoErstePauseEnde = (ZeitdatenDto) alUnter.get(alUnter.size() - 1);
							ZeitdatenDto dtoErstePauseBeginn = (ZeitdatenDto) alUnter.get(alUnter.size() - 2);

							long lNochZuVerbuchen = lPausenzeit - lRestPause;

							if (lNochZuVerbuchen < 1) {
								return;
							}
							// SP3470 Es muessen alle vorherigen Pausen
							// beruecksichtigt werden, aber nur wenn nicht
							// dynamisch

							tBis = new Timestamp(tBis.getTime() + lRestPause);
							if (tBis.after(tGeht)) {
								return;
							}

							if (tBis.getTime() - dtoErstePauseEnde.getTZeit().getTime() > lNochZuVerbuchen) {

								belegezeitenvorAutomatischeMindestpauseVerschieben(
										new java.sql.Timestamp(tBis.getTime() - lNochZuVerbuchen), tBis,
										zeitdatenDtosMitBelegzeiten, theClientDto);

								bucheAutomatischeMindestpause(personalIId, letztesKommt,
										new java.sql.Timestamp(tBis.getTime() - lNochZuVerbuchen), tBis, theClientDto);

								// Komplette Pause verbucht ->Passt
								return;

							} else {
								// SP9727
								// Wenns nachher nicht moeglich ist, dann vorher buchen

								Timestamp tBeginn = new Timestamp(
										(dtoErstePauseBeginn.getTZeit().getTime() - 10) - lNochZuVerbuchen);

								Timestamp tEnde = new Timestamp(dtoErstePauseBeginn.getTZeit().getTime() - 10);

								belegezeitenvorAutomatischeMindestpauseVerschieben(tBeginn, tEnde,
										zeitdatenDtosMitBelegzeiten, theClientDto);

								bucheAutomatischeMindestpause(personalIId, letztesKommt, tBeginn, tEnde, theClientDto);

							}

						}

						// }
						// catch (NoResultException ex) {
						// zeitdatenDtos = null;
						// }
					}

				} catch (EJBExceptionLP ex1) {
					// Mindestpause eintragen nicht moeglich

				}

			}
		}

	}

	private void belegezeitenvorAutomatischeMindestpauseVerschieben(java.sql.Timestamp tPauseVon,
			java.sql.Timestamp tPauseBis, ZeitdatenDto[] zeitdatenDtosMitBelegzeiten, TheClientDto theClientDto) {
		// Wenn Belegzeiten dazwischen sind, diese auf
		// "vor den Pausen-Beginn" verschieben

		// SP1792 + ENDE Buchungen auch verschieben
		Integer taetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();

		for (int i = 0; i < zeitdatenDtosMitBelegzeiten.length; i++) {
			ZeitdatenDto dtoTemp = zeitdatenDtosMitBelegzeiten[i];
			if ((dtoTemp.getArtikelIId() != null && dtoTemp.getCBelegartnr() != null)
					|| (dtoTemp.getTaetigkeitIId() != null && dtoTemp.getTaetigkeitIId().equals(taetigkeitIId_Ende))) {
				if (dtoTemp.getTZeit().getTime() >= tPauseVon.getTime()
						&& dtoTemp.getTZeit().getTime() <= tPauseBis.getTime()) {
					Zeitdaten z = em.find(Zeitdaten.class, dtoTemp.getIId());

					int iZusaetzlicheroffset = 0;
					boolean bHatPlatz = false;

					while (bHatPlatz == false) {
						try {
							Query query = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
							query.setParameter(1, dtoTemp.getPersonalIId());
							query.setParameter(2, new Timestamp((tPauseVon.getTime() - 10 * i) + iZusaetzlicheroffset));
							Zeitdaten doppelt = (Zeitdaten) query.getSingleResult();
							iZusaetzlicheroffset = iZusaetzlicheroffset + 3;
						} catch (NoResultException ex) {
							bHatPlatz = true;
						}
					}

					z.setTZeit(new Timestamp((tPauseVon.getTime() - 10 * i) + iZusaetzlicheroffset));
					z.setCBemerkungzubelegart("wg. automatischer Mindestpause verschoben.");
					em.merge(z);
				}
			}
		}
	}

	private boolean bucheAutomatischeMindestpause(Integer personalIId, Timestamp tLetztesKommt, Timestamp tPauseVon,
			Timestamp tPauseBis, TheClientDto theClientDto) {

		Integer taetigkeitIId_Unter = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER, theClientDto).getIId();

		Integer taetigkeitIId_Telefon = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_TELEFON, theClientDto).getIId();

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Criteria crit = session.createCriteria(FLRZeitdaten.class);
		crit.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalIId));
		crit.add(Restrictions.isNotNull(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID));
		crit.add(Restrictions.gt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tLetztesKommt));
		crit.add(Restrictions.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tPauseVon));
		crit.addOrder(Order.desc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));
		// @todo ohne ENDE und STOP

		// wenn die Pause nicht vollstaendig Platz hat, dann wird die Taetigkeit
		// nicht unterbrochen.
		Session sessionPause = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Criteria critPause = sessionPause.createCriteria(FLRZeitdaten.class);
		critPause.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalIId));
		critPause.add(Restrictions.isNotNull(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID));
		critPause.add(Restrictions.ge(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tPauseVon));
		critPause.add(Restrictions.le(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tPauseBis));
		critPause.addOrder(Order.desc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));
		List<?> resultListPause = critPause.list();

		boolean bPauseHatVollstaendigPlatz = true;
		if (resultListPause.size() > 0) {
			bPauseHatVollstaendigPlatz = false;
		}

		// Zeitdatenbuchung vorbereiten
		ZeitdatenDto zeitdatenDtoUnterVon = new ZeitdatenDto();
		zeitdatenDtoUnterVon.setPersonalIId(personalIId);
		zeitdatenDtoUnterVon.setTaetigkeitIId(taetigkeitIId_Unter);
		zeitdatenDtoUnterVon.setBAutomatikbuchung(Helper.boolean2Short(true));
		zeitdatenDtoUnterVon.setTZeit(tPauseVon);

		ZeitdatenDto zeitdatenDtoUnterBis = new ZeitdatenDto();
		zeitdatenDtoUnterBis.setPersonalIId(personalIId);
		zeitdatenDtoUnterBis.setTaetigkeitIId(taetigkeitIId_Unter);
		zeitdatenDtoUnterBis.setBAutomatikbuchung(Helper.boolean2Short(true));
		zeitdatenDtoUnterBis.setTZeit(tPauseBis);

		List<?> resultList = crit.list();
		Iterator<?> resultListIterator = resultList.iterator();

		// Wenn zwischen geplanter Pause und Kommt Buchungen sind,
		// muessen diese unterbrochen werden, wenn die Pause vollstaendig darin
		// Platz hat

		if (resultListIterator.hasNext()) {
			FLRZeitdaten flrLetzteTaetigkeitVorPause = (FLRZeitdaten) resultListIterator.next();
			Integer iIdTaetigkeit = flrLetzteTaetigkeitVorPause.getTaetigkeit_i_id();
			int iAnzahl = 1;

			while (resultListIterator.hasNext()) {
				FLRZeitdaten flrZeitdaten = (FLRZeitdaten) resultListIterator.next();
				if (iIdTaetigkeit.equals(flrZeitdaten.getTaetigkeit_i_id())) {
					iAnzahl++;
				}
			}

			sessionPause.close();

			// Wenn eine ungerade Anzahl von Sondertaetigkeiten, dann muss diese
			// vorher beendet werden
			// aber nur wenn sie bezahlt ist
			if (taetigkeitFindByPrimaryKey(iIdTaetigkeit, theClientDto).getFBezahlt() > 0) {

				if (iAnzahl % 2 == 1) {

					// SP5582 -> Bei Telefonzeit Ende verlegen und in
					// Telefonzeiteintrag vermerken
					if (!iIdTaetigkeit.equals(taetigkeitIId_Telefon)) {

						// Sondertaetigkeit vorher beenden
						ZeitdatenDto zeitdatenDtoVorherEnde = new ZeitdatenDto();
						zeitdatenDtoVorherEnde.setPersonalIId(personalIId);
						zeitdatenDtoVorherEnde.setTaetigkeitIId(iIdTaetigkeit);
						zeitdatenDtoVorherEnde.setBAutomatikbuchung(Helper.boolean2Short(true));
						zeitdatenDtoVorherEnde.setTZeit(new Timestamp(tPauseVon.getTime() - 100));
						createZeitdaten(zeitdatenDtoVorherEnde, false, false, false, false, theClientDto);
					} else {
						Query query = em.createNamedQuery("TelefonzeitenfindByPersonalIIdTVon");
						query.setParameter(1, personalIId);
						query.setParameter(2, flrLetzteTaetigkeitVorPause.getT_zeit());
						Telefonzeiten telefonzeiten = (Telefonzeiten) query.getSingleResult();
						Collection c = query.getResultList();

						if (telefonzeiten != null
								&& telefonzeiten.getTBis().getTime() <= zeitdatenDtoUnterBis.getTZeit().getTime()) {
							TelefonzeitenDto tzDto = telefonzeitenFindByPrimaryKey(telefonzeiten.getIId());

							tzDto.setXKommentarint(
									tzDto.getXKommentarint() + " TELEFON-ENDE aufgrund Automatischer-Mindestpause von "
											+ Helper.formatTimestamp(tzDto.getTBis(), theClientDto.getLocUi()) + " auf "
											+ Helper.formatTimestamp(new Timestamp(tPauseVon.getTime() - 100),
													theClientDto.getLocUi())
											+ " verschoben");
							tzDto.setTBis(new Timestamp(tPauseVon.getTime() - 100));

							updateTelefonzeiten(tzDto, theClientDto);
						}

					}
				}

			}
			// PauseBeginn buchen
			createZeitdaten(zeitdatenDtoUnterVon, false, false, false, false, theClientDto);

			// PauseEnde buchen
			createZeitdaten(zeitdatenDtoUnterBis, false, false, false, false, theClientDto);

			if (taetigkeitFindByPrimaryKey(iIdTaetigkeit, theClientDto).getFBezahlt() > 0) {
				if (iAnzahl % 2 == 1) {

					if (!iIdTaetigkeit.equals(taetigkeitIId_Telefon)) {
						// Sondertaetigkeit nachher wieder beginnen
						ZeitdatenDto zeitdatenDtoNachherBeginn = new ZeitdatenDto();
						zeitdatenDtoNachherBeginn.setPersonalIId(personalIId);
						zeitdatenDtoNachherBeginn.setTaetigkeitIId(iIdTaetigkeit);
						zeitdatenDtoNachherBeginn.setBAutomatikbuchung(Helper.boolean2Short(true));
						zeitdatenDtoNachherBeginn.setTZeit(new Timestamp(tPauseBis.getTime() + 100));
						createZeitdaten(zeitdatenDtoNachherBeginn, false, false, false, false, theClientDto);
					}
				}
			}

		} else {
			// PauseBeginn buchen
			createZeitdaten(zeitdatenDtoUnterVon, false, false, false, false, theClientDto);
			// PauseEnde buchen
			createZeitdaten(zeitdatenDtoUnterBis, false, false, false, false, theClientDto);
		}
		session.close();
		return true;
	}

	public void sindEintraegeBereitsVerrechnet(Integer zeitdatenIId, Integer maschinenzeitdatenIId,
			Integer telefonzeitenIId, Integer auftragszuordnungIId, Integer reiseIId) {
		// PJ20872

		Set<Integer> s = new HashSet<Integer>();

		if (zeitdatenIId != null) {

			Query query = em.createNamedQuery("ZeitdatenverrechnetFindByZeitdatenIId");
			query.setParameter(1, zeitdatenIId);
			Collection<?> cl = query.getResultList();
			Iterator itBereitsAbgerechnet = cl.iterator();
			while (itBereitsAbgerechnet.hasNext()) {
				Zeitdatenverrechnet zv = (Zeitdatenverrechnet) itBereitsAbgerechnet.next();

				s.add(zv.getRechnungpositionIId());
			}

		}

		if (maschinenzeitdatenIId != null) {

			Query query = em.createNamedQuery("MaschinenzeitdatenverrechnetFindByMaschinenzeitdatenIId");
			query.setParameter(1, maschinenzeitdatenIId);
			Collection<?> cl = query.getResultList();
			Iterator itBereitsAbgerechnet = cl.iterator();
			while (itBereitsAbgerechnet.hasNext()) {
				Maschinenzeitdatenverrechnet zv = (Maschinenzeitdatenverrechnet) itBereitsAbgerechnet.next();

				s.add(zv.getRechnungpositionIId());
			}

		}

		if (telefonzeitenIId != null) {

			Query query = em.createNamedQuery("TelefonzeitenverrechnetFindByTelefonzeitenIId");
			query.setParameter(1, telefonzeitenIId);
			Collection<?> cl = query.getResultList();
			Iterator itBereitsAbgerechnet = cl.iterator();
			while (itBereitsAbgerechnet.hasNext()) {
				Telefonzeitenverrechnet zv = (Telefonzeitenverrechnet) itBereitsAbgerechnet.next();

				s.add(zv.getRechnungpositionIId());
			}

		}

		if (auftragszuordnungIId != null) {

			Query query = em.createNamedQuery("AuftragszuordnungverrechnetFindByAuftragszuordnungIId");
			query.setParameter(1, auftragszuordnungIId);
			Collection<?> cl = query.getResultList();
			Iterator itBereitsAbgerechnet = cl.iterator();
			while (itBereitsAbgerechnet.hasNext()) {
				Auftragszuordnungverrechnet zv = (Auftragszuordnungverrechnet) itBereitsAbgerechnet.next();

				s.add(zv.getRechnungpositionIId());
			}

		}

		if (reiseIId != null) {

			Query query = em.createNamedQuery("ReiseverrechnetFindByReiseIId");
			query.setParameter(1, reiseIId);
			Collection<?> cl = query.getResultList();
			Iterator itBereitsAbgerechnet = cl.iterator();
			while (itBereitsAbgerechnet.hasNext()) {
				Reiseverrechnet zv = (Reiseverrechnet) itBereitsAbgerechnet.next();

				s.add(zv.getRechnungpositionIId());
			}

		}

		if (s.size() > 0) {

			Iterator it = s.iterator();

			TreeSet tmRechnungen = new TreeSet();

			while (it.hasNext()) {
				Integer rechnungspositionIId = (Integer) it.next();

				try {
					RechnungPositionDto rePosDto = getRechnungFac()
							.rechnungPositionFindByPrimaryKey(rechnungspositionIId);
					RechnungDto reDto = getRechnungFac().rechnungFindByPrimaryKey(rePosDto.getRechnungIId());
					Integer iPos = getRechnungFac().getPositionNummer(rechnungspositionIId);

					tmRechnungen.add(reDto.getCNr() + " Pos.Nr. " + iPos);
				} catch (RemoteException e) {
					throwEJBExceptionLPRespectOld(e);
				}

			}

			String rechnungen = "";
			byte[] CRLFAscii = { 13, 10 };
			Iterator itPositionen = tmRechnungen.iterator();

			while (itPositionen.hasNext()) {
				String remitpos = (String) itPositionen.next();

				rechnungen += remitpos + new String(CRLFAscii);
			}

			ArrayList al = new ArrayList();
			al.add(rechnungen);

			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DURCH_ABRECHNUNGSVORSCHLAG_BEREITS_VERRECHNET, al,
					new Exception("FEHLER_DURCH_ABRECHNUNGSVORSCHLAG_BEREITS_VERRECHNET " + rechnungen));

		}

	}

	public void removeZeitdaten(ZeitdatenDto zeitdatenDto, TheClientDto theClientDto) throws EJBExceptionLP {
		myLogger.entry();
		if (zeitdatenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitdatenDto == null"));
		}
		if (zeitdatenDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("zeitdatenDto.getIId() == null"));
		}

		// try {
		Zeitdaten zeitdaten = em.find(Zeitdaten.class, zeitdatenDto.getIId());
		if (zeitdaten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		// PJ20872
		sindEintraegeBereitsVerrechnet(zeitdaten.getIId(), null, null, null, null);
		getAbrechnungsvorschlagFac().sindEintraegeInAbrechnungsvorschlag(zeitdaten.getIId(), null, null, null, null,
				theClientDto);

		// SP3289
		bringeFehlerWennZeitabschlussvorhanden(zeitdatenDto.getPersonalIId(), zeitdatenDto.getTZeit(), theClientDto);

		HvDtoLogger<ZeitdatenDto> zeitdatenLogger = new HvDtoLogger<ZeitdatenDto>(em, zeitdatenDto.getPersonalIId(),
				theClientDto);
		zeitdatenLogger.logDelete(zeitdatenDto);

		byte[] CRLFAscii = { 13, 10 };
		Query q2 = em.createNamedQuery("LosgutschlechtFindByZeitdatenIId");
		q2.setParameter(1, zeitdatenDto.getIId());

		if (q2.getResultList().size() > 0) {

			Iterator it = q2.getResultList().iterator();

			String meldung = "";

			while (it.hasNext()) {
				Losgutschlecht lgs = (Losgutschlecht) it.next();

				LossollarbeitsplanDto soaDto = getFertigungFac()
						.lossollarbeitsplanFindByPrimaryKey(lgs.getLossollarbeitsplanIId());

				try {
					LosDto losDto = getFertigungFac().losFindByPrimaryKey(soaDto.getLosIId());

					meldung += losDto.getCNr() + " AG " + soaDto.getIArbeitsgangnummer();

					if (soaDto.getIUnterarbeitsgang() != null) {
						meldung += "." + soaDto.getIUnterarbeitsgang();
					}

					meldung += ";" + new String(CRLFAscii);

				} catch (RemoteException e) {
					throwEJBExceptionLPRespectOld(e);
				}

			}

			ArrayList al = new ArrayList();
			al.add(meldung);

			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_LOSGUTSCHLECHT_VORHANDEN, al,
					new Exception("FEHLER_LOSGUTSCHLECHT_VORHANDEN"));
		}

		try {
			em.remove(zeitdaten);
			em.flush();
		} catch (EntityExistsException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, ex);
		}

		// PJ18356
		if (zeitdatenDto.getZeitdatenIId_BisZeit() != null) {
			Zeitdaten zdBis = em.find(Zeitdaten.class, zeitdatenDto.getZeitdatenIId_BisZeit());
			em.remove(zdBis);
			em.flush();
		}

	}

	public void updateZeitdaten(ZeitdatenDto zeitdatenDto, TheClientDto theClientDto) throws EJBExceptionLP {
		if (zeitdatenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitdatenDto == null"));
		} else if (zeitdatenDto.getIId() == null || zeitdatenDto.getPersonalIId() == null
				|| zeitdatenDto.getTZeit() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception(
					"zeitdatenDto.getIId() == null || zeitdatenDto.getPersonalIId() == null || zeitdatenDto.getTZeit() == null"));
		} else if (zeitdatenDto.getTaetigkeitIId() == null && zeitdatenDto.getArtikelIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("zeitdatenDto.getTaetigkeitIId() == null && zeitdatenDto.getArtikelIId() == null"));
		}

		boolean bVonBisErfassung = false;

		try {
			ParametermandantDto parameterVonBis = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_VON_BIS_ERFASSUNG);

			bVonBisErfassung = ((Boolean) parameterVonBis.getCWertAsObject());

			Integer tetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();
			Integer tetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();

			if (zeitdatenDto.getTaetigkeitIId() != null && (zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_Kommt)
					|| zeitdatenDto.getTaetigkeitIId().equals(tetigkeitIId_Geht))) {
				zeitdatenDto.settZeit_Bis(null);
				zeitdatenDto.setZeitdatenIId_BisZeit(null);
			}

			// Wenn von-bis erfassung, dann darf zwischen von-bis keine
			// Zeitbuchung
			// vorhanden sein

			if (bVonBisErfassung && zeitdatenDto.gettZeit_Bis() != null
					&& zeitdatenDto.getZeitdatenIId_BisZeit() != null) {
				ZeitdatenDto[] dtos = getZeiterfassungFac().zeitdatenFindZeitdatenEinesTagesUndEinerPerson(
						zeitdatenDto.getPersonalIId(), zeitdatenDto.getTZeit(),
						new Timestamp(zeitdatenDto.gettZeit_Bis().getTime()));
				if (dtos.length > 0) {

					for (int i = 0; i < dtos.length; i++) {
						ZeitdatenDto zd = dtos[i];

						if (zd.getIId().equals(zeitdatenDto.getIId())
								|| zd.getIId().equals(zeitdatenDto.getZeitdatenIId_BisZeit())) {

						} else {
							throw getExceptionData(zd, EJBExceptionLP.FEHLER_BUCHUNG_ZWISCHEN_VON_BIS,
									"EJBExceptionLP.FEHLER_BUCHUNG_ZWISCHEN_VON_BIS", theClientDto);
							// throw new EJBExceptionLP(
							// EJBExceptionLP.FEHLER_BUCHUNG_ZWISCHEN_VON_BIS,
							// new Exception(
							// "EJBExceptionLP.FEHLER_BUCHUNG_ZWISCHEN_VON_BIS"));
						}

					}

				}
			}

			if (bVonBisErfassung == true && zeitdatenDto.gettZeit_Bis() == null) {
				Integer zeitdatenIId = binIchZwischenEinerVonBisBuchung(zeitdatenDto.getPersonalIId(),
						zeitdatenDto.getTZeit(), theClientDto);
				if (zeitdatenIId != null) {
					throw getExceptionData(zeitdatenDto,
							EJBExceptionLP.FEHLER_BUCHUNG_EINFUEGEN_ZWISCHEN_VON_BIS_NICHT_ERLAUBT,
							"EJBExceptionLP.FEHLER_BUCHUNG_EINFUEGEN_ZWISCHEN_VON_BIS_NICHT_ERLAUBT", theClientDto);
					// throw new EJBExceptionLP(
					// EJBExceptionLP.FEHLER_BUCHUNG_EINFUEGEN_ZWISCHEN_VON_BIS_NICHT_ERLAUBT,
					// new Exception(
					// "EJBExceptionLP.FEHLER_BUCHUNG_EINFUEGEN_ZWISCHEN_VON_BIS_NICHT_ERLAUBT"));
				}

			}

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		if (zeitdatenDto.getBAutomatikbuchung() == null) {
			zeitdatenDto.setBAutomatikbuchung(Helper.boolean2Short(false));
		}

		if (zeitdatenDto.getTaetigkeitIId() != null) {
			zeitdatenDto.setCBelegartnr(null);
			zeitdatenDto.setArtikelIId(null);
			zeitdatenDto.setIBelegartid(null);
			zeitdatenDto.setIBelegartpositionid(null);
		}

		// PJ19158
		if (zeitdatenDto.getCWowurdegebucht() != null) {
			KeyvaluePK keyvaluePK = new KeyvaluePK(SystemServicesFac.KEYVALUE_ZEITDATEN_QUELLE,
					zeitdatenDto.getCWowurdegebucht());
			Keyvalue keyvalue = em.find(Keyvalue.class, keyvaluePK);
			if (keyvalue != null) {
				zeitdatenDto.setCWowurdegebucht(keyvalue.getCValue());
			}
		}

		// SP3289
		bringeFehlerWennZeitabschlussvorhanden(zeitdatenDto.getPersonalIId(), zeitdatenDto.getTZeit(), theClientDto);

		vergleicheZeitdatenDtoVorherNachherUndLoggeAenderungen(zeitdatenDto, theClientDto);

		Integer iId = zeitdatenDto.getIId();
		// try {
		Zeitdaten zeitdaten = em.find(Zeitdaten.class, zeitdatenDto.getIId());
		if (zeitdaten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");

		}

		// PJ20872
		sindEintraegeBereitsVerrechnet(zeitdaten.getIId(), null, null, null, null);
		Integer abrechnungsvorschlagIIdVorhanden = getAbrechnungsvorschlagFac()
				.sindEintraegeInAbrechnungsvorschlag(zeitdaten.getIId(), null, null, null, null, theClientDto);

		try {
			Query query = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
			query.setParameter(1, zeitdatenDto.getPersonalIId());
			query.setParameter(2, zeitdatenDto.getTZeit());
			Zeitdaten zeitdaten2 = (Zeitdaten) query.getSingleResult();
			Integer iIdVorhanden = zeitdaten2.getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_ZEITDATEN.UK"));
			}

		} catch (NoResultException ex) {
			//
		}

		zeitdatenDto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));
		// Aus Automatikbuchungen wir bei einem Update IMMER eine 'Handbuchung'
		zeitdatenDto.setBAutomatikbuchung(Helper.boolean2Short(false));

		// Bei Zeitdaten Sekunden abschneiden und dann vergleichen
		Calendar c1 = Calendar.getInstance();
		c1.setTimeInMillis(zeitdaten.getTZeit().getTime());
		c1.set(Calendar.SECOND, 0);

		Calendar c2 = Calendar.getInstance();
		c2.setTimeInMillis(zeitdatenDto.getTZeit().getTime());
		c2.set(Calendar.SECOND, 0);

		if (c1.equals(c2)) {
			zeitdatenDto.setTAendern(zeitdaten.getTAendern());
			if (zeitdaten.getTaetigkeitIId() != null
					&& !zeitdaten.getTaetigkeitIId().equals(zeitdatenDto.getTaetigkeitIId())) {
				zeitdatenDto.setBTaetigkeitgeaendert(Helper.boolean2Short(true));

			} else if (zeitdaten.getArtikelIId() != null
					&& !zeitdaten.getArtikelIId().equals(zeitdatenDto.getArtikelIId())) {
				zeitdatenDto.setBTaetigkeitgeaendert(Helper.boolean2Short(true));

			} else if (zeitdaten.getTaetigkeitIId() == null && zeitdatenDto.getTaetigkeitIId() != null) {
				zeitdatenDto.setBTaetigkeitgeaendert(Helper.boolean2Short(true));
			} else if (zeitdaten.getArtikelIId() == null && zeitdatenDto.getArtikelIId() != null) {
				zeitdatenDto.setBTaetigkeitgeaendert(Helper.boolean2Short(true));
			}
		}

		zeitdatenDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		setZeitdatenFromZeitdatenDto(zeitdaten, zeitdatenDto);

		// Losablieferungen auf "Neu Berechnen" setzen
		if (zeitdatenDto.getCBelegartnr() != null && zeitdatenDto.getCBelegartnr().equals(LocaleFac.BELEGART_LOS)) {
			try {
				if (zeitdatenDto.getIBelegartid() != null) {
					getFertigungFac().setzeLosablieferungenAufNeuBerechnen(zeitdatenDto.getIBelegartid(), theClientDto);
				}
			} catch (RemoteException ex2) {
				throwEJBExceptionLPRespectOld(ex2);
			}
		}

		// PJ18356

		if (zeitdatenDto.getZeitdatenIId_BisZeit() != null && zeitdatenDto.gettZeit_Bis() != null) {
			Zeitdaten zdBis = em.find(Zeitdaten.class, zeitdatenDto.getZeitdatenIId_BisZeit());
			zdBis.setTZeit(zeitdatenDto.gettZeit_Bis());
		}

		// PJ20872
		if (abrechnungsvorschlagIIdVorhanden != null) {
			getAbrechnungsvorschlagFac().erstelleAbrechnungsvorschlagZeitdaten(null, abrechnungsvorschlagIIdVorhanden,
					theClientDto);
		}

	}

	public ZeitdatenDto zeitdatenFindByPrimaryKey(Integer iId, TheClientDto theClientDto) throws EJBExceptionLP {
		if (iId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}
		// try {
		Zeitdaten zeitdaten = em.find(Zeitdaten.class, iId);
		if (zeitdaten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");

		}
		ZeitdatenDto zDto = assembleZeitdatenDto(zeitdaten);

		ParametermandantDto parameter = null;
		try {
			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_VON_BIS_ERFASSUNG);
		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		boolean bVonBisErfassung = ((Boolean) parameter.getCWertAsObject());
		if (bVonBisErfassung == true) {

			ZeitdatenDto zDtoEnde = getZeiterfassungFac().getZugehoerigeEndeBuchung(zDto, theClientDto);
			if (zDtoEnde != null) {
				zDto.setZeitdatenIId_BisZeit(zDtoEnde.getIId());
				zDto.settZeit_Bis(zDtoEnde.getTZeit());
			}

		}

		return zDto;

	}

	public ZeitdatenDto zeitdatenFindByPrimaryKeyOhneExc(Integer id) {
		if (id == null)
			return null;
		Zeitdaten zeitdaten = em.find(Zeitdaten.class, id);
		return zeitdaten == null ? null : assembleZeitdatenDto(zeitdaten);
	}

	public ZeitdatenDto zeitdatenFindByPersonalIIdTZeit(Integer personalIId, Timestamp tZeit) throws EJBExceptionLP {
		if (personalIId == null || tZeit == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("personalIId == null || tZeit == null"));
		}
		// try {
		Query query = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
		query.setParameter(1, personalIId);
		query.setParameter(2, tZeit);
		Zeitdaten zeitdaten = (Zeitdaten) query.getSingleResult();
		if (zeitdaten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleZeitdatenDto(zeitdaten);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	public ZeitdatenDto[] zeitdatenFindZeitdatenEinesTagesUndEinerPerson(Integer personalIId, Timestamp tVon,
			Timestamp tBis) throws EJBExceptionLP {
		if (personalIId == null || tVon == null || tBis == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("personalIId == null || tVon == null || tBis == null"));
		}
		// try {
		Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
		query.setParameter(1, personalIId);
		query.setParameter(2, tVon);
		query.setParameter(3, tBis);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// null);
		// }
		return assembleZeitdatenDtos(cl);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);

		// }
	}

	// @ToDo warum gibt es die gleiche unter anderem Namen!
	public ZeitdatenDto[] zeitdatenFindZeitdatenEinesTagesUndEinerPersonOnheBelegzeiten(Integer personalIId,
			Timestamp tVon, Timestamp tBis) throws EJBExceptionLP {
		if (personalIId == null || tVon == null || tBis == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("personalIId == null || tVon == null || tBis == null"));
		}
		// try {
		Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
		query.setParameter(1, personalIId);
		query.setParameter(2, tVon);
		query.setParameter(3, tBis);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// null);
		// }
		return assembleZeitdatenDtos(cl);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);

		// }
	}

	private void setZeitdatenFromZeitdatenDto(Zeitdaten zeitdaten, ZeitdatenDto zeitdatenDto) {
		zeitdaten.setPersonalIId(zeitdatenDto.getPersonalIId());
		zeitdaten.setTZeit(zeitdatenDto.getTZeit());
		zeitdaten.setCBelegartnr(zeitdatenDto.getCBelegartnr());
		zeitdaten.setIBelegartpositionid(zeitdatenDto.getIBelegartpositionid());
		zeitdaten.setIBelegartid(zeitdatenDto.getIBelegartid());
		zeitdaten.setCBemerkungzubelegart(zeitdatenDto.getCBemerkungZuBelegart());
		zeitdaten.setTaetigkeitIId(zeitdatenDto.getTaetigkeitIId());
		zeitdaten.setArtikelIId(zeitdatenDto.getArtikelIId());
		zeitdaten.setBTaetigkeitgeaendert(zeitdatenDto.getBTaetigkeitgeaendert());
		zeitdaten.setBAutomatikbuchung(zeitdatenDto.getBAutomatikbuchung());
		zeitdaten.setPersonalIIdAendern(zeitdatenDto.getPersonalIIdAendern());
		zeitdaten.setTAendern(zeitdatenDto.getTAendern());
		zeitdaten.setXKommentar(zeitdatenDto.getXKommentar());
		zeitdaten.setCWowurdegebucht(zeitdatenDto.getCWowurdegebucht());
		zeitdaten.setFVerrechenbar(zeitdatenDto.getFVerrechenbar());
		zeitdaten.setPersonalIIdErledigt(zeitdatenDto.getPersonalIIdErledigt());
		zeitdaten.setTErledigt(zeitdatenDto.getTErledigt());
		zeitdaten.setMaschineIId(zeitdatenDto.getMaschineIId());
		zeitdaten.setXKommentarIntern(zeitdatenDto.getXKommentarIntern());
		zeitdaten.setFDauerUebersteuert(zeitdatenDto.getFDauerUebersteuert());

		em.merge(zeitdaten);
		em.flush();
	}

	private ZeitdatenDto assembleZeitdatenDto(Zeitdaten zeitdaten) {
		return ZeitdatenDtoAssembler.createDto(zeitdaten);
	}

	private ZeitdatenDto[] assembleZeitdatenDtos(Collection<?> zeitdatens) {
		List<ZeitdatenDto> list = new ArrayList<ZeitdatenDto>();
		if (zeitdatens != null) {
			Iterator<?> iterator = zeitdatens.iterator();
			while (iterator.hasNext()) {
				Zeitdaten zeitdaten = (Zeitdaten) iterator.next();
				list.add(assembleZeitdatenDto(zeitdaten));
			}
		}
		ZeitdatenDto[] returnArray = new ZeitdatenDto[list.size()];
		return (ZeitdatenDto[]) list.toArray(returnArray);
	}

	public ZeitdatenDto[] assembleZeitdatenDtosOhneBelegzeiten(Collection<?> zeitdatens) {
		List<ZeitdatenDto> list = new ArrayList<ZeitdatenDto>();

		Integer taetigkeitIId_Ende = null;

		try {
			Query query = em.createNamedQuery("TaetigkeitfindByCNr");
			query.setParameter(1, ZeiterfassungFac.TAETIGKEIT_ENDE);
			Taetigkeit taetigkeit = (Taetigkeit) query.getSingleResult();
			taetigkeitIId_Ende = taetigkeit.getIId();

		} catch (NoResultException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, ex);
		}

		if (zeitdatens != null) {
			Iterator<?> iterator = zeitdatens.iterator();
			while (iterator.hasNext()) {
				Zeitdaten zeitdaten = (Zeitdaten) iterator.next();
				if (zeitdaten.getArtikelIId() == null) {
					if (!taetigkeitIId_Ende.equals(zeitdaten.getTaetigkeitIId())) {

						list.add(assembleZeitdatenDto(zeitdaten));

					}
				}
			}
		}
		ZeitdatenDto[] returnArray = new ZeitdatenDto[list.size()];
		return (ZeitdatenDto[]) list.toArray(returnArray);
	}

	private ZeitdatenDto[] assembleZeitdatenDtosOhneEnde(Collection<?> zeitdatens) {
		List<ZeitdatenDto> list = new ArrayList<ZeitdatenDto>();

		Integer taetigkeitIId_Ende = null;

		try {
			Query query = em.createNamedQuery("TaetigkeitfindByCNr");
			query.setParameter(1, ZeiterfassungFac.TAETIGKEIT_ENDE);
			Taetigkeit taetigkeit = (Taetigkeit) query.getSingleResult();
			taetigkeitIId_Ende = taetigkeit.getIId();

		} catch (NoResultException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, ex);
		}

		if (zeitdatens != null) {
			Iterator<?> iterator = zeitdatens.iterator();
			while (iterator.hasNext()) {
				Zeitdaten zeitdaten = (Zeitdaten) iterator.next();

				if (!taetigkeitIId_Ende.equals(zeitdaten.getTaetigkeitIId())) {

					list.add(assembleZeitdatenDto(zeitdaten));

				}

			}
		}
		ZeitdatenDto[] returnArray = new ZeitdatenDto[list.size()];
		return (ZeitdatenDto[]) list.toArray(returnArray);
	}

	private ZeitdatenDto[] assembleZeitdatenOhneArbeitsUndMaschienzeitenDtos(Collection<?> zeitdatens) {
		List<ZeitdatenDto> list = new ArrayList<ZeitdatenDto>();
		if (zeitdatens != null) {
			Iterator<?> iterator = zeitdatens.iterator();
			while (iterator.hasNext()) {
				Zeitdaten zeitdaten = (Zeitdaten) iterator.next();
				if (zeitdaten.getTaetigkeitIId() != null) {
					list.add(assembleZeitdatenDto(zeitdaten));
				}
			}
		}
		ZeitdatenDto[] returnArray = new ZeitdatenDto[list.size()];
		return (ZeitdatenDto[]) list.toArray(returnArray);
	}

	public Timestamp pruefeObAmLetztenBuchungstagKommtUndGehtGebuchtWurde(Integer personalIId,
			TheClientDto theClientDto) {

		Date tKommt = null;
		Date tGeht = null;

		Timestamp tTag = null;

		TaetigkeitDto taetigkeitDto_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto);
		TaetigkeitDto taetigkeitDto_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto);

		// Meldung ob GEHT oder KOMMT ind den letzten Tagen fehlt
		// Hole letzte Buchung vor Heute
		Session session = FLRSessionFactory.getFactory().openSession();
		org.hibernate.Criteria liste = session.createCriteria(FLRZeitdaten.class);
		liste.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalIId));

		liste.addOrder(Order.desc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));
		liste.setMaxResults(1);
		List<?> letzerAuftrag = liste.list();

		Iterator<?> it = letzerAuftrag.iterator();

		if (it.hasNext()) {
			FLRZeitdaten flrLetzteBuchung = (FLRZeitdaten) it.next();
			tTag = new Timestamp(flrLetzteBuchung.getT_zeit().getTime());

			// Wenn heute, dann nichts

			Timestamp tHeute = Helper.cutTimestamp(new Timestamp(System.currentTimeMillis()));

			if (tHeute.equals(Helper.cutTimestamp(tTag))) {
				return null;
			}

			if (flrLetzteBuchung.getTaetigkeit_i_id() != null
					&& flrLetzteBuchung.getTaetigkeit_i_id().equals(taetigkeitDto_Geht.getIId())) {
				tGeht = flrLetzteBuchung.getT_zeit();
			}

			String sQuery = "select zeitdaten FROM FLRZeitdaten zeitdaten WHERE zeitdaten.t_zeit<'"
					+ Helper.formatTimestampWithSlashes(new Timestamp(flrLetzteBuchung.getT_zeit().getTime()))
					+ "' AND zeitdaten.personal_i_id=" + personalIId + " AND (zeitdaten.taetigkeit_i_id="
					+ taetigkeitDto_Kommt.getIId() + " OR zeitdaten.taetigkeit_i_id=" + taetigkeitDto_Geht.getIId()
					+ ") ORDER BY zeitdaten.t_zeit DESC";

			Session session2 = FLRSessionFactory.getFactory().openSession();

			org.hibernate.Query letzteKommtGeht = session2.createQuery(sQuery);
			letzteKommtGeht.setMaxResults(1);

			List<?> resultList = letzteKommtGeht.list();

			Iterator<?> resultListIterator = resultList.iterator();

			if (resultListIterator.hasNext()) {
				FLRZeitdaten l = (FLRZeitdaten) resultListIterator.next();
				// Wenn zuletzt ein Kommt gebucht wurde, dann OK

				if (l.getTaetigkeit_i_id().equals(taetigkeitDto_Kommt.getIId())) {
					tKommt = l.getT_zeit();

				}
			}

		}

		if (tKommt == null || tGeht == null) {
			return tTag;
		}

		return null;
	}

	public Integer createTaetigkeit(TaetigkeitDto taetigkeitDto, TheClientDto theClientDto) throws EJBExceptionLP {
		if (taetigkeitDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("taetigkeitDto == null"));
		}
		if (taetigkeitDto.getCNr() == null || taetigkeitDto.getTaetigkeitartCNr() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("taetigkeitDto.getCNr() == null || taetigkeitDto.getTaetigkeitartCNr() == null"));
		}
		try {
			Query query = em.createNamedQuery("TaetigkeitfindByCNr");
			query.setParameter(1, taetigkeitDto.getCNr());
			Taetigkeit doppelt = (Taetigkeit) query.getSingleResult();
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_TAETIGKEIT.C_NR"));
		} catch (NoResultException ex1) {
			// nothing here
		}
		if (taetigkeitDto.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_REISE)) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN,
					new Exception("Taetigkeit REISE is Reserviert und darf nicht angelegt werden"));

		}

		try {

			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_TAETIGKEIT);
			taetigkeitDto.setIId(pk);
			taetigkeitDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
			taetigkeitDto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));

			taetigkeitDto.setISort(new Integer(0));

			if (taetigkeitDto.getBDarfSelberBuchen() == null) {
				taetigkeitDto.setBDarfSelberBuchen(Helper.boolean2Short(false));
			}

			Taetigkeit taetigkeit = new Taetigkeit(taetigkeitDto.getIId(), taetigkeitDto.getCNr(),
					taetigkeitDto.getTaetigkeitartCNr(), taetigkeitDto.getISort(),
					taetigkeitDto.getPersonalIIdAendern(), taetigkeitDto.getBDarfSelberBuchen());
			em.persist(taetigkeit);
			em.flush();

			if (taetigkeitDto.getBBdebuchbar() == null) {
				taetigkeitDto.setBBdebuchbar(taetigkeit.getBBdebuchbar());
			}
			if (taetigkeitDto.getFBezahlt() == null) {
				taetigkeitDto.setFBezahlt(taetigkeit.getFBezahlt());
			}
			if (taetigkeitDto.getBFeiertag() == null) {
				taetigkeitDto.setBFeiertag(taetigkeit.getBFeiertag());
			}

			if (taetigkeitDto.getBTagbuchbar() == null) {
				taetigkeitDto.setBTagbuchbar(taetigkeit.getBTagbuchbar());
			}
			if (taetigkeitDto.getBVersteckt() == null) {
				taetigkeitDto.setBVersteckt(taetigkeit.getbVersteckt());
			}
			setTaetigkeitFromTaetigkeitDto(taetigkeit, taetigkeitDto);
			if (taetigkeitDto.getTaetigkeitsprDto() != null) {
				String sprache = theClientDto.getLocUiAsString();
				Taetigkeitspr taetigkeitspr = new Taetigkeitspr(taetigkeitDto.getIId(), sprache);
				em.persist(taetigkeitspr);
				em.flush();
				setTaetigkeitsprFromTaetigkeitsprDto(taetigkeitspr, taetigkeitDto.getTaetigkeitsprDto());
			}
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
		return taetigkeitDto.getIId();
	}

	public boolean isMaschinenZeitbuchungNachZeitpunktVorhanden(Integer maschineIId, java.sql.Timestamp ts) {

		Query query = em.createNamedQuery("MaschinenzeitdatenfindMaschinenzeitdatenNachZeitpunkt");
		query.setParameter(1, maschineIId);
		query.setParameter(2, ts);
		Collection<?> cl = query.getResultList();

		if (cl.size() > 0) {
			return true;

		} else {
			return false;
		}

	}

	public Integer createMaschinenzeitdaten(MaschinenzeitdatenDto maschinenzeitdatenDto, TheClientDto theClientDto) {
		return createMaschinenzeitdaten(maschinenzeitdatenDto, true, theClientDto);
	}

	public Integer createMaschinenzeitdaten(MaschinenzeitdatenDto maschinenzeitdatenDto,
			boolean zusaetzlicheAgsAnstempeln, TheClientDto theClientDto) {

		try {

			// Wenn bei der vorherigen Buchung das bis leer ist, wird das mit
			// dem jetzigen von beendet.

			Query query = em.createNamedQuery("MaschinenzeitdatenfindLetzeOffeneMaschinenzeitdaten");
			query.setParameter(1, maschinenzeitdatenDto.getMaschineIId());
			Collection<?> cl = query.getResultList();

			if (cl.size() > 0) {
				Maschinenzeitdaten m = (Maschinenzeitdaten) cl.iterator().next();

				m.setTBis(maschinenzeitdatenDto.getTVon());
				em.merge(m);
				em.flush();

			}

			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_MASCHINENZEITDATEN);
			maschinenzeitdatenDto.setIId(pk);
			maschinenzeitdatenDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
			maschinenzeitdatenDto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));
			maschinenzeitdatenDto.setPersonalIIdAnlegen(theClientDto.getIDPersonal());
			maschinenzeitdatenDto.setTAnlegen(new java.sql.Timestamp(System.currentTimeMillis()));

			doCreateMaschinenzeitdaten(maschinenzeitdatenDto);

			Lossollarbeitsplan lsa = em.find(Lossollarbeitsplan.class,
					maschinenzeitdatenDto.getLossollarbeitsplanIId());

			try {
				// PJ20739
				if (maschinenzeitdatenDto.getFVerrechenbar() == null) {
					LosDto losDto = getFertigungFac().losFindByPrimaryKey(lsa.getLosIId());
					if (losDto.getAuftragpositionIId() != null) {

						AuftragpositionDto apDto = getAuftragpositionFac()
								.auftragpositionFindByPrimaryKey(losDto.getAuftragpositionIId());

						if (Helper.short2boolean(apDto.getBPauschal())) {
							maschinenzeitdatenDto.setFVerrechenbar(0D);
						} else {
							maschinenzeitdatenDto.setFVerrechenbar(100D);
						}
					}

				}

				getFertigungFac().setzeLosablieferungenAufNeuBerechnen(lsa.getLosIId(), theClientDto);
			} catch (RemoteException e) {
				throwEJBExceptionLPRespectOld(e);
			}

			if (lsa.getMaschineIId() == null) {
				// keine Maschin im Arbeitgang definiert, daher kommt die
				// Maschine aus der createMaschinenzeit
				Query query1 = em.createNamedQuery("LossollarbeitsplanfindByLosIIdIArbeitsgangnummer");
				query1.setParameter(1, lsa.getLosIId());
				query1.setParameter(2, lsa.getIArbeitsgangnummer());
				Collection<Lossollarbeitsplan> lsaList = query1.getResultList();
				Iterator<Lossollarbeitsplan> it = lsaList.iterator();
				while (it.hasNext()) {
					if (it.next().getIId().equals(lsa.getIId()))
						// eigenen Arbeitsgang suchen
						if (it.hasNext()) {
							Lossollarbeitsplan lsa1 = it.next();
							// naechste Laufzeit des Arbeitsgangs suchen (muss
							// folgender sein!)
							if (lsa1.getAgartCNr() != null && lsa1.getAgartCNr().equals(StuecklisteFac.AGART_LAUFZEIT)
									&& lsa1.getMaschineIId() == null) {
								// Maschinenzeit buchen
								letzteMaschinenzeitBuchungBeenden(maschinenzeitdatenDto.getMaschineIId(),
										maschinenzeitdatenDto.getTVon());
								maschinenzeitdatenDto.setIId(pkGen.getNextPrimaryKey(PKConst.PK_MASCHINENZEITDATEN));
								maschinenzeitdatenDto.setLossollarbeitsplanIId(lsa1.getIId());
								maschinenzeitdatenDto
										.setTVon(new Timestamp(maschinenzeitdatenDto.getTVon().getTime() + 200));
								doCreateMaschinenzeitdaten(maschinenzeitdatenDto);
							}
							// wurde keiner gefunden oder ist der folgende keine
							// Laufzeit wird keine zusaetzliche Maschinenzeit
							// gebucht!
							break;
						}
				}
			} else {

				if (zusaetzlicheAgsAnstempeln) {

					LossollarbeitsplanDto[] zusDtos = getFertigungFac().getAlleZusatzlichZuBuchuchendenArbeitsgaenge(
							maschinenzeitdatenDto.getLossollarbeitsplanIId(), theClientDto);

					for (int i = 0; i < zusDtos.length; i++) {
						if (zusDtos[i].getMaschineIId() != null) {
							// Wenn bei der vorherigen Buchung das bis leer ist,
							// wird
							// das mit
							// dem jetzigen von beendet.
							letzteMaschinenzeitBuchungBeenden(maschinenzeitdatenDto.getMaschineIId(),
									maschinenzeitdatenDto.getTVon());

							pk = pkGen.getNextPrimaryKey(PKConst.PK_MASCHINENZEITDATEN);
							maschinenzeitdatenDto.setIId(pk);

							maschinenzeitdatenDto.setLossollarbeitsplanIId(zusDtos[i].getIId());
							maschinenzeitdatenDto
									.setTVon(new Timestamp(maschinenzeitdatenDto.getTVon().getTime() + 200));
							doCreateMaschinenzeitdaten(maschinenzeitdatenDto);
						}

					}
				}

			}
		} catch (

		EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
		return maschinenzeitdatenDto.getIId();
	}

	private void doCreateMaschinenzeitdaten(MaschinenzeitdatenDto maschinenzeitdatenDto) {

		if (maschinenzeitdatenDto.getBParallel() == null) {
			maschinenzeitdatenDto.setBParallel(Helper.boolean2Short(false));
		}

		Maschinenzeitdaten taetigkeit = new Maschinenzeitdaten(maschinenzeitdatenDto.getIId(),
				maschinenzeitdatenDto.getMaschineIId(), maschinenzeitdatenDto.getTVon(),
				maschinenzeitdatenDto.getPersonalIIdAnlegen(), maschinenzeitdatenDto.getPersonalIIdAendern(),
				maschinenzeitdatenDto.getLossollarbeitsplanIId(), maschinenzeitdatenDto.getTAendern(),
				maschinenzeitdatenDto.getTAnlegen(), maschinenzeitdatenDto.getPersonalIIdGestartet(),
				maschinenzeitdatenDto.getBParallel());
		em.persist(taetigkeit);
		em.flush();

		setMaschinenzeitdatenFromMaschinenzeitdatenDto(taetigkeit, maschinenzeitdatenDto);
	}

	public void importiereSonderzeiten(java.sql.Date tLoescheVorhandenevon, java.sql.Date tLoescheVorhandenebis,
			HashMap<Integer, ArrayList<SonderzeitenImportDto>> daten, TheClientDto theClientDto) {

		Iterator<Integer> it = daten.keySet().iterator();
		while (it.hasNext()) {

			Integer personalIId = it.next();

			HashMap hm = taetigkeitenMitImportkennzeichen();

			Iterator itTaetigkeiten = hm.keySet().iterator();

			while (itTaetigkeiten.hasNext()) {
				Integer taetigkeitIId = (Integer) hm.get(itTaetigkeiten.next());
				// Zuerst Sonderzeiten im Zeitraum loechen
				Session session = FLRSessionFactory.getFactory().openSession();

				// Mit Fr. Krautenbacher besprochen:
				// Es werden ALLE Sonderzeiten in dem Zeitraom geloescht, da es
				// den Fall gab, das bei einer Person eine Stundenweise
				// Sonderzeit manuell
				// hinterlegt wurde und somit der UK verletzt wurde

				String hqlDelete = "delete FROM FLRSonderzeiten z WHERE z.taetigkeit_i_id=" + taetigkeitIId
						+ " AND  z.personal_i_id=" + personalIId + " AND z.t_datum>=' "
						+ Helper.formatDateWithSlashes(tLoescheVorhandenevon) + "' AND z.t_datum<' "
						+ Helper.formatDateWithSlashes(tLoescheVorhandenebis) + "'";
				session.createQuery(hqlDelete).executeUpdate();

				session.close();
			}

			// Danach neu anlegen
			ArrayList<SonderzeitenImportDto> list = daten.get(personalIId);

			for (int i = 0; i < list.size(); i++) {
				SonderzeitenImportDto szDto = list.get(i);
				SonderzeitenDto sonderzeitenDto = new SonderzeitenDto();
				sonderzeitenDto.setBTag(Helper.boolean2Short(true));
				sonderzeitenDto.setBHalbtag(Helper.boolean2Short(false));
				sonderzeitenDto.setPersonalIId(personalIId);
				sonderzeitenDto.setTaetigkeitIId(szDto.getTaetigkeitIId());
				sonderzeitenDto.setTDatum(szDto.gettDatum());
				try {
					createSonderzeiten(sonderzeitenDto, theClientDto);
				} catch (EJBExceptionLP e) {
					if (e.getCode() == EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE) {
						ArrayList alDaten = new ArrayList();
						try {
							PersonalDto pDto = getPersonalFac()
									.personalFindByPrimaryKey(sonderzeitenDto.getPersonalIId(), theClientDto);

							TaetigkeitDto tDto = getZeiterfassungFac()
									.taetigkeitFindByPrimaryKey(sonderzeitenDto.getTaetigkeitIId(), theClientDto);

							String sheetInfo = "Zeile: " + (szDto.getRow() + 1) + " Spalte: "
									+ sheetColumn(szDto.getCol()) + " Blatt: " + szDto.getSource();
							alDaten.add("Pers.Nr.:" + pDto.getCPersonalnr() + ", Datum: "
									+ Helper.formatDatum(sonderzeitenDto.getTDatum(), theClientDto.getLocUi()) + " ("
									+ tDto.getCNr() + ") " + sheetInfo);
						} catch (RemoteException e1) {
							throwEJBExceptionLPRespectOld(e1);
						}

						throw new EJBExceptionLP(EJBExceptionLP.FEHLER_SONDERZEITENIMPORT_DOPPELTER_EINTRAG, alDaten,
								new Exception("FEHLER_SONDERZEITENIMPORT_DOPPELTER_EINTRAG"));

					} else {
						throw e;
					}
				}
			}

		}
	}

	private String sheetColumn(int column0) {
		int first = column0 / 26;
		int second = column0 % 26;

		String s = "";
		if (first > 0) {
			s += new Character((char) ("A".charAt(0) + first - 1)).toString();
		}
		s += new Character((char) ("A".charAt(0) + (second))).toString();
		return s;
	}

	private void letzteMaschinenzeitBuchungBeenden(Integer maschineIId, Timestamp t) {
		Query query;
		Collection<?> cl;

		query = em.createNamedQuery("MaschinenzeitdatenfindLetzeOffeneMaschinenzeitdaten");
		query.setParameter(1, maschineIId);
		cl = query.getResultList();

		if (cl.size() > 0) {
			Maschinenzeitdaten m = (Maschinenzeitdaten) cl.iterator().next();
			m.setTBis(t);
			em.merge(m);
			em.flush();
		}
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public void testMSSQLTreiber(TheClientDto theClientDto) {

		Calendar cal1 = Calendar.getInstance();
		cal1.set(2020, Calendar.SEPTEMBER, 1, 8, 0, 0);
		cal1.set(Calendar.MILLISECOND, 205);
		Timestamp tZeitpunkt = new Timestamp(cal1.getTimeInMillis());

		ZeitdatenDto zeitdatenDto = new ZeitdatenDto();
		zeitdatenDto.setPersonalIId(theClientDto.getIDPersonal());
		zeitdatenDto.setTaetigkeitIId(
				getZeiterfassungFac().taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId());
		zeitdatenDto.setTZeit(tZeitpunkt);

		/*
		 * Integer zeitdatenIId=-300;
		 * 
		 * Zeitdaten zeitdaten = new Zeitdaten(zeitdatenIId,
		 * theClientDto.getIDPersonal(), getTimeOnDefaultDay(8, 0),
		 * Helper.boolean2Short(false), theClientDto.getIDPersonal(),
		 * theClientDto.getIDPersonal(), Helper.boolean2Short(false));
		 * em.persist(zeitdaten); em.flush();
		 */

		try {

			// 205 Millisekunden werden dem Dto/Bean uebergeben
			Integer id1 = getZeiterfassungFac().createZeitdaten(zeitdatenDto, false, false, false, false, theClientDto);

			// Datenbank rundet auf 207 Millisekunden (kann man auch im ManagmentStudio
			// sehen)
			// 207 Millisekunden werden zurueckgegeben
			ZeitdatenDto temp = getZeiterfassungFac().zeitdatenFindByPrimaryKey(id1, theClientDto);

			Zeitdaten tempEM = em.find(Zeitdaten.class, temp.getIId());

			// Wenn man nun nach sich selbst >=207 MS sucht, dann liefert der JTDS den
			// Datensatz zurueck
			// der MSSQL-Original jedoch nicht
			Query query = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
			query.setParameter(1, theClientDto.getIDPersonal());
			query.setParameter(2, temp.getTZeit());

			query.setParameter(3, Helper.addiereTageZuDatum(zeitdatenDto.getTZeit(), 1));

			ZeitdatenDto[] tagesDaten = assembleZeitdatenDtos(query.getResultList());

			// tagesDaten enthaelt bei JTDS EINEN Datensatz, bei MSSQL leider keinen

			// WARUM?????

			Query query5 = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
			query5.setParameter(1, theClientDto.getIDPersonal());
			query5.setParameter(2, temp.getTZeit());
			ZeitdatenDto[] tagesDatenVergleich = assembleZeitdatenDtos(query5.getResultList());

			// auch tagesDatenVergleich enthaelt bei JTDS EINEN Datensatz, bei MSSQL leider
			// keinen

			// WARUM?????

			// SQL-Query liefert bei beiden das Ergebnis
			Session session2 = FLRSessionFactory.getFactory().openSession();
			org.hibernate.Query querySQL = session2
					.createSQLQuery("SELECT I_ID,T_ZEIT FROM PERS_ZEITDATEN WHERE T_ZEIT >='"
							+ Helper.formatTimestampWithSlashes(temp.getTZeit()) + "' AND T_ZEIT<'"
							+ Helper.formatTimestampWithSlashes(
									Helper.addiereTageZuTimestamp(zeitdatenDto.getTZeit(), 1))
							+ "' ");
			Collection<?> cl = querySQL.list();

			// Wieder loeschen
			zeitdatenDto.setIId(id1);
			getZeiterfassungFac().removeZeitdaten(zeitdatenDto, theClientDto);

		} catch (RemoteException e) {
			throwEJBExceptionLPRespectOld(e);
		}

	}

	public ZeitverteilungDto[] zeitverteilungFindByPersonalIIdUndTag(Integer personalIId, java.sql.Timestamp tTag) {
		Query query = em.createNamedQuery("ZeitverteilungfindByPersonalIIdTZeitVonTZeitBis");
		query.setParameter(1, personalIId);

		// SP8716 Letztes KOMMT sucehn, wg. Schicht

		Query queryTaetigkeit = em.createNamedQuery("TaetigkeitfindByCNr");
		queryTaetigkeit.setParameter(1, ZeiterfassungFac.TAETIGKEIT_KOMMT);
		Taetigkeit taetigkeit = (Taetigkeit) queryTaetigkeit.getSingleResult();

		Integer taetigkeitIId_Kommt = taetigkeit.getIId();

		queryTaetigkeit = em.createNamedQuery("TaetigkeitfindByCNr");
		queryTaetigkeit.setParameter(1, ZeiterfassungFac.TAETIGKEIT_GEHT);
		taetigkeit = (Taetigkeit) queryTaetigkeit.getSingleResult();

		Integer taetigkeitIId_Geht = taetigkeit.getIId();

		Session session = FLRSessionFactory.getFactory().openSession();
		org.hibernate.Criteria liste = session.createCriteria(FLRZeitdaten.class);
		liste.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalIId));

		liste.add(Restrictions.or(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID, taetigkeitIId_Kommt),
				Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID, taetigkeitIId_Geht)));
		liste.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tTag));

		// Maximal am Vortag
		liste.add(Expression.gt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, Helper.addiereTageZuTimestamp(tTag, -1)));

		liste.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_B_AUTOMATIKBUCHUNG, Helper.boolean2Short(false)));

		liste.addOrder(Order.desc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));
		liste.setMaxResults(1);
		List<?> letztesKommt = liste.list();

		Iterator it = letztesKommt.iterator();

		Timestamp tVon = Helper.cutTimestamp(new Timestamp(System.currentTimeMillis()));

		if (it.hasNext()) {
			FLRZeitdaten zd = (FLRZeitdaten) it.next();
			if (zd.getTaetigkeit_i_id() == taetigkeitIId_Kommt) {
				tTag = new Timestamp(zd.getT_zeit().getTime());
			} else {
				// Von
				tTag = Helper.cutTimestamp(tTag);
			}
		} else {
			// Von
			tTag = Helper.cutTimestamp(tTag);
		}

		query.setParameter(2, tTag);
		Calendar c = Calendar.getInstance();
		c.setTimeInMillis(tTag.getTime());
		tTag = Helper.cutTimestamp(tTag);

		c.set(Calendar.DATE, c.get(Calendar.DATE) + 1);
		// Bis
		query.setParameter(3, new Timestamp(c.getTimeInMillis()));
		Collection<?> cl = query.getResultList();
		return assembleZeitverteilungDtos(cl);
	}

	public ArrayList<LossollarbeitsplanDto> getZugehoerigeSollarbeitplanDtos(Integer zeitdatenIId) {
		ArrayList<LossollarbeitsplanDto> al = new ArrayList<LossollarbeitsplanDto>();

		Query query = em.createNamedQuery("ZeitverteilungfindByZeitdatenIIdUmgewandelt");
		query.setParameter(1, zeitdatenIId);

		Collection<?> cl = query.getResultList();

		if (cl.size() > 0) {
			Zeitverteilung zv = (Zeitverteilung) cl.iterator().next();

			Query query2 = em.createNamedQuery("ZeitverteilungfindByIIdBlock");
			query2.setParameter(1, zv.getIIdBlock());
			Collection<?> cl2 = query2.getResultList();
			Iterator itBlock = cl2.iterator();
			while (itBlock.hasNext()) {
				Zeitverteilung zvAusBlock = (Zeitverteilung) itBlock.next();

				if (zvAusBlock.getZeitdatenIIdUmgewandelt() != null
						&& zvAusBlock.getZeitdatenIIdUmgewandelt().equals(zeitdatenIId)) {
					continue;
				}

				if (zvAusBlock.getLossollarbeitsplanIId() != null) {

					LossollarbeitsplanDto saDto = getFertigungFac()
							.lossollarbeitsplanFindByPrimaryKeyOhneExc(zvAusBlock.getLossollarbeitsplanIId());
					if (saDto != null) {
						al.add(saDto);
					}
				}
			}

		}

		return al;
	}

	public ZeitverteilungDto[] zeitverteilungFindByPersonalIIdLosIIdUndTag(Integer personalIId, Integer losIId,
			java.sql.Timestamp tTag) {
		Query query = em.createNamedQuery("ZeitverteilungfindByPersonalIIdLosIIdTZeitVonTZeitBis");
		query.setParameter(1, personalIId);
		query.setParameter(2, losIId);

		// Von
		tTag = Helper.cutTimestamp(tTag);
		query.setParameter(3, tTag);
		Calendar c = Calendar.getInstance();
		c.setTimeInMillis(tTag.getTime());
		c.set(Calendar.DATE, c.get(Calendar.DATE) + 1);
		// Bis
		query.setParameter(4, new Timestamp(c.getTimeInMillis()));
		Collection<?> cl = query.getResultList();
		return assembleZeitverteilungDtos(cl);
	}

	public void removeZeitverteilungByPersonalIIdUndTag(Integer personalIId, java.sql.Timestamp tTag) {

		ZeitverteilungDto[] dtos = zeitverteilungFindByPersonalIIdUndTag(personalIId, tTag);

		for (int i = 0; i < dtos.length; i++) {
			Zeitverteilung zeitverteilung = em.find(Zeitverteilung.class, dtos[i].getIId());
			em.remove(zeitverteilung);
			em.flush();
		}
	}

	public void wandleUrlaubsantragInUrlaubUm(Integer[] sonderzeitenIIds, boolean bGehehmigt,
			boolean bBestehendeLoeschen, TheClientDto theClientDto) {
		Integer urlaubsantragIId = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_URLAUBSANTRAG, theClientDto)
				.getIId();
		Integer urlaubIId = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_URLAUB, theClientDto).getIId();

		Integer zaantragIId = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ZAANTRAG, theClientDto).getIId();
		Integer zeitausgleichIId = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ZEITAUSGLEICH, theClientDto)
				.getIId();

		Integer krankantragIId = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KRANKANTRAG, theClientDto).getIId();
		Integer krankIId = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KRANK, theClientDto).getIId();

		for (int i = 0; i < sonderzeitenIIds.length; i++) {
			Sonderzeiten sonderzeiten = em.find(Sonderzeiten.class, sonderzeitenIIds[i]);

			if (bGehehmigt == true) {

				if (sonderzeiten.getTaetigkeitIId().equals(urlaubsantragIId)) {
					sonderzeiten.setTaetigkeitIId(urlaubIId);
					em.flush();
				}

				else if (sonderzeiten.getTaetigkeitIId().equals(zaantragIId)) {
					sonderzeiten.setTaetigkeitIId(zeitausgleichIId);
					em.flush();
				}

				else if (sonderzeiten.getTaetigkeitIId().equals(krankantragIId)) {
					sonderzeiten.setTaetigkeitIId(krankIId);
					em.flush();
				}

			} else {
				// SP3537

				if (sonderzeiten.getTaetigkeitIId().equals(urlaubsantragIId)
						|| sonderzeiten.getTaetigkeitIId().equals(zaantragIId)
						|| sonderzeiten.getTaetigkeitIId().equals(krankantragIId)) {
					em.remove(sonderzeiten);
				}

				if (bBestehendeLoeschen == true) {
					if (sonderzeiten.getTaetigkeitIId().equals(urlaubIId)
							|| sonderzeiten.getTaetigkeitIId().equals(zeitausgleichIId)
							|| sonderzeiten.getTaetigkeitIId().equals(krankIId)) {
						em.remove(sonderzeiten);
					}
				}

			}

		}
	}

	public Integer createZeitverteilung(ZeitverteilungDto zeitverteilungDto, TheClientDto theClientDto) {
		if (zeitverteilungDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitverteilungDto == null"));
		}
		if (zeitverteilungDto.getPersonalIId() == null || zeitverteilungDto.getLosIId() == null
				|| zeitverteilungDto.getTZeit() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception(
					"taetigkeitDto.getPersonalIId() == null || taetigkeitDto.getLosIId() == null || taetigkeitDto.getTZeit() == null"));
		}

		if (zeitverteilungDto.getBVerteilt() == null) {
			zeitverteilungDto.setBVerteilt(Helper.boolean2Short(false));
		}

		Integer taetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();
		Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();
		Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();
		Integer taetigkeitIId_Unter = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER, theClientDto).getIId();

		ZeitdatenDto zeitdatenDto = new ZeitdatenDto();

		zeitdatenDto.setPersonalIId(zeitverteilungDto.getPersonalIId());
		zeitdatenDto.setTaetigkeitIId(taetigkeitIId_Ende);
		zeitdatenDto.setTZeit(zeitverteilungDto.getTZeit());
		pruefeUndBucheAutoKommt(zeitdatenDto, theClientDto, taetigkeitIId_Geht, taetigkeitIId_Kommt,
				taetigkeitIId_Unter);

		try {

			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_ZEITVERTEILUNG);
			zeitverteilungDto.setIId(pk);

			Zeitverteilung zeitverteilung = new Zeitverteilung(zeitverteilungDto.getIId(),
					zeitverteilungDto.getPersonalIId(), zeitverteilungDto.getTZeit(), zeitverteilungDto.getLosIId(),
					zeitverteilungDto.getBVerteilt());

			zeitverteilung.setMaschineIId(zeitverteilungDto.getMaschineIId());
			zeitverteilung.setLossollarbeitsplanIId(zeitverteilungDto.getLossollarbeitsplanIId());
			em.persist(zeitverteilung);
			em.flush();

		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}

		if (zeitverteilungDto.getArtikelIId() != null) {
			// Abschlussbuchung, jetzt wird ueberall die Taetigkeit hinterlegt
			Query query = em.createNamedQuery("ZeitverteilungfindByPersonalIId");
			query.setParameter(1, zeitverteilungDto.getPersonalIId());
			Collection<?> cl = query.getResultList();

			Iterator<?> iterator = cl.iterator();
			while (iterator.hasNext()) {
				Zeitverteilung zeitverteilung = (Zeitverteilung) iterator.next();

				// SP9594
				if (zeitverteilung.getArtikelIId() == null) {
					zeitverteilung.setArtikelIId(zeitverteilungDto.getArtikelIId());
				}
				// Aufgrund PJ20756 auskommentiert
				// zeitverteilung.setMaschineIId(zeitverteilungDto.getMaschineIId());

				em.merge(zeitverteilung);
				em.flush();
			}

		}

		return zeitverteilungDto.getIId();
	}

	public void pflegeUmstellungAufVonBisErfassung(TheClientDto theClientDto) {

		HashMap<Integer, TreeMap<java.util.Date, TreeMap<java.sql.Timestamp, FLRZeitdaten>>> hmPersonal = new HashMap<Integer, TreeMap<java.util.Date, TreeMap<java.sql.Timestamp, FLRZeitdaten>>>();

		String sQuery = "SELECT z FROM FLRZeitdaten z WHERE z.c_belegartnr IS NOT NULL AND z.i_belegartid IS NOT NULL ORDER BY z.personal_i_id, z.t_zeit";

		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();

		org.hibernate.Query inventurliste = session.createQuery(sQuery);

		List<?> resultList = inventurliste.list();

		Iterator<?> resultListIterator = resultList.iterator();

		while (resultListIterator.hasNext()) {
			FLRZeitdaten zeitdaten = (FLRZeitdaten) resultListIterator.next();

			TreeMap<java.util.Date, TreeMap<java.sql.Timestamp, FLRZeitdaten>> tmDaten = null;

			if (hmPersonal.containsKey(zeitdaten.getPersonal_i_id())) {
				tmDaten = hmPersonal.get(zeitdaten.getPersonal_i_id());
			} else {
				tmDaten = new TreeMap<java.util.Date, TreeMap<java.sql.Timestamp, FLRZeitdaten>>();
			}

			java.util.Date dTag = Helper.cutDate(zeitdaten.getT_zeit());

			TreeMap<java.sql.Timestamp, FLRZeitdaten> tmTage = null;
			if (tmDaten.containsKey(dTag)) {
				tmTage = tmDaten.get(dTag);
			} else {
				tmTage = new TreeMap<java.sql.Timestamp, FLRZeitdaten>();
			}

			tmTage.put(new java.sql.Timestamp(zeitdaten.getT_zeit().getTime()), zeitdaten);

			tmDaten.put(dTag, tmTage);
			hmPersonal.put(zeitdaten.getPersonal_i_id(), tmDaten);

		}

		// Daten sind nun nach Personal und Tagen getrennt

		// Auftraege muessen durch ENDE als bis abgeschlossen werden

		Integer taetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();

		Iterator<Integer> itPersonen = hmPersonal.keySet().iterator();
		while (itPersonen.hasNext()) {
			Integer personalIId = itPersonen.next();

			TreeMap<java.util.Date, TreeMap<java.sql.Timestamp, FLRZeitdaten>> tmDaten = hmPersonal.get(personalIId);

			Iterator<java.util.Date> itDatum = tmDaten.keySet().iterator();

			while (itDatum.hasNext()) {
				java.util.Date datum = itDatum.next();

				TreeMap<java.sql.Timestamp, FLRZeitdaten> tmTagesdaten = tmDaten.get(datum);

				Iterator<java.sql.Timestamp> itTagesdaten = tmTagesdaten.keySet().iterator();

				while (itTagesdaten.hasNext()) {

					Timestamp t = itTagesdaten.next();

					FLRZeitdaten zeiteintrag = tmTagesdaten.get(t);

					// Nun die naechste Zeitbuchung suchen

					// Wenn dies kein ende ist, dann nachtragen

					Timestamp tMorgen = Helper
							.cutTimestamp(Helper.addiereTageZuTimestamp(new Timestamp(t.getTime()), 1));

					String sQuery2 = "SELECT z FROM FLRZeitdaten z WHERE z.personal_i_id=" + personalIId
							+ " AND z.t_zeit>'" + Helper.formatTimestampWithSlashes(t) + "' AND z.t_zeit <'"
							+ Helper.formatTimestampWithSlashes(tMorgen) + "' ORDER BY z.t_zeit ASC";

					SessionFactory factory2 = FLRSessionFactory.getFactory();
					Session session2 = factory2.openSession();

					org.hibernate.Query naechsteZeitbuchung = session2.createQuery(sQuery2);
					naechsteZeitbuchung.setMaxResults(1);

					List<?> resultList2 = naechsteZeitbuchung.list();

					Iterator<?> resultListIterator2 = resultList2.iterator();

					// wenn die naechste Buchung kein Ende ist, bzw keine
					// Buchung vorhanden ist, dann kurz davor ein Ende
					// nachtragen

					java.sql.Timestamp tEnde = null;

					if (resultListIterator2.hasNext()) {
						FLRZeitdaten zeitdaten = (FLRZeitdaten) resultListIterator2.next();

						if (zeitdaten.getTaetigkeit_i_id() != null
								&& zeitdaten.getTaetigkeit_i_id().equals(taetigkeitIId_Ende)) {
							// Naechste Taetigkeit ist ein ENDE
						} else {
							// Ende 10 ms vorher nachtragen
							tEnde = new java.sql.Timestamp(zeitdaten.getT_zeit().getTime() - 10);
						}

					} else {
						// Nachtragen
						// ende am ende des Tages
						tEnde = new java.sql.Timestamp(tMorgen.getTime() - 10);
					}

					if (tEnde != null) {
						PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
						Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_ZEITDATEN);

						Zeitdaten zEnde = new Zeitdaten(pk, personalIId, tEnde, Helper.boolean2Short(false),
								theClientDto.getIDPersonal(), theClientDto.getIDPersonal(),
								Helper.boolean2Short(false));
						zEnde.setTaetigkeitIId(taetigkeitIId_Ende);
						em.persist(zEnde);
						em.flush();

					}

					session2.close();

				}

			}

		}

	}

	public void removeTaetigkeit(TaetigkeitDto taetigkeitDto) throws EJBExceptionLP {
		myLogger.entry();
		if (taetigkeitDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("taetigkeitDto == null"));
		}
		if (taetigkeitDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("taetigkeitDto.getIId() == null"));
		}

		Taetigkeit taetigkeit = em.find(Taetigkeit.class, taetigkeitDto.getIId());

		if (taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ARZT)
				|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_BEHOERDE)
				|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ENDE)
				|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_GEHT)
				|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KOMMT)
				|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KRANK)
				|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_URLAUBSANTRAG)
				|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ZAANTRAG)
				|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KRANKANTRAG)
				|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KINDKRANK)
				|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_TELEFON)
				|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_UNTER)
				|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_URLAUB)
				|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ZEITAUSGLEICH)) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, new Exception("DARF_NICHT_GELOESCHT_WERDEN"));

		}
		// try {
		try {
			Query query = em.createNamedQuery("TaetigkeitsprfindByTaetigkeitIId");
			query.setParameter(1, taetigkeitDto.getIId());
			Collection<?> allTaetigkeitspr = query.getResultList();
			Iterator<?> iter = allTaetigkeitspr.iterator();
			while (iter.hasNext()) {
				Taetigkeitspr taetigkeitsprTemp = (Taetigkeitspr) iter.next();
				em.remove(taetigkeitsprTemp);
			}

			em.remove(taetigkeit);
			em.flush();
		} catch (EntityExistsException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, ex);
		}
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FIND, e);
		// }
	}

	public void updateTaetigkeit(TaetigkeitDto taetigkeitDto, TheClientDto theClientDto) throws EJBExceptionLP {
		if (taetigkeitDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("taetigkeitDto == null"));
		}
		if (taetigkeitDto.getIId() == null || taetigkeitDto.getCNr() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("taetigkeitDto.getIId() == null || taetigkeitDto.getCNr() == null"));
		}
		if (taetigkeitDto.getBBdebuchbar() == null || taetigkeitDto.getFBezahlt() == null
				|| taetigkeitDto.getBFeiertag() == null || taetigkeitDto.getBTagbuchbar() == null
				|| taetigkeitDto.getBVersteckt() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN, new Exception(
					"taetigkeitDto.getBBdebuchbar() == null || taetigkeitDto.getFBezahlt() == null || taetigkeitDto.getBFeiertag() == null || taetigkeitDto.getBTagbuchbar() == null"));
		}

		taetigkeitDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		taetigkeitDto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));

		Integer iId = taetigkeitDto.getIId();
		// try {
		Taetigkeit taetigkeit = em.find(Taetigkeit.class, iId);
		if (taetigkeit == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		try {
			Query query = em.createNamedQuery("TaetigkeitfindByCNr");
			query.setParameter(1, taetigkeitDto.getCNr());
			Integer iIdVorhanden = ((Taetigkeit) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_TAETIGKEIT.CNR"));
			}

		} catch (NoResultException ex) {
			//
		}

		// Eigenschaften nur bei Taetigken AUSSER KOMMT, GEHT, UNTER, ENDE

		if (taetigkeitDto.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KOMMT)
				|| taetigkeitDto.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_GEHT)
				|| taetigkeitDto.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_UNTER)
				|| taetigkeitDto.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_TELEFON)
				|| taetigkeitDto.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ENDE)) {

			taetigkeit.setBBdebuchbar(taetigkeitDto.getBBdebuchbar());
			taetigkeit.setBTagbuchbar(Helper.boolean2Short(false));

		} else {
			setTaetigkeitFromTaetigkeitDto(taetigkeit, taetigkeitDto);
		}
		if (taetigkeitDto.getTaetigkeitsprDto() != null) {
			// try {
			Taetigkeitspr taetigkeitspr = em.find(Taetigkeitspr.class,
					new TaetigkeitsprPK(iId, theClientDto.getLocUiAsString()));
			if (taetigkeitspr == null) {
				try {

					taetigkeitspr = new Taetigkeitspr(iId, theClientDto.getLocUiAsString());
					em.persist(taetigkeitspr);
					em.flush();
					setTaetigkeitsprFromTaetigkeitsprDto(taetigkeitspr, taetigkeitDto.getTaetigkeitsprDto());
				} catch (EntityExistsException e) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, "");
				}
			}
			setTaetigkeitsprFromTaetigkeitsprDto(taetigkeitspr, taetigkeitDto.getTaetigkeitsprDto());
			// }
			// catch (NoResultException ex) {
			// try {

			// Taetigkeitspr taetigkeitspr = new
			// Taetigkeitspr(iId,getTheClient(idUser).getLocUiAsString());
			// em.persist(taetigkeitspr);
			// setTaetigkeitsprFromTaetigkeitsprDto(taetigkeitspr,
			// taetigkeitDto.getTaetigkeitsprDto());
			// }
			// catch (CreateException e) {
			// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN,
			// e);
			// }
			// }
		}

		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }

	}

	public TaetigkeitDto taetigkeitFindByCNr(String cNr, TheClientDto theClientDto) {
		// check2(idUser);
		if (cNr == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN, new Exception("cNr == null"));
		}
		try {
			Query query = em.createNamedQuery("TaetigkeitfindByCNr");
			query.setParameter(1, cNr);
			Taetigkeit taetigkeit = (Taetigkeit) query.getSingleResult();
			TaetigkeitDto tDto = assembleTaetigkeitDto(taetigkeit);

			Taetigkeitspr taetigkeitspr = em.find(Taetigkeitspr.class,
					new TaetigkeitsprPK(taetigkeit.getIId(), theClientDto.getLocMandantAsString()));
			if (taetigkeitspr != null) {
				tDto.setTaetigkeitsprDto(assembleTaetigkeitsprDto(taetigkeitspr));
			}
			return tDto;
		} catch (NoResultException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, ex);

		}
	}

	public TaetigkeitDto taetigkeitFindByCNrSmallOhneExc(String cnr) throws EJBExceptionLP {
		Validator.notEmpty(cnr, "cnr");

		try {
			Query query = em.createNamedQuery("TaetigkeitfindByCNr");
			query.setParameter(1, cnr);
			Taetigkeit taetigkeit = (Taetigkeit) query.getSingleResult();
			TaetigkeitDto tDto = assembleTaetigkeitDto(taetigkeit);
			return tDto;
		} catch (NoResultException ex) {
		}

		return null;
	}

	public TaetigkeitDto taetigkeitFindByPrimaryKey(Integer iId, TheClientDto theClientDto) throws EJBExceptionLP {

		if (iId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}
		// try {
		Taetigkeit taetigkeit = em.find(Taetigkeit.class, iId);
		if (taetigkeit == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		TaetigkeitDto taetigkeitDto = assembleTaetigkeitDto(taetigkeit);
		TaetigkeitsprDto taetigkeitsprDto = null;
		// try {
		Taetigkeitspr taetigkeitspr = em.find(Taetigkeitspr.class,
				new TaetigkeitsprPK(iId, theClientDto.getLocUiAsString()));
		if (taetigkeitspr != null) {
			taetigkeitsprDto = assembleTaetigkeitsprDto(taetigkeitspr);
		}

		if (taetigkeitsprDto == null) {
			// try {
			Taetigkeitspr temp = em.find(Taetigkeitspr.class,
					new TaetigkeitsprPK(iId, theClientDto.getLocMandantAsString()));
			if (temp != null) {
				taetigkeitsprDto = assembleTaetigkeitsprDto(temp);
			}

		}

		if (taetigkeitsprDto == null) {
			// try {
			Taetigkeitspr temp = em.find(Taetigkeitspr.class,
					new TaetigkeitsprPK(iId, theClientDto.getLocKonzernAsString()));
			if (temp != null) {
				taetigkeitsprDto = assembleTaetigkeitsprDto(temp);
			}

		}
		taetigkeitDto.setTaetigkeitsprDto(taetigkeitsprDto);
		return taetigkeitDto;
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }

	}

	private void setMaschinenzeitdatenFromMaschinenzeitdatenDto(Maschinenzeitdaten maschinenzeitdaten,
			MaschinenzeitdatenDto maschinenzeitdatenDto) {
		maschinenzeitdaten.setCBemerkung(maschinenzeitdatenDto.getCBemerkung());
		maschinenzeitdaten.setLossollarbeitsplanIId(maschinenzeitdatenDto.getLossollarbeitsplanIId());
		maschinenzeitdaten.setMaschineIId(maschinenzeitdatenDto.getMaschineIId());
		maschinenzeitdaten.setPersonalIIdAendern(maschinenzeitdatenDto.getPersonalIIdAendern());
		maschinenzeitdaten.setPersonalIIdAnlegen(maschinenzeitdatenDto.getPersonalIIdAnlegen());
		maschinenzeitdaten.setPersonalIIdGestartet(maschinenzeitdatenDto.getPersonalIIdGestartet());
		maschinenzeitdaten.setTAendern(maschinenzeitdatenDto.getTAendern());
		maschinenzeitdaten.setTAnlegen(maschinenzeitdatenDto.getTAnlegen());
		maschinenzeitdaten.setTBis(maschinenzeitdatenDto.getTBis());
		maschinenzeitdaten.setTVon(maschinenzeitdatenDto.getTVon());
		maschinenzeitdaten.setFVerrechenbar(maschinenzeitdatenDto.getFVerrechenbar());
		maschinenzeitdaten.setPersonalIIdErledigt(maschinenzeitdatenDto.getPersonalIIdErledigt());
		maschinenzeitdaten.setTErledigt(maschinenzeitdatenDto.getTErledigt());
		maschinenzeitdaten.setBParallel(maschinenzeitdatenDto.getBParallel());
		em.merge(maschinenzeitdaten);
		em.flush();
	}

	private void setTaetigkeitFromTaetigkeitDto(Taetigkeit taetigkeit, TaetigkeitDto taetigkeitDto) {
		taetigkeit.setCNr(taetigkeitDto.getCNr());
		taetigkeit.setTaetigkeitartCNr(taetigkeitDto.getTaetigkeitartCNr());
		taetigkeit.setBBdebuchbar(taetigkeitDto.getBBdebuchbar());
		taetigkeit.setBFeiertag(taetigkeitDto.getBFeiertag());
		taetigkeit.setFBezahlt(taetigkeitDto.getFBezahlt());
		taetigkeit.setBTagbuchbar(taetigkeitDto.getBTagbuchbar());
		taetigkeit.setISort(taetigkeitDto.getISort());
		taetigkeit.setPersonalIIdAendern(taetigkeitDto.getPersonalIIdAendern());
		taetigkeit.setTAendern(taetigkeitDto.getTAendern());
		taetigkeit.setIWarnmeldunginkalendertagen(taetigkeitDto.getIWarnmeldunginkalendertagen());
		taetigkeit.setCImportkennzeichen(taetigkeitDto.getCImportkennzeichen());
		taetigkeit.setBUnterbrichtwarnmeldung(taetigkeitDto.getBUnterbrichtwarnmeldung());
		taetigkeit.setbVersteckt(taetigkeitDto.getBVersteckt());
		taetigkeit.setBDarfSelberBuchen(taetigkeitDto.getBDarfSelberBuchen());
		taetigkeit.setAbwesenheitsartIId(taetigkeitDto.getAbwesenheitsartIId());
		em.merge(taetigkeit);
		em.flush();
	}

	private TaetigkeitDto assembleTaetigkeitDto(Taetigkeit taetigkeit) {
		return TaetigkeitDtoAssembler.createDto(taetigkeit);
	}

	private TaetigkeitDto[] assembleTaetigkeitDtos(Collection<?> taetigkeits) {
		List<TaetigkeitDto> list = new ArrayList<TaetigkeitDto>();
		if (taetigkeits != null) {
			Iterator<?> iterator = taetigkeits.iterator();
			while (iterator.hasNext()) {
				Taetigkeit taetigkeit = (Taetigkeit) iterator.next();
				list.add(assembleTaetigkeitDto(taetigkeit));
			}
		}
		TaetigkeitDto[] returnArray = new TaetigkeitDto[list.size()];
		return (TaetigkeitDto[]) list.toArray(returnArray);
	}

	private void setTaetigkeitsprFromTaetigkeitsprDto(Taetigkeitspr taetigkeitspr, TaetigkeitsprDto taetigkeitsprDto) {
		taetigkeitspr.setCBez(taetigkeitsprDto.getCBez());
		em.merge(taetigkeitspr);
		em.flush();
	}

	private TaetigkeitsprDto assembleTaetigkeitsprDto(Taetigkeitspr taetigkeitspr) {
		return TaetigkeitsprDtoAssembler.createDto(taetigkeitspr);
	}

	private TaetigkeitsprDto[] assembleTaetigkeitsprDtos(Collection<?> taetigkeitsprs) {
		List<TaetigkeitsprDto> list = new ArrayList<TaetigkeitsprDto>();
		if (taetigkeitsprs != null) {
			Iterator<?> iterator = taetigkeitsprs.iterator();
			while (iterator.hasNext()) {
				Taetigkeitspr taetigkeitspr = (Taetigkeitspr) iterator.next();
				list.add(assembleTaetigkeitsprDto(taetigkeitspr));
			}
		}
		TaetigkeitsprDto[] returnArray = new TaetigkeitsprDto[list.size()];
		return (TaetigkeitsprDto[]) list.toArray(returnArray);
	}

	public boolean esGibtBereitsPersonalOderMaschinenzeitdaten(Integer maschineIId, TheClientDto theClientDto) {
		boolean b = false;

		String sQuery = "SELECT count(mz) FROM FLRMaschinenzeitdaten mz WHERE mz.maschine_i_id=" + maschineIId;

		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();
		org.hibernate.Query inventurliste = session.createQuery(sQuery);
		List<?> resultList = inventurliste.list();
		Iterator<?> resultListIterator = resultList.iterator();

		if (resultListIterator.hasNext()) {
			Long l = (Long) resultListIterator.next();
			if (l != null && l > 0) {
				return true;
			}
		}

		sQuery = "SELECT count(mz) FROM FLRZeitdaten mz WHERE mz.flrmaschine.i_id=" + maschineIId;

		session = factory.openSession();
		inventurliste = session.createQuery(sQuery);
		resultList = inventurliste.list();
		resultListIterator = resultList.iterator();

		if (resultListIterator.hasNext()) {
			Long l = (Long) resultListIterator.next();
			if (l != null && l > 0) {
				return true;
			}
		}

		return b;
	}

	public void createTaetigkeitart(TaetigkeitartDto taetigkeitartDto, TheClientDto theClientDto)
			throws EJBExceptionLP {
		if (taetigkeitartDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("taetigkeitartDto == null"));
		}
		if (taetigkeitartDto.getCNr() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("taetigkeitartDto.getCNr() == null"));
		}
		try {
			Taetigkeitart taetigkeitart = new Taetigkeitart(taetigkeitartDto.getCNr());
			em.persist(taetigkeitart);
			em.flush();
			setTaetigkeitartFromTaetigkeitartDto(taetigkeitart, taetigkeitartDto);
			if (taetigkeitartDto.getTaetigkeitartsprDto() != null) {
				Taetigkeitartspr taetigkeitartspr = new Taetigkeitartspr(theClientDto.getLocMandantAsString(),
						taetigkeitartDto.getCNr());
				em.persist(taetigkeitartspr);
				em.flush();
				setTaetigkeitartsprFromTaetigkeitartsprDto(taetigkeitartspr, taetigkeitartDto.getTaetigkeitartsprDto());
			}
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
	}

	public void removeTaetigkeitart(String cNr) throws EJBExceptionLP {
		// try {
		Taetigkeitart toRemove = em.find(Taetigkeitart.class, cNr);
		if (toRemove == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		try {
			em.remove(toRemove);
			em.flush();
		} catch (EntityExistsException er) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, er);
		}
		// }
		// catch (RemoveException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, ex);
		// }

	}

	public void removeTaetigkeitart(TaetigkeitartDto taetigkeitartDto) throws EJBExceptionLP {
		if (taetigkeitartDto != null) {
			String cNr = taetigkeitartDto.getCNr();
			removeTaetigkeitart(cNr);
		}
	}

	public void updateTaetigkeitart(TaetigkeitartDto taetigkeitartDto) throws EJBExceptionLP {
		if (taetigkeitartDto != null) {
			String cNr = taetigkeitartDto.getCNr();

			Taetigkeitart taetigkeitart = em.find(Taetigkeitart.class, cNr);
			if (taetigkeitart == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
			}
			setTaetigkeitartFromTaetigkeitartDto(taetigkeitart, taetigkeitartDto);

		}
	}

	public void updateMaschinenzeitdaten(MaschinenzeitdatenDto maschinenzeitdatenDto, TheClientDto theClientDto) {

		maschinenzeitdatenDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		maschinenzeitdatenDto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));

		Maschinenzeitdaten maschinenzeitdaten = em.find(Maschinenzeitdaten.class, maschinenzeitdatenDto.getIId());

		// PJ20872
		sindEintraegeBereitsVerrechnet(null, maschinenzeitdaten.getIId(), null, null, null);
		Integer abrechnungsvorschlagIIdVorhanden = getAbrechnungsvorschlagFac()
				.sindEintraegeInAbrechnungsvorschlag(null, maschinenzeitdaten.getIId(), null, null, null, theClientDto);

		try {
			Lossollarbeitsplan lsa = em.find(Lossollarbeitsplan.class,
					maschinenzeitdatenDto.getLossollarbeitsplanIId());
			getFertigungFac().setzeLosablieferungenAufNeuBerechnen(lsa.getLosIId(), theClientDto);
		} catch (RemoteException e) {
			throwEJBExceptionLPRespectOld(e);
		}

		if (maschinenzeitdaten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		setMaschinenzeitdatenFromMaschinenzeitdatenDto(maschinenzeitdaten, maschinenzeitdatenDto);
		// PJ20872
		if (abrechnungsvorschlagIIdVorhanden != null) {
			getAbrechnungsvorschlagFac().erstelleAbrechnungsvorschlagMaschinenzeitdaten(null,
					abrechnungsvorschlagIIdVorhanden, theClientDto);
		}
	}

	public TaetigkeitartDto taetigkeitartFindByPrimaryKey(String cNr) throws EJBExceptionLP {
		// try {
		Taetigkeitart taetigkeitart = em.find(Taetigkeitart.class, cNr);
		if (taetigkeitart == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleTaetigkeitartDto(taetigkeitart);
		// }
		// catch (NoResultException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
		// ex);
		// }

	}

	private void setTaetigkeitartFromTaetigkeitartDto(Taetigkeitart taetigkeitart, TaetigkeitartDto taetigkeitartDto) {
		em.merge(taetigkeitart);
		em.flush();
	}

	private TaetigkeitartDto assembleTaetigkeitartDto(Taetigkeitart taetigkeitart) {
		return TaetigkeitartDtoAssembler.createDto(taetigkeitart);
	}

	private TaetigkeitartDto[] assembleTaetigkeitartDtos(Collection<?> taetigkeitarts) {
		List<TaetigkeitartDto> list = new ArrayList<TaetigkeitartDto>();
		if (taetigkeitarts != null) {
			Iterator<?> iterator = taetigkeitarts.iterator();
			while (iterator.hasNext()) {
				Taetigkeitart taetigkeitart = (Taetigkeitart) iterator.next();
				list.add(assembleTaetigkeitartDto(taetigkeitart));
			}
		}
		TaetigkeitartDto[] returnArray = new TaetigkeitartDto[list.size()];
		return (TaetigkeitartDto[]) list.toArray(returnArray);
	}

	private MaschinenzeitdatenDto[] assembleMaschinenzeitdatenDtos(Collection<?> taetigkeitarts) {
		List<MaschinenzeitdatenDto> list = new ArrayList<MaschinenzeitdatenDto>();
		if (taetigkeitarts != null) {
			Iterator<?> iterator = taetigkeitarts.iterator();
			while (iterator.hasNext()) {
				Maschinenzeitdaten taetigkeitart = (Maschinenzeitdaten) iterator.next();
				list.add(assembleMaschinenzeitdatenDto(taetigkeitart));
			}
		}
		MaschinenzeitdatenDto[] returnArray = new MaschinenzeitdatenDto[list.size()];
		return (MaschinenzeitdatenDto[]) list.toArray(returnArray);
	}

	private void setTaetigkeitartsprFromTaetigkeitartsprDto(Taetigkeitartspr taetigkeitartspr,
			TaetigkeitartsprDto taetigkeitartsprDto) {
		taetigkeitartspr.setCBez(taetigkeitartsprDto.getCBez());
		em.merge(taetigkeitartspr);
		em.flush();
	}

	private TaetigkeitartsprDto assembleTaetigkeitartsprDto(Taetigkeitartspr taetigkeitartspr) {
		return TaetigkeitartsprDtoAssembler.createDto(taetigkeitartspr);
	}

	private TaetigkeitartsprDto[] assembleTaetigkeitartsprDtos(Collection<?> taetigkeitartsprs) {
		List<TaetigkeitartsprDto> list = new ArrayList<TaetigkeitartsprDto>();
		if (taetigkeitartsprs != null) {
			Iterator<?> iterator = taetigkeitartsprs.iterator();
			while (iterator.hasNext()) {
				Taetigkeitartspr taetigkeitartspr = (Taetigkeitartspr) iterator.next();
				list.add(assembleTaetigkeitartsprDto(taetigkeitartspr));
			}
		}
		TaetigkeitartsprDto[] returnArray = new TaetigkeitartsprDto[list.size()];
		return (TaetigkeitartsprDto[]) list.toArray(returnArray);
	}

	/**
	 * holt die Zeitmodell-Sollzeit zu einem best. Datum und einer bestimmten Person
	 * 
	 * @deprecated use getZeitmodelltagZuDatum()...
	 * @param personalDto          das Personal
	 * @param d_datum              Sprachkurzzeichen (zB DE oder EN)
	 * @param tagesartIId_Feiertag Integer
	 * @param tagesartIId_Halbtag  Integer
	 * @param theClientDto         User-ID
	 * @param bSollzeit            boolean
	 * @return Die Partnerart
	 * @throws EJBExceptionLP
	 */
	protected java.sql.Time getSollzeitZuDatum(PersonalDto personalDto, java.sql.Timestamp d_datum,
			Integer tagesartIId_Feiertag, Integer tagesartIId_Halbtag, TheClientDto theClientDto, boolean bSollzeit)
			throws EJBExceptionLP {
		d_datum = Helper.cutTimestamp(d_datum);
		java.sql.Time u_sollzeit = null;

		PersonalzeitmodellDto personalzeitmodellDto = null;
		try {
			personalzeitmodellDto = getPersonalFac().personalzeitmodellFindZeitmodellZuDatum(personalDto.getIId(),
					d_datum, theClientDto);
		} catch (RemoteException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		}

		Calendar c = Calendar.getInstance();
		c.setTime(d_datum);
		Integer tagesartIId = null;
		u_sollzeit = null;
		try {
			Query query = em.createNamedQuery("TagesartfindByCNr");
			query.setParameter(1, Helper.holeTagbezeichnungLang(c.get(Calendar.DAY_OF_WEEK)));
			Tagesart tagesart = (Tagesart) query.getSingleResult();
			tagesartIId = tagesart.getIId();

			BetriebskalenderDto dto = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(d_datum,
					theClientDto.getMandant(), theClientDto);
			if (dto != null) {
				// Wenn Religion NULL oder Religion gleich Religion in
				// Betriebskalender
				if (dto.getReligionIId() == null || dto.getReligionIId() == personalDto.getReligionIId()) {
					if (dto.getTagesartIId().equals(tagesartIId_Feiertag)
							|| dto.getTagesartIId().equals(tagesartIId_Halbtag)) {
						tagesartIId = dto.getTagesartIId();
					} else {
						tagesartIId = dto.getTagesartIId();
					}
				}
			}

			if (tagesartIId != null && personalzeitmodellDto != null) {
				if (bSollzeit == true) {
					Query query2 = em.createNamedQuery("ZeitmodelltagfindSollzeitZuTagesart");
					query2.setParameter(1, personalzeitmodellDto.getZeitmodellIId());
					query2.setParameter(2, tagesartIId);
					Zeitmodelltag zeitmodelltag = (Zeitmodelltag) query2.getSingleResult();
					u_sollzeit = zeitmodelltag.getUSollzeit();

				} else {
					Query query2 = em.createNamedQuery("ZeitmodelltagfindSollzeitZuTagesart");
					query2.setParameter(1, personalzeitmodellDto.getZeitmodellIId());
					query2.setParameter(2, tagesartIId);
					Zeitmodelltag zeitmodelltag = (Zeitmodelltag) query2.getSingleResult();
					u_sollzeit = zeitmodelltag.getUErlaubteanwesenheitszeit();

				}
			}
		} catch (NoResultException e) {
			u_sollzeit = null;
		}
		return u_sollzeit;
	}

	public boolean istUrlaubstagZuDatumNoetig(Integer personalIId, java.sql.Timestamp d_datum,
			TheClientDto theClientDto) throws EJBExceptionLP {
		d_datum = Helper.cutTimestamp(d_datum);
		boolean bTagNoetig = true;
		java.sql.Time u_sollzeit = null;

		PersonalzeitmodellDto personalzeitmodellDto = null;
		PersonalDto personalDto = null;
		try {
			personalzeitmodellDto = getPersonalFac().personalzeitmodellFindZeitmodellZuDatum(personalIId, d_datum,
					theClientDto);
			personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);
		} catch (RemoteException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		}

		Calendar c = Calendar.getInstance();
		c.setTime(d_datum);
		Integer tagesartIId = null;
		try {
			Query query = em.createNamedQuery("TagesartfindByCNr");
			query.setParameter(1, Helper.holeTagbezeichnungLang(c.get(Calendar.DAY_OF_WEEK)));
			Tagesart tagesart = (Tagesart) query.getSingleResult();
			tagesartIId = tagesart.getIId();

			BetriebskalenderDto dto = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(d_datum,
					theClientDto.getMandant(), theClientDto);

			// SP8370
			Integer tagesartIId_Betriebsurlab = tagesartFindByCNr(ZeiterfassungFac.TAGESART_BETRIEBSURLAUB,
					theClientDto).getIId();

			if (dto != null && !dto.getTagesartIId().equals(tagesartIId_Betriebsurlab)) {
				if (personalDto.getReligionIId() == null && dto.getReligionIId() == null) {
					tagesartIId = dto.getTagesartIId();
				} else if (personalDto.getReligionIId() != null && dto.getReligionIId() == null) {
					tagesartIId = dto.getTagesartIId();
				} else if (personalDto.getReligionIId() != null
						&& personalDto.getReligionIId().equals(dto.getReligionIId())) {
					tagesartIId = dto.getTagesartIId();
				}
			}

			if (tagesartIId != null && personalzeitmodellDto != null) {

				// SP4796
				Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto)
						.getIId();
				Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto)
						.getIId();
				if (tagesartIId.equals(tagesartIId_Halbtag)) {
					ZeitmodelltagDto zeitmodelltagDtoOriginaltag = getZeitmodelltagZuDatum(personalIId, d_datum,
							tagesartIId_Feiertag, tagesartIId_Halbtag, true, theClientDto);

					if (zeitmodelltagDtoOriginaltag != null && zeitmodelltagDtoOriginaltag.getUSollzeit() != null) {
						tagesartIId = zeitmodelltagDtoOriginaltag.getTagesartIId();
					}
				}

				Query query2 = em.createNamedQuery("ZeitmodelltagfindSollzeitZuTagesart");
				query2.setParameter(1, personalzeitmodellDto.getZeitmodellIId());
				query2.setParameter(2, tagesartIId);
				u_sollzeit = ((Zeitmodelltag) query2.getSingleResult()).getUSollzeit();
				if (u_sollzeit != null && u_sollzeit.getTime() > -3600000) {
					return true;
				} else {
					bTagNoetig = false;
				}
			}

		} catch (NoResultException e) {
			return false;
		}
		return bTagNoetig;
	}

	public ZeitmodelltagDto getZeitmodelltagDesFirmenzeitmodellsZuDatum(java.sql.Timestamp d_datum,
			TheClientDto theClientDto) {

		ZeitmodelltagDto zeitmodelltagDto = null;

		Integer zeitmodellIId = null;

		Query queryFZ = em.createNamedQuery("ZeitmodellfindByBFirmenzeitmodellMandantCNr");
		queryFZ.setParameter(1, new Short((short) 1));
		queryFZ.setParameter(2, theClientDto.getMandant());
		// @todo getSingleResult oder getResultList ?
		Collection coll = queryFZ.getResultList();
		if (coll.size() > 0) {

			zeitmodellIId = ((Zeitmodell) coll.iterator().next()).getIId();
			d_datum = Helper.cutTimestamp(d_datum);

			Calendar c = Calendar.getInstance();
			c.setTime(d_datum);
			Integer tagesartIId = null;
			try {
				Query query = em.createNamedQuery("TagesartfindByCNr");
				query.setParameter(1, Helper.holeTagbezeichnungLang(c.get(Calendar.DAY_OF_WEEK)));
				Tagesart tagesart = (Tagesart) query.getSingleResult();
				tagesartIId = tagesart.getIId();

				BetriebskalenderDto dto = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(d_datum,
						theClientDto.getMandant(), theClientDto);
				if (dto != null) {
					tagesartIId = dto.getTagesartIId();
				}

				if (tagesartIId != null && zeitmodellIId != null) {

					Query query2 = em.createNamedQuery("ZeitmodelltagfindSollzeitZuTagesart");
					query2.setParameter(1, zeitmodellIId);
					query2.setParameter(2, tagesartIId);
					zeitmodelltagDto = assembleZeitmodelltagDto((Zeitmodelltag) query2.getSingleResult());
				}
			} catch (NoResultException e) {
				zeitmodelltagDto = new ZeitmodelltagDto();
			}
		}

		return zeitmodelltagDto;
	}

	public ZeitmodelltagDto getZeitmodelltagFirmenzeitmodellZuDatum(Integer zeitmodellIId, java.sql.Timestamp d_datum,
			TheClientDto theClientDto) {
		d_datum = Helper.cutTimestamp(d_datum);
		ZeitmodelltagDto zeitmodelltagDto = new ZeitmodelltagDto();

		Calendar c = Calendar.getInstance();
		c.setTime(d_datum);
		Integer tagesartIId = null;
		try {
			Query query = em.createNamedQuery("TagesartfindByCNr");
			query.setParameter(1, Helper.holeTagbezeichnungLang(c.get(Calendar.DAY_OF_WEEK)));
			Tagesart tagesart = (Tagesart) query.getSingleResult();
			tagesartIId = tagesart.getIId();

			BetriebskalenderDto dto = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(d_datum,
					theClientDto.getMandant(), theClientDto);
			if (dto != null) {
				tagesartIId = dto.getTagesartIId();
			}

			if (tagesartIId != null && zeitmodellIId != null) {

				Query query2 = em.createNamedQuery("ZeitmodelltagfindSollzeitZuTagesart");
				query2.setParameter(1, zeitmodellIId);
				query2.setParameter(2, tagesartIId);
				zeitmodelltagDto = assembleZeitmodelltagDto((Zeitmodelltag) query2.getSingleResult());
			}
		} catch (NoResultException e) {
			zeitmodelltagDto = new ZeitmodelltagDto();
		}
		return zeitmodelltagDto;
	}

	public ZeitmodelltagDto getZeitmodelltagZuDatum(Integer personalIId, java.sql.Timestamp d_datum,
			Integer tagesartIId_Feiertag, Integer tagesartIId_Halbtag, boolean bOriginaltagWennHalberFeiertag,
			TheClientDto theClientDto) throws EJBExceptionLP {
		d_datum = Helper.cutTimestamp(d_datum);
		ZeitmodelltagDto zeitmodelltagDto = new ZeitmodelltagDto();

		String sQuery = "select pzm.flrzeitmodell.i_id FROM FLRPersonalzeitmodell pzm WHERE pzm.personal_i_id="
				+ personalIId + " AND pzm.t_gueltigab<='"
				+ Helper.formatDateWithSlashes(new java.sql.Date(d_datum.getTime()))
				+ "' ORDER BY pzm.t_gueltigab DESC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query gueltigesZm = session.createQuery(sQuery);
		gueltigesZm.setMaxResults(1);

		List<?> resultList = gueltigesZm.list();

		Iterator<?> resultListIterator = resultList.iterator();

		Integer zeitmodellIId = null;

		if (resultListIterator.hasNext()) {
			zeitmodellIId = (Integer) resultListIterator.next();

		}

		Personal personal = em.find(Personal.class, personalIId);

		Calendar c = Calendar.getInstance();
		c.setTime(d_datum);
		Integer tagesartIId = null;
		try {
			Query query = em.createNamedQuery("TagesartfindByCNr");
			query.setParameter(1, Helper.holeTagbezeichnungLang(c.get(Calendar.DAY_OF_WEEK)));
			Tagesart tagesart = (Tagesart) query.getSingleResult();
			tagesartIId = tagesart.getIId();

			BetriebskalenderDto dto = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(d_datum,
					theClientDto.getMandant(), theClientDto);
			if (dto != null) {

				// PJ20849 Betriebsurlaub ist fuer Monatsabrechnung irrelevant
				Integer tagesartIId_betriebsurlaub = tagesartFindByCNr(ZeiterfassungFac.TAGESART_BETRIEBSURLAUB,
						theClientDto).getIId();
				if (!dto.getTagesartIId().equals(tagesartIId_betriebsurlaub)) {
					// Wenn Religion NULL oder Religion gleich Religion in
					// Betriebskalender
					if (dto.getReligionIId() == null || dto.getReligionIId().equals(personal.getReligionIId())) {
						if (dto.getTagesartIId().equals(tagesartIId_Feiertag)
								|| dto.getTagesartIId().equals(tagesartIId_Halbtag)) {

							if (bOriginaltagWennHalberFeiertag == true
									&& dto.getTagesartIId().equals(tagesartIId_Halbtag)) {
								//
							} else {
								tagesartIId = dto.getTagesartIId();
							}

						} else {
							tagesartIId = dto.getTagesartIId();
						}
					}
				}

			}

			if (tagesartIId != null && zeitmodellIId != null) {

				Query query2 = em.createNamedQuery("ZeitmodelltagfindSollzeitZuTagesart");
				query2.setParameter(1, zeitmodellIId);
				query2.setParameter(2, tagesartIId);
				zeitmodelltagDto = assembleZeitmodelltagDto((Zeitmodelltag) query2.getSingleResult());
			}
		} catch (NoResultException e) {
			zeitmodelltagDto = new ZeitmodelltagDto();
		}
		return zeitmodelltagDto;
	}

	private BereitschafttagDto getBereitschafttagZuDatum(Integer personalIId, java.sql.Timestamp d_datum,
			Integer tagesartIId_Feiertag, Integer tagesartIId_Halbtag, boolean bOriginaltagWennHalberFeiertag,
			Integer bereitschaftartIId, TheClientDto theClientDto) throws EJBExceptionLP {
		d_datum = Helper.cutTimestamp(d_datum);
		BereitschafttagDto zeitmodelltagDto = new BereitschafttagDto();

		PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);

		Calendar c = Calendar.getInstance();
		c.setTime(d_datum);
		Integer tagesartIId = null;
		try {
			Query query = em.createNamedQuery("TagesartfindByCNr");
			query.setParameter(1, Helper.holeTagbezeichnungLang(c.get(Calendar.DAY_OF_WEEK)));
			Tagesart tagesart = (Tagesart) query.getSingleResult();
			tagesartIId = tagesart.getIId();

			BetriebskalenderDto dto = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(d_datum,
					theClientDto.getMandant(), theClientDto);
			if (dto != null) {
				// Wenn Religion NULL oder Religion gleich Religion in
				// Betriebskalender
				if (dto.getReligionIId() == null || dto.getReligionIId().equals(personalDto.getReligionIId())) {
					if (dto.getTagesartIId().equals(tagesartIId_Feiertag)
							|| dto.getTagesartIId().equals(tagesartIId_Halbtag)) {

						if (bOriginaltagWennHalberFeiertag == true
								&& dto.getTagesartIId().equals(tagesartIId_Halbtag)) {
							//
						} else {
							tagesartIId = dto.getTagesartIId();
						}

					} else {
						tagesartIId = dto.getTagesartIId();
					}
				}
			}

			if (tagesartIId != null && bereitschaftartIId != null) {

				Query query2 = em.createNamedQuery("BereitschafttagfindByBereitschaftartIIdTagesartIId");
				query2.setParameter(1, bereitschaftartIId);
				query2.setParameter(2, tagesartIId);
				zeitmodelltagDto = BereitschafttagDtoAssembler.createDto((Bereitschafttag) query2.getSingleResult());
			}
		} catch (NoResultException e) {
			zeitmodelltagDto = new BereitschafttagDto();
		}
		return zeitmodelltagDto;
	}

	/**
	 * holt die Zeitmodell-Sollzeit zu einem best. Datum und einer bestimmten Person
	 * 
	 * @param personalIId  Die sprachabh&auml;ngige Bezeichnung der Partnerart (zB
	 *                     Firma oder Company)
	 * @param d_datum      Sprachkurzzeichen (zB DE oder EN)
	 * @param theClientDto User-ID
	 * @return Die Partnerart
	 * @exception EJBExceptionLP
	 */
	protected java.sql.Time getSollzeitZuDatumWennFeiertag(Integer personalIId, java.sql.Timestamp d_datum,
			TheClientDto theClientDto) throws EJBExceptionLP {
		d_datum = Helper.cutTimestamp(d_datum);
		java.sql.Time u_sollzeit = null;

		PersonalzeitmodellDto personalzeitmodellDto = null;
		try {
			personalzeitmodellDto = getPersonalFac().personalzeitmodellFindZeitmodellZuDatum(personalIId, d_datum,
					theClientDto);
		} catch (RemoteException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		}

		Calendar c = Calendar.getInstance();
		c.setTime(d_datum);
		Integer tagesartIId = null;
		try {
			Query query = em.createNamedQuery("TagesartfindByCNr");
			query.setParameter(1, Helper.holeTagbezeichnungLang(c.get(Calendar.DAY_OF_WEEK)));
			Tagesart tagesart = (Tagesart) query.getSingleResult();
			tagesartIId = tagesart.getIId();
			Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
			Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();

			BetriebskalenderDto dto = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(d_datum,
					theClientDto.getMandant(), theClientDto);
			if (dto != null) {

				if (dto.getTagesartIId().equals(tagesartIId_Feiertag)
						|| dto.getTagesartIId().equals(tagesartIId_Halbtag)) {
					// tagesartIId=dto.getTagesartIId();
				} else {
					tagesartIId = dto.getTagesartIId();
				}
			}

			if (tagesartIId != null && personalzeitmodellDto != null) {
				Query query2 = em.createNamedQuery("ZeitmodelltagfindSollzeitZuTagesart");
				query2.setParameter(1, personalzeitmodellDto.getZeitmodellIId());
				query2.setParameter(2, tagesartIId);
				u_sollzeit = ((Zeitmodelltag) query2.getSingleResult()).getUSollzeit();
			}
		} catch (NoResultException e) {
			u_sollzeit = null;
		}
		return u_sollzeit;
	}

	public Integer getEntfernungInKmEinerReise(Integer reiseIId) {

		Reise r = em.find(Reise.class, reiseIId);

		if (Helper.short2boolean(r.getBBeginn())) {

			// SP7315 Wenn bei einem Beginn kein KB-Beginn hinterlegt ist, dann gibt auch
			// keine Entfernung
			if (r.getIKmbeginn() == null) {
				return null;
			}

			Session session2 = FLRSessionFactory.getFactory().openSession();
			String sQuery = "SELECT r FROM FLRReise r WHERE r.personal_i_id=" + r.getPersonalIId() + " AND r.t_zeit > '"
					+ Helper.formatTimestampWithSlashes(r.getTZeit())
					+ "' AND (r.i_kmbeginn IS NOT NULL OR r.i_kmende IS NOT NULL) ORDER BY r.t_zeit ASC";

			org.hibernate.Query q = session2.createQuery(sQuery);
			q.setMaxResults(1);
			List l = q.list();
			if (l.size() > 0) {

				FLRReise flrReiseNachfolger = (FLRReise) l.iterator().next();

				if (Helper.short2boolean(flrReiseNachfolger.getB_beginn())) {
					if (r.getIKmbeginn() != null && flrReiseNachfolger.getI_kmbeginn() != null) {
						return flrReiseNachfolger.getI_kmbeginn() - r.getIKmbeginn();
					}
				} else {
					if (flrReiseNachfolger.getI_kmende() != null && r.getIKmbeginn() != null) {
						return flrReiseNachfolger.getI_kmende() - r.getIKmbeginn();
					} else if (flrReiseNachfolger.getI_kmende() != null && r.getIKmbeginn() == null) {
						return flrReiseNachfolger.getI_kmende();
					}
				}

			}
		}

		return null;
	}

	/**
	 * Ermittelt ob dieser Tag ein Feiertag oder ein Sonntag ist
	 * 
	 * @param d_datum      Datum
	 * @param partner_i_id ID des Partners
	 * @param theClientDto User-ID
	 * @return Feiertag/Halbtag/Sonntag/null(Wenn kein Feiertag/Sonntag)
	 * @exception EJBExceptionLP
	 */
	public Integer istFeiertagOderSamstagSonntag(java.sql.Timestamp d_datum, Integer partner_i_id,
			TheClientDto theClientDto) throws EJBExceptionLP

	{
		d_datum = Helper.cutTimestamp(d_datum);
		Integer tagesartIId = null;

		BetriebskalenderDto dtoTemp = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(d_datum,
				theClientDto.getMandant(), theClientDto);
		if (dtoTemp != null) {
			tagesartIId = dtoTemp.getTagesartIId();
		}

		if (tagesartIId == null) {
			Calendar cKalendar = Calendar.getInstance();
			cKalendar.setTime(d_datum);

			if (cKalendar.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) {
				try {
					Query query = em.createNamedQuery("TagesartfindByCNr");
					query.setParameter(1, ZeiterfassungFac.TAGESART_SONNTAG);
					Tagesart tagesart = (Tagesart) query.getSingleResult();
					tagesartIId = tagesart.getIId();
				} catch (NoResultException ex2) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, ex2);
				}
			}
			if (cKalendar.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY) {
				try {
					Query query = em.createNamedQuery("TagesartfindByCNr");
					query.setParameter(1, ZeiterfassungFac.TAGESART_SONNTAG);
					Tagesart tagesart = (Tagesart) query.getSingleResult();
					tagesartIId = tagesart.getIId();
				} catch (NoResultException ex2) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, ex2);
				}
			}
		}

		return tagesartIId;
	}

	public Integer getTagesartZuDatum(Integer personalIId, java.sql.Timestamp d_datum, Integer tagesartIId_Feiertag,
			Integer tagesartIId_Halbtag, Integer tagesartIId_Betriebsurlaub, TheClientDto theClientDto)
			throws EJBExceptionLP {
		d_datum = Helper.cutTimestamp(d_datum);
		Personal personal = em.find(Personal.class, personalIId);

		Calendar c = Calendar.getInstance();
		c.setTime(d_datum);
		Integer tagesartIId = null;
		try {
			Query query = em.createNamedQuery("TagesartfindByCNr");
			query.setParameter(1, Helper.holeTagbezeichnungLang(c.get(Calendar.DAY_OF_WEEK)));
			Tagesart tagesart = (Tagesart) query.getSingleResult();
			tagesartIId = tagesart.getIId();

			BetriebskalenderDto dto = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(d_datum,
					theClientDto.getMandant(), theClientDto);
			if (dto != null) {
				// Wenn Religion NULL oder Religion gleich Religion in
				// Betriebskalender

				// PJ20849 Betriebsurlaub ist fuer Monatsabrechnung irrelevant
				if (dto.getTagesartIId().equals(tagesartIId_Betriebsurlaub)) {
					return tagesartIId;
				}

				if (dto.getReligionIId() == null || dto.getReligionIId().equals(personal.getReligionIId())) {
					if (dto.getTagesartIId().equals(tagesartIId_Feiertag)
							|| dto.getTagesartIId().equals(tagesartIId_Halbtag)) {
						tagesartIId = dto.getTagesartIId();
					} else {
						tagesartIId = dto.getTagesartIId();
					}
				}
			}

		} catch (NoResultException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, e);
		}
		return tagesartIId;
	}

	/**
	 * Pr&uuml;ft, ob die Zeitbuchungen zur aktuellen Zeit gebucht worden sind und
	 * setzt bManipuliert auf true, wenn die Buchungszeit um mehr als 2 Min von der
	 * aktuellen Zeit abweicht
	 * 
	 * @param i_id ID der Zeitbewegung
	 * @return boolean ob die Buchung manipuliert ist oder nicht
	 * @exception RemoteException
	 * @exception EJBExceptionLP
	 */
	public boolean istBuchungManipuliert(Integer i_id) throws EJBExceptionLP {
		boolean bManipuliert = false;
		// try {

		Zeitdaten zeitdaten = em.find(Zeitdaten.class, i_id);
		if (zeitdaten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");

		}

		java.sql.Timestamp t_zeit = zeitdaten.getTZeit();
		java.sql.Timestamp t_aendern = zeitdaten.getTAendern();
		if ((t_aendern.getTime() - t_zeit.getTime()) > 180000 || (t_aendern.getTime() - t_zeit.getTime()) < -180000) {
			bManipuliert = true;
		}

		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);

		// }
		return bManipuliert;
	}

	private BigDecimal getAlteUrlaubStunden(PersonalDto personalDto, java.sql.Timestamp dEintrittsdatum,
			java.sql.Timestamp dAktuellerUrlaubsbeginn, Integer tagesartIId_Feiertag, Integer tagesartIId_Halbtag,
			TheClientDto theClientDto) {

		// VERBRAUCHTE TAGE+HALBTAGE+STUNDEN in Stunden umgerechnet ALT:
		Integer iIdUrlaub = null;
		try {
			Query query = em.createNamedQuery("TaetigkeitfindByCNr");
			query.setParameter(1, ZeiterfassungFac.TAETIGKEIT_URLAUB);
			Taetigkeit taetigkeit = (Taetigkeit) query.getSingleResult();
			iIdUrlaub = taetigkeit.getIId();
		} catch (NoResultException ex7) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, ex7);
		}
		double dStundenAlt = 0;

		// try {
		Query query2 = em.createNamedQuery("SonderzeitenfindTageweiseUndHalbtageweiseTaetigkeitenAlt");
		query2.setParameter(1, personalDto.getIId());
		query2.setParameter(2, iIdUrlaub);
		query2.setParameter(3, dEintrittsdatum);
		query2.setParameter(4, dAktuellerUrlaubsbeginn);

		SonderzeitenDto[] altTageDtos = assembleSonderzeitenDtos(query2.getResultList());

		for (int i = 0; i < altTageDtos.length; i++) {

			Double d = Helper.time2Double(getSollzeitZuDatum(personalDto, altTageDtos[i].getTDatum(),
					tagesartIId_Feiertag, tagesartIId_Halbtag, theClientDto, true));
			if (d != null) {
				dStundenAlt = dStundenAlt + d.doubleValue();
			}
		}
		// }
		// catch (NoResultException ex) {
		// Keiner da
		// }
		// try {
		query2 = em.createNamedQuery("SonderzeitenfindStundenweiseTaetigkeitenAlt");
		query2.setParameter(1, personalDto.getIId());
		query2.setParameter(2, iIdUrlaub);
		query2.setParameter(3, dEintrittsdatum);
		query2.setParameter(4, dAktuellerUrlaubsbeginn);

		SonderzeitenDto[] altStundenDtos = assembleSonderzeitenDtos(query2.getResultList());
		for (int i = 0; i < altStundenDtos.length; i++) {
			Double d = Helper.time2Double(altStundenDtos[i].getUStunden());
			if (d != null) {
				dStundenAlt = dStundenAlt + d.doubleValue();
			}
		}
		// }
		// catch (NoResultException ex) {
		// Keiner da
		// }

		return new BigDecimal(dStundenAlt);
	}

	private BigDecimal getGeplanteUrlaubStunden(PersonalDto personalDto, java.sql.Timestamp dAbrechnungzeitpunkt,
			Integer tagesartIId_Feiertag, Integer tagesartIId_Halbtag, TheClientDto theClientDto) {

		// GEPLANTE TAGE+HALBTAGE+STUNDEN in Stunden umgerechnet:
		Integer iIdUrlaub = null;
		// try {
		Query query = em.createNamedQuery("TaetigkeitfindByCNr");
		query.setParameter(1, ZeiterfassungFac.TAETIGKEIT_URLAUB);
		Taetigkeit taetigkeit = (Taetigkeit) query.getSingleResult();
		if (taetigkeit == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		dAbrechnungzeitpunkt = Helper.cutTimestamp(dAbrechnungzeitpunkt);

		iIdUrlaub = taetigkeit.getIId();
		// }
		// catch (NoResultException ex7) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
		// ex7);
		// }
		double dStundenAlt = 0;

		// try {
		Query query2 = em.createNamedQuery("SonderzeitenfindTageweiseUndHalbtageweiseTaetigkeitenGeplant");
		query2.setParameter(1, personalDto.getIId());
		query2.setParameter(2, iIdUrlaub);
		query2.setParameter(3, dAbrechnungzeitpunkt);

		SonderzeitenDto[] altTageDtos = assembleSonderzeitenDtos(query2.getResultList());

		for (int i = 0; i < altTageDtos.length; i++) {

			ZeitmodelltagDto zeitmodelltagDto = getZeitmodelltagZuDatum(personalDto.getIId(),
					altTageDtos[i].getTDatum(), tagesartIId_Feiertag, tagesartIId_Halbtag, true, theClientDto);

			if (zeitmodelltagDto.getUSollzeit() != null) {

				Double d = Helper.time2Double(zeitmodelltagDto.getUSollzeit());

				if (Helper.short2boolean(altTageDtos[i].getBTag()) == true) {
					dStundenAlt = dStundenAlt + d.doubleValue();
				}
				if (Helper.short2boolean(altTageDtos[i].getBHalbtag()) == true) {
					double dTemp = d.doubleValue() / 2;
					dStundenAlt = dStundenAlt + dTemp;
				}
			}
		}
		// }
		// catch (NoResultException ex) {
		// Keiner da
		// }
		try {
			query2 = em.createNamedQuery("SonderzeitenfindStundenweiseTaetigkeitenGeplant");
			query2.setParameter(1, personalDto.getIId());
			query2.setParameter(2, iIdUrlaub);
			query2.setParameter(3, dAbrechnungzeitpunkt);

			SonderzeitenDto[] altStundenDtos = assembleSonderzeitenDtos(query2.getResultList());

			for (int i = 0; i < altStundenDtos.length; i++) {
				Double d = Helper.time2Double(altStundenDtos[i].getUStunden());
				if (d != null) {
					dStundenAlt = dStundenAlt + d.doubleValue();
				}
			}
		} catch (NoResultException ex) {
			// Keiner da
		}

		return new BigDecimal(dStundenAlt);
	}

	private BigDecimal getAktuelleUrlaubStunden(Integer personalIId, java.sql.Timestamp dAktuellerUrlaubsbeginn,
			java.sql.Timestamp dAbrechnungzeitpunkt, Integer tagesartIId_Feiertag, Integer tagesartIId_Halbtag,
			TheClientDto theClientDto) {
		// AKTUELLE TAGE+HALBTAGE+STUNDEN in Stunden umgerechnet:
		Integer iIdUrlaub = null;
		try {
			Query query = em.createNamedQuery("TaetigkeitfindByCNr");
			query.setParameter(1, ZeiterfassungFac.TAETIGKEIT_URLAUB);
			Taetigkeit taetigkeit = (Taetigkeit) query.getSingleResult();
			iIdUrlaub = taetigkeit.getIId();
		} catch (NoResultException ex7) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, ex7);
		}
		double dStundenAktuell = 0;

		// try {
		Query query2 = em.createNamedQuery("SonderzeitenfindTageweiseUndHalbtageweiseTaetigkeitenAktuell");
		query2.setParameter(1, personalIId);
		query2.setParameter(2, iIdUrlaub);
		query2.setParameter(3, dAktuellerUrlaubsbeginn);
		query2.setParameter(4, dAbrechnungzeitpunkt);

		SonderzeitenDto[] aktuellTageDtos = assembleSonderzeitenDtos(query2.getResultList());

		for (int i = 0; i < aktuellTageDtos.length; i++) {

			boolean bIstHalberFeiertag = false;

			BetriebskalenderDto dto = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(
					aktuellTageDtos[i].getTDatum(), theClientDto.getMandant(), theClientDto);

			if (dto != null) {

				if (dto.getTagesartIId().equals(tagesartIId_Halbtag)) {
					bIstHalberFeiertag = true;
				}
			}

			if (bIstHalberFeiertag) {
				ZeitmodelltagDto zeitmodelltagDtoOriginaltag = getZeitmodelltagZuDatum(personalIId,
						aktuellTageDtos[i].getTDatum(), tagesartIId_Feiertag, tagesartIId_Halbtag, true, theClientDto);

				if (zeitmodelltagDtoOriginaltag != null && zeitmodelltagDtoOriginaltag.getUSollzeit() != null) {

					BigDecimal dbHalbtagsUrlaub = null;
					if (Helper.short2boolean(aktuellTageDtos[i].getBHalbtag())) {
						dbHalbtagsUrlaub = new BigDecimal(
								Helper.time2Double(zeitmodelltagDtoOriginaltag.getUSollzeit()).doubleValue() / 2);
					} else {
						dbHalbtagsUrlaub = new BigDecimal(
								Helper.time2Double(zeitmodelltagDtoOriginaltag.getUSollzeit()).doubleValue());
					}

					dbHalbtagsUrlaub = Helper.rundeKaufmaennisch(dbHalbtagsUrlaub, 2);
					dStundenAktuell = dStundenAktuell + dbHalbtagsUrlaub.doubleValue();

				}
			} else {
				ZeitmodelltagDto zmTag = getZeitmodelltagZuDatum(personalIId, aktuellTageDtos[i].getTDatum(),
						tagesartIId_Feiertag, tagesartIId_Halbtag, false, theClientDto);

				Double d = Helper.time2Double(zmTag.getUSollzeit());
				if (d != null) {
					if (Helper.short2boolean(aktuellTageDtos[i].getBHalbtag())) {
						dStundenAktuell = dStundenAktuell + d.doubleValue() / 2;
					} else {
						dStundenAktuell = dStundenAktuell + d.doubleValue();
					}
				}
			}

		}
		// }
		// catch (NoResultException ex) {
		// Keiner da
		// }
		// try {
		query2 = em.createNamedQuery("SonderzeitenfindStundenweiseTaetigkeitenAktuell");
		query2.setParameter(1, personalIId);
		query2.setParameter(2, iIdUrlaub);
		query2.setParameter(3, dAktuellerUrlaubsbeginn);
		query2.setParameter(4, dAbrechnungzeitpunkt);

		SonderzeitenDto[] aktuellStundenDtos = assembleSonderzeitenDtos(query2.getResultList());

		for (int i = 0; i < aktuellStundenDtos.length; i++) {
			Double d = Helper.time2Double(aktuellStundenDtos[i].getUStunden());
			if (d != null) {
				dStundenAktuell = dStundenAktuell + d.doubleValue();
			}
		}
		// }
		// catch (NoResultException ex) {
		// Keiner da
		// }

		return new BigDecimal(dStundenAktuell);
	}

	private BigDecimal getAlterUrlaubTageweise(Integer personalIId, java.sql.Timestamp dEintrittsdatum,
			java.sql.Timestamp dAktuellerUrlaubsbeginn) {
		// VERBRAUCHTE TAGE+HALBTAGE ALT:
		Integer iIdUrlaub = null;
		try {
			Query query = em.createNamedQuery("TaetigkeitfindByCNr");
			query.setParameter(1, ZeiterfassungFac.TAETIGKEIT_URLAUB);
			Taetigkeit taetigkeit = (Taetigkeit) query.getSingleResult();
			// if (taetigkeit==null) {
			// throw new
			// EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
			// / null);
			// }
			iIdUrlaub = taetigkeit.getIId();
		} catch (NoResultException ex7) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, ex7);
		}

		double dAlterUrlaubTagesweise = 0;
		// Ganze Urlaubstage ALT holen
		Query query2 = em.createNamedQuery("SonderzeitenejbSelectGanztaegigeTaetigkeitenAlt");
		query2.setParameter(1, personalIId);
		query2.setParameter(2, iIdUrlaub);
		query2.setParameter(3, dEintrittsdatum);
		query2.setParameter(4, dAktuellerUrlaubsbeginn);

		Long urlAltTage = (Long) query2.getSingleResult();

		if (urlAltTage != null) {
			dAlterUrlaubTagesweise = dAlterUrlaubTagesweise + urlAltTage.doubleValue();
		}

		query2 = em.createNamedQuery("SonderzeitenejbSelectHalbtaegigeTaetigkeitenAlt");
		query2.setParameter(1, personalIId);
		query2.setParameter(2, iIdUrlaub);
		query2.setParameter(3, dEintrittsdatum);
		query2.setParameter(4, dAktuellerUrlaubsbeginn);
		Long urlAltHalbtage = (Long) query2.getSingleResult();

		if (urlAltHalbtage != null) {
			double dTemp = urlAltHalbtage.doubleValue() / 2;
			dAlterUrlaubTagesweise = dAlterUrlaubTagesweise + dTemp;

		}
		return new BigDecimal(dAlterUrlaubTagesweise);

	}

	public Map<String, String> getBebuchbareBelegarten(TheClientDto theClientDto) {

		boolean bHatAngebotszeiterfassung = false;
		boolean bHatProjektzeiterfassung = false;

		if (getMandantFac().darfAnwenderAufModulZugreifen(LocaleFac.BELEGART_PROJEKT, theClientDto) && getMandantFac()
				.darfAnwenderAufZusatzfunktionZugreifen(MandantFac.ZUSATZFUNKTION_PROJEKTZEITERFASSUNG, theClientDto)) {
			bHatProjektzeiterfassung = true;
		}
		if (getMandantFac().darfAnwenderAufModulZugreifen(LocaleFac.BELEGART_ANGEBOT, theClientDto)
				&& getMandantFac().darfAnwenderAufZusatzfunktionZugreifen(
						MandantFac.ZUSATZFUNKTION_ANGEBOTSZEITERFASSUNG, theClientDto)) {
			bHatAngebotszeiterfassung = true;
		}

		Map<String, String> mBelegarten = new TreeMap<String, String>();
		if (getMandantFac().darfAnwenderAufModulZugreifen(LocaleFac.BELEGART_AUFTRAG, theClientDto)) {
			mBelegarten.put(LocaleFac.BELEGART_AUFTRAG,
					getTextRespectUISpr("auft.auftrag", theClientDto.getMandant(), theClientDto.getLocUi()));
		}
		if (getMandantFac().darfAnwenderAufModulZugreifen(LocaleFac.BELEGART_LOS, theClientDto)) {
			mBelegarten.put(LocaleFac.BELEGART_LOS, getTextRespectUISpr("fert.tab.unten.los.title",
					theClientDto.getMandant(), theClientDto.getLocUi()));
		}
		if (bHatAngebotszeiterfassung) {
			mBelegarten.put(LocaleFac.BELEGART_ANGEBOT,
					getTextRespectUISpr("angb.angebot", theClientDto.getMandant(), theClientDto.getLocUi()));
		}
		if (bHatProjektzeiterfassung == true) {
			mBelegarten.put(LocaleFac.BELEGART_PROJEKT,
					getTextRespectUISpr("lp.projekt.modulname", theClientDto.getMandant(), theClientDto.getLocUi()));
		}

		return Helper.sortByValue(mBelegarten);

	}

	private BigDecimal getAktuellerUrlaubTageweise(Integer personalIId, java.sql.Timestamp dAktuellerUrlaubsbeginn,
			java.sql.Timestamp dAbrechnungzeitpunkt) {
		// VERBRAUCHTE TAGE+HALBTAGE ALT:
		Integer iIdUrlaub = null;
		try {
			Query query = em.createNamedQuery("TaetigkeitfindByCNr");
			query.setParameter(1, ZeiterfassungFac.TAETIGKEIT_URLAUB);

			Taetigkeit taetigkeit = (Taetigkeit) query.getSingleResult();
			// if (taetigkeit==null) {
			// throw new
			// EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
			// null);
			// }
			iIdUrlaub = taetigkeit.getIId();
		} catch (NoResultException ex7) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, ex7);
		}

		// VERBRAUCHTE TAGE+HALBTAGE AKTUELL:
		double dAktuellerUrlaubTagesweise = 0;
		// Ganze Urlaubstage ALT holen
		Query query2 = em.createNamedQuery("SonderzeitenejbSelectGanztaegigeTaetigkeitenAktuell");
		query2.setParameter(1, personalIId);
		query2.setParameter(2, iIdUrlaub);
		query2.setParameter(3, dAktuellerUrlaubsbeginn);
		query2.setParameter(4, dAbrechnungzeitpunkt);

		Long urlAktuellTage = (Long) query2.getSingleResult();

		if (urlAktuellTage != null) {
			dAktuellerUrlaubTagesweise = dAktuellerUrlaubTagesweise + urlAktuellTage.doubleValue();
		}

		query2 = em.createNamedQuery("SonderzeitenejbSelectHalbtaegigeTaetigkeitenAktuell");
		query2.setParameter(1, personalIId);
		query2.setParameter(2, iIdUrlaub);
		query2.setParameter(3, dAktuellerUrlaubsbeginn);
		query2.setParameter(4, dAbrechnungzeitpunkt);

		Long urlAktuellHalbtage = (Long) query2.getSingleResult();

		if (urlAktuellHalbtage != null) {
			double dTemp = urlAktuellHalbtage.doubleValue() / 2;
			dAktuellerUrlaubTagesweise = dAktuellerUrlaubTagesweise + dTemp;

		}

		return new BigDecimal(dAktuellerUrlaubTagesweise);

	}

	private BigDecimal getGeplanterUrlaubTageweise(Integer personalIId, java.sql.Timestamp dAbrechnungzeitpunkt) {
		// GEPLANTE TAGE+HALBTAGE ALT:
		Integer iIdUrlaub = null;
		try {
			Query query = em.createNamedQuery("TaetigkeitfindByCNr");
			query.setParameter(1, ZeiterfassungFac.TAETIGKEIT_URLAUB);
			Taetigkeit taetigkeit = (Taetigkeit) query.getSingleResult();
			if (taetigkeit == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
			}
			iIdUrlaub = taetigkeit.getIId();
		} catch (NoResultException ex7) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, ex7);
		}

		dAbrechnungzeitpunkt = Helper.cutTimestamp(dAbrechnungzeitpunkt);

		// GEPLANTE TAGE+HALBTAGE AKTUELL:
		double dGeplanterUrlaubTagesweise = 0;
		// Ganze Urlaubstage ALT holen
		Query query2 = em.createNamedQuery("SonderzeitenejbSelectGanztaegigeTaetigkeitenGeplant");
		query2.setParameter(1, personalIId);
		query2.setParameter(2, iIdUrlaub);
		query2.setParameter(3, dAbrechnungzeitpunkt);

		Long urlGeplantTage = (Long) query2.getSingleResult();

		if (urlGeplantTage != null) {
			dGeplanterUrlaubTagesweise = dGeplanterUrlaubTagesweise + urlGeplantTage.doubleValue();
		}
		query2 = em.createNamedQuery("SonderzeitenejbSelectHalbtaegigeTaetigkeitenGeplant");
		query2.setParameter(1, personalIId);
		query2.setParameter(2, iIdUrlaub);
		query2.setParameter(3, dAbrechnungzeitpunkt);

		Long urlGeplantHalbtage = (Long) query2.getSingleResult();

		if (urlGeplantHalbtage != null) {
			double dTemp = urlGeplantHalbtage.doubleValue() / 2;
			dGeplanterUrlaubTagesweise = dGeplanterUrlaubTagesweise + dTemp;

		}

		return new BigDecimal(dGeplanterUrlaubTagesweise);

	}

	private BigDecimal getAliquoterUrlaubsanspruchStunden(java.sql.Timestamp tStichtag, Double jahresStunden,
			TheClientDto theClientDto, Date dEintrittsdatum) {
		if (tStichtag == null || jahresStunden == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("tStichtag == null || jahresStunden == null"));
		}

		double dAliquoterAnspruch = 0;

		Calendar c = Calendar.getInstance();
		c.setTime(new Date(tStichtag.getTime()));

		Calendar cEintritt = Calendar.getInstance();
		cEintritt.setTime(dEintrittsdatum);

		if (c.get(Calendar.YEAR) != cEintritt.get(Calendar.YEAR)) {

			double iTagDesJahres = c.get(Calendar.DAY_OF_YEAR);
			double anzahlTageDesJahres = c.getActualMaximum(Calendar.DAY_OF_YEAR);

			dAliquoterAnspruch = (jahresStunden.doubleValue() / anzahlTageDesJahres) * iTagDesJahres;

			return new BigDecimal(dAliquoterAnspruch);
		} else {

			/*
			 * Bei w&auml;hrend des Jahres eingetretenen Mitarbeitern gibt es immer die
			 * Problematik wie wird der aliquoate Urlaub w&auml;hrend des Jahres richtig
			 * errechnet. Dies geht nur in der Form, dass a.) Der volle Jahres
			 * Urlaubsanspruch eingetragen wird b.) Es wird der Aliquote Urlaubsanspruch vom
			 * 1.1. bis zum Stichtag berechnet. c.) Davon wird der aliquote Anspruch vom
			 * 1.1. bis zum EIntrittsdatum abgezogen. Dies ergibt den Rest-Aliquoten
			 * Anspruch bis zum Stichtag.
			 */

			double iAktuelleTagDesJahres = c.get(Calendar.DAY_OF_YEAR);
			double anzahlTageDesJahres = c.getActualMaximum(Calendar.DAY_OF_YEAR);
			double urlaub = 0;

			double iAbTagUrlaubsansprung = cEintritt.get(Calendar.DAY_OF_YEAR);

			if (iAktuelleTagDesJahres > iAbTagUrlaubsansprung) {
				double urlaubsansprunhProTag = (jahresStunden.doubleValue() / (anzahlTageDesJahres));

				dAliquoterAnspruch = ((iAktuelleTagDesJahres - iAbTagUrlaubsansprung) * urlaubsansprunhProTag);
			} else {
				dAliquoterAnspruch = 0;
			}

			return new BigDecimal(dAliquoterAnspruch);
		}
	}

	private int getAnzahlTageDesUrlaubsjahres(java.sql.Timestamp tStichtag, boolean bUrlaubsabrechnungZumEintrittsdatum,
			Date dEintrittsdatum) {

		if (bUrlaubsabrechnungZumEintrittsdatum == false) {
			Calendar cBeginnUrlaubsjahr = Calendar.getInstance();
			cBeginnUrlaubsjahr.setTime(tStichtag);
			return cBeginnUrlaubsjahr.getActualMaximum(Calendar.DAY_OF_YEAR);
		} else {
			Calendar cBeginnUrlaubsjahr = Calendar.getInstance();
			cBeginnUrlaubsjahr.setTime(dEintrittsdatum);
			cBeginnUrlaubsjahr.set(Calendar.YEAR,
					getUrlaubsjahrAnhandAbrechnungszeitpunkt(tStichtag, true, dEintrittsdatum));

			Timestamp tBeginn = Helper.cutTimestamp(new Timestamp(cBeginnUrlaubsjahr.getTimeInMillis()));
			cBeginnUrlaubsjahr.add(Calendar.YEAR, 1);
			Timestamp tEnde = Helper.cutTimestamp(new Timestamp(cBeginnUrlaubsjahr.getTimeInMillis()));

			return Helper.getDifferenzInTagen(tBeginn, tEnde);
		}

	}

	private int getAktuellerTagDesUrlaubsjahres(java.sql.Timestamp tStichtag, Date dEintrittsdatum) {
		Calendar cBeginnUrlaubsjahr = Calendar.getInstance();
		cBeginnUrlaubsjahr.setTime(dEintrittsdatum);
		cBeginnUrlaubsjahr.set(Calendar.YEAR,
				getUrlaubsjahrAnhandAbrechnungszeitpunkt(tStichtag, true, dEintrittsdatum));

		Timestamp tBeginn = Helper.cutTimestamp(new Timestamp(cBeginnUrlaubsjahr.getTimeInMillis()));

		return Helper.getDifferenzInTagen(tBeginn, Helper.cutTimestamp(tStichtag)) + 1;
	}

	private Double getAliquoterUrlaubsanspruchTageweise(java.sql.Timestamp tStichtag, Double urlaubstageDesJahres,
			Date dEintrittsdatum, boolean bUrlaubsabrechnungZumEintrittsdatum, TheClientDto theClientDto) {
		if (tStichtag == null || urlaubstageDesJahres == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("tStichtag == null || urlaubstageDesJahres == null"));
		}
		Calendar c = Calendar.getInstance();
		c.setTime(new Date(tStichtag.getTime()));

		Calendar cEintritt = Calendar.getInstance();
		cEintritt.setTime(dEintrittsdatum);

		BigDecimal bdUrlaub = BigDecimal.ZERO;

		if (bUrlaubsabrechnungZumEintrittsdatum) {
			double iTagDesJahres = getAktuellerTagDesUrlaubsjahres(tStichtag, dEintrittsdatum);
			double anzahlTageDesJahres = getAnzahlTageDesUrlaubsjahres(tStichtag, bUrlaubsabrechnungZumEintrittsdatum,
					dEintrittsdatum);

			double urlaub = (iTagDesJahres / anzahlTageDesJahres) * urlaubstageDesJahres.doubleValue();
			bdUrlaub = new BigDecimal(urlaub);

		} else {

			if (c.get(Calendar.YEAR) != cEintritt.get(Calendar.YEAR)) {
				double iTagDesJahres = c.get(Calendar.DAY_OF_YEAR);
				double anzahlTageDesJahres = c.getActualMaximum(Calendar.DAY_OF_YEAR);

				double urlaub = (iTagDesJahres / anzahlTageDesJahres) * urlaubstageDesJahres.doubleValue();
				bdUrlaub = new BigDecimal(urlaub);

			} else {

				/*
				 * Bei w&auml;hrend des Jahres eingetretenen Mitarbeitern gibt es immer die
				 * Problematik wie wird der aliquoate Urlaub w&auml;hrend des Jahres richtig
				 * errechnet. Dies geht nur in der Form, dass a.) Der volle Jahres
				 * Urlaubsanspruch eingetragen wird b.) Es wird der Aliquote Urlaubsanspruch vom
				 * 1.1. bis zum Stichtag berechnet. c.) Davon wird der aliquote Anspruch vom
				 * 1.1. bis zum EIntrittsdatum abgezogen. Dies ergibt den Rest-Aliquoten
				 * Anspruch bis zum Stichtag.
				 */

				double iAktuelleTagDesJahres = c.get(Calendar.DAY_OF_YEAR);
				double anzahlTageDesJahres = c.getActualMaximum(Calendar.DAY_OF_YEAR);
				double urlaub = 0;

				double iAbTagUrlaubsansprung = cEintritt.get(Calendar.DAY_OF_YEAR);

				if ((iAktuelleTagDesJahres - 1) > iAbTagUrlaubsansprung) {
					double urlaubsansprunhProTag = (urlaubstageDesJahres.doubleValue()
							/ (anzahlTageDesJahres - (iAbTagUrlaubsansprung - 1)));

					urlaub = (iAktuelleTagDesJahres * urlaubsansprunhProTag)
							- ((iAbTagUrlaubsansprung - 1) * urlaubsansprunhProTag);
				}
				bdUrlaub = new BigDecimal(urlaub);

			}

		}
		bdUrlaub = rundeUrlaubstageAnhandParameter(bdUrlaub, theClientDto);

		return bdUrlaub.doubleValue();
	}

	private BigDecimal rundeUrlaubstageAnhandParameter(BigDecimal bdUrlaubstage, TheClientDto theClientDto) {

		if (bdUrlaubstage == null) {
			return null;
		}

		try {
			ParametermandantDto parameter = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_URLAUBSTAGE_RUNDUNG);

			int i = (Integer) parameter.getCWertAsObject();

			if (i == 0) {
				bdUrlaubstage = bdUrlaubstage.divide(BigDecimal.ONE, 2, BigDecimal.ROUND_HALF_UP);
			} else if (i == 1) {
				bdUrlaubstage = bdUrlaubstage.divide(BigDecimal.ONE, 0, BigDecimal.ROUND_HALF_UP);
			} else if (i == 2) {
				bdUrlaubstage = bdUrlaubstage.divide(BigDecimal.ONE, 0, BigDecimal.ROUND_DOWN);
			} else if (i == 3) {
				bdUrlaubstage = bdUrlaubstage.divide(BigDecimal.ONE, 0, BigDecimal.ROUND_UP);
			}

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}
		return bdUrlaubstage;
	}

	public BigDecimal berechneDiaetenAusScript(Integer diaetenIId, java.sql.Timestamp tVon, java.sql.Timestamp tBis,
			TheClientDto theClientDto, String personalart) {

		String scriptName = null;
		DiaetentagessatzDto[] diaetentagessatzDtos = getDiaetenTagesSatzDtos(diaetenIId, tVon);
		if (diaetentagessatzDtos.length != 0) {
			scriptName = diaetentagessatzDtos[0].getCFilenameScript();
		}

		if (scriptName != null) {
			Integer landId = diaetenFindByPrimaryKey(diaetenIId).getLandIId();
			String lkz = getSystemFac().landFindByPrimaryKey(landId).getCLkz();

			int bginnYear = getYear(tVon);
			int endYear = getYear(tBis);

			ReisekostenDto reisekostenDto = new ReisekostenDto(tVon, tBis, lkz, personalart.trim(), bginnYear, endYear);

			ReisekostenScript script = new ReisekostenScript(getSystemFac(), theClientDto);
			BigDecimal bdDiaeten = script.getValue(reisekostenDto, scriptName);

			if (bdDiaeten == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_SCRIPT_FEHLERHAFTE_STAMMDATEN,
						"FEHLER_SCRIPT_FEHLERHAFTE_STAMMDATEN", scriptName, tVon, tBis, lkz, personalart);
			}

			return BigDecimal.ZERO.setScale(2).add(bdDiaeten);
		} else {
			return berechneDiaeten(diaetenIId, tVon, tBis, theClientDto);
		}
	}

	private int getYear(Timestamp ts) {
		long time = ts.getTime();
		Calendar cal = Calendar.getInstance();
		cal.setTimeInMillis(time);
		int year = cal.get(Calendar.YEAR);
		return year;
	}

	private BigDecimal berechneDiaeten(Integer diaetenIId, java.sql.Timestamp tVon, java.sql.Timestamp tBis,
			TheClientDto theClientDto) {

		// BigDecimal diaetenGesamt = new BigDecimal(0);
		// diaetenGesamt.setScale(2);
		BigDecimal diaetenGesamt = BigDecimal.ZERO.setScale(2);
		boolean bInland = true;

		if (tVon.before(tBis)) {
			Calendar cVon = Calendar.getInstance();
			cVon.setTimeInMillis(tVon.getTime());

			Calendar cBis = Calendar.getInstance();
			cBis.setTimeInMillis(tBis.getTime());

			while (cBis.after(cVon)) {
				java.sql.Time tDauer = null;
				if (cVon.get(Calendar.DAY_OF_YEAR) == cBis.get(Calendar.DAY_OF_YEAR)) {

					tDauer = new java.sql.Time(cBis.getTimeInMillis() - cVon.getTimeInMillis());

				} else {
					Calendar cTemp = Calendar.getInstance();
					cTemp.setTimeInMillis(cVon.getTimeInMillis());
					cTemp.set(Calendar.HOUR_OF_DAY, 23);
					cTemp.set(Calendar.MINUTE, 59);
					cTemp.set(Calendar.MILLISECOND, 999);
					cTemp.set(Calendar.SECOND, 59);

					tDauer = new java.sql.Time(cTemp.getTimeInMillis() - cVon.getTimeInMillis());

				}

				tDauer.setTime(tDauer.getTime() - 3600000);
				Double dDauer = Helper.time2Double(tDauer);

				// BigDecimal diaeten = new BigDecimal(0);
				// diaeten.setScale(2);
				BigDecimal diaeten = BigDecimal.ZERO.setScale(2);
				// try {
				Diaeten temp = em.find(Diaeten.class, diaetenIId);
				if (temp == null) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
				}
				Integer landIId = temp.getLandIId();

				try {
					PartnerDto mandant = getMandantFac()
							.mandantFindByPrimaryKey(theClientDto.getMandant(), theClientDto).getPartnerDto();
					if (mandant.getLandplzortDto() != null) {
						if (!landIId.equals(mandant.getLandplzortDto().getIlandID())) {
							bInland = false;
						}
					}
				} catch (RemoteException ex) {
					throwEJBExceptionLPRespectOld(ex);
				}

				DiaetentagessatzDto[] dtos = getDiaetenTagesSatzDtos(diaetenIId, tVon);

				if (dtos.length > 0) {
					DiaetentagessatzDto dto = dtos[0];

					if (dDauer.doubleValue() > 12) {
						dDauer = new Double(12);
					}
					if (dDauer.doubleValue() % 1 > 0) {
						dDauer = new Double(dDauer.intValue() + 1);

					}

					if (Helper.short2boolean(dto.getBStundenweise()) == true) {
						if (dDauer.doubleValue() > dto.getIAbstunden().doubleValue()) {
							diaeten = new BigDecimal(dDauer.intValue() * dto.getNStundensatz().doubleValue());
						}
					} else {
						if (dDauer.doubleValue() <= 3) {
							diaeten = new BigDecimal(0);
						} else {
							diaeten = dto.getNStundensatz().multiply(new BigDecimal(dDauer.intValue()));
						}
					}

				}

				// }
				// catch (NoResultException e) {
				// throw new
				// EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
				// e);
				// }

				diaetenGesamt = diaetenGesamt.add(Helper.rundeKaufmaennisch(diaeten, 2));

				cVon.set(Calendar.DAY_OF_MONTH, cVon.get(Calendar.DAY_OF_MONTH) + 1);
				cVon.set(Calendar.HOUR_OF_DAY, 0);
				cVon.set(Calendar.MINUTE, 0);
				cVon.set(Calendar.MILLISECOND, 0);
				cVon.set(Calendar.SECOND, 0);
			}

		}

		return diaetenGesamt;
	}

	// public BigDecimal berechneDiaeten(Integer diaetenIId,
	// java.sql.Timestamp tVon, java.sql.Timestamp tBis,
	// TheClientDto theClientDto) {
	//
	// // BigDecimal diaetenGesamt = new BigDecimal(0);
	// // diaetenGesamt.setScale(2);
	// BigDecimal diaetenGesamt = BigDecimal.ZERO.setScale(2);
	// boolean bInland = true;
	//
	// if (tVon.before(tBis)) {
	// Calendar cVon = Calendar.getInstance();
	// cVon.setTimeInMillis(tVon.getTime());
	//
	// Calendar cBis = Calendar.getInstance();
	// cBis.setTimeInMillis(tBis.getTime());
	//
	// while (cBis.after(cVon)) {
	// java.sql.Time tDauer = null;
	// if (cVon.get(Calendar.DAY_OF_YEAR) == cBis
	// .get(Calendar.DAY_OF_YEAR)) {
	//
	// tDauer = new java.sql.Time(cBis.getTimeInMillis()
	// - cVon.getTimeInMillis());
	//
	// } else {
	// Calendar cTemp = Calendar.getInstance();
	// cTemp.setTimeInMillis(cVon.getTimeInMillis());
	// cTemp.set(Calendar.HOUR_OF_DAY, 23);
	// cTemp.set(Calendar.MINUTE, 59);
	// cTemp.set(Calendar.MILLISECOND, 999);
	// cTemp.set(Calendar.SECOND, 59);
	//
	// tDauer = new java.sql.Time(cTemp.getTimeInMillis()
	// - cVon.getTimeInMillis());
	//
	// }
	//
	// tDauer.setTime(tDauer.getTime() - 3600000);
	// Double dDauer = Helper.time2Double(tDauer);
	//
	// // BigDecimal diaeten = new BigDecimal(0);
	// // diaeten.setScale(2);
	// BigDecimal diaeten = BigDecimal.ZERO.setScale(2);
	// // try {
	// Diaeten temp = em.find(Diaeten.class, diaetenIId);
	// if (temp == null) {
	// throw new EJBExceptionLP(
	// EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
	// }
	// Integer landIId = temp.getLandIId();
	//
	// try {
	// PartnerDto mandant = getMandantFac()
	// .mandantFindByPrimaryKey(theClientDto.getMandant(),
	// theClientDto).getPartnerDto();
	// if (mandant.getLandplzortDto() != null) {
	// if (!landIId.equals(mandant.getLandplzortDto()
	// .getIlandID())) {
	// bInland = false;
	// }
	// }
	// } catch (RemoteException ex) {
	// throwEJBExceptionLPRespectOld(ex);
	// }
	//
	// // Query query2 = em
	// // .createNamedQuery("DiaetentagessatzfindGueltigenTagessatzZuDatum");
	// // query2.setParameter(1, diaetenIId);
	// // query2.setParameter(2, tVon);
	// //
	// // DiaetentagessatzDto[] dtos = assembleDiaetentagessatzDtos(query2
	// // .getResultList());
	//
	// DiaetentagessatzDto[] dtos = getDiaetenTagesSatzDtos(diaetenIId, tVon);
	//
	// if (dtos.length > 0) {
	// DiaetentagessatzDto dto = dtos[0];
	//
	// if (dDauer.doubleValue() > 12) {
	// dDauer = new Double(12);
	// }
	// if (dDauer.doubleValue() % 1 > 0) {
	// dDauer = new Double(dDauer.doubleValue() + 1);
	//
	// }
	//
	// if (Helper.short2boolean(dto.getBStundenweise()) == true) {
	// if (dDauer.doubleValue() > dto.getIAbstunden()
	// .doubleValue()) {
	// diaeten = new BigDecimal(dDauer.intValue()
	// * dto.getNStundensatz().doubleValue());
	// }
	// } else {
	// if (dDauer.doubleValue() <= 3) {
	// diaeten = new BigDecimal(0);
	// } else {
	// diaeten = dto.getNStundensatz().multiply(
	// new BigDecimal(dDauer.intValue()));
	// }
	// }
	//
	// }
	//
	// // }
	// // catch (NoResultException e) {
	// // throw new
	// // EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
	// // e);
	// // }
	//
	// diaetenGesamt = diaetenGesamt.add(diaeten);
	//
	// cVon.set(Calendar.DAY_OF_MONTH,
	// cVon.get(Calendar.DAY_OF_MONTH) + 1);
	// cVon.set(Calendar.HOUR_OF_DAY, 0);
	// cVon.set(Calendar.MINUTE, 0);
	// cVon.set(Calendar.MILLISECOND, 0);
	// cVon.set(Calendar.SECOND, 0);
	// }
	//
	// }
	//
	// return diaetenGesamt;
	// }

	public DiaetentagessatzDto[] getDiaetenTagesSatzDtos(Integer diaetenIId, java.sql.Timestamp tVon) {
		Query query2 = em.createNamedQuery("DiaetentagessatzfindGueltigenTagessatzZuDatum");
		query2.setParameter(1, diaetenIId);
		query2.setParameter(2, tVon);

		DiaetentagessatzDto[] dtos = assembleDiaetentagessatzDtos(query2.getResultList());
		return dtos;
	}

	private BigDecimal berechneAliquotenUrlaubsanspruchsstundenAb2009(Integer personalIId,
			java.sql.Date tAbrechnungszeitpunkt, Date tLetzterEintritt, boolean bUrlaubsabrechnungZumEintrittsdatum,
			TheClientDto theClientDto) {

		// Anspruch Aliquot lt. Zeitmodellen berechnen

		Calendar c = Calendar.getInstance();
		c.setTimeInMillis(tAbrechnungszeitpunkt.getTime());
		// In DB eintragen
		int iJahr = getUrlaubsjahrAnhandAbrechnungszeitpunkt(tAbrechnungszeitpunkt, bUrlaubsabrechnungZumEintrittsdatum,
				tLetzterEintritt);

		try {
			UrlaubsanspruchDto dto = getPersonalFac().urlaubsanspruchFindByPersonalIIdIJahr(personalIId,
					new Integer(iJahr));

			UrlaubsanspruchDto[] dtosFrueher = getPersonalFac()
					.urlaubsanspruchFindByPersonalIIdIJahrKleiner(personalIId, new Integer(iJahr));

			if (dto != null || (dtosFrueher != null && dtosFrueher.length > 0)) {
				BigDecimal iWochenUrlaub = new BigDecimal(5);
				if (dto != null) {
					iWochenUrlaub = new BigDecimal(dto.getFJahresurlaubinwochen().doubleValue());
				} else {
					iWochenUrlaub = new BigDecimal(dtosFrueher[0].getFJahresurlaubinwochen().doubleValue());
				}

				Query query = em.createNamedQuery("PersonalzeitmodellfindZeitmodellImZeitraum");
				query.setParameter(1, personalIId);

				Calendar cBeginnUrlaubsjahr = Calendar.getInstance();

				if (bUrlaubsabrechnungZumEintrittsdatum) {

					Calendar cEintritt = Calendar.getInstance();
					cEintritt.setTimeInMillis(tLetzterEintritt.getTime());

					cBeginnUrlaubsjahr.set(Calendar.YEAR, iJahr);
					cBeginnUrlaubsjahr.set(Calendar.MONTH, cEintritt.get(Calendar.MONTH));
					cBeginnUrlaubsjahr.set(Calendar.DATE, cEintritt.get(Calendar.DATE));
					cBeginnUrlaubsjahr.set(Calendar.MINUTE, 0);
					cBeginnUrlaubsjahr.set(Calendar.HOUR_OF_DAY, 0);
					cBeginnUrlaubsjahr.set(Calendar.SECOND, 0);
					cBeginnUrlaubsjahr.set(Calendar.MILLISECOND, 0);

				} else {

					cBeginnUrlaubsjahr.set(Calendar.YEAR, iJahr);
					cBeginnUrlaubsjahr.set(Calendar.MONTH, Calendar.JANUARY);
					cBeginnUrlaubsjahr.set(Calendar.DATE, 1);
					cBeginnUrlaubsjahr.set(Calendar.MINUTE, 0);
					cBeginnUrlaubsjahr.set(Calendar.HOUR_OF_DAY, 0);
					cBeginnUrlaubsjahr.set(Calendar.SECOND, 0);
					cBeginnUrlaubsjahr.set(Calendar.MILLISECOND, 0);
				}

				boolean bErstNachErstemJaennerEingetreten = false;

				if (cBeginnUrlaubsjahr.getTimeInMillis() < tLetzterEintritt.getTime()) {
					cBeginnUrlaubsjahr.setTimeInMillis(tLetzterEintritt.getTime());
					bErstNachErstemJaennerEingetreten = true;
				}

				query.setParameter(2, new java.sql.Timestamp(cBeginnUrlaubsjahr.getTimeInMillis()));
				PersonalzeitmodellDto zeitmodellZumErstenJaenner = getPersonalFac()
						.personalzeitmodellFindZeitmodellZuDatum(personalIId,
								new Timestamp(cBeginnUrlaubsjahr.getTimeInMillis()), theClientDto);
				Double dSollstundenZumErstenJaenner = new Double(0);
				if (zeitmodellZumErstenJaenner != null) {
					dSollstundenZumErstenJaenner = getSummeSollzeitWochentagsUndSonntags(
							zeitmodellZumErstenJaenner.getZeitmodellIId());

				}

				Calendar cAbrechnungszeitpunkt = Calendar.getInstance();
				c.setTimeInMillis(tAbrechnungszeitpunkt.getTime());

				cAbrechnungszeitpunkt.set(Calendar.YEAR, c.get(Calendar.YEAR));
				cAbrechnungszeitpunkt.set(Calendar.MONTH, c.get(Calendar.MONTH));
				cAbrechnungszeitpunkt.set(Calendar.DATE, c.get(Calendar.DAY_OF_MONTH));
				cAbrechnungszeitpunkt.set(Calendar.MINUTE, 0);
				cAbrechnungszeitpunkt.set(Calendar.HOUR_OF_DAY, 0);
				cAbrechnungszeitpunkt.set(Calendar.SECOND, 0);
				cAbrechnungszeitpunkt.set(Calendar.MILLISECOND, 0);
				PersonalzeitmodellDto zeitmodellZumAbrechungszeitpunkt = getPersonalFac()
						.personalzeitmodellFindZeitmodellZuDatum(personalIId,
								new Timestamp(cAbrechnungszeitpunkt.getTimeInMillis()), theClientDto);

				query.setParameter(3, new java.sql.Timestamp(cAbrechnungszeitpunkt.getTimeInMillis()));

				Collection<?> cl = query.getResultList();

				double fStunden = 0;

				int ianzahlTageImJahr = getAnzahlTageDesUrlaubsjahres(new Timestamp(tAbrechnungszeitpunkt.getTime()),
						bUrlaubsabrechnungZumEintrittsdatum, tLetzterEintritt);
				if (cl.size() > 0) {

					List<PersonalzeitmodellDto> list = new ArrayList<PersonalzeitmodellDto>();
					if (cl != null) {
						Iterator<?> iterator = cl.iterator();
						while (iterator.hasNext()) {
							Personalzeitmodell personalzeitmodell = (Personalzeitmodell) iterator.next();
							list.add(PersonalzeitmodellDtoAssembler.createDto(personalzeitmodell));
						}
					}

					PersonalzeitmodellDto[] temp = new PersonalzeitmodellDto[list.size()];
					PersonalzeitmodellDto[] returnArray = (PersonalzeitmodellDto[]) list.toArray(temp);
					for (int i = 0; i < returnArray.length; i++) {

						if (i == 0) {
							// && bErstNachErstemJaennerEingetreten == false) {

							// bis zum naechstenZeitmodell
							PersonalzeitmodellDto dtoNaechstesZeitmodell = returnArray[0];

							int iAnzahlTage = Helper.getDifferenzInTagen(
									new java.sql.Timestamp(cBeginnUrlaubsjahr.getTimeInMillis()),
									dtoNaechstesZeitmodell.getTGueltigab());

							// PJ 15884
							ZeitmodellDto zeitmodellDto = zeitmodellFindByPrimaryKey(
									dtoNaechstesZeitmodell.getZeitmodellIId(), theClientDto);

							fStunden = ((iWochenUrlaub.doubleValue() * iAnzahlTage) / ianzahlTageImJahr)
									* dSollstundenZumErstenJaenner;

						}

						if (i > 0 && i != returnArray.length) {
							// Vom letzten bis zum aktuellen

							PersonalzeitmodellDto letztes = returnArray[i - 1];
							PersonalzeitmodellDto aktuelles = returnArray[i];

							Double d = getSummeSollzeitWochentagsUndSonntags(letztes.getZeitmodellIId());

							int iAnzahlTage = Helper.getDifferenzInTagen(letztes.getTGueltigab(),
									aktuelles.getTGueltigab());

							// PJ 15884
							ZeitmodellDto zeitmodellDto = zeitmodellFindByPrimaryKey(letztes.getZeitmodellIId(),
									theClientDto);

							fStunden += ((iWochenUrlaub.doubleValue() * iAnzahlTage) / ianzahlTageImJahr) * d;

						}

						if (i == returnArray.length - 1) {

							// bis zum naechstenZeitmodell
							PersonalzeitmodellDto dtoNaechstesZeitmodell = returnArray[i];

							Double d = getSummeSollzeitWochentagsUndSonntags(dtoNaechstesZeitmodell.getZeitmodellIId());
							int iAnzahlTage = Helper.getDifferenzInTagen(dtoNaechstesZeitmodell.getTGueltigab(),
									new java.sql.Timestamp(cAbrechnungszeitpunkt.getTimeInMillis())) + 1;
							// PJ 15884
							ZeitmodellDto zeitmodellDto = zeitmodellFindByPrimaryKey(
									dtoNaechstesZeitmodell.getZeitmodellIId(), theClientDto);

							fStunden += ((iWochenUrlaub.doubleValue() * iAnzahlTage) / ianzahlTageImJahr) * d;

						}

					}

				} else {
					// Einfach berechnen mit Zeitmodell zum ersten
					int iAnzahlTage = Helper.getDifferenzInTagen(new Timestamp(cBeginnUrlaubsjahr.getTimeInMillis()),
							new java.sql.Timestamp(cAbrechnungszeitpunkt.getTimeInMillis())) + 1;
					fStunden = dSollstundenZumErstenJaenner.doubleValue() * iWochenUrlaub.doubleValue()
							/ ianzahlTageImJahr * iAnzahlTage;
				}
				/*
				 * if (dto != null && dto.getFStundenzusaetzlich() != null) { fStunden +=
				 * dto.getFStundenzusaetzlich().doubleValue(); }
				 */

				return new BigDecimal(fStunden);

			}

		} catch (RemoteException e) {
			throwEJBExceptionLPRespectOld(e);
		}

		return new BigDecimal(0);
	}

	private BigDecimal berechneUrlaubsanspruchsstundenAb2009(Integer personalIId, int iJahr, Date tLetzterEintritt,
			boolean bUrlaubsabrechnungZumEintrittsdatum, TheClientDto theClientDto) {

		// Anspruch lt. Zeitmodellen berechnen
		try {
			UrlaubsanspruchDto dto = getPersonalFac().urlaubsanspruchFindByPersonalIIdIJahr(personalIId,
					new Integer(iJahr));

			UrlaubsanspruchDto[] dtosFrueher = getPersonalFac()
					.urlaubsanspruchFindByPersonalIIdIJahrKleiner(personalIId, new Integer(iJahr));

			if (dto != null || (dtosFrueher != null && dtosFrueher.length > 0)) {

				BigDecimal iWochenUrlaub = new BigDecimal(5);
				if (dto != null) {
					iWochenUrlaub = new BigDecimal(dto.getFJahresurlaubinwochen().doubleValue());
				} else {
					iWochenUrlaub = new BigDecimal(dtosFrueher[0].getFJahresurlaubinwochen().doubleValue());
				}

				Query query = em.createNamedQuery("PersonalzeitmodellfindZeitmodellImZeitraum");
				query.setParameter(1, personalIId);

				Calendar cBeginnUrlaubsjahr = Calendar.getInstance();

				if (bUrlaubsabrechnungZumEintrittsdatum) {

					Calendar cEintritt = Calendar.getInstance();
					cEintritt.setTimeInMillis(tLetzterEintritt.getTime());

					cBeginnUrlaubsjahr.set(Calendar.YEAR, iJahr);
					cBeginnUrlaubsjahr.set(Calendar.MONTH, cEintritt.get(Calendar.MONTH));
					cBeginnUrlaubsjahr.set(Calendar.DATE, cEintritt.get(Calendar.DATE));
					cBeginnUrlaubsjahr.set(Calendar.MINUTE, 0);
					cBeginnUrlaubsjahr.set(Calendar.HOUR_OF_DAY, 0);
					cBeginnUrlaubsjahr.set(Calendar.SECOND, 0);
					cBeginnUrlaubsjahr.set(Calendar.MILLISECOND, 0);

				} else {

					cBeginnUrlaubsjahr.set(Calendar.YEAR, iJahr);
					cBeginnUrlaubsjahr.set(Calendar.MONTH, Calendar.JANUARY);
					cBeginnUrlaubsjahr.set(Calendar.DATE, 1);
					cBeginnUrlaubsjahr.set(Calendar.MINUTE, 0);
					cBeginnUrlaubsjahr.set(Calendar.HOUR_OF_DAY, 0);
					cBeginnUrlaubsjahr.set(Calendar.SECOND, 0);
					cBeginnUrlaubsjahr.set(Calendar.MILLISECOND, 0);
				}

				boolean bErstNachErstemJaennerEingetreten = false;

				// PJ14891
				ParametermandantDto parameter = null;
				try {
					parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
							ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_ERWEITERTER_URLAUBSANSPRUCH);
				} catch (RemoteException ex5) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
				}

				int bErweiterterUrlaubsanspruch = ((Integer) parameter.getCWertAsObject());

				Date tLetzterEintrittOriginal = new Date(tLetzterEintritt.getTime());

				if (bErweiterterUrlaubsanspruch >= 1) {
					// Wenn vor 30.6. eingetreten oder TVOeD, dann ist das wie
					// wenn am 1.1.
					// eingetreten
					Calendar cEintritt = Calendar.getInstance();
					cEintritt.setTimeInMillis(tLetzterEintritt.getTime());

					if (cEintritt.get(Calendar.MONTH) <= Calendar.JUNE || bErweiterterUrlaubsanspruch == 2) {
						tLetzterEintritt = new Timestamp(cBeginnUrlaubsjahr.getTimeInMillis());
					}

				}

				PersonalzeitmodellDto zeitmodellZumErstenJaenner = null;
				if (cBeginnUrlaubsjahr.getTimeInMillis() < tLetzterEintritt.getTime()) {
					zeitmodellZumErstenJaenner = getPersonalFac().personalzeitmodellFindZeitmodellZuDatum(personalIId,
							new Timestamp(tLetzterEintritt.getTime()), theClientDto);

					query.setParameter(2, tLetzterEintritt);

					cBeginnUrlaubsjahr.setTimeInMillis(tLetzterEintritt.getTime());
					bErstNachErstemJaennerEingetreten = true;
				} else {
					zeitmodellZumErstenJaenner = getPersonalFac().personalzeitmodellFindZeitmodellZuDatum(personalIId,
							new Timestamp(cBeginnUrlaubsjahr.getTimeInMillis()), theClientDto);
					query.setParameter(2, new java.sql.Timestamp(cBeginnUrlaubsjahr.getTimeInMillis()));
				}

				Double dSollstundenZumErstenJaenner = new Double(0);
				if (zeitmodellZumErstenJaenner != null) {
					dSollstundenZumErstenJaenner = getSummeSollzeitWochentagsUndSonntags(
							zeitmodellZumErstenJaenner.getZeitmodellIId());

				}

				Calendar cEndeUrlaubsjahr = Calendar.getInstance();

				if (bUrlaubsabrechnungZumEintrittsdatum == true) {

					Calendar cEintritt = Calendar.getInstance();
					cEintritt.setTimeInMillis(tLetzterEintritt.getTime());

					cEndeUrlaubsjahr.set(Calendar.YEAR, iJahr + 1);
					cEndeUrlaubsjahr.set(Calendar.MONTH, cEintritt.get(Calendar.MONTH));
					cEndeUrlaubsjahr.set(Calendar.DATE, cEintritt.get(Calendar.DATE));
					cEndeUrlaubsjahr.set(Calendar.MINUTE, 0);
					cEndeUrlaubsjahr.set(Calendar.HOUR_OF_DAY, 0);
					cEndeUrlaubsjahr.set(Calendar.SECOND, 0);
					cEndeUrlaubsjahr.set(Calendar.MILLISECOND, 0);

					// SP9538
					cEndeUrlaubsjahr.add(Calendar.DATE, -1);

				} else {
					cEndeUrlaubsjahr.set(Calendar.YEAR, iJahr);
					cEndeUrlaubsjahr.set(Calendar.MONTH, Calendar.DECEMBER);
					cEndeUrlaubsjahr.set(Calendar.DATE, 31);
					cEndeUrlaubsjahr.set(Calendar.MINUTE, 0);
					cEndeUrlaubsjahr.set(Calendar.HOUR_OF_DAY, 0);
					cEndeUrlaubsjahr.set(Calendar.SECOND, 0);
					cEndeUrlaubsjahr.set(Calendar.MILLISECOND, 0);
				}
				PersonalzeitmodellDto zeitmodellZumLetztenDezember = getPersonalFac()
						.personalzeitmodellFindZeitmodellZuDatum(personalIId,
								new Timestamp(cEndeUrlaubsjahr.getTimeInMillis()), theClientDto);

				query.setParameter(3, new java.sql.Timestamp(cEndeUrlaubsjahr.getTimeInMillis()));

				Collection<?> cl = query.getResultList();

				double fStunden = 0;
				double fTage = 0;

				int ianzahlTageImJahr = cEndeUrlaubsjahr.getActualMaximum(Calendar.DAY_OF_YEAR);

				if (bUrlaubsabrechnungZumEintrittsdatum) {
					ianzahlTageImJahr = getAnzahlTageDesUrlaubsjahres(
							new Timestamp(cBeginnUrlaubsjahr.getTimeInMillis()), bUrlaubsabrechnungZumEintrittsdatum,
							tLetzterEintritt);
				}

				if (cl.size() > 0) {

					List<PersonalzeitmodellDto> list = new ArrayList<PersonalzeitmodellDto>();
					if (cl != null) {
						Iterator<?> iterator = cl.iterator();
						while (iterator.hasNext()) {
							Personalzeitmodell personalzeitmodell = (Personalzeitmodell) iterator.next();
							list.add(PersonalzeitmodellDtoAssembler.createDto(personalzeitmodell));
						}
					}

					PersonalzeitmodellDto[] temp = new PersonalzeitmodellDto[list.size()];
					PersonalzeitmodellDto[] returnArray = (PersonalzeitmodellDto[]) list.toArray(temp);
					for (int i = 0; i < returnArray.length; i++) {

						if (i == 0) {

							// bis zum naechstenZeitmodell
							PersonalzeitmodellDto dtoNaechstesZeitmodell = returnArray[0];

							int iAnzahlTage = Helper.getDifferenzInTagen(
									new java.sql.Timestamp(cBeginnUrlaubsjahr.getTimeInMillis()),
									dtoNaechstesZeitmodell.getTGueltigab());
							// +1 entfernt, da, wenn kein Zeitmodell
							// vorhanden
							// ist, 366 Tage im Jahr gerechnet werden

							// PJ 15884
							if (zeitmodellZumErstenJaenner != null) {
								ZeitmodellDto zeitmodellDto = zeitmodellFindByPrimaryKey(
										zeitmodellZumErstenJaenner.getZeitmodellIId(), theClientDto);

								fStunden = ((iWochenUrlaub.doubleValue() * iAnzahlTage) / ianzahlTageImJahr)
										* dSollstundenZumErstenJaenner;
								fTage = ((iWochenUrlaub.doubleValue() * iAnzahlTage) / ianzahlTageImJahr)
										* zeitmodellDto.getFUrlaubstageprowoche();
							}
						}

						if (i > 0 && i != returnArray.length) {
							// Vom letzten bis zum aktuellen

							PersonalzeitmodellDto letztes = returnArray[i - 1];
							PersonalzeitmodellDto aktuelles = returnArray[i];

							Double d = getSummeSollzeitWochentagsUndSonntags(letztes.getZeitmodellIId());

							int iAnzahlTage = Helper.getDifferenzInTagen(letztes.getTGueltigab(),
									aktuelles.getTGueltigab());

							// PJ 15884
							ZeitmodellDto zeitmodellDto = zeitmodellFindByPrimaryKey(letztes.getZeitmodellIId(),
									theClientDto);

							fStunden += ((iWochenUrlaub.doubleValue() * iAnzahlTage) / ianzahlTageImJahr) * d;

							fTage += ((iWochenUrlaub.doubleValue() * iAnzahlTage) / ianzahlTageImJahr)
									* zeitmodellDto.getFUrlaubstageprowoche();
						}

						if (i == returnArray.length - 1) {

							// bis zum naechstenZeitmodell
							PersonalzeitmodellDto dtoNaechstesZeitmodell = returnArray[i];

							Double d = getSummeSollzeitWochentagsUndSonntags(dtoNaechstesZeitmodell.getZeitmodellIId());
							int iAnzahlTage = Helper.getDifferenzInTagen(dtoNaechstesZeitmodell.getTGueltigab(),
									new java.sql.Timestamp(cEndeUrlaubsjahr.getTimeInMillis())) + 1;

							// PJ 15884
							ZeitmodellDto zeitmodellDto = zeitmodellFindByPrimaryKey(
									dtoNaechstesZeitmodell.getZeitmodellIId(), theClientDto);

							fStunden += ((iWochenUrlaub.doubleValue() * iAnzahlTage) / ianzahlTageImJahr) * d;
							fTage += ((iWochenUrlaub.doubleValue() * iAnzahlTage) / ianzahlTageImJahr)
									* zeitmodellDto.getFUrlaubstageprowoche();
						}

					}

				} else {
					// Einfach berechnen mit Zeitmodell zum ersten
					if (zeitmodellZumErstenJaenner != null) {
						ZeitmodellDto zeitmodellDto = zeitmodellFindByPrimaryKey(
								zeitmodellZumErstenJaenner.getZeitmodellIId(), theClientDto);

						if (bErstNachErstemJaennerEingetreten == false) {
							fStunden = dSollstundenZumErstenJaenner.doubleValue() * iWochenUrlaub.doubleValue();

							if (zeitmodellZumErstenJaenner != null) {

								fTage = iWochenUrlaub.doubleValue() * zeitmodellDto.getFUrlaubstageprowoche();
							}
						} else {

							int iAnzahlTage = Helper.getDifferenzInTagen(tLetzterEintritt,
									new java.sql.Timestamp(cEndeUrlaubsjahr.getTimeInMillis())) + 1;

							fStunden = ((iWochenUrlaub.doubleValue() * iAnzahlTage) / ianzahlTageImJahr)
									* dSollstundenZumErstenJaenner;
							fTage = ((iWochenUrlaub.doubleValue() * iAnzahlTage) / ianzahlTageImJahr)
									* zeitmodellDto.getFUrlaubstageprowoche();
						}
					}

				}

				// TVOeD: PJ 16677
				if (bErweiterterUrlaubsanspruch == 2) {

					Calendar cEintritt = Calendar.getInstance();
					cEintritt.setTimeInMillis(tLetzterEintrittOriginal.getTime());

					if (cEintritt.get(Calendar.YEAR) == iJahr) {

						double dMonate = 11 - cEintritt.get(Calendar.MONTH);
						if (cEintritt.get(Calendar.DAY_OF_MONTH) == 1) {
							dMonate = dMonate + 1;
						}

						fTage = fTage / 12 * dMonate;
						fStunden = fStunden / 12 * dMonate;
					}

					// Kaufmaennich auf ganze Tage runden
					fTage = Math.round(fTage);

				} else {
					// Tage auf 2 Nachkommastellen runden, da ansonsten bei 22
					// Zeitmodellen 29,999996 rauskommt und spaeter
					fTage = Math.round(fTage * 100.) / 100.;
				}

				if (dto == null) {
					UrlaubsanspruchDto[] dtos = getPersonalFac()
							.urlaubsanspruchFindByPersonalIIdIJahrKleiner(personalIId, new Integer(iJahr));

					if (dtos.length > 0) {
						dto = dtos[0];

						if (dto.getIJahr() >= 2009) {

							dto.setIId(null);

							dto.setIJahr(iJahr);
							dto.setFStundenzusaetzlich(0D);
							dto.setFTagezusaetzlich(0D);
							dto.setFStunden(fStunden);
							dto.setFTage(fTage);
							getPersonalFac().createUrlaubsanspruch(dto, theClientDto);
						}

					}

				} else {
					// Stunden heuer updaten
					dto.setFStunden(fStunden);
					dto.setFTage(fTage);
					getPersonalFac().updateUrlaubsanspruch(dto, theClientDto);
				}

			}

		} catch (RemoteException e) {
			throwEJBExceptionLPRespectOld(e);
		}

		return null;
	}

	private int getUrlaubsjahrAnhandAbrechnungszeitpunkt(java.util.Date dZeitpunkt,
			boolean bUrlaubsabrechnungZumEintrittsdatum, java.util.Date dEintrittsdatum) {

		if (bUrlaubsabrechnungZumEintrittsdatum == true) {

			Calendar cZeitpunkt = Calendar.getInstance();
			cZeitpunkt.setTimeInMillis(dZeitpunkt.getTime());

			Calendar cEintrittsdatum = Calendar.getInstance();
			cEintrittsdatum.setTimeInMillis(dEintrittsdatum.getTime());

			int iMonatZeitpunkt = cZeitpunkt.get(Calendar.MONTH);
			int iMonatEintritt = cEintrittsdatum.get(Calendar.MONTH);

			int iTagZeitpunkt = cZeitpunkt.get(Calendar.DAY_OF_MONTH);
			int iTagEintritt = cEintrittsdatum.get(Calendar.DAY_OF_MONTH);

			if (iMonatZeitpunkt < iMonatEintritt
					|| (iMonatZeitpunkt == iMonatEintritt && iTagZeitpunkt < iTagEintritt)) {
				return cZeitpunkt.get(Calendar.YEAR) - 1;
			} else {
				return cZeitpunkt.get(Calendar.YEAR);
			}
		} else {
			Calendar cTemp = Calendar.getInstance();
			cTemp.setTimeInMillis(dZeitpunkt.getTime());

			return cTemp.get(Calendar.YEAR);

		}

	}

	public UrlaubsabrechnungDto berechneUrlaubsanspruchAliquotMitKarenzenZumAbrechnungszeitpunkt(Integer personalIId,
			java.sql.Date dAbrechnungzeitpunkt, TheClientDto theClientDto) {

		UrlaubsabrechnungDto urlDto = new UrlaubsabrechnungDto();

		Calendar cAbrechnungszeitpunkt = Calendar.getInstance();
		cAbrechnungszeitpunkt.setTime(Helper.cutDate(dAbrechnungzeitpunkt));

		Calendar cErsterJaenner = Calendar.getInstance();

		cErsterJaenner.setTime(Helper.cutDate(dAbrechnungzeitpunkt));

		cErsterJaenner.set(Calendar.DAY_OF_MONTH, 1);
		cErsterJaenner.set(Calendar.MONTH, Calendar.JANUARY);

		// Letzter ECHTER eintritt vor Wiedereintritt:

		Session session = FLRSessionFactory.getFactory().openSession();

		String sQuery = "select ea FROM FLREintrittaustritt ea WHERE ea.personal_i_id=" + personalIId
				+ " AND ea.t_eintritt<='"
				+ Helper.formatDateWithSlashes(new java.sql.Date(dAbrechnungzeitpunkt.getTime()))
				+ "' AND ea.b_wiedereintritt=0 ORDER BY ea.t_eintritt DESC";
		org.hibernate.Query query = session.createQuery(sQuery);
		List<?> resultList = query.list();

		Iterator<?> resultListIterator = resultList.iterator();

		query.setMaxResults(1);

		resultList = query.list();

		resultListIterator = resultList.iterator();

		Date dLetzterEchterEintritt = null;

		if (resultListIterator.hasNext()) {
			FLREintrittaustritt ea = (FLREintrittaustritt) resultListIterator.next();

			dLetzterEchterEintritt = ea.getT_eintritt();
		}

		if (dLetzterEchterEintritt != null && dLetzterEchterEintritt.after(cErsterJaenner.getTime())) {
			cErsterJaenner.setTime(dLetzterEchterEintritt);
		}

		// 31.12
		Calendar c31Dezember = Calendar.getInstance();
		c31Dezember.setTime(Helper.cutDate(dAbrechnungzeitpunkt));
		c31Dezember.set(Calendar.DAY_OF_MONTH, 31);
		c31Dezember.set(Calendar.MONTH, Calendar.DECEMBER);
		if (dAbrechnungzeitpunkt.before(c31Dezember.getTime())) {
			c31Dezember.setTime(Helper.cutDate(dAbrechnungzeitpunkt));
		}

		class Abschnitt {
			java.util.Date dVon = null;
			java.util.Date dBis = null;
			Integer zeitmodellIId = null;

			Abschnitt(java.util.Date dVon, java.util.Date dBis, Integer zeitmodellIId) {
				this.dVon = dVon;
				this.dBis = dBis;
				this.zeitmodellIId = zeitmodellIId;
			}
		}

		TreeMap<java.util.Date, FLRPersonalzeitmodell> hmAbschnitte = new TreeMap<java.util.Date, FLRPersonalzeitmodell>();

		sQuery = "select pz FROM FLRPersonalzeitmodell pz WHERE pz.personal_i_id=" + personalIId
				+ " ORDER BY pz.t_gueltigab";

		session = FLRSessionFactory.getFactory().openSession();

		query = session.createQuery(sQuery);

		resultList = query.list();

		resultListIterator = resultList.iterator();

		while (resultListIterator.hasNext()) {

			FLRPersonalzeitmodell pz = (FLRPersonalzeitmodell) resultListIterator.next();

			java.util.Date dBeginn = Helper.cutDate(pz.getT_gueltigab());
			if (dBeginn.before(cErsterJaenner.getTime())) {
				dBeginn = cErsterJaenner.getTime();

			}
			if (dBeginn.getTime() <= cAbrechnungszeitpunkt.getTime().getTime()) {
				hmAbschnitte.put(Helper.cutDate(dBeginn), pz);
			}

		}

		ArrayList<Abschnitt> abschnitte = new ArrayList<Abschnitt>();

		Iterator itPZ = hmAbschnitte.keySet().iterator();
		while (itPZ.hasNext()) {
			Date key = (Date) itPZ.next();

			FLRPersonalzeitmodell pz = (FLRPersonalzeitmodell) hmAbschnitte.get(key);
			Date naechsterKey = (Date) hmAbschnitte.higherKey(key);

			if (naechsterKey == null) {

				abschnitte.add(new Abschnitt(key, c31Dezember.getTime(), pz.getFlrzeitmodell().getI_id()));
			} else {
				abschnitte.add(new Abschnitt(key, Helper.addiereTageZuDatum(naechsterKey, -1),
						pz.getFlrzeitmodell().getI_id()));
			}
		}

		// Nun noch Eintritt/Austritt beruecksichtigen

		for (int i = 0; i < abschnitte.size(); i++) {

			Abschnitt abschnitt = abschnitte.get(i);

			sQuery = "select ea FROM FLREintrittaustritt ea WHERE ea.personal_i_id=" + personalIId
					+ " AND ea.t_eintritt<='"
					+ Helper.formatDateWithSlashes(new java.sql.Date(abschnitt.dVon.getTime()))
					+ "' ORDER BY ea.t_eintritt DESC";

			query = session.createQuery(sQuery);
			query.setMaxResults(1);

			resultList = query.list();

			resultListIterator = resultList.iterator();

			if (resultListIterator.hasNext()) {

				FLREintrittaustritt ea = (FLREintrittaustritt) resultListIterator.next();

				if (ea.getT_austritt() != null && ea.getT_austritt().before(abschnitt.dBis)) {

					// Wiedereintritt

					sQuery = "select ea FROM FLREintrittaustritt ea WHERE ea.personal_i_id=" + personalIId
							+ " AND ea.t_eintritt>'"
							+ Helper.formatDateWithSlashes(new java.sql.Date(ea.getT_austritt().getTime()))
							+ "' AND ea.t_eintritt<='"
							+ Helper.formatDateWithSlashes(new java.sql.Date(abschnitt.dBis.getTime()))
							+ "' ORDER BY ea.t_eintritt ASC";

					org.hibernate.Query query2 = session.createQuery(sQuery);
					query2.setMaxResults(1);

					List resultList2 = query2.list();

					Iterator resultListIterator2 = resultList2.iterator();

					if (resultListIterator2.hasNext()) {
						// Bereich splitten
						FLREintrittaustritt eaWiedereintritt = (FLREintrittaustritt) resultListIterator2.next();

						Abschnitt abschnittNeu = new Abschnitt(eaWiedereintritt.getT_eintritt(), abschnitt.dBis,
								abschnitt.zeitmodellIId);
						abschnitte.add(abschnittNeu);
					}

					abschnitt.dBis = ea.getT_austritt();

					if (ea.getT_austritt().before(abschnitt.dVon)) {
						abschnitte.set(i, null);
					}

				}

			}

		}

		try {

			int ianzahlTageImJahr = cErsterJaenner.getActualMaximum(Calendar.DAY_OF_YEAR);

			Integer iJahr = cErsterJaenner.get(Calendar.YEAR);

			UrlaubsanspruchDto[] urlaubsanspruchDto = getPersonalFac()
					.urlaubsanspruchFindByPersonalIIdIJahrKleiner(personalIId, iJahr);

			if (urlaubsanspruchDto != null && urlaubsanspruchDto.length > 0) {

				Double fStunden = 0D;
				Double fTage = 0D;

				BigDecimal iWochenUrlaub = new BigDecimal(
						urlaubsanspruchDto[0].getFJahresurlaubinwochen().doubleValue());

				for (int i = 0; i < abschnitte.size(); i++) {
					Abschnitt abschnitt = abschnitte.get(i);
					if (abschnitt != null) {

						int iAnzahlTage = Helper.getDifferenzInTagen(abschnitt.dVon, abschnitt.dBis) + 1;

						// PJ 15884
						ZeitmodellDto zeitmodellDto = zeitmodellFindByPrimaryKey(abschnitt.zeitmodellIId, theClientDto);

						Double d = getSummeSollzeitWochentagsUndSonntags(zeitmodellDto.getIId());

						fStunden += ((iWochenUrlaub.doubleValue() * iAnzahlTage) / ianzahlTageImJahr) * d;

						fTage += ((iWochenUrlaub.doubleValue() * iAnzahlTage) / ianzahlTageImJahr)
								* zeitmodellDto.getFUrlaubstageprowoche();

						int z = 0;

					}

				}

				urlDto.setNAktuellerUrlaubsanspruchTage(new BigDecimal(fTage));
				urlDto.setNAktuellerUrlaubsanspruchStunden(new BigDecimal(fStunden));

				if (urlaubsanspruchDto != null && urlaubsanspruchDto.length > 1) {

					// Wenn Abrechnungszeitpunkt = EchtesEintrittsjahr
					boolean bAbrechnungsJahrIstEintrittsjahr = false;
					if (dLetzterEchterEintritt != null) {
						Calendar cLetzterEchterEintritt = Calendar.getInstance();
						cLetzterEchterEintritt.setTime(dLetzterEchterEintritt);

						if (cLetzterEchterEintritt.get(Calendar.YEAR) == cAbrechnungszeitpunkt.get(Calendar.YEAR)) {
							bAbrechnungsJahrIstEintrittsjahr = true;
						}

					}
					if (bAbrechnungsJahrIstEintrittsjahr) {
						urlDto.setNAlterUrlaubsanspruchTage(BigDecimal.ZERO);
						urlDto.setNAlterUrlaubsanspruchStunden(BigDecimal.ZERO);
					} else {
						urlDto.setNAlterUrlaubsanspruchTage(
								new BigDecimal(urlaubsanspruchDto[1].getFResturlaubjahresendetage()));
						urlDto.setNAlterUrlaubsanspruchStunden(
								new BigDecimal(urlaubsanspruchDto[1].getFResturlaubjahresendestunden()));
					}

				}

				BigDecimal nAktuellerUrlaubVerbrauchtTage = getAktuellerUrlaubTageweise(personalIId,
						new java.sql.Timestamp(cErsterJaenner.getTimeInMillis()),
						new java.sql.Timestamp(dAbrechnungzeitpunkt.getTime()));
				urlDto.setNAktuellerUrlaubVerbrauchtTage(nAktuellerUrlaubVerbrauchtTage);

				// Verfuegbaren Tageweisen Urlaub berechnen

				if (urlDto.getNAlterUrlaubsanspruchTage() == null) {
					urlDto.setNAlterUrlaubsanspruchTage(BigDecimal.ZERO);
				}
				if (urlDto.getNAlterUrlaubsanspruchStunden() == null) {
					urlDto.setNAlterUrlaubsanspruchStunden(BigDecimal.ZERO);
				}

				BigDecimal bdVerfuegbarAktuellTage = urlDto.getNAktuellerUrlaubsanspruchTage()
						.subtract(nAktuellerUrlaubVerbrauchtTage).add(urlDto.getNAlterUrlaubsanspruchTage());

				urlDto.setNVerfuegbarerUrlaubTage(bdVerfuegbarAktuellTage);

				Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto)
						.getIId();
				Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto)
						.getIId();

				BigDecimal nAktuellerUrlaubVerbrauchtStunden = getAktuelleUrlaubStunden(personalIId,
						new java.sql.Timestamp(cErsterJaenner.getTimeInMillis()),
						new java.sql.Timestamp(dAbrechnungzeitpunkt.getTime()), tagesartIId_Feiertag,
						tagesartIId_Halbtag, theClientDto);

				urlDto.setNAktuellerUrlaubVerbrauchtStunden(nAktuellerUrlaubVerbrauchtStunden);

				BigDecimal bdVerfuegbarAktuellStunden = urlDto.getNAktuellerUrlaubsanspruchStunden()
						.subtract(nAktuellerUrlaubVerbrauchtStunden).add(urlDto.getNAlterUrlaubsanspruchStunden());

				urlDto.setNVerfuegbarerUrlaubStunden(bdVerfuegbarAktuellStunden);

				// Resturlaub im Dezember niederschreiben
				if (cAbrechnungszeitpunkt.get(Calendar.MONTH) == Calendar.DECEMBER
						&& cAbrechnungszeitpunkt.get(Calendar.DAY_OF_MONTH) == 31) {
					UrlaubsanspruchDto urlAnspDto = getPersonalFac()
							.urlaubsanspruchFindByPrimaryKey(urlaubsanspruchDto[0].getIId());

					if (!Helper.short2boolean(urlAnspDto.getBGesperrt())) {
						urlAnspDto.setFStunden(urlDto.getNAktuellerUrlaubsanspruchStunden().doubleValue());
						urlAnspDto.setFTage(urlDto.getNAktuellerUrlaubsanspruchTage().doubleValue());

						urlAnspDto.setFResturlaubjahresendestunden(bdVerfuegbarAktuellStunden.doubleValue());
						urlAnspDto.setFResturlaubjahresendetage(bdVerfuegbarAktuellTage.doubleValue());
						getPersonalFac().updateUrlaubsanspruch(urlAnspDto, theClientDto);
					}
				}

			} else {
				// SP7014
				urlDto.setNAktuellerUrlaubsanspruchStunden(new BigDecimal(0));
				urlDto.setNAktuellerUrlaubVerbrauchtStunden(new BigDecimal(0));
				urlDto.setNAlterUrlaubsanspruchStunden(new BigDecimal(0));
				urlDto.setNGeplanterUrlaubStunden(new BigDecimal(0));
				urlDto.setNVerfuegbarerUrlaubStunden(new BigDecimal(0));

				urlDto.setNAktuellerUrlaubsanspruchTage(new BigDecimal(0));
				urlDto.setNAktuellerUrlaubVerbrauchtTage(new BigDecimal(0));
				urlDto.setNAlterUrlaubsanspruchTage(new BigDecimal(0));
				urlDto.setNGeplanterUrlaubTage(new BigDecimal(0));
				urlDto.setNVerfuegbarerUrlaubTage(new BigDecimal(0));
				urlDto.setDAbrechnungszeitpunkt(dAbrechnungzeitpunkt);
			}

		} catch (RemoteException e) {
			throwEJBExceptionLPRespectOld(e);
		}

		return urlDto;
	}

	/**
	 * Berechnen des Urlaubsanspruches einer Person Eintrittsdatum bis heute oder
	 * einem best. Datum
	 * 
	 * Wenn Urlaubsabrechnung nach Gesch&auml;ftsjahr, dann muss f&uuml;r das
	 * Eintrittsjahr der entstprechende Urlaub eingegeben werden
	 * 
	 * @param personalIId          des partners
	 * @param dAbrechnungzeitpunkt Berechnung bis
	 * @param theClientDto         User-ID
	 * @return UrlaubsabrechnungDto
	 * @exception EJBExceptionLP
	 */
	public UrlaubsabrechnungDto berechneUrlaubsAnspruch(Integer personalIId, java.sql.Date dAbrechnungzeitpunkt,
			TheClientDto theClientDto) throws EJBExceptionLP {

		if (personalIId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("personalIId == null"));
		}
		if (dAbrechnungzeitpunkt == null) {
			dAbrechnungzeitpunkt = new java.sql.Date(System.currentTimeMillis()); // heute
		}

		Date dEintrittsdatum = null;

		Date dAustrittsdatum = null;

		// Hole letztes Eintrittsdatum

		EintrittaustrittDto eaDto = null;

		try {
			eaDto = getPersonalFac().eintrittaustrittFindLetztenEintrittBisDatum(personalIId,
					new Timestamp(dAbrechnungzeitpunkt.getTime()));
			if (eaDto != null) {
				dEintrittsdatum = eaDto.getTEintritt();
				dAustrittsdatum = eaDto.getTAustritt();
			}
		} catch (RemoteException ex3) {
			throwEJBExceptionLPRespectOld(ex3);
		}

		// /-------------
		Calendar cTemp = Calendar.getInstance();
		cTemp.setTimeInMillis(dAbrechnungzeitpunkt.getTime());

		ParametermandantDto parameter = null;
		try {
			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_URLAUBSABRECHNUNG_ZUM_EINTRITT);
		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		boolean bUrlaubsabrechnungZumEintrittsdatum = ((Boolean) parameter.getCWertAsObject());

		int iEintrittsjahr = getUrlaubsjahrAnhandAbrechnungszeitpunkt(dEintrittsdatum,
				bUrlaubsabrechnungZumEintrittsdatum, dEintrittsdatum);

		int iAkttuellesjahr = getUrlaubsjahrAnhandAbrechnungszeitpunkt(dAbrechnungzeitpunkt,
				bUrlaubsabrechnungZumEintrittsdatum, dEintrittsdatum);

		double i_stunden_resturlaub = 0;
		double i_tage_resturlaub = 0;

		// Resturlaub aus dem Vorjahr holen
		if (iAkttuellesjahr > iEintrittsjahr) {
			try {
				UrlaubsanspruchDto[] urlaubsanspruchDto = getPersonalFac()
						.urlaubsanspruchFindByPersonalIIdIJahrKleiner(personalIId, iAkttuellesjahr - 1);
				if (urlaubsanspruchDto != null && urlaubsanspruchDto.length > 0
						&& urlaubsanspruchDto[0].getIJahr().intValue() == iAkttuellesjahr - 1
						&& urlaubsanspruchDto[0].getFResturlaubjahresendestunden() != null
						&& urlaubsanspruchDto[0].getFResturlaubjahresendetage() != null
						&& bUrlaubsabrechnungZumEintrittsdatum == false) {
					// nix
					i_stunden_resturlaub = urlaubsanspruchDto[0].getFResturlaubjahresendestunden();
					i_tage_resturlaub = urlaubsanspruchDto[0].getFResturlaubjahresendetage();
				} else {

					// Vorjahr berechnen
					Calendar cVorjahr = Calendar.getInstance();

					if (bUrlaubsabrechnungZumEintrittsdatum) {
						cVorjahr.set(iAkttuellesjahr, Calendar.DECEMBER, 31, 23, 59);

						Calendar cEintrittsdatum = Calendar.getInstance();
						cEintrittsdatum.setTimeInMillis(dEintrittsdatum.getTime());

						cVorjahr.set(Calendar.MONTH, cEintrittsdatum.get(Calendar.MONTH));
						cVorjahr.set(Calendar.DAY_OF_MONTH, cEintrittsdatum.get(Calendar.DAY_OF_MONTH));
						cVorjahr.add(Calendar.DAY_OF_MONTH, -1);

					} else {
						cVorjahr.set(iAkttuellesjahr - 1, Calendar.DECEMBER, 31, 23, 59);
					}

					berechneUrlaubsAnspruch(personalIId, new java.sql.Date(cVorjahr.getTimeInMillis()), theClientDto);

					// Nun sollte es fuer das letzte jahr einen uebertrag geben
					urlaubsanspruchDto = getPersonalFac().urlaubsanspruchFindByPersonalIIdIJahrKleiner(personalIId,
							iAkttuellesjahr - 1);
					if (urlaubsanspruchDto != null && urlaubsanspruchDto.length > 0) {
						i_stunden_resturlaub = 0;
						if (urlaubsanspruchDto[0].getFResturlaubjahresendestunden() != null) {
							i_stunden_resturlaub = urlaubsanspruchDto[0].getFResturlaubjahresendestunden();
						}
						i_tage_resturlaub = 0;
						if (urlaubsanspruchDto[0].getFResturlaubjahresendetage() != null) {
							i_tage_resturlaub = urlaubsanspruchDto[0].getFResturlaubjahresendetage();
						}

					}
				}
			} catch (RemoteException ex4) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex4);
			}
		}
		// ----------------

		// Hole Personal
		PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);

		java.sql.Timestamp dAktuellerUrlaubsbeginn = null;

		Calendar cAktuellerUrlaubsbeginn = Calendar.getInstance();
		cAktuellerUrlaubsbeginn.setTime(dAbrechnungzeitpunkt);

		if (bUrlaubsabrechnungZumEintrittsdatum == true) {

			cAktuellerUrlaubsbeginn.set(Calendar.YEAR, iAkttuellesjahr);

			Calendar cEintrittsdatum = Calendar.getInstance();
			cEintrittsdatum.setTimeInMillis(dEintrittsdatum.getTime());
			cAktuellerUrlaubsbeginn.set(Calendar.MONTH, cEintrittsdatum.get(Calendar.MONTH));
			cAktuellerUrlaubsbeginn.set(Calendar.DAY_OF_MONTH, cEintrittsdatum.get(Calendar.DAY_OF_MONTH));

		} else {

			cAktuellerUrlaubsbeginn.set(Calendar.MONTH, 0);
			cAktuellerUrlaubsbeginn.set(Calendar.DAY_OF_MONTH, 1);

		}

		dAktuellerUrlaubsbeginn = new java.sql.Timestamp(cAktuellerUrlaubsbeginn.getTime().getTime()); // aktueller
		// Geschaeftsjahreswechsel
		// Fuer erstes Jahr muss ein separater Eintrag angelegt werden
		// darauffolgendes Jahr muss extra definiert werden.

		// 2 Neue Parameter: Geschaeftsjahresbeginn (Monat (1-12)) und
		// B_VOREILEND*/

		dAktuellerUrlaubsbeginn = Helper.cutTimestamp(dAktuellerUrlaubsbeginn);
		// PJ 14091
		if (dEintrittsdatum != null && dEintrittsdatum.after(dAktuellerUrlaubsbeginn)) {
			dAktuellerUrlaubsbeginn = Helper.cutTimestamp(new Timestamp(dEintrittsdatum.getTime()));
		}

		UrlaubsabrechnungDto urlaubsabrechnungDto = new UrlaubsabrechnungDto();

		urlaubsabrechnungDto.setDAktuellerUrlaubsbeginn(dAktuellerUrlaubsbeginn);

		urlaubsabrechnungDto.setNAktuellerUrlaubsanspruchStunden(new BigDecimal(0));
		urlaubsabrechnungDto.setNAktuellerUrlaubVerbrauchtStunden(new BigDecimal(0));
		urlaubsabrechnungDto.setNAlterUrlaubsanspruchStunden(new BigDecimal(0));
		urlaubsabrechnungDto.setNGeplanterUrlaubStunden(new BigDecimal(0));
		urlaubsabrechnungDto.setNVerfuegbarerUrlaubStunden(new BigDecimal(0));

		urlaubsabrechnungDto.setNAktuellerUrlaubsanspruchTage(new BigDecimal(0));
		urlaubsabrechnungDto.setNAktuellerUrlaubVerbrauchtTage(new BigDecimal(0));
		urlaubsabrechnungDto.setNAlterUrlaubsanspruchTage(new BigDecimal(0));
		urlaubsabrechnungDto.setNGeplanterUrlaubTage(new BigDecimal(0));
		urlaubsabrechnungDto.setNVerfuegbarerUrlaubTage(new BigDecimal(0));
		urlaubsabrechnungDto.setDAbrechnungszeitpunkt(dAbrechnungzeitpunkt);

		// --- TAGESWEISE BETRACHTUNG ----
		// Ganze Urlaubstage ALT holen
		urlaubsabrechnungDto.setNAlterUrlaubsanspruchTage(new BigDecimal(i_tage_resturlaub));

		// Ganze Urlaubstage AKTUELL holen
		urlaubsabrechnungDto.setNAktuellerUrlaubVerbrauchtTage(
				getAktuellerUrlaubTageweise(personalIId, new java.sql.Timestamp(dAktuellerUrlaubsbeginn.getTime()),
						new java.sql.Timestamp(dAbrechnungzeitpunkt.getTime())));

		// Ganze Urlaubstage GEPLANT holen
		urlaubsabrechnungDto.setNGeplanterUrlaubTage(getGeplanterUrlaubTageweise(personalIId,
				Helper.addiereTageZuTimestamp(new java.sql.Timestamp(dAbrechnungzeitpunkt.getTime()), 1)));

		// --- STUNDENWEISE BETRACHTUNG ----

		Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
		Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();

		// Urlaubsstunden ALT holen
		urlaubsabrechnungDto.setNAlterUrlaubsanspruchTage(new BigDecimal(i_stunden_resturlaub));
		// Urlaubsstunden AKTUELL holen
		urlaubsabrechnungDto.setNAktuellerUrlaubVerbrauchtStunden(getAktuelleUrlaubStunden(personalIId,
				dAktuellerUrlaubsbeginn, new java.sql.Timestamp(dAbrechnungzeitpunkt.getTime()), tagesartIId_Feiertag,
				tagesartIId_Halbtag, theClientDto));
		// Urlaubsstunden GEPLANT holen
		urlaubsabrechnungDto.setNGeplanterUrlaubStunden(getGeplanteUrlaubStunden(personalDto,
				Helper.addiereTageZuTimestamp(new java.sql.Timestamp(dAbrechnungzeitpunkt.getTime()), 1),
				tagesartIId_Feiertag, tagesartIId_Halbtag, theClientDto));

		// AB HIER BEGINNT BERECHNUNG DES URLAUBSANSPRUCHES

		// Beginn und Endjahr des alten Urlaubsanspruches setzen

		Calendar c = Calendar.getInstance();

		c.setTime(dEintrittsdatum);
		int i_jahr_rest_beginn = c.get(Calendar.YEAR);

		double dAnzahlDerTageDesJahres = c.getActualMaximum(Calendar.DAY_OF_YEAR);
		double dTagUrlaubsbeginn = c.get(Calendar.DAY_OF_YEAR) - 1;

		c.setTime(dAktuellerUrlaubsbeginn);
		c.set(Calendar.YEAR, c.get(Calendar.YEAR) - 1);
		int i_jahr_rest_ende = c.get(Calendar.YEAR);

		if (iAkttuellesjahr >= 2009) {
			// Ab 2009 werden die Urlaubsanspruchsstunden lt. PJ 13282 gerechnet

			berechneUrlaubsanspruchsstundenAb2009(personalIId, iAkttuellesjahr, dEintrittsdatum,
					bUrlaubsabrechnungZumEintrittsdatum, theClientDto);

		}

		// PJ14891
		try {
			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_ERWEITERTER_URLAUBSANSPRUCH);
		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		int bErweiterterUrlaubsanspruch = ((Integer) parameter.getCWertAsObject());

		// Jahr des Aktuellen-Urlaubsanspruches
		c.setTime(dAktuellerUrlaubsbeginn);
		int iJahr = c.get(Calendar.YEAR);
		UrlaubsanspruchDto[] urlaubsanspruchDtos = null;
		try {
			urlaubsanspruchDtos = getPersonalFac().urlaubsanspruchFindByPersonalIIdIJahrKleiner(personalIId,
					new Integer(iJahr));

			if (urlaubsanspruchDtos.length > 0) {

				if (iJahr == i_jahr_rest_beginn && bErweiterterUrlaubsanspruch == 1
						&& bUrlaubsabrechnungZumEintrittsdatum == false) {

					Calendar cX = Calendar.getInstance();
					cX.setTimeInMillis(dEintrittsdatum.getTime());

					BigDecimal anspruchGesamt = new BigDecimal((urlaubsanspruchDtos[0].getFTage().doubleValue()
							+ urlaubsanspruchDtos[0].getFTagezusaetzlich().doubleValue()));

					BigDecimal anspruchGesamtStunden = new BigDecimal(
							(urlaubsanspruchDtos[0].getFStunden().doubleValue()
									+ urlaubsanspruchDtos[0].getFStundenzusaetzlich().doubleValue()));

					BigDecimal fFaktorFuerErweitertenUrlaubsanspruch =

							anspruchGesamtStunden.divide(anspruchGesamt, 4, BigDecimal.ROUND_HALF_EVEN);

					// Aliquote Urlaubsstunden
					double dAliquoterAnspruch = 0;

					Calendar cEintritt = Calendar.getInstance();
					cEintritt.setTime(dEintrittsdatum);

					double iAktuelleTagDesJahres = cTemp.get(Calendar.DAY_OF_YEAR);
					double anzahlTageDesJahres = c.getActualMaximum(Calendar.DAY_OF_YEAR);
					double urlaub = 0;

					double iAbTagUrlaubsansprung = cEintritt.get(Calendar.DAY_OF_YEAR);

					if (iAktuelleTagDesJahres > iAbTagUrlaubsansprung) {
						double urlaubsansprunhProTag = (anspruchGesamtStunden.doubleValue()
								/ (anzahlTageDesJahres - iAbTagUrlaubsansprung));

						dAliquoterAnspruch = ((iAktuelleTagDesJahres - iAbTagUrlaubsansprung) * urlaubsansprunhProTag);
					} else {
						dAliquoterAnspruch = 0;
					}

					urlaubsabrechnungDto.setNAliquoterAnspruchStunden(new BigDecimal(dAliquoterAnspruch));

					urlaubsabrechnungDto.setNAktuellerUrlaubsanspruchTage(
							rundeUrlaubstageAnhandParameter(anspruchGesamt, theClientDto));

					urlaubsabrechnungDto.setNAktuellerUrlaubsanspruchStunden(anspruchGesamtStunden);

				} else {

					urlaubsabrechnungDto
							.setNAktuellerUrlaubsanspruchTage(rundeUrlaubstageAnhandParameter(
									new BigDecimal(urlaubsanspruchDtos[0].getFTage().doubleValue()
											+ urlaubsanspruchDtos[0].getFTagezusaetzlich().doubleValue()),
									theClientDto));
					urlaubsabrechnungDto
							.setNAktuellerUrlaubsanspruchStunden(
									Helper.rundeKaufmaennisch(
											new BigDecimal(urlaubsanspruchDtos[0].getFStunden().doubleValue()
													+ urlaubsanspruchDtos[0].getFStundenzusaetzlich().doubleValue()),
											2));

					if (dAustrittsdatum != null) {
						// SP1042
						Calendar cAustritt = Calendar.getInstance();
						cAustritt.setTime(dAustrittsdatum);
						double anzahlTageDesJahres = cAustritt.getActualMaximum(Calendar.DAY_OF_YEAR);

						Calendar cEndeDesJahres = Calendar.getInstance();

						cEndeDesJahres.setTime(cAustritt.getTime());

						cEndeDesJahres.set(Calendar.MONTH, Calendar.DECEMBER);
						cEndeDesJahres.set(Calendar.DAY_OF_MONTH, 31);

						if (cAustritt.get(Calendar.YEAR) == iAkttuellesjahr) {

							int iTageUrlaub = 0;
							if (iEintrittsjahr == iAkttuellesjahr) {

								anzahlTageDesJahres = Helper.ermittleTageEinesZeitraumes(
										new java.sql.Date(dEintrittsdatum.getTime()),
										new java.sql.Date(cEndeDesJahres.getTime().getTime()));

								iTageUrlaub = Helper.ermittleTageEinesZeitraumes(
										new java.sql.Date(dEintrittsdatum.getTime()),
										new java.sql.Date(dAustrittsdatum.getTime()));
							} else {

								cAustritt.set(Calendar.MONTH, Calendar.JANUARY);
								cAustritt.set(Calendar.DAY_OF_MONTH, 1);
								iTageUrlaub = Helper.ermittleTageEinesZeitraumes(
										new java.sql.Date(cAustritt.getTimeInMillis()),
										new java.sql.Date(dAustrittsdatum.getTime()));
							}
							anzahlTageDesJahres++;
							iTageUrlaub++;

							urlaubsabrechnungDto
									.setNAktuellerUrlaubsanspruchTage(
											rundeUrlaubstageAnhandParameter(
													urlaubsabrechnungDto.getNAktuellerUrlaubsanspruchTage().multiply(
															new BigDecimal(iTageUrlaub / anzahlTageDesJahres)),
													theClientDto));

							urlaubsabrechnungDto.setNAktuellerUrlaubsanspruchStunden(
									urlaubsabrechnungDto.getNAktuellerUrlaubsanspruchStunden()
											.multiply(new BigDecimal(iTageUrlaub / anzahlTageDesJahres)));

						}

					}

				}

				// Ganze Urlaubstage AKTUELL ALIQUOT holen
				Double dAliquotTageweise = getAliquoterUrlaubsanspruchTageweise(
						new java.sql.Timestamp(dAbrechnungzeitpunkt.getTime()), urlaubsanspruchDtos[0].getFTage(),
						dEintrittsdatum, bUrlaubsabrechnungZumEintrittsdatum, theClientDto);
				urlaubsabrechnungDto.setNAliquoterAnspruchTage(new BigDecimal(
						dAliquotTageweise.doubleValue() + urlaubsanspruchDtos[0].getFTagezusaetzlich().doubleValue()));

				BigDecimal bdAliquotStunden = null;
				if (bErweiterterUrlaubsanspruch > 0 && iJahr == i_jahr_rest_beginn
						&& bUrlaubsabrechnungZumEintrittsdatum == false) {
					// Muesste schon vorher berechnet worden sein
					if (urlaubsabrechnungDto.getNAliquoterAnspruchStunden() == null) {
						urlaubsabrechnungDto.setNAliquoterAnspruchStunden(new BigDecimal(0));
					}

				} else {

					if (iAkttuellesjahr >= 2009) {
						bdAliquotStunden = berechneAliquotenUrlaubsanspruchsstundenAb2009(personalIId,
								dAbrechnungzeitpunkt, dEintrittsdatum, bUrlaubsabrechnungZumEintrittsdatum,
								theClientDto);
					} else {
						// Urlaubsstunden AKTUELL ALIQUOT holen

						bdAliquotStunden = getAliquoterUrlaubsanspruchStunden(
								new java.sql.Timestamp(dAbrechnungzeitpunkt.getTime()),
								urlaubsanspruchDtos[0].getFStunden(), theClientDto, dEintrittsdatum);
					}

					// PJ 14082
					bdAliquotStunden = bdAliquotStunden
							.add(new BigDecimal(urlaubsanspruchDtos[0].getFStundenzusaetzlich().doubleValue()));

					urlaubsabrechnungDto.setNAliquoterAnspruchStunden(bdAliquotStunden);

				}

			} else {
				urlaubsabrechnungDto.setNAliquoterAnspruchTage(new BigDecimal(0));
				urlaubsabrechnungDto.setNAliquoterAnspruchStunden(new BigDecimal(0));

			}

		} catch (RemoteException ex6) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex6);
		}

		// Resturlaub

		urlaubsabrechnungDto
				.setNAlterUrlaubsanspruchTage(Helper.rundeKaufmaennisch(new BigDecimal(i_tage_resturlaub), 2));
		urlaubsabrechnungDto
				.setNAlterUrlaubsanspruchStunden(Helper.rundeKaufmaennisch(new BigDecimal(i_stunden_resturlaub), 2));

		// Verfuegbaren Tageweisen Urlaub berechnen
		BigDecimal bdVerfuegbarAltTage = new BigDecimal(i_tage_resturlaub);
		BigDecimal bdVerfuegbarAktuellTage = urlaubsabrechnungDto.getNAliquoterAnspruchTage()
				.subtract(urlaubsabrechnungDto.getNAktuellerUrlaubVerbrauchtTage());

		urlaubsabrechnungDto.setNVerfuegbarerUrlaubTage(bdVerfuegbarAltTage.add(bdVerfuegbarAktuellTage));

		// Verfuegbaren Stundenweisen Urlaub berechnen
		BigDecimal bdVerfuegbarAltStunden = new BigDecimal(i_stunden_resturlaub);
		BigDecimal bdVerfuegbarAktuellStunden = urlaubsabrechnungDto.getNAliquoterAnspruchStunden()
				.subtract(urlaubsabrechnungDto.getNAktuellerUrlaubVerbrauchtStunden());

		urlaubsabrechnungDto.setNVerfuegbarerUrlaubStunden(bdVerfuegbarAltStunden.add(bdVerfuegbarAktuellStunden));

		// Wenn Dezember, dann fuers aktuelle Jahr niederschreiben

		Calendar cTempDezember = Calendar.getInstance();
		cTempDezember.setTimeInMillis(dAbrechnungzeitpunkt.getTime());

		Calendar cEintrittsdatum = Calendar.getInstance();
		cEintrittsdatum.setTimeInMillis(dEintrittsdatum.getTime());

		if ((bUrlaubsabrechnungZumEintrittsdatum == false && cTempDezember.get(Calendar.MONTH) == Calendar.DECEMBER
				&& cTempDezember.get(Calendar.DAY_OF_MONTH) == 31) || bUrlaubsabrechnungZumEintrittsdatum == true) {
			try {
				UrlaubsanspruchDto[] urlaubsanspruchDto = getPersonalFac()
						.urlaubsanspruchFindByPersonalIIdIJahrKleiner(personalIId, iAkttuellesjahr);

				if (urlaubsanspruchDto != null && urlaubsanspruchDto.length > 0) {

					if (urlaubsanspruchDto[0].getIJahr().intValue() == iAkttuellesjahr) {

						if (Helper.short2boolean(urlaubsanspruchDto[0].getBGesperrt()) == false) {
							urlaubsanspruchDto[0].setFResturlaubjahresendestunden(
									urlaubsabrechnungDto.getNAliquoterAnspruchStunden().doubleValue()
											+ urlaubsabrechnungDto.getNAlterUrlaubsanspruchStunden().doubleValue()
											- urlaubsabrechnungDto.getNAktuellerUrlaubVerbrauchtStunden()
													.doubleValue());

							Double dUrlaubIntagen = urlaubsabrechnungDto.getNAliquoterAnspruchTage().doubleValue()
									+ urlaubsabrechnungDto.getNAlterUrlaubsanspruchTage().doubleValue()
									- urlaubsabrechnungDto.getNAktuellerUrlaubVerbrauchtTage().doubleValue();

							// SP1984

							urlaubsanspruchDto[0].setFResturlaubjahresendetage(
									rundeUrlaubstageAnhandParameter(new BigDecimal(dUrlaubIntagen), theClientDto)
											.doubleValue());
							getPersonalFac().updateUrlaubsanspruch(urlaubsanspruchDto[0], theClientDto);
						}

					} else {
						// Wenns fuer heuer keine gibt, den letzten kopieren
						urlaubsanspruchDto[0].setIJahr(iAkttuellesjahr);
						urlaubsanspruchDto[0].setBGesperrt(Helper.boolean2Short(false));
						urlaubsanspruchDto[0].setFStundenzusaetzlich(new Double(0));
						urlaubsanspruchDto[0].setFTagezusaetzlich(new Double(0));
						urlaubsanspruchDto[0].setFResturlaubjahresendestunden(
								urlaubsabrechnungDto.getNAliquoterAnspruchStunden().doubleValue()
										- urlaubsabrechnungDto.getNAktuellerUrlaubVerbrauchtStunden().doubleValue());

						// SP1984

						Double dUrlaubIntagen = urlaubsabrechnungDto.getNAliquoterAnspruchTage().doubleValue()
								- urlaubsabrechnungDto.getNAktuellerUrlaubVerbrauchtTage().doubleValue();
						urlaubsanspruchDto[0].setFResturlaubjahresendetage(
								rundeUrlaubstageAnhandParameter(new BigDecimal(dUrlaubIntagen), theClientDto)
										.doubleValue());
						getPersonalFac().createUrlaubsanspruch(urlaubsanspruchDto[0], theClientDto);
					}

				} else {
					// geht nicht, da ueberhaupt noch nie ein Anspruch
					// definiert wurde
				}

			} catch (RemoteException e) {
				throwEJBExceptionLPRespectOld(e);
			}

		}

		// PJ20020/SP6495
		boolean bLinearerUrlaubsanspruch = true;
		try {
			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_URLAUBSANSPRUCH_LINEAR_VERTEILT);

			bLinearerUrlaubsanspruch = ((Boolean) parameter.getCWertAsObject());

			if (bLinearerUrlaubsanspruch == false) {

				// Bis zum Abrechnungszeitpunkt
				UrlaubsabrechnungDto urlaubsabrechnungDtoNichtLinear = berechneUrlaubsanspruchAliquotMitKarenzenZumAbrechnungszeitpunkt(
						personalIId, dAbrechnungzeitpunkt, theClientDto);

				urlaubsabrechnungDto.setNAliquoterAnspruchStunden(
						urlaubsabrechnungDtoNichtLinear.getNAktuellerUrlaubsanspruchStunden());
				urlaubsabrechnungDto
						.setNAliquoterAnspruchTage(urlaubsabrechnungDtoNichtLinear.getNAktuellerUrlaubsanspruchTage());

				urlaubsabrechnungDto
						.setNVerfuegbarerUrlaubStunden(urlaubsabrechnungDtoNichtLinear.getNVerfuegbarerUrlaubStunden());

				urlaubsabrechnungDto
						.setNVerfuegbarerUrlaubTage(urlaubsabrechnungDtoNichtLinear.getNVerfuegbarerUrlaubTage());

				urlaubsabrechnungDto.setNAktuellerUrlaubVerbrauchtTage(
						urlaubsabrechnungDtoNichtLinear.getNAktuellerUrlaubVerbrauchtTage());
				urlaubsabrechnungDto.setNAktuellerUrlaubVerbrauchtStunden(
						urlaubsabrechnungDtoNichtLinear.getNAktuellerUrlaubVerbrauchtStunden());

				// Bis zum Ende des Jahres
				Calendar c31Dezember = Calendar.getInstance();
				c31Dezember.setTime(dAbrechnungzeitpunkt);
				c31Dezember.set(Calendar.MONTH, Calendar.DECEMBER);
				c31Dezember.set(Calendar.DAY_OF_MONTH, 31);

				urlaubsabrechnungDtoNichtLinear = berechneUrlaubsanspruchAliquotMitKarenzenZumAbrechnungszeitpunkt(
						personalIId, new java.sql.Date(c31Dezember.getTimeInMillis()), theClientDto);

				urlaubsabrechnungDto.setNAktuellerUrlaubsanspruchStunden(
						urlaubsabrechnungDtoNichtLinear.getNAktuellerUrlaubsanspruchStunden());
				urlaubsabrechnungDto.setNAktuellerUrlaubsanspruchTage(
						urlaubsabrechnungDtoNichtLinear.getNAktuellerUrlaubsanspruchTage());

				urlaubsabrechnungDto.setNAlterUrlaubsanspruchStunden(
						urlaubsabrechnungDtoNichtLinear.getNAlterUrlaubsanspruchStunden());
				urlaubsabrechnungDto
						.setNAlterUrlaubsanspruchTage(urlaubsabrechnungDtoNichtLinear.getNAlterUrlaubsanspruchTage());

			}

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		return urlaubsabrechnungDto;
	}

	private TaetigkeitDto[] getAllBenutzerdefinierteSondertaetigkeiten() {
		// try {

		Query query = em.createNamedQuery("TaetigkeitfindByTaetigkeitartCNr");
		query.setParameter(1, ZeiterfassungFac.TAETIGKEITART_SONDERTAETIGKEIT);
		Collection<?> c = query.getResultList();
		// if (c.isEmpty()) {
		// return new TaetigkeitDto[0];
		// }
		List<TaetigkeitDto> list = new ArrayList<TaetigkeitDto>();
		if (c != null) {
			Iterator<?> iterator = c.iterator();
			while (iterator.hasNext()) {
				Taetigkeit taetigkeit = (Taetigkeit) iterator.next();

				if (taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ARZT)
						|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_BEHOERDE)
						|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ENDE)
						|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_GEHT)
						|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KOMMT)
						|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KRANK)
						|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_UNTER)
						|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_URLAUB)
						|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ZEITAUSGLEICH)) {

				} else {
					list.add(assembleTaetigkeitDto(taetigkeit));
				}

			}
		}

		TaetigkeitDto[] returnArray = new TaetigkeitDto[list.size()];
		return (TaetigkeitDto[]) list.toArray(returnArray);

	}

	public BigDecimal getStundenAllerBezahltenSondertaetigkeitenImZeitraum(Integer personalIId,
			Integer tagesartIId_Feiertag, Integer tagesartIId_Halbtag, java.sql.Timestamp tVon, java.sql.Timestamp tBis,
			TheClientDto theClientDto) {
		TaetigkeitDto[] taetigkeitenDtos = getAllSondertaetigkeitenOhneKommtUndGeht(theClientDto);

		double dGesamtdauer = 0;

		for (int j = 0; j < taetigkeitenDtos.length; j++) {

			if (taetigkeitenDtos[j].getFBezahlt() > 0) {
				double dDauer = getGesamtDauerEinerSondertaetigkeitImZeitraum(personalIId, tVon, tBis,
						taetigkeitenDtos[j].getIId(), theClientDto, tagesartIId_Feiertag, tagesartIId_Halbtag).dStunden;

				dDauer = dDauer * (taetigkeitenDtos[j].getFBezahlt() / 100);

				dGesamtdauer += dDauer;
			}
		}

		return new BigDecimal(dGesamtdauer);
	}

	private TaetigkeitDto[] getAllSondertaetigkeitenOhneKommtUndGeht(TheClientDto theClientDto) {
		// try {

		Query query = em.createNamedQuery("TaetigkeitfindByTaetigkeitartCNr");
		query.setParameter(1, ZeiterfassungFac.TAETIGKEITART_SONDERTAETIGKEIT);
		Collection<?> c = query.getResultList();
		List<TaetigkeitDto> list = new ArrayList<TaetigkeitDto>();
		if (c != null) {
			Iterator<?> iterator = c.iterator();
			while (iterator.hasNext()) {
				Taetigkeit taetigkeit = (Taetigkeit) iterator.next();

				if (taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ENDE)
						|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_GEHT)
						|| taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KOMMT)) {

				} else {

					list.add(taetigkeitFindByPrimaryKey(taetigkeit.getIId(), theClientDto));
				}

			}
		}

		TaetigkeitDto[] returnArray = new TaetigkeitDto[list.size()];
		return (TaetigkeitDto[]) list.toArray(returnArray);

		// }
		// catch (NoResultException ex) {
		// return new TaetigkeitDto[0];
		// }
	}

	/**
	 * Ermittelt ob eine bestimmte Person an diesem Tag einen Sondertaetigkeit
	 * stundenweise eingetragen hat. Der R&uuml;ckgabewert ist ein Vector welcher
	 * die Bezeichnung der Sondertaetigkeit mit dazugeh&ouml;rige Stundenanzahl
	 * (dezimal) enth&auml;lt. Sind mehrere Sondert&auml;tigkeiten an diesem Tag
	 * eingetragen sieht der Vector zB folgenderma&szlig;en aus: Vector: Element 0:
	 * URLAUB Element 1: 5.5 (Stunden) Element 2: ARZT Element 3: 3.5 (Stunden) ...
	 * Vector enth&auml;lt also immer eine gerade Zahl von Elementen
	 * 
	 * @param taetigkeitCNr Taetigkeit
	 * @param tDatum        Datum
	 * @param personalIId   Personal-ID
	 * @return SonderzeitenDto
	 */
	private SonderzeitenDto sonderzeitenFindByPersonalIIdDDatumTaetigkeitIId(Integer personalIId,
			java.sql.Timestamp tDatum, String taetigkeitCNr) {
		try {
			Query query = em.createNamedQuery("SonderzeitenfindByPersonalIIdTDatumTaetigkeitIId");
			query.setParameter(1, personalIId);
			query.setParameter(2, tDatum);
			query.setParameter(3, ((Taetigkeit) em.createNamedQuery("TaetigkeitfindByCNr")
					.setParameter(1, taetigkeitCNr).getSingleResult()).getIId());
			Sonderzeiten sonderzeiten = (Sonderzeiten) query.getSingleResult();
			return assembleSonderzeitenDto(sonderzeiten);
		} catch (NoResultException ex) {
			return null;
		}
	}

	public JasperPrintLP printSondertaetigkeiten(TheClientDto theClientDto) {

		index = -1;
		sAktuellerReport = ZeiterfassungFac.REPORT_SONDERTAETIKGEITEN;
		HashMap parameter = new HashMap<Object, Object>();

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Criteria taetigkeiten = session.createCriteria(FLRTaetigkeit.class);

		taetigkeiten.add(Restrictions.ge(ZeiterfassungFac.FLR_TAETIGKEIT_B_BDEBUCHBAR, Helper.boolean2Short(true)));

		taetigkeiten.addOrder(Order.asc("c_nr"));

		List<?> resultListArtikel = taetigkeiten.list();

		Iterator<?> resultListIterator = resultListArtikel.iterator();

		String sLocUI = Helper.locale2String(theClientDto.getLocUi());
		data = new Object[resultListArtikel.size()][2];
		int row = 0;
		while (resultListIterator.hasNext()) {
			FLRTaetigkeit artikel = (FLRTaetigkeit) resultListIterator.next();

			data[row][REPORT_SONDERTAETIGKEITEN_KENNUNG] = artikel.getC_nr().toUpperCase().trim();

			Iterator<?> sprsetIterator = artikel.getTaetigkeitsprset().iterator();
			while (sprsetIterator.hasNext()) {
				FLRTaetigkeitspr taetigkeitspr = (FLRTaetigkeitspr) sprsetIterator.next();
				if (taetigkeitspr.getLocale().getC_nr().compareTo(sLocUI) == 0) {
					data[row][REPORT_SONDERTAETIGKEITEN_BEZEICHNUNG] = taetigkeitspr.getC_bez();
					break;
				}
			}

			row++;

		}

		initJRDS(parameter, ZeiterfassungFac.REPORT_MODUL, ZeiterfassungFac.REPORT_SONDERTAETIKGEITEN,
				theClientDto.getMandant(), theClientDto.getLocUi(), theClientDto);
		return getReportPrint();
	}

	/**
	 * Erstellt eine Anwesenheitsliste zum Zeitpunkt JETZT
	 * 
	 * @param theClientDto String
	 * @return JasperPrint
	 * @throws RemoteException
	 * @throws EJBExceptionLP
	 */
	public JasperPrintLP printAnwesenheitsliste(TheClientDto theClientDto) throws EJBExceptionLP, RemoteException {

		return printAnwesenheitsliste(theClientDto, null);
	}

	public JasperPrintLP printAnwesenheitsliste(TheClientDto theClientDto, Integer kostenstelleIId)
			throws EJBExceptionLP, RemoteException {
		boolean bDarfAlleSehen = getTheJudgeFac().hatRecht(RechteFac.RECHT_PERS_ANWESENHEITSLISTE_R, theClientDto);

		if (bDarfAlleSehen == false) {
			bDarfAlleSehen = getTheJudgeFac().hatRecht(RechteFac.RECHT_PERS_SICHTBARKEIT_ALLE, theClientDto);
		}

		boolean bDarfAbteilungSehen = getTheJudgeFac().hatRecht(RechteFac.RECHT_PERS_SICHTBARKEIT_ABTEILUNG,
				theClientDto);
		return printAnwesenheitsliste2(theClientDto, bDarfAlleSehen, bDarfAbteilungSehen, kostenstelleIId);
	}

	private Object[] befuelleAnwesenheitslisteMitBelegdaten(Object[] dataHelp, ZeitdatenDto dto,
			TheClientDto theClientDto) {

		if (dto.getCBelegartnr() != null) {

			if (dto.getArtikelIId() != null) {
				ArtikelDto aDtoTaetigkeit = getArtikelFac().artikelFindByPrimaryKeySmall(dto.getArtikelIId(),
						theClientDto);
				dataHelp[REPORT_ANWESENHEITSLISTE_TAETIGKEIT_ARTIKELNUMMER] = aDtoTaetigkeit.getCNr();
				dataHelp[REPORT_ANWESENHEITSLISTE_TAETIGKEIT_BEZEICHNUNG] = aDtoTaetigkeit.getCBezAusSpr();
			}

			if (dto.getMaschineIId() != null) {
				MaschineDto mDto = getZeiterfassungFac().maschineFindByPrimaryKey(dto.getMaschineIId());
				dataHelp[REPORT_ANWESENHEITSLISTE_MASCHINE_INVENTARNUMMER] = mDto.getCInventarnummer();
				dataHelp[REPORT_ANWESENHEITSLISTE_MASCHINE_BEZEICHNUNG] = mDto.getCBez();
			}

			if (dto.getCBelegartnr().equals(LocaleFac.BELEGART_AUFTRAG)) {
				try {
					AuftragDto auftragDto = getAuftragFac().auftragFindByPrimaryKey(dto.getIBelegartid());
					dataHelp[REPORT_ANWESENHEITSLISTE_TAETIGKEIT] = "AB-" + auftragDto.getCNr();

					dataHelp[REPORT_ANWESENHEITSLISTE_AUFTRAGSNUMMER] = auftragDto.getCNr();
					dataHelp[REPORT_ANWESENHEITSLISTE_PROJEKTBEZEICHNUNG] = auftragDto.getCBezProjektbezeichnung();

					KundeDto kdDto = getKundeFac().kundeFindByPrimaryKey(auftragDto.getKundeIIdAuftragsadresse(),
							theClientDto);
					dataHelp[REPORT_ANWESENHEITSLISTE_KUNDE_KURZBEZEICHNUNG] = kdDto.getPartnerDto().getCKbez();

				} catch (Throwable ex5) {
					dataHelp[REPORT_ANWESENHEITSLISTE_TAETIGKEIT] = "AUFT-NOT-FOUND";
				}
			} else if (dto.getCBelegartnr().equals(LocaleFac.BELEGART_LOS)) {
				try {
					LosDto losDto = getFertigungFac().losFindByPrimaryKey(dto.getIBelegartid());
					dataHelp[REPORT_ANWESENHEITSLISTE_TAETIGKEIT] = "LO-" + losDto.getCNr();

					dataHelp[REPORT_ANWESENHEITSLISTE_LOSNUMMER] = losDto.getCNr();
					dataHelp[REPORT_ANWESENHEITSLISTE_LOS_KOMMENTAR] = losDto.getCKommentar();

					dataHelp[REPORT_ANWESENHEITSLISTE_PROJEKTBEZEICHNUNG] = losDto.getCProjekt();

					if (losDto.getAuftragIId() != null) {
						AuftragDto auftragDtoLos = getAuftragFac().auftragFindByPrimaryKey(losDto.getAuftragIId());
						dataHelp[REPORT_ANWESENHEITSLISTE_AUFTRAGSNUMMER] = auftragDtoLos.getCNr();
					}

					if (dto.getIBelegartpositionid() != null) {
						LossollarbeitsplanDto saDto = getFertigungFac()
								.lossollarbeitsplanFindByPrimaryKeyOhneExc(dto.getIBelegartpositionid());
						if (saDto != null) {

							dataHelp[REPORT_ANWESENHEITSLISTE_LOS_AGNUMMER] = saDto.getIArbeitsgangnummer();
							dataHelp[REPORT_ANWESENHEITSLISTE_LOS_UAGNUMMER] = saDto.getIUnterarbeitsgang();

							if (saDto.getMaschineIId() != null) {
								MaschineDto mDto = getZeiterfassungFac()
										.maschineFindByPrimaryKey(saDto.getMaschineIId());
								dataHelp[REPORT_ANWESENHEITSLISTE_LOS_MASCHINE_INVENTARNUMMER] = mDto
										.getCInventarnummer();
								dataHelp[REPORT_ANWESENHEITSLISTE_LOS_MASCHINE_BEZEICHNUNG] = mDto.getCBez();
							}
						}

					}
					if (losDto.getKundeIId() != null) {
						KundeDto kdDto = getKundeFac().kundeFindByPrimaryKey(losDto.getKundeIId(), theClientDto);
						dataHelp[REPORT_ANWESENHEITSLISTE_KUNDE_KURZBEZEICHNUNG] = kdDto.getPartnerDto().getCKbez();
						dataHelp[REPORT_ANWESENHEITSLISTE_PARTNER_KURZBEZEICHNUNG] = kdDto.getPartnerDto().getCKbez();
					}

				} catch (RemoteException ex5) {
					dataHelp[REPORT_ANWESENHEITSLISTE_TAETIGKEIT] = "LOS-NOT-FOUND";
				}
			} else if (dto.getCBelegartnr().equals(LocaleFac.BELEGART_PROJEKT)) {
				try {
					ProjektDto projektDto = getProjektFac().projektFindByPrimaryKey(dto.getIBelegartid());
					dataHelp[REPORT_ANWESENHEITSLISTE_TAETIGKEIT] = "PJ-" + projektDto.getCNr();

					PartnerDto pDto = getPartnerFac().partnerFindByPrimaryKey(projektDto.getPartnerIId(), theClientDto);
					dataHelp[REPORT_ANWESENHEITSLISTE_PARTNER_KURZBEZEICHNUNG] = pDto.getCKbez();
					dataHelp[REPORT_ANWESENHEITSLISTE_PROJEKTNUMMER] = projektDto.getCNr();
					dataHelp[REPORT_ANWESENHEITSLISTE_PROJEKTBEZEICHNUNG] = projektDto.getCTitel();

				} catch (RemoteException ex5) {
					dataHelp[REPORT_ANWESENHEITSLISTE_TAETIGKEIT] = "PJ-NOT-FOUND";
				}
			}
		}
		dataHelp[REPORT_ANWESENHEITSLISTE_ZEIT] = new java.sql.Time(dto.getTZeit().getTime()).toString().substring(0,
				5);
		dataHelp[REPORT_ANWESENHEITSLISTE_QUELLE] = dto.getCWowurdegebucht();

		return dataHelp;
	}

	/***
	 * Anwesenheitsliste f&uuml;r Terminal (nur Local IF)
	 * 
	 * @param theClientDto
	 * @param bDarfAlleSehen
	 * @param bDarfAbteilungSehen
	 * @return JasperPrint der Anwesenheitsliste
	 */
	public JasperPrintLP printAnwesenheitsliste2(TheClientDto theClientDto, boolean bDarfAlleSehen,
			boolean bDarfAbteilungSehen, Integer kostenstelleIId) {

		index = -1;
		sAktuellerReport = ZeiterfassungFac.REPORT_ANWESENHEITSLISTE;

		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = null;
		session = factory.openSession();

		HashMap parameter = new HashMap<Object, Object>();

		String sQery = "SELECT personal from FLRPersonal as personal WHERE personal.mandant_c_nr='"
				+ theClientDto.getMandant() + "' AND personal.b_versteckt=0";

		if (bDarfAlleSehen == false) {
			PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(theClientDto.getIDPersonal(),
					theClientDto);
			if (bDarfAbteilungSehen && personalDto.getKostenstelleIIdAbteilung() != null) {
				sQery += " AND personal.flrkostenstelleabteilung.i_id=" + personalDto.getKostenstelleIIdAbteilung();
			} else {
				sQery += " AND personal.i_id=" + theClientDto.getIDPersonal();
			}
		} else {
			if (kostenstelleIId != null) {
				sQery += " AND personal.flrkostenstelleabteilung.i_id=" + kostenstelleIId;

				parameter.put("P_KOSTENSTELLE_ABTEILUNG",
						getSystemFac().kostenstelleFindByPrimaryKey(kostenstelleIId).formatKostenstellenbezeichnung());

			}
		}

		sQery += " ORDER BY personal.flrpartner.c_name1nachnamefirmazeile1 ASC";

		Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
		Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();

		org.hibernate.Query query = session.createQuery(sQery);

		List<?> resultList = query.list();
		Iterator<?> resultListIterator = resultList.iterator();
		int row = 0;
		Object[][] dataHelp = new Object[resultList.size()][REPORT_ANWESENHEITSLISTE_ANZAHL_SPALTEN];

		java.sql.Timestamp tsJetzt = new java.sql.Timestamp(System.currentTimeMillis());

		while (resultListIterator.hasNext()) {

			FLRPersonal personal = (FLRPersonal) resultListIterator.next();

			ZeitdatenDto[] dtos = null;
			ZeitdatenDto[] dtosMitBelegzeiten = null;
			// try {
			Query query2 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
			query2.setParameter(1, personal.getI_id());
			query2.setParameter(2, Helper.cutTimestamp(tsJetzt));
			query2.setParameter(3, tsJetzt);
			dtos = assembleZeitdatenOhneArbeitsUndMaschienzeitenDtos(query2.getResultList());
			dtosMitBelegzeiten = assembleZeitdatenDtos(query2.getResultList());
			// }
			// catch (NoResultException ex) {
			// dtos = new ZeitdatenDto[0];
			// }
			boolean bAnzeigen = false;

			// Nachsehen, ob noch eingetreten oder in Personalliste anzeigen
			// aktiviert
			PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personal.getI_id(), theClientDto);

			if (Helper.short2boolean(personalDto.getBAnwesenheitsliste()) == true) {
				bAnzeigen = true;
			}
			try {
				Boolean bAusgetreten = getPersonalFac().istPersonalAusgetreten(personal.getI_id(),
						Helper.cutTimestamp(tsJetzt), theClientDto);
				if (bAusgetreten.booleanValue() == false && bAnzeigen == true) {
					bAnzeigen = true;
				}
			} catch (RemoteException ex3) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex3);
			}

			// Wenn noch eingetreten und Hakerl in Personalliste anzeigen
			// aktiviert
			if (bAnzeigen == true) {
				dataHelp[row][REPORT_ANWESENHEITSLISTE_PERSONAL_I_ID] = personalDto.getIId();
				dataHelp[row][REPORT_ANWESENHEITSLISTE_NAME] = personalDto.formatAnrede();

				dataHelp[row][REPORT_ANWESENHEITSLISTE_VORNAME] = personalDto.getPartnerDto()
						.getCName2vornamefirmazeile2();
				dataHelp[row][REPORT_ANWESENHEITSLISTE_NACHNAME] = personalDto.getPartnerDto()
						.getCName1nachnamefirmazeile1();

				dataHelp[row][REPORT_ANWESENHEITSLISTE_PERSONALNUMMER] = personalDto.getCPersonalnr();

				SonderzeitenDto[] sonderzeitenDtos = null;
				try {
					// Hier nun Sonderzeiten holen
					sonderzeitenDtos = getZeiterfassungFac().sonderzeitenFindByPersonalIIdDDatum(personalDto.getIId(),
							Helper.cutTimestamp(tsJetzt));
					if (sonderzeitenDtos.length > 0) {
						TaetigkeitDto taeitgkeitDto = getZeiterfassungFac()
								.taetigkeitFindByPrimaryKey(sonderzeitenDtos[0].getTaetigkeitIId(), theClientDto);

						if (taeitgkeitDto.getAbwesenheitsartIId() != null) {
							AbwesenheitsartDto abwDto = getPersonalFac().abwesenheitsartFindByPrimaryKey(
									taeitgkeitDto.getAbwesenheitsartIId(), theClientDto);
							dataHelp[row][REPORT_ANWESENHEITSLISTE_ABWESENHEITSART_KENNUNG] = abwDto.getCNr();
							dataHelp[row][REPORT_ANWESENHEITSLISTE_ABWESENHEITSART_BEZEICHNUNG] = abwDto
									.getBezeichnung();

						}

						dataHelp[row][REPORT_ANWESENHEITSLISTE_SONDERZEIT] = taeitgkeitDto.getBezeichnung();

						dataHelp[row][REPORT_ANWESENHEITSLISTE_SONDERZEIT_STUNDEN] = sonderzeitenDtos[0].getUStunden();
						if (sonderzeitenDtos[0].getUStunden() != null) {
							dataHelp[row][REPORT_ANWESENHEITSLISTE_SONDERZEIT_ART] = "Stunden";
						} else {
							if (Helper.short2boolean(sonderzeitenDtos[0].getBTag()) == true) {
								dataHelp[row][REPORT_ANWESENHEITSLISTE_SONDERZEIT_ART] = "Ganzer Tag";
							} else {
								dataHelp[row][REPORT_ANWESENHEITSLISTE_SONDERZEIT_ART] = "Halber Tag";
							}
						}

					}
					ParametermandantDto parameterMandantDto = getParameterFac().getMandantparameter(
							theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
							ParameterFac.ANWESENHEITSLISTE_TELEFON_PRIVAT_ANZEIGEN);
					Boolean bTelPrivatAnzeigen = (Boolean) parameterMandantDto.getCWertAsObject();

					if (personalDto.getPartnerDto().getCTelefon() != null
							&& bTelPrivatAnzeigen.booleanValue() == true) {
						dataHelp[row][REPORT_ANWESENHEITSLISTE_TEL_PRIVAT] = personalDto.getPartnerDto().getCTelefon();
					}
				} catch (RemoteException ex6) {
					throwEJBExceptionLPRespectOld(ex6);
				}

				// Reise holen
				// Wenn letzter Reiseeintrag Beginn, dann abwesend
				SessionFactory factoryReise = FLRSessionFactory.getFactory();
				Session sessionReise = factoryReise.openSession();

				org.hibernate.Criteria critReise = sessionReise.createCriteria(FLRReise.class);
				critReise.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_PERSONAL_I_ID, personalDto.getIId()));
				critReise.add(Restrictions.lt(ZeiterfassungFac.FLR_REISE_T_ZEIT, tsJetzt));
				critReise.addOrder(Order.desc(ZeiterfassungFac.FLR_REISE_T_ZEIT));

				List<?> resultListReise = critReise.list();

				Iterator<?> resultListIteratorReise = resultListReise.iterator();
				// Erster Eintrag ist beginn
				FLRReise letzterReiseEintrag = null;
				if (resultListIteratorReise.hasNext()) {
					letzterReiseEintrag = (FLRReise) resultListIteratorReise.next();
				}

				if (letzterReiseEintrag != null && Helper.short2boolean(letzterReiseEintrag.getB_beginn()) == true) {
					dataHelp[row][REPORT_ANWESENHEITSLISTE_ZEIT] = new java.sql.Time(
							letzterReiseEintrag.getT_zeit().getTime()).toString().substring(0, 5);
					dataHelp[row][REPORT_ANWESENHEITSLISTE_TAETIGKEIT] = ZeiterfassungFac.TAETIGKEIT_REISE.trim();
					dataHelp[row][REPORT_ANWESENHEITSLISTE_ANWESEND] = new Integer(0);
				} else {

					if (dtos.length > 0) {
						// Wenn Zeitdaten vorhanden dann letzten Eintrag holen
						ZeitdatenDto letzterEintrag = dtos[dtos.length - 1];

						TaetigkeitDto letzteTaetigkeit = taetigkeitFindByPrimaryKey(letzterEintrag.getTaetigkeitIId(),
								theClientDto);
						dataHelp[row][REPORT_ANWESENHEITSLISTE_TAETIGKEIT] = letzteTaetigkeit.getBezeichnung();
						dataHelp[row][REPORT_ANWESENHEITSLISTE_ZEIT] = new java.sql.Time(
								letzterEintrag.getTZeit().getTime()).toString().substring(0, 5);
						dataHelp[row][REPORT_ANWESENHEITSLISTE_QUELLE] = letzterEintrag.getCWowurdegebucht();

						if (letzteTaetigkeit.getAbwesenheitsartIId() != null) {
							AbwesenheitsartDto abwDto = getPersonalFac().abwesenheitsartFindByPrimaryKey(
									letzteTaetigkeit.getAbwesenheitsartIId(), theClientDto);
							dataHelp[row][REPORT_ANWESENHEITSLISTE_ABWESENHEITSART_KENNUNG] = abwDto.getCNr();
							dataHelp[row][REPORT_ANWESENHEITSLISTE_ABWESENHEITSART_BEZEICHNUNG] = abwDto
									.getBezeichnung();

						}

						// Ist letzte Taetigkeit ein GEHT
						if (letzteTaetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_GEHT)) {
							// ABWESEND
							dataHelp[row][REPORT_ANWESENHEITSLISTE_ANWESEND] = new Integer(0);

						} else if (letzteTaetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_KOMMT)
								|| letzteTaetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ENDE)) {
							// ANWESEND
							dataHelp[row][REPORT_ANWESENHEITSLISTE_ANWESEND] = new Integer(1);

							// Auftragsnummer anzeigen, wenn gerade auf Auftrag
							// gestempelt wird
							// try {
							Query query3 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
							query3.setParameter(1, personalDto.getIId());
							query3.setParameter(2, letzterEintrag.getTZeit());
							query3.setParameter(3, new Timestamp(System.currentTimeMillis()));

							ZeitdatenDto[] auftraege = assembleZeitdatenDtos(query3.getResultList());
							if (auftraege != null && auftraege.length > 1) {
								ZeitdatenDto dto = auftraege[auftraege.length - 1];

								dataHelp[row] = befuelleAnwesenheitslisteMitBelegdaten(dataHelp[row], dto,
										theClientDto);

							}
							// }
							// catch (NoResultException ex4) {
							// nothing here
							// }
						} else {

							ZeitdatenDto[] zeitdatenEinerTaetigkeit = null;
							// try {
							Query query5 = em.createNamedQuery("ZeitdatenfindByPersonalIIdTaetigkeitIIdTVonTBis");
							query5.setParameter(1, personal.getI_id());
							query5.setParameter(2, letzterEintrag.getTaetigkeitIId());
							query5.setParameter(3, Helper.cutTimestamp(tsJetzt));
							query5.setParameter(4, tsJetzt);
							zeitdatenEinerTaetigkeit = assembleZeitdatenDtos(query5.getResultList());
							// }
							// catch (NoResultException ex1) {
							// zeitdatenEinerTaetigkeit = new ZeitdatenDto[0];
							// }
							// Wenn Anzahl der Taetigkeiten gerade, dann
							// anwesend
							if (zeitdatenEinerTaetigkeit.length % 2 == 0) {
								// ANWESEND
								dataHelp[row][REPORT_ANWESENHEITSLISTE_ANWESEND] = new Integer(1);

								// Auftragsnummer anzeigen, wenn gerade auf
								// Auftrag gestempelt wird
								// try {
								Query query3 = em.createNamedQuery("ZeitdatenfindZeitdatenEinesTagesUndEinerPerson");
								query3.setParameter(1, personalDto.getIId());
								query3.setParameter(2, letzterEintrag.getTZeit());
								query3.setParameter(3, new Timestamp(System.currentTimeMillis()));

								ZeitdatenDto[] auftraege = assembleZeitdatenDtos(query3.getResultList());
								if (auftraege != null && auftraege.length > 1) {
									ZeitdatenDto dto = auftraege[auftraege.length - 1];
									dataHelp[row] = befuelleAnwesenheitslisteMitBelegdaten(dataHelp[row], dto,
											theClientDto);
								} else {

									// PJ18768 Wenn nach der Pause auf keinen
									// Auftrag gestempelt wurde, dann den letzen
									// offenen suchen
									for (int k = dtosMitBelegzeiten.length - 1; k > 0; --k) {

										// Wenn zuletzt ENDE, dann kein Auftrag
										// angestempelt
										if (dtosMitBelegzeiten[k].getTaetigkeitIId() != null) {

											TaetigkeitDto taetigkeit = taetigkeitFindByPrimaryKey(
													dtosMitBelegzeiten[k].getTaetigkeitIId(), theClientDto);
											if (taetigkeit.getCNr().equals(ZeiterfassungFac.TAETIGKEIT_ENDE)) {
												break;
											}

										}

										if (dtosMitBelegzeiten[k].getCBelegartnr() != null
												&& dtosMitBelegzeiten[k].getIBelegartid() != null) {
											ZeitdatenDto dto = dtosMitBelegzeiten[k];

											String belegartUndNummer = "";

											if (dto.getCBelegartnr().equals(LocaleFac.BELEGART_AUFTRAG)) {
												try {
													AuftragDto auftragDto = getAuftragFac()
															.auftragFindByPrimaryKey(dto.getIBelegartid());
													belegartUndNummer = "AB-" + auftragDto.getCNr();
												} catch (Throwable ex5) {
													belegartUndNummer = "AUFT-NOT-FOUND";
												}
											} else if (dto.getCBelegartnr().equals(LocaleFac.BELEGART_LOS)) {
												try {
													LosDto losDto = getFertigungFac()
															.losFindByPrimaryKey(dto.getIBelegartid());
													belegartUndNummer = "LO-" + losDto.getCNr();
												} catch (RemoteException ex5) {
													belegartUndNummer = "LOS-NOT-FOUND";
												}
											} else if (dto.getCBelegartnr().equals(LocaleFac.BELEGART_PROJEKT)) {
												try {
													ProjektDto projektDto = getProjektFac()
															.projektFindByPrimaryKey(dto.getIBelegartid());
													belegartUndNummer = "PJ-" + projektDto.getCNr();
												} catch (RemoteException ex5) {
													belegartUndNummer = "PJ-NOT-FOUND";
												}
											}

											String sVorhanden = (String) dataHelp[row][REPORT_ANWESENHEITSLISTE_TAETIGKEIT];

											sVorhanden += " (" + belegartUndNummer + ")";
											dataHelp[row][REPORT_ANWESENHEITSLISTE_TAETIGKEIT] = sVorhanden;

											break;

										}

									}

								}
								// }
								// catch (NoResultException ex4) {
								// nothing here
								// }

							} else {
								// ABWESEND
								dataHelp[row][REPORT_ANWESENHEITSLISTE_ANWESEND] = new Integer(0);
							}

						}

						// Wenn vorhanden, vorletzten Eintrag Holen

					} else {
						// Wenn keine Zeitdaten vorhanden dann in Sonderzeiten
						// nachsehen; Auf jeden Fall abwesend
						dataHelp[row][REPORT_ANWESENHEITSLISTE_ANWESEND] = new Integer(0);

						dataHelp[row][REPORT_ANWESENHEITSLISTE_TAETIGKEIT] = "Kein Eintrag f\u00FCr Heute";
						SonderzeitenDto[] sonderzeiten = null;
						// try {
						Query query8 = em.createNamedQuery("SonderzeitenfindByPersonalIIdTDatum");
						query8.setParameter(1, personal.getI_id());
						query8.setParameter(2, Helper.cutTimestamp(tsJetzt));
						sonderzeiten = assembleSonderzeitenDtos(query8.getResultList());
						// }
						// catch (NoResultException ex2) {
						// sonderzeiten = new SonderzeitenDto[0];
						// }

						if (sonderzeiten.length > 0) {
							SonderzeitenDto sonderzeitenDto = sonderzeiten[0];
							TaetigkeitDto taetigkeitDto = taetigkeitFindByPrimaryKey(sonderzeitenDto.getTaetigkeitIId(),
									theClientDto);

							if (taetigkeitDto.getAbwesenheitsartIId() != null) {
								AbwesenheitsartDto abwDto = getPersonalFac().abwesenheitsartFindByPrimaryKey(
										taetigkeitDto.getAbwesenheitsartIId(), theClientDto);
								dataHelp[row][REPORT_ANWESENHEITSLISTE_ABWESENHEITSART_KENNUNG] = abwDto.getCNr();
								dataHelp[row][REPORT_ANWESENHEITSLISTE_ABWESENHEITSART_BEZEICHNUNG] = abwDto
										.getBezeichnung();

							}

							dataHelp[row][REPORT_ANWESENHEITSLISTE_TAETIGKEIT] = taetigkeitDto.getBezeichnung();
						} else {

							// PJ21860
							ZeitmodelltagDto zmDto = getZeitmodelltagZuDatum(personal.getI_id(),
									Helper.cutTimestamp(tsJetzt), tagesartIId_Feiertag, tagesartIId_Halbtag, false,
									theClientDto);
							if (zmDto == null || zmDto.getUSollzeit() == null
									|| (zmDto.getUSollzeit() != null && zmDto.getUSollzeit().getTime() == -3600000)) {
								dataHelp[row][REPORT_ANWESENHEITSLISTE_TAETIGKEIT] = "Keine Sollzeit";
							}
						}
					}
				}
				row++;

				sessionReise.close();
			}
		}

		session.close();

		for (int i = row - 1; i > 0; --i) {
			for (int j = 0; j < i; ++j) {
				if (((Integer) dataHelp[j][REPORT_ANWESENHEITSLISTE_ANWESEND])
						.intValue() < ((Integer) dataHelp[j + 1][REPORT_ANWESENHEITSLISTE_ANWESEND]).intValue()) {
					Object[] oTemp = dataHelp[j];
					dataHelp[j] = dataHelp[j + 1];
					dataHelp[j + 1] = oTemp;
				}
			}
		}

		data = new Object[row][REPORT_ANWESENHEITSLISTE_ANZAHL_SPALTEN];
		for (int i = 0; i < row; i++) {
			data[i] = dataHelp[i];
		}

		PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(theClientDto.getIDPersonal(), theClientDto);

		if (personalDto.getKostenstelleDto_Abteilung() != null) {
			parameter.put("P_ABTEILUNG_AUFRUFER",
					personalDto.getKostenstelleDto_Abteilung().formatKostenstellenbezeichnung());
		}

		index = -1;
		sAktuellerReport = ZeiterfassungFac.REPORT_ANWESENHEITSLISTE;
		initJRDS(parameter, ZeiterfassungFac.REPORT_MODUL, ZeiterfassungFac.REPORT_ANWESENHEITSLISTE,
				theClientDto.getMandant(), theClientDto.getLocUi(), theClientDto);
		return getReportPrint();
	}

	public DauerSondertaetigkeitenDto getGesamtDauerEinerSondertaetigkeitImZeitraum(Integer personalIId, Timestamp tVon,
			Timestamp tBis, Integer taetigkeitIId, TheClientDto theClientDto, Integer tagesartIId_Feiertag,
			Integer tagesartIId_Halbtag) {

		boolean bVonBisZeiterfassungOhneKommtGeht = false;
		boolean bKommtGeht = true;
		boolean bVonBis = false;

		TreeMap<String, Object[]> tmDatenSubreportSchichtzulagen = new TreeMap<String, Object[]>();

		try {
			ParametermandantDto parameter = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_VON_BIS_ERFASSUNG);

			bVonBis = (Boolean) parameter.getCWertAsObject();

			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_VON_BIS_ERFASSUNG_KOMMT_GEHT_BUCHEN);

			bKommtGeht = (Boolean) parameter.getCWertAsObject();

			if (bVonBis == true && bKommtGeht == false) {
				bVonBisZeiterfassungOhneKommtGeht = true;
			}

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}
		double dDauer = 0;

		if (bVonBisZeiterfassungOhneKommtGeht) {
			dDauer = berechneDauerPaarweiserSondertaetigkeitenEinerPersonUndEinesZeitraumesVonBis(personalIId, tVon,
					tBis, taetigkeitIId, theClientDto);
		} else {
			dDauer = berechneDauerPaarweiserSondertaetigkeitenEinerPersonUndEinesZeitraumes(personalIId, tVon, tBis,
					taetigkeitIId);
		}

		PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);
		double dTage = 0;
		// try {
		Query query = em.createNamedQuery("SonderzeitenfindByPersonalIIdTVonTBisTaetigkeitIId");
		query.setParameter(1, personalIId);
		query.setParameter(2, tVon);
		query.setParameter(3, tBis);
		query.setParameter(4, taetigkeitIId);
		SonderzeitenDto[] sonderzeitenDtos = assembleSonderzeitenDtos(query.getResultList());
		for (int k = 0; k < sonderzeitenDtos.length; k++) {

			if (Helper.short2boolean(sonderzeitenDtos[k].getBTag()) == true) {

				Double dDauerTagesweise = Helper
						.time2Double(getSollzeitZuDatum(personalDto, sonderzeitenDtos[k].getTDatum(),
								tagesartIId_Feiertag, tagesartIId_Halbtag, theClientDto, true));
				if (dDauerTagesweise != null) {
					dTage = dTage + 1;
					dDauer = dDauer + dDauerTagesweise.doubleValue();
				}
			} else if (Helper.short2boolean(sonderzeitenDtos[k].getBHalbtag()) == true) {
				Double dDauerHalbtagesweise = Helper
						.time2Double(getSollzeitZuDatum(personalDto, sonderzeitenDtos[k].getTDatum(),
								tagesartIId_Feiertag, tagesartIId_Halbtag, theClientDto, true));
				if (dDauerHalbtagesweise != null) {
					double dTemp = dDauerHalbtagesweise.doubleValue();
					dDauer = dDauer + dTemp;
					dTage = dTage + 0.5;
				}

			} else if (sonderzeitenDtos[k].getUStunden() != null) {
				dDauer = dDauer + Helper.time2Double(sonderzeitenDtos[k].getUStunden()).doubleValue();

			}

		}

		// }
		// catch (NoResultException ex2) {
		// nothing here
		// }

		return new DauerSondertaetigkeitenDto(dDauer, dTage);

	}

	public boolean sindReisezeitenZueinemTagVorhanden(Integer personalIId, java.sql.Timestamp tDatum,
			TheClientDto theClientDto) {

		String sQuery = "select reise FROM FLRReise reise WHERE reise.t_zeit='"
				+ Helper.formatDateWithSlashes(new java.sql.Date(tDatum.getTime())) + "' AND reise.personal_i_id="
				+ personalIId;

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query query = session.createQuery(sQuery);
		query.setMaxResults(1);

		List<?> resultList = query.list();

		Iterator<?> resultListIterator = resultList.iterator();

		if (resultListIterator.hasNext()) {
			return true;
		} else {
			return false;
		}

	}

	public Timestamp getErstesKommtEinesTages(Integer personalIId, java.sql.Timestamp tDatum,
			TheClientDto theClientDto) {

		Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();

		tDatum = Helper.cutTimestamp(tDatum);

		String sQuery = "select zeitdaten FROM FLRZeitdaten zeitdaten WHERE zeitdaten.t_zeit>='"
				+ Helper.formatDateWithSlashes(new java.sql.Date(tDatum.getTime())) + "' AND zeitdaten.t_zeit<'"
				+ Helper.formatDateWithSlashes(Helper.addiereTageZuDatum(new java.sql.Date(tDatum.getTime()), 1))
				+ "' AND zeitdaten.personal_i_id=" + personalIId + " AND zeitdaten.taetigkeit_i_id="
				+ taetigkeitIId_Kommt + " ORDER BY zeitdaten.t_zeit ASC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query letzteKommtGeht = session.createQuery(sQuery);
		letzteKommtGeht.setMaxResults(1);

		List<?> resultList = letzteKommtGeht.list();

		Iterator<?> resultListIterator = resultList.iterator();

		if (resultListIterator.hasNext()) {
			FLRZeitdaten l = (FLRZeitdaten) resultListIterator.next();
			return new Timestamp(l.getT_zeit().getTime());
		}

		return null;
	}

	public Timestamp getLetzteGebuchteZeit(Integer personalIId, java.sql.Timestamp tDatum, TheClientDto theClientDto) {

		String sQuery = "select zeitdaten FROM FLRZeitdaten zeitdaten WHERE zeitdaten.t_zeit<'"
				+ Helper.formatDateWithSlashes(Helper.addiereTageZuDatum(new java.sql.Date(tDatum.getTime()), 1))
				+ "' AND zeitdaten.t_zeit>='" + Helper.formatDateWithSlashes(new java.sql.Date(tDatum.getTime()))
				+ "' AND zeitdaten.personal_i_id=" + personalIId + " ORDER BY zeitdaten.t_zeit DESC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query letzteBuchung = session.createQuery(sQuery);
		letzteBuchung.setMaxResults(1);

		List<?> resultList = letzteBuchung.list();

		Iterator<?> resultListIterator = resultList.iterator();

		if (resultListIterator.hasNext()) {
			FLRZeitdaten l = (FLRZeitdaten) resultListIterator.next();
			return new Timestamp(l.getT_zeit().getTime());
		}

		return null;
	}

	public Timestamp getLetztesGehtEinesTages(Integer personalIId, java.sql.Timestamp tDatum,
			TheClientDto theClientDto) {

		Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();
		tDatum = Helper.cutTimestamp(tDatum);

		String sQuery = "select zeitdaten FROM FLRZeitdaten zeitdaten WHERE zeitdaten.t_zeit>='"
				+ Helper.formatDateWithSlashes(new java.sql.Date(tDatum.getTime())) + "' AND zeitdaten.t_zeit<'"
				+ Helper.formatDateWithSlashes(Helper.addiereTageZuDatum(new java.sql.Date(tDatum.getTime()), 1))
				+ "' AND zeitdaten.personal_i_id=" + personalIId + " AND zeitdaten.taetigkeit_i_id="
				+ taetigkeitIId_Geht + " ORDER BY zeitdaten.t_zeit DESC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query letzteKommtGeht = session.createQuery(sQuery);
		letzteKommtGeht.setMaxResults(1);

		List<?> resultList = letzteKommtGeht.list();

		Iterator<?> resultListIterator = resultList.iterator();

		if (resultListIterator.hasNext()) {
			FLRZeitdaten l = (FLRZeitdaten) resultListIterator.next();
			return new Timestamp(l.getT_zeit().getTime());
		}

		return null;
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public JasperPrintLP printSondertaetigkeitsliste(Integer personalIId, Integer taetigkeitIId,
			java.sql.Timestamp tVon, java.sql.Timestamp tBis, Integer iOption, Integer kostenstelleIIdAbteilung,
			Boolean bPlusVersteckte, boolean bNurAnwesende, int iOptionSortierung, boolean bMitDetails,
			TheClientDto theClientDto) {
		if (tVon == null || tBis == null || personalIId == iOption) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("tVon == null || tBis == null || personalIId == iOption"));
		}

		Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();

		Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
		Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();

		PersonalDto[] personalDtos = null;
		String sParameter_Personen = "";
		try {
			if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON) {

				if (personalIId == null) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
							new Exception("personalIId == null"));
				}

				personalDtos = new PersonalDto[1];

				personalDtos[0] = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);
				sParameter_Personen = personalDtos[0].getPartnerDto().formatAnrede();
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_PERSONEN) {
				personalDtos = getPersonalFac().personalFindByMandantCNr(theClientDto.getMandant(), bPlusVersteckte);
				sParameter_Personen = "Alle Personen";
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_EINE_ABTEILUNG) {
				PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);
				personalDtos = getPersonalFac().personalFindAllPersonenEinerAbteilung(kostenstelleIIdAbteilung,
						theClientDto.getMandant(), bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ARBEITER) {
				personalDtos = getPersonalFac().personalFindAllArbeiterEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
				sParameter_Personen = "Alle Arbeiter";
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ANGESTELLTE) {
				personalDtos = getPersonalFac().personalFindAllAngestellteEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
				sParameter_Personen = "Alle Angestellten";
			} else {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER, new Exception("OPTION NICHT VERFUEGBAR"));
			}
			if (bNurAnwesende) {
				personalDtos = getZeiterfassungFac().entferneNichtAnwesendePersonen(tVon, tBis, personalDtos,
						theClientDto);
			}
		} catch (RemoteException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		}

		TaetigkeitDto[] taetigkeitenDtos = null;
		if (taetigkeitIId == null) {
			taetigkeitenDtos = getAllSondertaetigkeitenOhneKommtUndGeht(theClientDto);
		} else {
			taetigkeitenDtos = new TaetigkeitDto[1];
			taetigkeitenDtos[0] = taetigkeitFindByPrimaryKey(taetigkeitIId, theClientDto);
		}

		List<Object[]> list = new ArrayList<Object[]>();
		double[] dGesamtDauer = new double[taetigkeitenDtos.length];
		double[] dGesamtDauerTage = new double[taetigkeitenDtos.length];
		for (int i = 0; i < personalDtos.length; i++) {
			PersonalDto personalDto = personalDtos[i];

			personalDto
					.setPartnerDto(getPartnerFac().partnerFindByPrimaryKey(personalDto.getPartnerIId(), theClientDto));

			for (int j = 0; j < taetigkeitenDtos.length; j++) {
				Object[] reihe = new Object[REPORT_SONDERTAETIGKEITENLISTE_ANZAHL_SPALTEN];

				DauerSondertaetigkeitenDto objDauer =

						getGesamtDauerEinerSondertaetigkeitImZeitraum(personalDto.getIId(), tVon, tBis,
								taetigkeitenDtos[j].getIId(), theClientDto, tagesartIId_Feiertag, tagesartIId_Halbtag);
				double dDauer = objDauer.dStunden;
				double dDauerTage = objDauer.dTage;

				// SP310

				if (taetigkeitenDtos[j].getIId() == 19) {
					int z = 0;
				}

				Integer iTageHintereinander = 0;
				SonderzeitenDto[] sonderzeitenDtos = sonderzeitenFindByPersonalIIdDDatum(personalDto.getIId(), tBis);
				TaetigkeitDto t2Dto = null;
				if (sonderzeitenDtos.length > 0) {
					t2Dto = taetigkeitFindByPrimaryKey(sonderzeitenDtos[0].getTaetigkeitIId(), theClientDto);
				}

				if ((sonderzeitenDtos.length > 0 && Helper.short2boolean(sonderzeitenDtos[0].getBTag())
						&& sonderzeitenDtos[0].getTaetigkeitIId().equals(taetigkeitenDtos[j].getIId()))
						|| (sonderzeitenDtos.length > 0 && Helper.short2boolean(sonderzeitenDtos[0].getBTag())
								&& !sonderzeitenDtos[0].getTaetigkeitIId().equals(taetigkeitenDtos[j].getIId())
								&& Helper.short2Boolean(t2Dto.getBUnterbrichtwarnmeldung()) == false)) {

					iTageHintereinander++;
					SessionFactory factory = FLRSessionFactory.getFactory();
					Session session = factory.openSession();
					org.hibernate.Criteria letztesKommt = session.createCriteria(FLRZeitdaten.class);

					letztesKommt.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalDto.getIId()));
					letztesKommt
							.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID, taetigkeitIId_Kommt));

					letztesKommt.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tBis));
					letztesKommt.addOrder(Order.desc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));
					letztesKommt.setMaxResults(1);

					List<?> resultListLetztesKommt = letztesKommt.list();

					Date tLetztesKommt = new Timestamp(0);

					if (resultListLetztesKommt.size() > 0) {
						tLetztesKommt = ((FLRZeitdaten) resultListLetztesKommt.iterator().next()).getT_zeit();
					}

					Integer taetigkeitIIdWarnnmeldung = taetigkeitenDtos[j].getIId();

					Timestamp tTag = tBis;
					tTag = Helper.addiereTageZuTimestamp(new Timestamp(tTag.getTime()), -1);

					while (tTag.getTime() > tLetztesKommt.getTime()) {

						sonderzeitenDtos = sonderzeitenFindByPersonalIIdDDatum(personalDto.getIId(), tTag);

						TaetigkeitDto tDto = null;

						if (sonderzeitenDtos.length > 0) {
							tDto = taetigkeitFindByPrimaryKey(sonderzeitenDtos[0].getTaetigkeitIId(), theClientDto);
						} else {
							tDto = null;
						}

						if ((sonderzeitenDtos.length > 0 && Helper.short2boolean(sonderzeitenDtos[0].getBTag())
								&& sonderzeitenDtos[0].getTaetigkeitIId().equals(taetigkeitIIdWarnnmeldung))
								|| sonderzeitenDtos.length == 0
								|| (sonderzeitenDtos.length > 0 && Helper.short2boolean(sonderzeitenDtos[0].getBTag())
										&& !sonderzeitenDtos[0].getTaetigkeitIId().equals(taetigkeitIIdWarnnmeldung)
										&& Helper.short2Boolean(tDto.getBUnterbrichtwarnmeldung()) == false)) {
							iTageHintereinander++;
						} else {
							break;
						}
						tTag = Helper.addiereTageZuTimestamp(new Timestamp(tTag.getTime()), -1);
					}
				}

				if (dDauer > 0) {

					reihe[REPORT_SONDERTAETIGKEITENLISTE_PERSONALNUMMER_GRUPPIERUNG] = personalDto.getCPersonalnr();

					reihe[REPORT_SONDERTAETIGKEITENLISTE_NAME] = personalDto.formatAnrede();
					reihe[REPORT_SONDERTAETIGKEITENLISTE_PERSONALNUMMER] = personalDto.getCPersonalnr();

					reihe[REPORT_SONDERTAETIGKEITENLISTE_TAETIGKEIT] = taetigkeitenDtos[j].getBezeichnung();
					reihe[REPORT_SONDERTAETIGKEITENLISTE_WARNMEDLUNG_IN_KALENDERTAGEN] = taetigkeitenDtos[j]
							.getIWarnmeldunginkalendertagen();
					reihe[REPORT_SONDERTAETIGKEITENLISTE_LFD_FEHLTAGE] = iTageHintereinander;

					reihe[REPORT_SONDERTAETIGKEITENLISTE_ZEIT] = new Double(dDauer);
					reihe[REPORT_SONDERTAETIGKEITENLISTE_TAGE] = new Double(dDauerTage);
					reihe[REPORT_SONDERTAETIGKEITENLISTE_FAKTORBEZAHLT] = taetigkeitenDtos[j].getFBezahlt();

					reihe[REPORT_SONDERTAETIGKEITENLISTE_PARTNER_DTO] = personalDto.getPartnerDto();

					list.add(reihe);

					// PJ22578
					if (bMitDetails) {

						Query query = em.createNamedQuery("SonderzeitenfindByPersonalIIdTVonTBisTaetigkeitIId");
						query.setParameter(1, personalDto.getIId());
						query.setParameter(2, tVon);
						query.setParameter(3, tBis);
						query.setParameter(4, taetigkeitenDtos[j].getIId());
						SonderzeitenDto[] sonderzeitenDtosSub = assembleSonderzeitenDtos(query.getResultList());
						TreeSet<Date> tmTaetigkeiten = new TreeSet<Date>();

						for (SonderzeitenDto stDto : sonderzeitenDtosSub) {
							tmTaetigkeiten.add(Helper.cutDate(stDto.getTDatum()));
						}

						Calendar cAktuell = Calendar.getInstance();
						cAktuell.setTime(tVon);

						Date tVonSub = null;
						Date tBisSub = null;

						Date tLetzterTagMitSollzeit = null;
						Double dDauerSubStunden = 0D;
						Double dDauerSubTage = 0D;
						Integer iLfdNr = 1;

						ArrayList alDatenSub = new ArrayList();

						while (cAktuell.getTimeInMillis() <= tBis.getTime()) {

							Date dAktuell = Helper.cutDate(cAktuell.getTime());
							if (tmTaetigkeiten.contains(dAktuell) || tVonSub != null) {

								Double dSoll = Helper.time2Double(
										getSollzeitZuDatum(personalDto, new Timestamp(cAktuell.getTimeInMillis()),
												tagesartIId_Feiertag, tagesartIId_Halbtag, theClientDto, true));

								// ENDE

								if ((tVonSub != null && !tmTaetigkeiten.contains(dAktuell)
										&& dSoll.doubleValue() > 0)) {

									Object[] oZeileSub = new Object[5];

									oZeileSub[0] = tVonSub;
									if (tLetzterTagMitSollzeit != null) {
										oZeileSub[1] = tLetzterTagMitSollzeit;
									} else {
										oZeileSub[1] = tBisSub;
									}

									oZeileSub[2] = dDauerSubStunden;
									oZeileSub[3] = dDauerSubTage;
									oZeileSub[4] = iLfdNr;

									alDatenSub.add(oZeileSub);

									tVonSub = null;
									tBisSub = null;
									dDauerSubStunden = 0D;
									dDauerSubTage = 0D;
									tLetzterTagMitSollzeit = null;
									iLfdNr++;
								} else {

									DauerSondertaetigkeitenDto objDauerSub =

											getGesamtDauerEinerSondertaetigkeitImZeitraum(personalDto.getIId(),
													new Timestamp(cAktuell.getTimeInMillis()),
													new Timestamp(cAktuell.getTimeInMillis()),
													taetigkeitenDtos[j].getIId(), theClientDto, tagesartIId_Feiertag,
													tagesartIId_Halbtag);

									if (tVonSub == null) {
										tVonSub = dAktuell;
										tBisSub = dAktuell;
										dDauerSubStunden += objDauerSub.dStunden;
										dDauerSubTage += objDauerSub.dTage;
									} else {
										tBisSub = dAktuell;
										dDauerSubStunden += objDauerSub.dStunden;
										dDauerSubTage += objDauerSub.dTage;
									}

									if (dSoll > 0) {
										tLetzterTagMitSollzeit = dAktuell;
									}

									// Letzter Tag
									if (Helper.addiereTageZuDatum(dAktuell, 1).getTime() > tBis.getTime()) {
										Object[] oZeileSub = new Object[5];
										oZeileSub[0] = tVonSub;
										if (tLetzterTagMitSollzeit != null) {
											oZeileSub[1] = tLetzterTagMitSollzeit;
										} else {
											oZeileSub[1] = tBisSub;
										}
										oZeileSub[2] = dDauerSubStunden;
										oZeileSub[3] = dDauerSubTage;
										oZeileSub[4] = iLfdNr;
										alDatenSub.add(oZeileSub);

									}

								}
							}

							cAktuell.add(Calendar.DATE, 1);

						}

						if (alDatenSub.size() > 0) {
							String[] fieldnames = new String[] { "F_VON", "F_BIS", "F_DAUER_STUNDEN", "F_DAUER_TAGE",
									"F_LFD_NR" };

							Object[][] dataSub = new Object[alDatenSub.size()][fieldnames.length];
							dataSub = (Object[][]) alDatenSub.toArray(dataSub);

							reihe[REPORT_SONDERTAETIGKEITENLISTE_SUBREPORT_DETAILS] = new LPDatenSubreport(dataSub,
									fieldnames);
						}

					}

				}
				dGesamtDauer[j] = dGesamtDauer[j] + dDauer;
				dGesamtDauerTage[j] = dGesamtDauerTage[j] + dDauerTage;

			}

		}

		// Nun sortieren

		if (iOptionSortierung != ZeiterfassungFacAll.REPORT_SONDERZEITENLISTE_SORTIERUNG_PERSONALNUMMER) {
			for (int i = list.size() - 1; i > 0; --i) {
				for (int j = 0; j < i; ++j) {
					String vergleich = "";
					String vergleich1 = "";

					Object[] zeile = list.get(j);
					Object[] zeile1 = list.get(j + 1);

					String sondertaetigkeit = Helper
							.fitString2Length((String) zeile[REPORT_SONDERTAETIGKEITENLISTE_TAETIGKEIT], 40, ' ');
					String sondertaetigkeit1 = Helper
							.fitString2Length((String) zeile1[REPORT_SONDERTAETIGKEITENLISTE_TAETIGKEIT], 40, ' ');

					PartnerDto partnerDto = (PartnerDto) zeile[REPORT_SONDERTAETIGKEITENLISTE_PARTNER_DTO];
					PartnerDto partnerDto1 = (PartnerDto) zeile1[REPORT_SONDERTAETIGKEITENLISTE_PARTNER_DTO];

					String partner = Helper.fitString2Length(partnerDto.getCName1nachnamefirmazeile1(), 80, ' ')
							+ partnerDto.getCName2vornamefirmazeile2();
					String partner1 = Helper.fitString2Length(partnerDto1.getCName1nachnamefirmazeile1(), 80, ' ')
							+ partnerDto1.getCName2vornamefirmazeile2();

					if (iOptionSortierung == ZeiterfassungFacAll.REPORT_SONDERZEITENLISTE_SORTIERUNG_NACHNAME_VORNAME) {
						vergleich = partner;
						vergleich1 = partner1;
					} else if (iOptionSortierung == ZeiterfassungFacAll.REPORT_SONDERZEITENLISTE_SORTIERUNG_SONDERTAETIGKEIT_VORNAME_NACHNAME) {
						vergleich = sondertaetigkeit + partner;
						vergleich1 = sondertaetigkeit1 + partner1;
					}

					if (vergleich.compareTo(vergleich1) > 0) {
						list.set(j, zeile1);
						list.set(j + 1, zeile);
					}

				}
			}
		}

		// Gesamtsummen
		boolean gesamtGeduckt = false;
		for (int j = 0; j < taetigkeitenDtos.length; j++) {
			Object[] reihe = new Object[REPORT_SONDERTAETIGKEITENLISTE_ANZAHL_SPALTEN];
			if (dGesamtDauer[j] > 0) {
				reihe[REPORT_SONDERTAETIGKEITENLISTE_PERSONALNUMMER_GRUPPIERUNG] = null;
				if (gesamtGeduckt == false) {
					reihe[REPORT_SONDERTAETIGKEITENLISTE_NAME] = "GESAMT";
					reihe[REPORT_SONDERTAETIGKEITENLISTE_PERSONALNUMMER] = null;
					gesamtGeduckt = true;
				}
				reihe[REPORT_SONDERTAETIGKEITENLISTE_TAETIGKEIT] = taetigkeitenDtos[j].getBezeichnung();

				reihe[REPORT_SONDERTAETIGKEITENLISTE_ZEIT] = new Double(dGesamtDauer[j]);
				reihe[REPORT_SONDERTAETIGKEITENLISTE_TAGE] = new Double(dGesamtDauerTage[j]);
				reihe[REPORT_SONDERTAETIGKEITENLISTE_FAKTORBEZAHLT] = taetigkeitenDtos[j].getFBezahlt();
				list.add(reihe);
			}
		}
		data = new Object[list.size()][REPORT_SONDERTAETIGKEITENLISTE_ANZAHL_SPALTEN];
		for (int i = 0; i < list.size(); i++) {
			data[i] = (Object[]) list.get(i);
		}

		// Erstellung des Reports
		index = -1;
		sAktuellerReport = ZeiterfassungFac.REPORT_SONDERZEITENLISTE;

		HashMap parameter = new HashMap<Object, Object>();

		parameter.put("S_VON", new java.sql.Date(tVon.getTime()).toString());
		parameter.put("S_BIS", new java.sql.Date(tBis.getTime()).toString());
		parameter.put("T_VON", tVon);
		parameter.put("T_BIS", tBis);
		parameter.put("P_NUR_ANWESENDE", new Boolean(bNurAnwesende));
		parameter.put("P_PERSONEN", sParameter_Personen);

		parameter.put("P_MIT_DETAILS", new Boolean(bMitDetails));

		// SP9626
		if (kostenstelleIIdAbteilung != null) {
			parameter.put("P_KOSTENSTELLE_ABTEILUNG", getSystemFac()
					.kostenstelleFindByPrimaryKey(kostenstelleIIdAbteilung).formatKostenstellenbezeichnung());
		}

		if (iOptionSortierung == REPORT_SONDERZEITENLISTE_SORTIERUNG_PERSONALNUMMER) {
			parameter.put("P_SORTIERUNG", getTextRespectUISpr("pers.sonderzeitenliste.sort1", theClientDto.getMandant(),
					theClientDto.getLocUi()));
		} else if (iOptionSortierung == REPORT_SONDERZEITENLISTE_SORTIERUNG_NACHNAME_VORNAME) {
			parameter.put("P_SORTIERUNG", getTextRespectUISpr("pers.sonderzeitenliste.sort2", theClientDto.getMandant(),
					theClientDto.getLocUi()));
		} else if (iOptionSortierung == REPORT_SONDERZEITENLISTE_SORTIERUNG_SONDERTAETIGKEIT_VORNAME_NACHNAME) {
			parameter.put("P_SORTIERUNG", getTextRespectUISpr("pers.sonderzeitenliste.sort3", theClientDto.getMandant(),
					theClientDto.getLocUi()));
		}

		initJRDS(parameter, ZeiterfassungFac.REPORT_MODUL, ZeiterfassungFac.REPORT_SONDERZEITENLISTE,
				theClientDto.getMandant(), theClientDto.getLocUi(), theClientDto);
		return getReportPrint();
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public void versendeMonatsAbrechnung(ArrayList<MonatsabrechnungEmailVersand> infos, String absender, Integer iJahr,
			Integer iMonat, boolean bisMonatsende, java.sql.Date d_datum_bis, TheClientDto theClientDto) {

		DateFormatSymbols symbols = new DateFormatSymbols(theClientDto.getLocUi());
		String[] defaultMonths = symbols.getMonths();

		PersonalDto pDtoAbsender = getPersonalFac().personalFindByPrimaryKey(theClientDto.getIDPersonal(),
				theClientDto);

		Integer uebersteuerterReport = theClientDto.getReportvarianteIId();
		ParametermandantDto parameterDtoPfad = null;
		ParametermandantDto parameterDtoPrefix = null;
		try {
			parameterDtoPfad = getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_MONATSABRECHNUNGSVERSAND_PFAD_ANHAENGE);

			parameterDtoPrefix = getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_MONATSABRECHNUNGSVERSAND_PFAD_ANHAENGE_PREFIX);
		} catch (RemoteException e) {
			throwEJBExceptionLPRespectOld(e);
		}

		Calendar c = Calendar.getInstance();
		String oldVerzeichnis = "OLD_" + c.get(Calendar.YEAR)
				+ Helper.fitString2LengthAlignRight((c.get(Calendar.MONTH) + 1) + "", 2, '0')
				+ Helper.fitString2LengthAlignRight(c.get(Calendar.DAY_OF_MONTH) + "", 2, '0');

		for (int i = 0; i < infos.size(); i++) {
			MonatsabrechnungEmailVersand info = infos.get(i);

			theClientDto.setReportvarianteIId(uebersteuerterReport);

			VersandauftragDto versDto = new VersandauftragDto();
			versDto.setCEmpfaenger(info.getPrivateEmailAdresse());
			versDto.setCAbsenderadresse(absender);
			String betreff = "Monatsabrechnung " + defaultMonths[iMonat] + " " + iJahr;

			List<VersandanhangDto> anhaenge = new ArrayList<VersandanhangDto>();

			if (info.getKennwort() != null) {

				JasperPrintLP print = printMonatsAbrechnung(info.getPersonalIId(), iJahr, iMonat, bisMonatsende,
						d_datum_bis, theClientDto, ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON,
						null, ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_PERSONALNUMMER, 0D, true);

				VersandanhangDto anhangPdfDto = new VersandanhangDto();
				anhangPdfDto.setCDateiname(betreff.replaceAll(" ", "") + ".pdf");
				anhangPdfDto.setOInhalt(exportToPDF(print.getPrint(), info.getKennwort()));

				anhaenge.add(anhangPdfDto);

			}
			// Anhange aus Verzeichnis laden und verschieben
			// es wird davon ausgegangen, das die Anhaeng Lohnzettel bereits selbst
			// verschluesselt sind.

			if (parameterDtoPfad != null && parameterDtoPfad.getCWert() != null
					&& !parameterDtoPfad.getCWert().trim().equals(".")) {

				PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(info.getPersonalIId(),
						theClientDto);

				String pfad = parameterDtoPfad.getCWert();

				if (pfad != null && !pfad.endsWith("/")) {
					pfad += "/";
				}

				File f = new File(pfad);

				if (f.exists() && f.canWrite()) {

					String prefix = null;

					if (parameterDtoPrefix != null && parameterDtoPrefix.getCWert() != null
							&& !parameterDtoPrefix.getCWert().trim().equals(".")) {
						prefix = parameterDtoPrefix.getCWert();
					}

					File[] fileArray = f
							.listFiles(new AnhaengeMonatsabrechnungFilter(prefix, personalDto.getCPersonalnr()));

					if (fileArray != null) {

						for (int j = 0; j < fileArray.length; j++) {
							if (fileArray[j].isFile() == true) {

								File file = fileArray[j];

								VersandanhangDto anhangDto = new VersandanhangDto();
								anhangDto.setCDateiname(file.getName());

								FileInputStream fis = null;
								// Creating a byte array using the length of the file
								// file.length returns long which is cast to int
								byte[] bArray = new byte[(int) file.length()];
								try {
									fis = new FileInputStream(file);
									fis.read(bArray);
									fis.close();

								} catch (IOException ioExp) {
									ioExp.printStackTrace();
								}

								anhangDto.setOInhalt(bArray);

								anhaenge.add(anhangDto);

								// nach OLD verschieben

								String neuesVerzeichnis = file.getParent() + "/" + oldVerzeichnis + "/";

								File fNeuesVerzeichnis = new File(neuesVerzeichnis);
								if (!fNeuesVerzeichnis.exists()) {
									fNeuesVerzeichnis.mkdirs();
								}

								File fNeuesFile = new File(neuesVerzeichnis + file.getName());

								boolean b = file.renameTo(fNeuesFile);

							}
						}

					}

				} else {
					ArrayList al = new ArrayList();
					al.add(pfad);

					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_VERSAND_MONATSABRECHNUNG_ANHAENGE_PFAD, al,
							new Exception("FEHLER_VERSAND_MONATSABRECHNUNG_ANHAENGE_PFAD"));
				}

			}

			if (anhaenge.size() > 0) {
				long fiveMinutesInMillis = 1000 * 60 * 5;
				versDto.setTSendezeitpunktwunsch(new Timestamp(System.currentTimeMillis() + fiveMinutesInMillis));

				versDto.setCBetreff(betreff);

				try {
					com.lp.server.system.service.MailtextDto m = new com.lp.server.system.service.MailtextDto();

					PersonalDto pDto = getPersonalFac().personalFindByPrimaryKey(info.getPersonalIId(), theClientDto);

					m.setMailPartnerIId(pDto.getPartnerIId());
					m.setParamXslFile(ZeiterfassungFac.REPORT_MONATSABRECHNUNG);
					m.setParamLocale(theClientDto.getLocUi());
					m.setParamMandantCNr(theClientDto.getMandant());
					m.setParamModul(ZeiterfassungFac.REPORT_MODUL);
					m.setParamLocale(theClientDto.getLocUi());
					m.setMailBelegnummer(betreff);

					m.setPerson_anrede(pDto.getPartnerDto().getAnredeCNr());
					m.setPerson_personalnummer(pDto.getCPersonalnr());
					m.setPerson_titel(pDto.getPartnerDto().getCTitel());
					m.setPerson_vorname1(pDto.getPartnerDto().getCName2vornamefirmazeile2());
					m.setPerson_vorname2(pDto.getPartnerDto().getCName3vorname2abteilung());
					m.setPerson_nachname(pDto.getPartnerDto().getCName1nachnamefirmazeile1());
					m.setPerson_ntitel(pDto.getPartnerDto().getCNtitel());

					versDto.setCText(getVersandFac().getDefaultTextForBelegEmail(m, theClientDto));

					getVersandFac().createVersandauftrag(versDto, anhaenge, false, theClientDto);
				} catch (RemoteException e) {
					throwEJBExceptionLPRespectOld(e);
				}
			}

		}

	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public JasperPrintLP printMonatsAbrechnung(Integer personalIId, Integer iJahr, Integer iMonat,
			boolean bisMonatsende, java.sql.Date d_datum_bis, TheClientDto theClientDto, Integer iOption,
			Integer kostenstelleIIdAbteilung, Integer iOptionSortierung, Double dNurWennTagesistGroesser,
			Boolean bPlusVersteckte) {
		JasperPrintLP print = null;
		try {

			ArrayList<MonatsabrechnungEmailVersand> alVersandInfos = new ArrayList<MonatsabrechnungEmailVersand>();

			PersonalDto[] personalDtos = null;

			if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON) {

				if (personalIId == null) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
							new Exception("personalIId == null"));
				}

				personalDtos = new PersonalDto[1];

				personalDtos[0] = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);

			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_PERSONEN) {
				personalDtos = getPersonalFac().personalFindByMandantCNr(theClientDto.getMandant(), bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_EINE_ABTEILUNG) {
				personalDtos = getPersonalFac().personalFindAllPersonenEinerAbteilung(kostenstelleIIdAbteilung,
						theClientDto.getMandant(), bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ARBEITER) {
				personalDtos = getPersonalFac().personalFindAllArbeiterEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ANGESTELLTE) {
				personalDtos = getPersonalFac().personalFindAllAngestellteEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
			} else {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER, new Exception("OPTION NICHT VERFUEGBAR"));
			}

			// PJ 16763
			if (iOptionSortierung != ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_PERSONALNUMMER) {
				for (int i = personalDtos.length - 1; i > 0; --i) {
					for (int j = 0; j < i; ++j) {
						String vergleich1 = "";
						String vergleich2 = "";

						String kostenstelle1 = "               ";
						String kostenstelle2 = "               ";

						if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_KOSTENSTELLE_NAME_VORNAME
								|| iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_ABTEILUNG_KOSTENSTELLE_NAME_VORNAME) {
							if (personalDtos[j].getKostenstelleIIdStamm() != null) {

								KostenstelleDto kstDto = getSystemFac()
										.kostenstelleFindByPrimaryKey(personalDtos[j].getKostenstelleIIdStamm());
								kostenstelle1 = Helper.fitString2Length(kstDto.getCNr(), 15, ' ');

							}
							if (personalDtos[j + 1].getKostenstelleIIdStamm() != null) {
								KostenstelleDto kstDto = getSystemFac()
										.kostenstelleFindByPrimaryKey(personalDtos[j + 1].getKostenstelleIIdStamm());
								kostenstelle2 = Helper.fitString2Length(kstDto.getCNr(), 15, ' ');

							}

							if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_KOSTENSTELLE_NAME_VORNAME) {
								vergleich1 += kostenstelle1;
								vergleich2 += kostenstelle2;
							}

						}

						if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_ABTEILUNG_NAME_VORNAME
								|| iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_ABTEILUNG_KOSTENSTELLE_NAME_VORNAME) {

							String abteilung1 = "               ";
							String abteilung2 = "               ";

							if (personalDtos[j].getKostenstelleIIdAbteilung() != null) {

								KostenstelleDto kstDto = getSystemFac()
										.kostenstelleFindByPrimaryKey(personalDtos[j].getKostenstelleIIdAbteilung());
								abteilung1 = Helper.fitString2Length(kstDto.getCNr(), 15, ' ');

							} else {
								abteilung1 = "               ";
							}
							if (personalDtos[j + 1].getKostenstelleIIdAbteilung() != null) {
								KostenstelleDto kstDto = getSystemFac().kostenstelleFindByPrimaryKey(
										personalDtos[j + 1].getKostenstelleIIdAbteilung());
								abteilung2 = Helper.fitString2Length(kstDto.getCNr(), 15, ' ');

							} else {
								abteilung2 = "               ";
							}
							if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_ABTEILUNG_KOSTENSTELLE_NAME_VORNAME) {
								vergleich1 = kostenstelle1 + vergleich1;
								vergleich2 = kostenstelle2 + vergleich2;
							}
							vergleich1 = abteilung1 + vergleich1;
							vergleich2 = abteilung2 + vergleich2;

						}

						PartnerDto p1Dto = getPartnerFac().partnerFindByPrimaryKey(personalDtos[j].getPartnerIId(),
								theClientDto);
						personalDtos[j].setPartnerDto(p1Dto);
						PartnerDto p2Dto = getPartnerFac().partnerFindByPrimaryKey(personalDtos[j + 1].getPartnerIId(),
								theClientDto);
						vergleich1 += Helper.fitString2Length(p1Dto.getCName1nachnamefirmazeile1(), 80, ' ');
						vergleich2 += Helper.fitString2Length(p2Dto.getCName1nachnamefirmazeile1(), 80, ' ');

						if (p1Dto.getCName2vornamefirmazeile2() != null) {
							vergleich1 += p1Dto.getCName2vornamefirmazeile2();
						}
						if (p2Dto.getCName2vornamefirmazeile2() != null) {
							vergleich2 += p2Dto.getCName2vornamefirmazeile2();
						}

						if (vergleich1.compareTo(vergleich2) > 0) {
							PersonalDto tauschDto = personalDtos[j];
							personalDtos[j] = personalDtos[j + 1];
							personalDtos[j + 1] = tauschDto;
						}

					}
				}
			}

			Integer uebersteuerterReport = theClientDto.getReportvarianteIId();

			for (int i = 0; i < personalDtos.length; i++) {

				Calendar c = Calendar.getInstance();
				c.set(Calendar.YEAR, iJahr);
				c.set(Calendar.MONTH, iMonat);
				c.set(Calendar.DATE, 1);

				// SP9615
				boolean bAusgetretenErsterDesMonats = getPersonalFac().istPersonalAusgetreten(personalDtos[i].getIId(),
						new Timestamp(c.getTimeInMillis()), theClientDto);

				// SP9661
				c.set(Calendar.DATE, c.getActualMaximum(Calendar.DATE));
				boolean bAusgetretenLetzterDesMonats = getPersonalFac().istPersonalAusgetreten(personalDtos[i].getIId(),
						new Timestamp(c.getTimeInMillis()), theClientDto);

				if ((!bAusgetretenErsterDesMonats || !bAusgetretenLetzterDesMonats)
						|| iOption == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON) {

					try {

						theClientDto.setReportvarianteIId(uebersteuerterReport);

						MonatsabrechnungDto moaDto = erstelleMonatsAbrechnung(personalDtos[i].getIId(), iJahr, iMonat,
								bisMonatsende, d_datum_bis, theClientDto, true, iOptionSortierung,
								dNurWennTagesistGroesser);

						// PJ20122
						boolean bDruckHinzufuegen = true;

						if (dNurWennTagesistGroesser != null && dNurWennTagesistGroesser.doubleValue() > 0) {
							bDruckHinzufuegen = false;

							HashMap<Integer, BigDecimal> hmTagessummen = new HashMap<Integer, BigDecimal>();

							for (int j = 0; j < moaDto.getData().length; j++) {
								Object[] zeileMoa = moaDto.getData()[j];

								String tagesart = (String) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_TAGESART];

								Integer tag = (Integer) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_TAG];

								BigDecimal bdIstGesamt = BigDecimal.ZERO;

								if (hmTagessummen.containsKey(tag)) {
									bdIstGesamt = hmTagessummen.get(tag);
								}

								bdIstGesamt = bdIstGesamt
										.add((BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_IST]);

								hmTagessummen.put(tag, bdIstGesamt);
							}

							Iterator it = hmTagessummen.keySet().iterator();
							while (it.hasNext()) {

								Integer iTag = (Integer) it.next();

								BigDecimal bdIstGesamt = hmTagessummen.get(iTag);

								if (bdIstGesamt.doubleValue() >= dNurWennTagesistGroesser.doubleValue()) {
									bDruckHinzufuegen = true;
									break;
								}

							}

						}

						if (bDruckHinzufuegen == true) {
							if (print != null) {

								print = Helper.addReport2Report(print, moaDto.getJasperPrint().getPrint());
							} else {

								print = moaDto.getJasperPrint();
							}

							PartnerDto pDto = getPartnerFac().partnerFindByPrimaryKey(personalDtos[i].getPartnerIId(),
									theClientDto);

							String kennwort = personalDtos[i].getCSozialversnr();
							if (personalDtos[i].getCVersandkennwort() != null) {
								kennwort = personalDtos[i].getCVersandkennwort();
							}

							alVersandInfos.add(new MonatsabrechnungEmailVersand(personalDtos[i].getIId(),
									pDto.getCEmail(), kennwort, personalDtos[i].getKostenstelleIIdAbteilung(),
									moaDto.getJasperPrint()));

						}

					} catch (EJBExceptionLP ex1) {
						if (ex1.getCode() == EJBExceptionLP.FEHLER_PERSONAL_FEHLER_BEI_EINTRITTSDATUM && iOption
								.intValue() != ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON) {
							// NICHTS - PERSON WIRD AUSGELASSEN
						} else {
							throw new EJBExceptionLP(ex1);
						}
					}
				}

			}
			if (print != null) {
				print.putAdditionalInformation(MONATSABRECHNUNG_INFO_EMAIL_VERSAND, alVersandInfos);
			}

		} catch (RemoteException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		}

		return print;
	}

	public void konvertiereAngebotszeitenNachAuftragzeiten(Integer angebotIId, Integer auftragIId,
			TheClientDto theClientDto) throws EJBExceptionLP {

		if (angebotIId == null && auftragIId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("angebotIId == null && auftragIId == null"));
		}

		AuftragpositionDto[] auftragpositionDtos = null;
		try {
			auftragpositionDtos = getAuftragpositionFac().auftragpositionFindByAuftrag(auftragIId);
		} catch (RemoteException ex) {
			throwEJBExceptionLPRespectOld(ex);
		}
		if (auftragpositionDtos != null && auftragpositionDtos.length > 0) {
			Integer ersteAuftragsposition = auftragpositionDtos[0].getIId();
			Session session = FLRSessionFactory.getFactory().openSession();

			org.hibernate.Criteria critZeitdaten = session.createCriteria(FLRZeitdaten.class);

			critZeitdaten.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_C_BELEGARTNR, LocaleFac.BELEGART_ANGEBOT));
			critZeitdaten.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_I_BELEGARTID, angebotIId));

			List<?> resultListZeitdaten = critZeitdaten.list();

			Iterator<?> resultListIterator = resultListZeitdaten.iterator();

			int row = 0;
			while (resultListIterator.hasNext()) {
				FLRZeitdaten flrZeitdaten = (FLRZeitdaten) resultListIterator.next();

				// try {
				Zeitdaten zeitdaten = em.find(Zeitdaten.class, flrZeitdaten.getI_id());
				if (zeitdaten == null) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
				}
				zeitdaten.setCBelegartnr(LocaleFac.BELEGART_AUFTRAG);
				zeitdaten.setIBelegartid(auftragIId);
				zeitdaten.setIBelegartpositionid(ersteAuftragsposition);
				// }
				// catch (NoResultException e) {
				// throw new EJBExceptionLP(EJBExceptionLP.
				// FEHLER_BEI_FINDBYPRIMARYKEY,
				// e);
				// }
			}
			session.close();
		}
	}

	public void loszeitenVerschieben(Integer losIId_Quelle, Integer losIId_Ziel, TheClientDto theClientDto) {

		if (losIId_Quelle == null && losIId_Ziel == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("losIId_Quelle == null && losIId_Ziel == null"));
		}

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Criteria critZeitdaten = session.createCriteria(FLRZeitdaten.class);

		critZeitdaten.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_C_BELEGARTNR, LocaleFac.BELEGART_LOS));
		critZeitdaten.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_I_BELEGARTID, losIId_Quelle));

		List<?> resultListZeitdaten = critZeitdaten.list();

		Iterator<?> resultListIterator = resultListZeitdaten.iterator();

		int row = 0;
		while (resultListIterator.hasNext()) {
			FLRZeitdaten flrZeitdaten = (FLRZeitdaten) resultListIterator.next();

			Zeitdaten zeitdaten = em.find(Zeitdaten.class, flrZeitdaten.getI_id());
			if (zeitdaten == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
			}

			zeitdaten.setIBelegartid(losIId_Ziel);

		}
		session.close();

	}

	public void projektzeitenVerschieben(Integer projektIId_Quelle, Integer projektIId_Ziel,
			TheClientDto theClientDto) {

		if (projektIId_Quelle == null && projektIId_Ziel == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("projektIId_Quelle == null && projektIId_Ziel == null"));
		}

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Criteria critZeitdaten = session.createCriteria(FLRZeitdaten.class);

		critZeitdaten.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_C_BELEGARTNR, LocaleFac.BELEGART_PROJEKT));
		critZeitdaten.add(Restrictions.eq(ZeiterfassungFac.FLR_ZEITDATEN_I_BELEGARTID, projektIId_Quelle));

		List<?> resultListZeitdaten = critZeitdaten.list();

		Iterator<?> resultListIterator = resultListZeitdaten.iterator();

		int row = 0;
		while (resultListIterator.hasNext()) {
			FLRZeitdaten flrZeitdaten = (FLRZeitdaten) resultListIterator.next();

			Zeitdaten zeitdaten = em.find(Zeitdaten.class, flrZeitdaten.getI_id());
			if (zeitdaten == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
			}

			zeitdaten.setIBelegartid(projektIId_Ziel);

		}
		session.close();

	}

	@SuppressWarnings("static-access")
	public double getBlockzeitenEinesTages(PersonalDto personalDto, ZeitdatenDto[] einblock,
			Integer taetigkeitIId_Kommt, Integer taetigkeitIId_Geht) {
		double dBlockzeit = 0;

		if (personalDto.getKollektivDto() != null && einblock.length > 1) {
			if (personalDto.getKollektivDto().getUBlockzeitab() != null
					&& personalDto.getKollektivDto().getUBlockzeitbis() != null) {

				if (personalDto.getKollektivDto().getUBlockzeitab().getTime() > -3600000
						|| personalDto.getKollektivDto().getUBlockzeitbis().getTime() > -3600000) {

					java.sql.Timestamp tKommt = null;
					java.sql.Timestamp tGeht = null;

					// Kommt suchen
					Calendar c = Calendar.getInstance();
					c.setTime(einblock[0].getTZeit());
					// Wenn Kommt um 00:00, dann letztes Kommt holen
					if (c.get(Calendar.HOUR_OF_DAY) == 0 && c.get(Calendar.MINUTE) == 0
							&& taetigkeitIId_Kommt.equals(einblock[0].getTaetigkeitIId())) {
						SessionFactory factory = FLRSessionFactory.getFactory();
						Session session = factory.openSession();

						org.hibernate.Criteria letztesKommt = session.createCriteria(FLRZeitdaten.class);

						letztesKommt
								.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalDto.getIId()));
						letztesKommt.add(
								Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID, taetigkeitIId_Kommt));

						letztesKommt.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, einblock[0].getTZeit()));
						letztesKommt.addOrder(Order.desc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));
						letztesKommt.setMaxResults(1);

						List<?> resultListLetztesKommt = letztesKommt.list();
						if (resultListLetztesKommt.size() > 0) {
							tKommt = new java.sql.Timestamp(
									((FLRZeitdaten) resultListLetztesKommt.get(0)).getT_zeit().getTime());
						}
						session.close();
						tGeht = einblock[einblock.length - 1].getTZeit();
					} else {
						tKommt = einblock[0].getTZeit();

						// Geht suchen
						c = Calendar.getInstance();
						c.setTime(einblock[einblock.length - 1].getTZeit());
						// Wenn Kommt um 00:00, dann naechstes GEHT holen
						if (c.get(Calendar.HOUR_OF_DAY) == 23 && c.get(Calendar.MINUTE) == 59
								&& taetigkeitIId_Geht.equals(einblock[einblock.length - 1].getTaetigkeitIId())) {
							SessionFactory factory = FLRSessionFactory.getFactory();
							Session session = factory.openSession();

							org.hibernate.Criteria naechstesGeht = session.createCriteria(FLRZeitdaten.class);

							naechstesGeht.add(
									Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalDto.getIId()));
							naechstesGeht.add(
									Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID, taetigkeitIId_Geht));

							naechstesGeht.add(Expression.gt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT,
									einblock[einblock.length - 1].getTZeit()));
							naechstesGeht.addOrder(Order.asc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));
							naechstesGeht.setMaxResults(1);

							List<?> resultListLetztesGeht = naechstesGeht.list();
							if (resultListLetztesGeht.size() > 0) {
								tGeht = new java.sql.Timestamp(
										((FLRZeitdaten) resultListLetztesGeht.get(0)).getT_zeit().getTime());
							}
							session.close();
						} else {
							tGeht = einblock[einblock.length - 1].getTZeit();
						}
					}

					Calendar cBlockzeit = Calendar.getInstance();
					cBlockzeit.setTimeInMillis(Helper.cutTimestamp(einblock[0].getTZeit()).getTime());
					cBlockzeit.set(cBlockzeit.DAY_OF_MONTH, cBlockzeit.get(cBlockzeit.DAY_OF_MONTH) - 1);
					cBlockzeit.setTimeInMillis(cBlockzeit.getTimeInMillis()
							+ personalDto.getKollektivDto().getUBlockzeitab().getTime() + 3600000);

					java.sql.Timestamp tBlockzeitAbVortag = new Timestamp(cBlockzeit.getTimeInMillis());

					java.sql.Timestamp tBlockzeitBisHeute = new Timestamp(
							Helper.cutTimestamp(einblock[0].getTZeit()).getTime()
									+ personalDto.getKollektivDto().getUBlockzeitbis().getTime() + 3600000);

					java.sql.Timestamp tBlockzeitAbHeute = new Timestamp(
							Helper.cutTimestamp(einblock[0].getTZeit()).getTime()
									+ personalDto.getKollektivDto().getUBlockzeitab().getTime() + 3600000);

					cBlockzeit.setTimeInMillis(tBlockzeitBisHeute.getTime());
					cBlockzeit.set(cBlockzeit.DAY_OF_MONTH, cBlockzeit.get(cBlockzeit.DAY_OF_MONTH) + 1);

					java.sql.Timestamp tBlockzeitBisMorgen = new Timestamp(cBlockzeit.getTimeInMillis());

					// Block1
					if (tKommt.before(tBlockzeitBisHeute) || tKommt.equals(tBlockzeitBisHeute)) {
						java.sql.Timestamp tBeginn = tKommt;
						if (tKommt.before(tBlockzeitAbVortag)) {
							tBeginn = tBlockzeitAbVortag;
						}

						java.sql.Timestamp tEnde = tGeht;

						if (tGeht.after(tBlockzeitBisHeute)) {
							tEnde = tBlockzeitBisHeute;
						}

						long l = tEnde.getTime() - tBeginn.getTime() - 3600000;

						// muss mindestens 3 Stunden sein
						if (l >= 3600000 * 2) {

							Calendar cTemp = Calendar.getInstance();
							cTemp.setTimeInMillis(Helper.cutTimestamp(einblock[0].getTZeit()).getTime());
							cTemp.set(cTemp.DAY_OF_MONTH, cTemp.get(cTemp.DAY_OF_MONTH));
							if (tBeginn.before(cTemp.getTime())) {
								tBeginn = new Timestamp(cTemp.getTime().getTime());
							}
							l = tEnde.getTime() - tBeginn.getTime() - 3600000;

							dBlockzeit += Helper.time2Double(new Time(l));
						}

					}

					// Block2
					if (tKommt.after(tBlockzeitBisHeute) || tKommt.equals(tBlockzeitBisHeute)) {
						java.sql.Timestamp tBeginn = tKommt;
						if (tKommt.before(tBlockzeitAbHeute)) {
							tBeginn = tBlockzeitAbHeute;
						}
						java.sql.Timestamp tEnde = tGeht;

						if (tGeht.after(tBlockzeitBisMorgen)) {
							tEnde = tBlockzeitBisMorgen;
						}

						long l = tEnde.getTime() - tBeginn.getTime() - 3600000;

						// muss mindestens 3 Stunden sein
						if (l >= 3600000 * 2) {

							Calendar cTemp = Calendar.getInstance();
							cTemp.setTimeInMillis(Helper.cutTimestamp(einblock[0].getTZeit()).getTime());
							cTemp.set(cTemp.DAY_OF_MONTH, cTemp.get(cTemp.DAY_OF_MONTH) + 1);
							if (tEnde.after(cTemp.getTime())) {
								tEnde = new Timestamp(cTemp.getTime().getTime());
							}
							l = tEnde.getTime() - tBeginn.getTime() - 3600000;

							dBlockzeit += Helper.time2Double(new Time(l));
						}
					}
				}
			}
		}

		return dBlockzeit;
	}

	public ZeitsaldoDto erstelleMonatsabrechnungZeitsaldo(Integer personalIId, Integer iJahr, Integer iMonat,
			boolean bisMonatsende, java.sql.Date d_datum_bis, TheClientDto theClientDto, boolean bSaldozurueckschreiben,
			Integer iOptionSortierung) throws EJBExceptionLP {

		MonatsabrechnungDto monatsabrechnungDto = erstelleMonatsAbrechnung(personalIId, iJahr, iMonat, bisMonatsende,
				d_datum_bis, theClientDto, bSaldozurueckschreiben, iOptionSortierung, true, false, null);

		return monatsabrechnungDto.getZeitsaldoDto();
	}

	public String erstelleMonatsAbrechnungFuerBDE(Integer personalIId, Integer iJahr, Integer iMonat,
			boolean bisMonatsende, java.sql.Date d_datum_bis, TheClientDto theClientDto, boolean bSaldozurueckschreiben,
			boolean returnVariableAlsCSV) {

		MonatsabrechnungDto monatsabrechnungDto = erstelleMonatsAbrechnung(personalIId, iJahr, iMonat, bisMonatsende,
				d_datum_bis, theClientDto, bSaldozurueckschreiben,
				ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_PERSONALNUMMER, null);

		if (returnVariableAlsCSV == false) {
			byte[] CRLFAscii = { 13, 10 };
			String s = Helper
					.fitString2Length(
							getTextRespectUISpr("pers.monatsabrechnung.bde.zeitsaldo", theClientDto.getMandant(),
									theClientDto.getLocUi())
									+ Helper.formatZahl(monatsabrechnungDto.getnSaldo(), 2, theClientDto.getLocUi())
									+ " " + getTextRespectUISpr("pers.monatsabrechnung.bde.std",
											theClientDto.getMandant(), theClientDto.getLocUi())
									+ ".",
							40, ' ')
					+ new String(CRLFAscii);
			;
			s += Helper.fitString2Length(getTextRespectUISpr("pers.monatsabrechnung.bde.verfuegbarerurlaub",
					theClientDto.getMandant(), theClientDto.getLocUi())
					+ Helper.formatZahl(monatsabrechnungDto.getNVerfuegbarerurlaub(), 2, theClientDto.getLocUi())
					+ monatsabrechnungDto.getsEinheitVerfuegbarerUrlaub() + "", 40, ' ') + new String(CRLFAscii);
			;

			return s;

		} else {
			StringBuffer sb = new StringBuffer();

			sb.append("Zeitsaldo;Einheit;Urlaub;EinheitU\r\n");
			sb.append(monatsabrechnungDto.getnSaldo().toString());
			sb.append(";" + getTextRespectUISpr("pers.monatsabrechnung.bde.std", theClientDto.getMandant(),
					theClientDto.getLocUi()) + ";");
			sb.append(monatsabrechnungDto.getNVerfuegbarerurlaub().toString());
			sb.append(";" + monatsabrechnungDto.getsEinheitVerfuegbarerUrlaub());
			return sb.toString();

		}

	}

	public ZeitdatenDto getZugehoerigeEndeBuchung(ZeitdatenDto zeitdatenDto, TheClientDto theClientDto) {
		// Wenn die naechste Buchung ein Ende ist, dann ist ist das die
		// Bis-Buchung
		ZeitdatenDto zDto = null;
		Integer taetigkeitIId_Ende = getZeiterfassungFac()
				.taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();
		Integer taetigkeitIId_Kommt = getZeiterfassungFac()
				.taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();
		Integer taetigkeitIId_Geht = getZeiterfassungFac()
				.taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();

		if (zeitdatenDto.getTaetigkeitIId() != null && (zeitdatenDto.getTaetigkeitIId().equals(taetigkeitIId_Kommt)
				|| zeitdatenDto.getTaetigkeitIId().equals(taetigkeitIId_Geht))) {
			// Bei Kommt/Geht gibts kein BIS
			return null;
		}

		Session sessionEnde = FLRSessionFactory.getFactory().openSession();
		org.hibernate.Query queryEnde = sessionEnde.createQuery(
				"SELECT zeitdaten FROM FLRZeitdaten zeitdaten LEFT OUTER JOIN zeitdaten.flrartikel.artikelsprset AS aspr WHERE zeitdaten.personal_i_id="
						+ zeitdatenDto.getPersonalIId() + " AND zeitdaten.t_zeit > '"
						+ Helper.formatTimestampWithSlashes(zeitdatenDto.getTZeit()) + "' AND zeitdaten.t_zeit < '"
						+ Helper.formatTimestampWithSlashes(Helper.cutTimestampAddDays(zeitdatenDto.getTZeit(), 1))
						+ "' ORDER BY zeitdaten.t_zeit ASC");
		queryEnde.setMaxResults(1);
		List<?> resultListEnde = queryEnde.list();
		Iterator<?> resultListIteratorEnde = resultListEnde.iterator();
		if (resultListIteratorEnde.hasNext()) {
			FLRZeitdaten z = (FLRZeitdaten) resultListIteratorEnde.next();

			if (z.getTaetigkeit_i_id() != null && z.getTaetigkeit_i_id().equals(taetigkeitIId_Ende)) {
				zDto = zeitdatenFindByPrimaryKey(z.getI_id(), theClientDto);
			}

			if (z.getTaetigkeit_i_id() != null && z.getTaetigkeit_i_id().equals(zeitdatenDto.getTaetigkeitIId())) {
				zDto = zeitdatenFindByPrimaryKey(z.getI_id(), theClientDto);
			}

		}
		sessionEnde.close();

		return zDto;
	}

	private BigDecimal getIstZeitZwischenVonBis(ZeitdatenDto[] zeitdatenEinesTagesDtos, Time tVon, Time tBis,
			boolean bSonderzeitenAbziehen, TheClientDto theClientDto) {

		if (zeitdatenEinesTagesDtos.length > 1) {

			TaetigkeitDto taetigkeitDto_Arzt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ARZT, theClientDto);
			// Hole Dto der Behoerde
			TaetigkeitDto taetigkeitDto_Behoerde = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_BEHOERDE,
					theClientDto);
			// Hole Dto des Urlaub
			TaetigkeitDto taetigkeitDto_Urlaub = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_URLAUB, theClientDto);
			// Hole Dto des Zeitausgleichs
			TaetigkeitDto taetigkeitDto_ZA = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ZEITAUSGLEICH,
					theClientDto);
			// Hole Dto der Behoerde
			TaetigkeitDto taetigkeitDto_Krank = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KRANK, theClientDto);
			TaetigkeitDto taetigkeitDto_Kindkrank = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KINDKRANK,
					theClientDto);

			// Hole id der Taetigkeit KOMMT
			Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();
			// Hole id der Taetigkeit GEHT
			Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();
			// Hole id der Taetigkeit ENDE
			Integer taetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();
			// Hole id der Taetigkeit TELEFON
			Integer taetigkeitIId_telefon = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_TELEFON, theClientDto)
					.getIId();
			TaetigkeitDto[] sonstigeTaetigkeiten = getAllBenutzerdefinierteSondertaetigkeiten();

			BigDecimal bdIstZeit = BigDecimal.ZERO;

			Calendar cUestdTemp = Calendar.getInstance();
			cUestdTemp.setTimeInMillis(tVon.getTime());

			// Wenn Ja, dann Zeitbuchungen neu
			// setzen
			Calendar cUestdAb = Calendar.getInstance();
			cUestdAb.setTimeInMillis(zeitdatenEinesTagesDtos[0].getTZeit().getTime());
			cUestdAb.set(Calendar.HOUR_OF_DAY, cUestdTemp.get(Calendar.HOUR_OF_DAY));
			cUestdAb.set(Calendar.MINUTE, cUestdTemp.get(Calendar.MINUTE));
			cUestdAb.set(Calendar.SECOND, 0);
			cUestdAb.set(Calendar.MILLISECOND, 0);

			ZeitdatenDto[] zeitdatenFuerUestdAbrechnung = ZeitdatenDto.kopiereArrayUndVerschiebeAnfangsZeitNachSpaeter(
					zeitdatenEinesTagesDtos, cUestdAb.getTime().getTime());

			cUestdTemp = Calendar.getInstance();
			cUestdTemp.setTimeInMillis(tBis.getTime());
			Calendar cUestdBis = Calendar.getInstance();
			cUestdBis.setTimeInMillis(zeitdatenEinesTagesDtos[0].getTZeit().getTime());
			cUestdBis.set(Calendar.HOUR_OF_DAY, cUestdTemp.get(Calendar.HOUR_OF_DAY));
			cUestdBis.set(Calendar.MINUTE, cUestdTemp.get(Calendar.MINUTE));
			cUestdBis.set(Calendar.SECOND, 0);
			cUestdBis.set(Calendar.MILLISECOND, 0);

			zeitdatenFuerUestdAbrechnung = ZeitdatenDto.kopiereArrayUndVerschiebeEndZeitNachFrueher(
					zeitdatenFuerUestdAbrechnung, cUestdBis.getTime().getTime());

			// Ersten und letzten Eintrag des Tages
			// setzen

			long lDifferenz = zeitdatenFuerUestdAbrechnung[zeitdatenEinesTagesDtos.length - 1].getTZeit().getTime()
					- zeitdatenFuerUestdAbrechnung[0].getTZeit().getTime();

			Double dIstUestd = (double) lDifferenz / 3600000;

			// Ueber jede Zeitbuchung iterieren
			double dGesamt = dIstUestd;
			ZeitdatenDto zeitdatenDto_Vorher = null;

			for (int m = 0; m < zeitdatenFuerUestdAbrechnung.length; m++) {
				ZeitdatenDto zeitdatenDto_Aktuell = zeitdatenFuerUestdAbrechnung[m];
				// Milliskunden auf 0 setzen
				Timestamp tsTemp = zeitdatenDto_Aktuell.getTZeit();
				Calendar c2 = Calendar.getInstance();
				c2.setTimeInMillis(tsTemp.getTime());
				c2.set(Calendar.MILLISECOND, 0);
				tsTemp = new Timestamp(c2.getTimeInMillis());
				zeitdatenDto_Aktuell.setTZeit(tsTemp);
				// Bei jeder Geraden Zahl mit dem
				// Vorgaenger
				// vergleichen
				if (m % 2 == 0 && m != 0) {
					if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitIId_Kommt)
							&& zeitdatenDto_Vorher.getTaetigkeitIId().equals(taetigkeitIId_Geht)) {
						// Wenn KOMMT - GEHT, dann
						// nicht
						// dazuzaehlen

						Double dBeginn = Helper.time2Double(new Time(zeitdatenDto_Vorher.getTZeit().getTime()));
						Double dEnde = Helper.time2Double(new Time(zeitdatenDto_Aktuell.getTZeit().getTime()));
						double dSumme = dEnde.doubleValue() - dBeginn.doubleValue();
						dGesamt += dSumme;
					} else if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(zeitdatenDto_Vorher.getTaetigkeitIId())) {

						Double dBeginn = Helper.time2Double(new Time(zeitdatenDto_Vorher.getTZeit().getTime()));
						Double dEnde = Helper.time2Double(new Time(zeitdatenDto_Aktuell.getTZeit().getTime()));

						if (dBeginn != null && dEnde != null) {
							double dSumme = dEnde.doubleValue() - dBeginn.doubleValue();

							if (bSonderzeitenAbziehen == false && (zeitdatenDto_Aktuell.getTaetigkeitIId()
									.equals(taetigkeitDto_Arzt.getIId())
									|| zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitDto_Krank.getIId())
									|| zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitDto_Behoerde.getIId())
									|| zeitdatenDto_Aktuell.getTaetigkeitIId()
											.equals(taetigkeitDto_Kindkrank.getIId()))) {
								// Arz oder Krank werden nicht abgezogen
							}

							else {

								// Bezahlte
								// Taetigkeiten
								boolean bGefunden = false;
								for (int k = 0; k < sonstigeTaetigkeiten.length; k++) {
									if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(sonstigeTaetigkeiten[k].getIId())
											&& sonstigeTaetigkeiten[k].getFBezahlt().doubleValue() > 0) {
										bGefunden = true;
									}
								}

								if (bGefunden == false) {
									dGesamt -= dSumme;
								}
							}
						}
					}

				}
				zeitdatenDto_Vorher = zeitdatenDto_Aktuell;
			}
			dGesamt = Helper.rundeKaufmaennisch(new BigDecimal(dGesamt), 2).doubleValue();
			return new BigDecimal(dGesamt);
		} else
			return BigDecimal.ZERO;
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public MonatsabrechnungDto erstelleMonatsAbrechnung(Integer personalIId, Integer iJahr, Integer iMonat,
			boolean bisMonatsende, java.sql.Date d_datum_bis, TheClientDto theClientDto, boolean bSaldozurueckschreiben,
			Integer iOptionSortierung, Double dNurWennTagesistGroesser) throws EJBExceptionLP {

		return erstelleMonatsAbrechnung(personalIId, iJahr, iMonat, bisMonatsende, d_datum_bis, theClientDto,
				bSaldozurueckschreiben, iOptionSortierung, true, false, dNurWennTagesistGroesser);

	}

	/**
	 * Die Monatsabrechnung der Zeitdaten f&uuml;r ein bestimmtes Monat f&uuml;r
	 * eine bestimmte Person
	 * 
	 * @param personalIId   Eindeutige ID des Partners
	 * @param iJahr         Das Jahr der Abrechnung (zB 2005)
	 * @param iMonat        Das Monat der Abrechnung (zB 10 f&uuml;r Oktober)
	 * @param bisMonatsende Die Abrechnung kann bis zum Monatsende oder bis zum
	 *                      heutigen Datum durchgef&uuml;hrt werden
	 * @param d_datum_bis   Datum, bis wohin Monatsabrechnung berechnet wird, wenn
	 *                      bisMonatsende=false
	 * @param theClientDto  Das Monat der Abrechnung (zB 10 f&uuml;r Oktober)
	 * @return JasperPrint
	 * @throws EJBExceptionLP
	 */

	@TransactionAttribute(TransactionAttributeType.NEVER)
	private MonatsabrechnungDto erstelleMonatsAbrechnung(Integer personalIId, Integer iJahr, Integer iMonat,
			boolean bisMonatsende, java.sql.Date d_datum_bis, TheClientDto theClientDto, boolean bSaldozurueckschreiben,
			Integer iOptionSortierung, boolean vormonatFuerMaximaleAnwesenheitberechnen,
			boolean bTagesUndwochenmaximumIgnorieren, Double dNurWennTagesistGroesser) throws EJBExceptionLP {
		if (iJahr == null || iMonat == null || personalIId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("iJahr == null || iMonat == null || personalIId == null"));
		}
		if (bisMonatsende == false && d_datum_bis == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
					new Exception("bisMonatsende == false && d_datum_bis == null"));

		}

		// Index zuruecksetzten und Report setzten
		index = -1;
		sAktuellerReport = ZeiterfassungFac.REPORT_MONATSABRECHNUNG;

		// Personaldaten holen
		PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);

		// Ueberstundenberechnung
		BigDecimal nNormalstunden = null;
		BigDecimal nSollStundenFuerUestd50 = null;
		BigDecimal nSollStundenFIX = null;
		BigDecimal nMaximalesWochenIST = null;
		BigDecimal nMaximaleMehrzeit = null;

		boolean bSollstundenMitrechnen = true;

		Calendar calErstesZeitmodell = Calendar.getInstance();
		calErstesZeitmodell.set(iJahr.intValue(), iMonat.intValue(), 1);

		boolean bVonBisZeiterfassungOhneKommtGeht = false;
		boolean bKommtGeht = true;
		boolean bVonBis = false;

		boolean bFeiertagAmNaechstenTag = false;

		boolean bGutstundenZuUest50Addieren = true;

		TreeMap<String, Object[]> tmDatenSubreportSchichtzulagen = new TreeMap<String, Object[]>();

		try {
			ParametermandantDto parameter = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_VON_BIS_ERFASSUNG);

			bVonBis = (Boolean) parameter.getCWertAsObject();

			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_VON_BIS_ERFASSUNG_KOMMT_GEHT_BUCHEN);

			bKommtGeht = (Boolean) parameter.getCWertAsObject();

			if (bVonBis == true && bKommtGeht == false) {
				bVonBisZeiterfassungOhneKommtGeht = true;
			}

			parameter = (ParametermandantDto) getParameterFac().getMandantparameter(theClientDto.getMandant(),
					ParameterFac.KATEGORIE_PERSONAL, ParameterFac.PARAMETER_GUTSTUNDEN_ZU_UESTD50_ADDIEREN);

			bGutstundenZuUest50Addieren = (Boolean) parameter.getCWertAsObject();

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		try {
			PersonalzeitmodellDto personalzeitmodellDto = getPersonalFac().personalzeitmodellFindZeitmodellZuDatum(
					personalIId, new java.sql.Timestamp(calErstesZeitmodell.getTime().getTime()), theClientDto);
			if (personalzeitmodellDto != null) {
				nSollStundenFuerUestd50 = new BigDecimal(
						getSummeSollzeitWochentags(personalzeitmodellDto.getZeitmodellIId()).doubleValue());
				ZeitmodellDto zmDto = zeitmodellFindByPrimaryKey(personalzeitmodellDto.getZeitmodellIId(),
						theClientDto);
				nSollStundenFIX = zmDto.getNSollstundenfix();
				nMaximalesWochenIST = zmDto.getNMaximalesWochenist();

				nMaximaleMehrzeit = zmDto.getNMaximaleMehrzeit();

				bSollstundenMitrechnen = Helper.short2boolean(zmDto.getBFeiertagssollAddieren());

				bFeiertagAmNaechstenTag = Helper.short2boolean(zmDto.getBFeiertagAmNaechstenTag());

			} else {
				nSollStundenFuerUestd50 = new BigDecimal(0);
			}
		} catch (RemoteException ex11) {
			throwEJBExceptionLPRespectOld(ex11);
		}

		HashMap<Integer, KollektivuestdDto> hmKollektivUestd100 = new HashMap();
		HashMap<Integer, ArrayList> hmKollektivUestd50Tageweise = new HashMap();

		HashMap<Integer, KollektivUestdBVADto> hmKollektivUestdBVA = new HashMap();

		HashMap<Integer, PassivereiseDto> hmPassiveReise = new HashMap();

		String kollektivAbrechnungsart = null;

		// PJ19563
		int iBerechnungsbasisUestd = PersonalFac.KOLLEKTIV_BERECHNUNGSBASIS_UHRZEIT;

		if (personalDto.getKollektivDto() != null) {

			kollektivAbrechnungsart = personalDto.getKollektivDto().getCAbrechungsart();

			iBerechnungsbasisUestd = personalDto.getKollektivDto().getIBerechnungsbasis();
			;

			if (personalDto.getKollektivDto() != null && personalDto.getKollektivDto().getNNormalstunden() != null
					&& personalDto.getKollektivDto().getNNormalstunden().doubleValue() > 0) {
				nNormalstunden = personalDto.getKollektivDto().getNNormalstunden();

				try {
					KollektivuestdDto[] kollektivuestdDtos = getPersonalFac()
							.kollektivuestdFindByKollektivIId(personalDto.getKollektivDto().getIId());
					for (int i = 0; i < kollektivuestdDtos.length; i++) {
						hmKollektivUestd100.put(kollektivuestdDtos[i].getTagesartIId(), kollektivuestdDtos[i]);
					}
				} catch (RemoteException ex4) {
					throwEJBExceptionLPRespectOld(ex4);
				}

			}

			try {

				PassivereiseDto[] passivereiseDtos = getPersonalFac()
						.passivereiseFindByKollektivIId(personalDto.getKollektivDto().getIId());
				for (int i = 0; i < passivereiseDtos.length; i++) {
					PassivereiseDto dto = passivereiseDtos[i];

					hmPassiveReise.put(dto.getTagesartIId(), dto);

				}

				KollektivUestdBVADto[] kollektivuestdBVADtos = getPersonalFac()
						.kollektivuestdBVAfindByKollektivIId(personalDto.getKollektivDto().getIId());
				for (int i = 0; i < kollektivuestdBVADtos.length; i++) {
					KollektivUestdBVADto dto = kollektivuestdBVADtos[i];

					hmKollektivUestdBVA.put(dto.getTagesartIId(), dto);

				}

				Kollektivuestd50Dto[] kollektivuestd50Dtos = getPersonalFac()
						.kollektivuestd50FindByKollektivIId(personalDto.getKollektivDto().getIId());
				for (int i = 0; i < kollektivuestd50Dtos.length; i++) {
					Kollektivuestd50Dto kollektivuestd50Dto = kollektivuestd50Dtos[i];

					// Nachsehen ob an dem Tag 100%ige definiert sind und sich
					// ueberschneiden

					ArrayList alVonBis = new ArrayList();

					if (hmKollektivUestd100.containsKey(kollektivuestd50Dto.getTagesartIId())) {

						KollektivuestdDto kollektivuestd100Dto = (KollektivuestdDto) hmKollektivUestd100
								.get(kollektivuestd50Dto.getTagesartIId());

						if (Helper.short2boolean(kollektivuestd100Dto.getBRestdestages()) == false
								&& Helper.short2boolean(kollektivuestd50Dto.getBRestdestages()) == true) {
							if (kollektivuestd100Dto.getUAb().getTime() > kollektivuestd50Dto.getUVon().getTime()) {

								alVonBis.add(new Object[] { kollektivuestd50Dto.getUVon(),
										kollektivuestd100Dto.getUAb(), kollektivuestd50Dto.getBUnterignorieren() });

							}

							if (kollektivuestd100Dto.getUBis().getTime() > kollektivuestd50Dto.getUVon().getTime()) {

								alVonBis.add(new Object[] { kollektivuestd100Dto.getUBis(),
										kollektivuestd100Dto.getUAb(), kollektivuestd100Dto.getBUnterignorieren() });
							}

						}

						if (Helper.short2boolean(kollektivuestd100Dto.getBRestdestages()) == false
								&& Helper.short2boolean(kollektivuestd50Dto.getBRestdestages()) == false) {
							if (kollektivuestd100Dto.getUAb().getTime() > kollektivuestd50Dto.getUVon().getTime()) {

								alVonBis.add(new Object[] { kollektivuestd50Dto.getUVon(),
										kollektivuestd100Dto.getUAb(), kollektivuestd50Dto.getBUnterignorieren() });
							}
							if (kollektivuestd100Dto.getUBis().getTime() < kollektivuestd50Dto.getUBis().getTime()) {

								alVonBis.add(new Object[] { kollektivuestd100Dto.getUBis(),
										kollektivuestd50Dto.getUBis(), kollektivuestd100Dto.getBUnterignorieren() });
							}

						}
						if (Helper.short2boolean(kollektivuestd100Dto.getBRestdestages()) == true
								&& Helper.short2boolean(kollektivuestd50Dto.getBRestdestages()) == true) {
							if (kollektivuestd100Dto.getUAb().getTime() > kollektivuestd50Dto.getUVon().getTime()) {

								alVonBis.add(new Object[] { kollektivuestd50Dto.getUVon(),
										kollektivuestd100Dto.getUAb(), kollektivuestd50Dto.getBUnterignorieren() });
							}

						}

						if (Helper.short2boolean(kollektivuestd100Dto.getBRestdestages()) == true
								&& Helper.short2boolean(kollektivuestd50Dto.getBRestdestages()) == false) {

							if (kollektivuestd100Dto.getUAb().getTime() > kollektivuestd50Dto.getUVon().getTime()) {

								alVonBis.add(new Object[] { kollektivuestd50Dto.getUVon(),
										kollektivuestd100Dto.getUAb(), kollektivuestd50Dto.getBUnterignorieren() });
							}

							if (kollektivuestd50Dto.getUBis().getTime() <= kollektivuestd100Dto.getUAb().getTime()) {
								alVonBis.add(new Object[] { new Time(-3600000), kollektivuestd50Dto.getUBis(),
										kollektivuestd100Dto.getBUnterignorieren() });
							}

						}

					} else {

						if (iBerechnungsbasisUestd == PersonalFac.KOLLEKTIV_BERECHNUNGSBASIS_UHRZEIT) {

							if (Helper.short2boolean(kollektivuestd50Dto.getBRestdestages()) == false) {
								alVonBis.add(new Object[] { new Time(-3600000), kollektivuestd50Dto.getUBis(),
										kollektivuestd50Dto.getBUnterignorieren() });
								alVonBis.add(new Object[] { kollektivuestd50Dto.getUVon(), null,
										kollektivuestd50Dto.getBUnterignorieren() });
							}
							if (Helper.short2boolean(kollektivuestd50Dto.getBRestdestages()) == true) {
								alVonBis.add(new Object[] { kollektivuestd50Dto.getUVon(), null,
										kollektivuestd50Dto.getBUnterignorieren() });
							}

						} else {
							alVonBis.add(new Object[] { kollektivuestd50Dto.getUVon(), null,
									kollektivuestd50Dto.getBUnterignorieren() });
						}

					}

					hmKollektivUestd50Tageweise.put(kollektivuestd50Dto.getTagesartIId(), alVonBis);

				}
			} catch (RemoteException ex4) {
				throwEJBExceptionLPRespectOld(ex4);
			}

		}

		// Hat die ausgewaehlte Person eine Ueberstundenpauschale im aktuellen
		// Abrechnungsmonat
		double fUeberstundenpauschale = 0;
		BigDecimal nDRZPauschale = BigDecimal.ZERO;
		int iUeberstundenAutomatischAuszahlen = 0;
		BigDecimal bdUeberstundenPuffer = new BigDecimal(0);

		try {
			PersonalgehaltDto personalgehaltDto = getPersonalFac().personalgehaltFindLetztePersonalgehalt(personalIId,
					iJahr, iMonat);

			if (personalgehaltDto != null) {
				fUeberstundenpauschale = personalgehaltDto.getFUestpauschale().doubleValue();
				nDRZPauschale = personalgehaltDto.getNDrzpauschale();
				bdUeberstundenPuffer = personalgehaltDto.getNUestdpuffer();
				iUeberstundenAutomatischAuszahlen = personalgehaltDto.getIUestdauszahlen();
			}
		} catch (RemoteException ex) {
			// Keine Ueberstundenpauschale
		}
		// Hole Dto der Unterbrechung
		TaetigkeitDto taetigkeitDto_Unter = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_UNTER, theClientDto);
		// Hole Dto des Arztbesuchs
		TaetigkeitDto taetigkeitDto_Arzt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ARZT, theClientDto);
		// Hole Dto der Behoerde
		TaetigkeitDto taetigkeitDto_Behoerde = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_BEHOERDE, theClientDto);
		// Hole Dto des Urlaub
		TaetigkeitDto taetigkeitDto_Urlaub = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_URLAUB, theClientDto);
		// Hole Dto des Zeitausgleichs
		TaetigkeitDto taetigkeitDto_ZA = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ZEITAUSGLEICH, theClientDto);
		// Hole Dto der Behoerde
		TaetigkeitDto taetigkeitDto_Krank = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KRANK, theClientDto);
		TaetigkeitDto taetigkeitDto_Kindkrank = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KINDKRANK,
				theClientDto);

		// Hole id der Taetigkeit KOMMT
		Integer taetigkeitIId_Kommt = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_KOMMT, theClientDto).getIId();
		// Hole id der Taetigkeit GEHT
		Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();
		// Hole id der Taetigkeit ENDE
		Integer taetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();
		// Hole id der Taetigkeit TELEFON
		Integer taetigkeitIId_telefon = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_TELEFON, theClientDto).getIId();
		// Hole die Sonstigen Taetigkeiten
		TaetigkeitDto[] sonstigeTaetigkeiten = getAllBenutzerdefinierteSondertaetigkeiten();

		Integer tagesartIId_Feiertag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_FEIERTAG, theClientDto).getIId();
		Integer tagesartIId_Halbtag = tagesartFindByCNr(ZeiterfassungFac.TAGESART_HALBTAG, theClientDto).getIId();
		Integer tagesartIId_betriebsurlaub = tagesartFindByCNr(ZeiterfassungFac.TAGESART_BETRIEBSURLAUB, theClientDto)
				.getIId();

		// Anzahl der Tage im aktuellen Monat ermitteln
		int lAnzahlTageImMonat = Helper.ermittleAnzahlTageEinesMonats(iJahr, iMonat);

		// Wenn bis Monatsende false ist, dann nur bis zum angegebenen
		// d_datum_bis berechnen
		Calendar cal = Calendar.getInstance();
		if (bisMonatsende == false) {
			cal.setTime(d_datum_bis);
			lAnzahlTageImMonat = cal.get(Calendar.DAY_OF_MONTH);
		} else {
			cal.set(iJahr.intValue(), iMonat.intValue(), lAnzahlTageImMonat);
			d_datum_bis = new java.sql.Date(cal.getTime().getTime());
		}

		// Zeitmodell
		Integer iZeitmodellId = null;
		Integer iZeitmodellIdVortag = null;
		Integer schichtIId = null;

		Date dEintrittsdatum = null;

		Date dAustrittsdatum = null;
		Date dAustrittsdatumFuerParameter = null;

		// Hole letztes Eintrittsdatum
		try {

			EintrittaustrittDto eaDto = getPersonalFac().eintrittaustrittFindLetztenEintrittBisDatum(personalIId,
					new Timestamp(d_datum_bis.getTime()));
			if (eaDto != null) {
				dEintrittsdatum = eaDto.getTEintritt();
			}

		} catch (RemoteException ex3) {
			throwEJBExceptionLPRespectOld(ex3);
		}

		// Austrittsdatum suchen, wenn NULL, dann ist Austritt 2099
		if (dEintrittsdatum != null) {
			try {
				dAustrittsdatum = getPersonalFac().eintrittaustrittFindByPersonalIIdDEintritt(personalIId,
						new java.sql.Timestamp(dEintrittsdatum.getTime())).getTAustritt();

				dAustrittsdatumFuerParameter = dAustrittsdatum;

				if (dAustrittsdatum != null) {
					Calendar cAus = Calendar.getInstance();
					cAus.setTime(dAustrittsdatum);
					// Einen Tag dazuzaehlen, damit der Autrittstag auch noch
					// mitabgerechnet wird
					cAus.set(Calendar.DAY_OF_MONTH, cAus.get(Calendar.DAY_OF_MONTH) + 1);
					dAustrittsdatum = cAus.getTime();
				}
			} catch (RemoteException ex2) {
				// kein Austritt
			}
		}
		if (dAustrittsdatum == null) {
			Calendar x = Calendar.getInstance();
			x.set(Calendar.YEAR, 2099);
			dAustrittsdatum = x.getTime();
			// Einen Tag dazuzaehlen, damit der Autrittstag auch noch
			// mitabgerechnet wird
			dAustrittsdatum = new Date(dAustrittsdatum.getTime() + 24 * 3600000);
		}

		// Array initialisieren
		data = new Object[lAnzahlTageImMonat][23];

		ArrayList[] monatsDaten = new ArrayList[lAnzahlTageImMonat + 1];
		BigDecimal[] monatsDatenReisezeiten = new BigDecimal[lAnzahlTageImMonat + 1];
		for (int i = 0; i < lAnzahlTageImMonat + 1; i++) {
			monatsDaten[i] = new ArrayList<Object>();

		}

		// Kurze Tagebezeichnungen holen
		String[] kurzeWochentage = new DateFormatSymbols(theClientDto.getLocUi()).getShortWeekdays();

		Object[] auftragsDaten = new Object[lAnzahlTageImMonat + 1];

		// Monatserster
		cal.set(iJahr.intValue(), iMonat.intValue(), 1);
		Timestamp tsVon = new Timestamp(cal.getTime().getTime());
		tsVon = Helper.cutTimestamp(tsVon);

		// Bis Auswertungsdatum
		cal.set(iJahr.intValue(), iMonat.intValue() + 1, 1);
		Timestamp tsBis = new Timestamp(cal.getTime().getTime());
		tsBis = Helper.cutTimestamp(tsBis);

		// Alle ZeitdatenDesMonats holen
		SessionFactory factory = FLRSessionFactory.getFactory();
		Session session = factory.openSession();
		Session sessionZulagen = factory.openSession();

		org.hibernate.Criteria artikelzulagen = sessionZulagen.createCriteria(FLRArtikelzulage.class);
		artikelzulagen.add(Expression.lt("t_gueltigab", tsVon));

		artikelzulagen.addOrder(Order.asc(PersonalFac.FLR_ARTKELZULAGE_FLRARTIKEL + ".i_id"));
		artikelzulagen.addOrder(Order.desc("t_gueltigab"));

		List<?> resultListZulagen = artikelzulagen.list();

		Iterator<?> resultListIteratorZulagen = resultListZulagen.iterator();
		ArtikelzulageDto[] zulagenDtos = new ArtikelzulageDto[resultListZulagen.size()];
		Integer[] zulagenArtikelIId = new Integer[resultListZulagen.size()];

		int rowZulage = 0;
		while (resultListIteratorZulagen.hasNext()) {
			FLRArtikelzulage flrartikelzulagen = (FLRArtikelzulage) resultListIteratorZulagen.next();
			ArtikelzulageDto artikelzulageDto = new ArtikelzulageDto();
			artikelzulageDto.setIId(flrartikelzulagen.getI_id());
			artikelzulageDto.setArtikelIId(flrartikelzulagen.getFlrartikel().getI_id());
			artikelzulageDto.setTGueltigab(new Timestamp(flrartikelzulagen.getT_gueltigab().getTime()));

			ZulageDto zulageDto = new ZulageDto();
			zulageDto.setIId(flrartikelzulagen.getFlrzulage().getI_id());
			zulageDto.setCBez(flrartikelzulagen.getFlrzulage().getC_bez());
			artikelzulageDto.setZulageDto(zulageDto);

			zulagenDtos[rowZulage] = artikelzulageDto;
			zulagenArtikelIId[rowZulage] = flrartikelzulagen.getFlrartikel().getI_id();

			rowZulage++;
		}

		sessionZulagen.close();

		// PJ20936 Passive Reisezeiten
		// Alle Belegbuchungen mit Passiven Reisezeiten holen
		Session sessionBelegeMitPassivenReisezeiten = factory.openSession();

		org.hibernate.Criteria belegeMitPassivenReisezeiten = sessionBelegeMitPassivenReisezeiten
				.createCriteria(FLRZeitdaten.class);
		belegeMitPassivenReisezeiten.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalIId));
		belegeMitPassivenReisezeiten.add(Expression.ge(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tsVon));

		if (bisMonatsende) {
			belegeMitPassivenReisezeiten.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tsBis));
		} else {
			belegeMitPassivenReisezeiten.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT,
					Helper.addiereTageZuTimestamp(new Timestamp(d_datum_bis.getTime()), 1)));
		}
		belegeMitPassivenReisezeiten.add(Expression.isNotNull(ZeiterfassungFac.FLR_ZEITDATEN_ARTIKEL_I_ID));

		belegeMitPassivenReisezeiten.createAlias("flrartikel", "a")
				.add(Restrictions.eq("a.i_passive_reisezeit", ArtikelFac.REISEZEIT_PASSIV));

		belegeMitPassivenReisezeiten.addOrder(Order.asc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));
		List<?> resultListBelegeMitPassivenReisezeiten = belegeMitPassivenReisezeiten.list();

		Iterator<?> resultListIteratorBelegeMitPassivenReisezeitenn = resultListBelegeMitPassivenReisezeiten.iterator();

		HashMap<Integer, ArrayList<AuftragzeitenDto[]>> hmPassiveReisezeiten = new HashMap<Integer, ArrayList<AuftragzeitenDto[]>>();

		while (resultListIteratorBelegeMitPassivenReisezeitenn.hasNext()) {
			FLRZeitdaten belegzeit = (FLRZeitdaten) resultListIteratorBelegeMitPassivenReisezeitenn.next();

			Calendar c = Calendar.getInstance();
			c.setTime(belegzeit.getT_zeit());

			Integer iTag = c.get(Calendar.DAY_OF_MONTH);

			AuftragzeitenDto[] azDtos = getAllZeitenEinesBeleges(belegzeit.getC_belegartnr(),
					belegzeit.getI_belegartid(), belegzeit.getI_belegartpositionid(), personalIId,
					new Timestamp(belegzeit.getT_zeit().getTime()),
					Helper.cutTimestamp(
							Helper.addiereTageZuTimestamp(new Timestamp(belegzeit.getT_zeit().getTime()), 1)),
					SORTIERUNG_ZEITDATEN_ARTIKEL, false, belegzeit.getI_id(), null, BELEGZEITEN_NUR_PERSONALZEITEN,
					theClientDto);

			if (hmPassiveReisezeiten.containsKey(iTag)) {
				ArrayList<AuftragzeitenDto[]> alTag = hmPassiveReisezeiten.get(iTag);
				alTag.add(azDtos);
				hmPassiveReisezeiten.put(iTag, alTag);
			} else {
				ArrayList<AuftragzeitenDto[]> alTag = new ArrayList<AuftragzeitenDto[]>();
				alTag.add(azDtos);
				hmPassiveReisezeiten.put(iTag, alTag);
			}

		}

		HashMap<Integer, HashMap<Integer, Double>> hmBelegeMitZulagen = new HashMap<Integer, HashMap<Integer, Double>>();

		if (zulagenArtikelIId.length > 0) {
			// Alle Belegbuchungen mit Zulagen-Artikeln holen
			Session sessionBelegeMitZulagen = factory.openSession();

			org.hibernate.Criteria belegeMitzulagen = sessionBelegeMitZulagen.createCriteria(FLRZeitdaten.class);
			belegeMitzulagen.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalIId));
			belegeMitzulagen.add(Expression.ge(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tsVon));

			if (bisMonatsende) {
				belegeMitzulagen.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tsBis));
			} else {
				belegeMitzulagen.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT,
						Helper.addiereTageZuTimestamp(new Timestamp(d_datum_bis.getTime()), 1)));
			}

			belegeMitzulagen.add(Expression.isNotNull(ZeiterfassungFac.FLR_ZEITDATEN_ARTIKEL_I_ID));
			belegeMitzulagen.add(Expression.in(ZeiterfassungFac.FLR_ZEITDATEN_ARTIKEL_I_ID, zulagenArtikelIId));

			belegeMitzulagen.addOrder(Order.asc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));

			List<?> resultListBelegeMitZulagen = belegeMitzulagen.list();

			Iterator<?> resultListIteratorBelegeMitZulagen = resultListBelegeMitZulagen.iterator();

			HashSet hsBelegeUndTag = new HashSet();

			while (resultListIteratorBelegeMitZulagen.hasNext()) {
				FLRZeitdaten belegzeit = (FLRZeitdaten) resultListIteratorBelegeMitZulagen.next();

				Calendar c = Calendar.getInstance();
				c.setTime(belegzeit.getT_zeit());

				Integer iTag = c.get(Calendar.DAY_OF_MONTH);

				// SP5331
				String sVergl = iTag + " " + belegzeit.getC_belegartnr() + belegzeit.getI_belegartid() + " "
						+ belegzeit.getI_belegartpositionid();

				if (!hsBelegeUndTag.contains(sVergl)) {
					hsBelegeUndTag.add(sVergl);
					Timestamp tBis = Helper.addiereTageZuTimestamp(new Timestamp(belegzeit.getT_zeit().getTime()), 1);

					AuftragzeitenDto[] azDtos = getAllZeitenEinesBeleges(belegzeit.getC_belegartnr(),
							belegzeit.getI_belegartid(), belegzeit.getI_belegartpositionid(), personalIId,
							new Timestamp(belegzeit.getT_zeit().getTime()), Helper.cutTimestamp(tBis),
							SORTIERUNG_ZEITDATEN_ARTIKEL, theClientDto);

					for (int i = 0; i < azDtos.length; i++) {
						Integer artikelIId = azDtos[i].getArtikelIId();

						if (hmBelegeMitZulagen.containsKey(iTag)) {
							HashMap<Integer, Double> hmZulagen = hmBelegeMitZulagen.get(iTag);
							if (hmZulagen.containsKey(artikelIId)) {
								Double dDauer = hmZulagen.get(artikelIId);
								dDauer += azDtos[i].getDdDauer();
								hmZulagen.put(artikelIId, dDauer);
								hmBelegeMitZulagen.put(iTag, hmZulagen);
							} else {
								hmZulagen.put(artikelIId, azDtos[i].getDdDauer());
								hmBelegeMitZulagen.put(iTag, hmZulagen);
							}
						} else {
							HashMap<Integer, Double> hmZulagen = new HashMap<Integer, Double>();
							hmZulagen.put(artikelIId, azDtos[i].getDdDauer());
							hmBelegeMitZulagen.put(iTag, hmZulagen);
						}
					}
				}
			}
		}

		// Alle Monatszeitdaten holen
		org.hibernate.Criteria zeitdatenEinesMonatsOhneAuftraege = session.createCriteria(FLRZeitdaten.class);

		zeitdatenEinesMonatsOhneAuftraege.add(Expression.eq(ZeiterfassungFac.FLR_ZEITDATEN_PERSONAL_I_ID, personalIId));
		zeitdatenEinesMonatsOhneAuftraege.add(Expression.ge(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tsVon));

		if (bisMonatsende) {
			zeitdatenEinesMonatsOhneAuftraege.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT, tsBis));
		} else {
			zeitdatenEinesMonatsOhneAuftraege.add(Expression.lt(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT,
					Helper.cutTimestamp(Helper.addiereTageZuTimestamp(new Timestamp(d_datum_bis.getTime()), 1))));
		}

		zeitdatenEinesMonatsOhneAuftraege.add(Expression.isNull(ZeiterfassungFac.FLR_ZEITDATEN_ARTIKEL_I_ID));

		zeitdatenEinesMonatsOhneAuftraege.add(Expression.isNotNull(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID));

		Integer[] taetigkeiten = new Integer[2];
		taetigkeiten[0] = taetigkeitIId_Ende;
		// Und ohne Telefonzeiten
		taetigkeiten[1] = taetigkeitIId_telefon;

		zeitdatenEinesMonatsOhneAuftraege
				.add(Expression.not(Expression.in(ZeiterfassungFac.FLR_ZEITDATEN_TAETIGKEIT_I_ID, taetigkeiten)));
		zeitdatenEinesMonatsOhneAuftraege.addOrder(Order.asc(ZeiterfassungFac.FLR_ZEITDATEN_T_ZEIT));

		List<?> resultListZeitdatenOhneAuftraege = zeitdatenEinesMonatsOhneAuftraege.list();

		Iterator<?> resultListIteratorOhneAuftraege = resultListZeitdatenOhneAuftraege.iterator();

		ArrayList<MonatsabrechnungBereitschaftDto> alBereitschaften = new ArrayList();

		// Monatsdaten auf Kommt-Geht-Bloecke aufteilen
		boolean bKommt = false;
		ArrayList<ZeitdatenDto> kommtGehtBlock = new ArrayList<ZeitdatenDto>();
		int iLetzterTag = -1;
		while (resultListIteratorOhneAuftraege.hasNext()) {
			FLRZeitdaten flrzeitdaten = (FLRZeitdaten) resultListIteratorOhneAuftraege.next();

			Calendar c = Calendar.getInstance();
			c.setTime(flrzeitdaten.getT_zeit());
			int iTag = c.get(Calendar.DAY_OF_MONTH);
			if (iLetzterTag != -1 && iTag != iLetzterTag && kommtGehtBlock.size() > 0) {
				monatsDaten[iLetzterTag].add(kommtGehtBlock);
				kommtGehtBlock = new ArrayList<ZeitdatenDto>();
				bKommt = false;
			}

			ZeitdatenDto zeitdatenDto = new ZeitdatenDto();
			zeitdatenDto.setTaetigkeitIId(flrzeitdaten.getFlrtaetigkeit().getI_id());
			zeitdatenDto.setTZeit(new Timestamp(flrzeitdaten.getT_zeit().getTime()));
			zeitdatenDto.setIId(flrzeitdaten.getI_id());
			zeitdatenDto.setBAutomatikbuchung(flrzeitdaten.getB_automatikbuchung());
			kommtGehtBlock.add(zeitdatenDto);

			if (bKommt == false) {
				if (zeitdatenDto.getTaetigkeitIId() != null
						&& zeitdatenDto.getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {
					bKommt = true;
				} else {
					// FEHLER: 2 KOMMT NACHEINANDER
				}
			} else if (bKommt == true) {
				if (zeitdatenDto.getTaetigkeitIId() != null
						&& zeitdatenDto.getTaetigkeitIId().equals(taetigkeitIId_Geht)) {
					bKommt = false;

					monatsDaten[iTag].add(kommtGehtBlock);
					kommtGehtBlock = new ArrayList<ZeitdatenDto>();
				}

			}

			if (resultListIteratorOhneAuftraege.hasNext() == false && kommtGehtBlock.size() > 0) {
				monatsDaten[iTag].add(kommtGehtBlock);
			}

			iLetzterTag = iTag;
		}
		session.close();

		// fuer jeden KOMMT-GEHT-Block Mitternachtssprung simulieren

		for (int i = 1; i < lAnzahlTageImMonat + 1; i++) {
			ArrayList<ArrayList<ZeitdatenDto>> bloecke = monatsDaten[i];

			for (int j = 0; j < bloecke.size(); j++) {

				ArrayList<ZeitdatenDto> al = bloecke.get(j);

				ZeitdatenDto[] dtos = new ZeitdatenDto[al.size()];

				dtos = (ZeitdatenDto[]) al.toArray(dtos);

				dtos = simuliereMitternachssprung(personalIId, new java.sql.Date(al.get(0).getTZeit().getTime()),
						taetigkeitIId_Kommt, taetigkeitIId_Geht, dtos);

				al = new ArrayList();
				for (int k = 0; k < dtos.length; k++) {
					al.add(dtos[k]);
				}
				bloecke.set(j, al);
			}
			monatsDaten[i] = bloecke;
		}

		// nochmals auf KOMMT-GEHT Bloecke aufteilen
		for (int i = 1; i < lAnzahlTageImMonat + 1; i++) {
			ArrayList<ArrayList<ZeitdatenDto>> bloecke = monatsDaten[i];

			ArrayList<ArrayList<ZeitdatenDto>> alNeueBloecke = new ArrayList<ArrayList<ZeitdatenDto>>();
			for (int j = 0; j < bloecke.size(); j++) {

				ArrayList<ZeitdatenDto> al = bloecke.get(j);

				ZeitdatenDto[] dtos = new ZeitdatenDto[al.size()];
				dtos = (ZeitdatenDto[]) al.toArray(dtos);

				boolean bMehrereBloecke = false;

				if (dtos.length > 1) {
					for (int m = 2; m < dtos.length; m++) {
						ZeitdatenDto dto = dtos[m];
						if (dto.getTaetigkeitIId() != null && dto.getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {

							// Auf 2 Bloecke aufteilen
							bMehrereBloecke = true;
							ArrayList<ZeitdatenDto> alTemp = new ArrayList<ZeitdatenDto>();
							for (int l = 0; l < m; l++) {
								alTemp.add(dtos[l]);
							}
							alNeueBloecke.add(alTemp);

							alTemp = new ArrayList<ZeitdatenDto>();
							for (int l = m; l < dtos.length; l++) {
								alTemp.add(dtos[l]);
							}
							alNeueBloecke.add(alTemp);
							break;

						}
					}
				}

				if (bMehrereBloecke == false) {
					alNeueBloecke.add(bloecke.get(j));
				}

			}

			monatsDaten[i] = alNeueBloecke;

		}

		// Reisezeiten holen

		for (int i = 1; i < lAnzahlTageImMonat + 1; i++) {

			cal.set(iJahr.intValue(), iMonat.intValue(), i, 0, 0, 0);
			cal.set(Calendar.MILLISECOND, 0);
			Timestamp tVon = new Timestamp(cal.getTimeInMillis());

			cal.set(iJahr.intValue(), iMonat.intValue(), i + 1, 0, 0, 0);
			cal.set(Calendar.MILLISECOND, 0);
			Timestamp tBis = new Timestamp(cal.getTimeInMillis());

			Session sessReise = FLRSessionFactory.getFactory().openSession();
			org.hibernate.Criteria reisezeiten = sessReise.createCriteria(FLRReise.class);
			reisezeiten.add(Expression.eq(ZeiterfassungFac.FLR_REISE_PERSONAL_I_ID, personalIId));
			reisezeiten.add(Expression.ge(ZeiterfassungFac.FLR_REISE_T_ZEIT, tVon));
			reisezeiten.add(Expression.lt(ZeiterfassungFac.FLR_REISE_T_ZEIT, tBis));
			reisezeiten.addOrder(Order.asc(ZeiterfassungFac.FLR_REISE_T_ZEIT));

			List<?> lReisezeiten = reisezeiten.list();

			long reiseGesamt = 0;

			if (lReisezeiten.size() == 0) {
				// Hole letzten Eintrag
				Session sessReiseLetztesBeginn = FLRSessionFactory.getFactory().openSession();
				org.hibernate.Criteria criteriaLetztesBeginn = sessReiseLetztesBeginn.createCriteria(FLRReise.class);
				criteriaLetztesBeginn.add(Expression.eq(ZeiterfassungFac.FLR_REISE_PERSONAL_I_ID, personalIId));
				criteriaLetztesBeginn.add(Expression.lt(ZeiterfassungFac.FLR_REISE_T_ZEIT, tVon));
				criteriaLetztesBeginn.addOrder(Order.desc(ZeiterfassungFac.FLR_REISE_T_ZEIT));
				criteriaLetztesBeginn.setMaxResults(1);
				List<?> listLetzttesBeginn = criteriaLetztesBeginn.list();
				if (listLetzttesBeginn.size() > 0) {
					FLRReise flrLetzterEintrag = (FLRReise) listLetzttesBeginn.get(0);
					if (Helper.short2boolean(flrLetzterEintrag.getB_beginn()) == true) {
						reiseGesamt = 24 * 3600000;
					}
				}

			}

			FLRReise letzterReiseeintrag = null;
			for (int j = 0; j < lReisezeiten.size(); j++) {
				FLRReise reise = (FLRReise) lReisezeiten.get(j);

				if (j == 0) {
					// Hole letzten Eintrag
					Session sessReiseLetztesBeginn = FLRSessionFactory.getFactory().openSession();
					org.hibernate.Criteria criteriaLetztesBeginn = sessReiseLetztesBeginn
							.createCriteria(FLRReise.class);
					criteriaLetztesBeginn.add(Expression.eq(ZeiterfassungFac.FLR_REISE_PERSONAL_I_ID, personalIId));
					criteriaLetztesBeginn.add(Expression.lt(ZeiterfassungFac.FLR_REISE_T_ZEIT, reise.getT_zeit()));
					criteriaLetztesBeginn.addOrder(Order.desc(ZeiterfassungFac.FLR_REISE_T_ZEIT));
					criteriaLetztesBeginn.setMaxResults(1);
					List<?> listLetzttesBeginn = criteriaLetztesBeginn.list();
					if (Helper.short2boolean(reise.getB_beginn()) == true) {
						if (listLetzttesBeginn.size() > 0) {

							FLRReise flrLetzterEintrag = (FLRReise) listLetzttesBeginn.get(0);

							if (Helper.short2boolean(flrLetzterEintrag.getB_beginn()) == true) {
								reiseGesamt += reise.getT_zeit().getTime() - tVon.getTime();
							}

						}
					} else {
						reiseGesamt += reise.getT_zeit().getTime() - tVon.getTime();
					}

					sessReiseLetztesBeginn.close();
				}
				if (j > 0 && j < lReisezeiten.size()) {

					if (Helper.short2boolean(reise.getB_beginn()) == true
							&& Helper.short2boolean(letzterReiseeintrag.getB_beginn()) == true) {
						reiseGesamt += reise.getT_zeit().getTime() - letzterReiseeintrag.getT_zeit().getTime();
					} else if (Helper.short2boolean(reise.getB_beginn()) == false
							&& Helper.short2boolean(letzterReiseeintrag.getB_beginn()) == true) {
						reiseGesamt += reise.getT_zeit().getTime() - letzterReiseeintrag.getT_zeit().getTime();
					}

				}

				if (j == 0 && lReisezeiten.size() == 1) {
					if (Helper.short2boolean(reise.getB_beginn()) == true) {
						reiseGesamt += tBis.getTime() - reise.getT_zeit().getTime();
					}
				}

				// Wenn letzer Eintrag Beginn ist
				if (j > 0 && j == lReisezeiten.size() - 1) {
					if (Helper.short2boolean(reise.getB_beginn()) == true) {
						reiseGesamt += tBis.getTime() - reise.getT_zeit().getTime();
					}
				}

				letzterReiseeintrag = reise;
			}

			double dReiseDesamt = reiseGesamt;
			monatsDatenReisezeiten[i] = new BigDecimal(dReiseDesamt / 1000 / 60 / 60);
			sessReise.close();
		}

		boolean bUestdVerteilen = false;
		boolean bWochengesamtsicht = false;

		if (personalDto.getKollektivDto() != null
				&& Helper.short2boolean(personalDto.getKollektivDto().getbWochengesamtsicht())) {
			bWochengesamtsicht = true;
		}

		int iFaktorPassiveReisezeit = 0;
		if (personalDto.getKollektivDto() != null) {
			iFaktorPassiveReisezeit = personalDto.getKollektivDto().getIFaktorPassiveReisezeit();
		}

		double dSummeMonatFeiertagSoll = 0;

		double dWochensummeUestd200 = 0;
		double dWochensummeUestd100 = 0;
		double dWochensummeUestd50Tageweise = 0;
		double dWochensummeIst = 0;
		double dWochensummeIstOhneSonderzeiten = 0;

		boolean bEintrittsmonatMonat = false;

		// SP3265 Wenn Eintrittsmonat, dann Vormonat nicht berechnen
		if (dEintrittsdatum != null) {
			Calendar cVergleich = Calendar.getInstance();
			cVergleich.setTimeInMillis(dEintrittsdatum.getTime());
			if (cVergleich.get(Calendar.MONTH) == iMonat && cVergleich.get(Calendar.YEAR) == iJahr) {
				bEintrittsmonatMonat = true;
			}
		}

		if (vormonatFuerMaximaleAnwesenheitberechnen == true && nMaximalesWochenIST != null
				&& nMaximalesWochenIST.doubleValue() > 0 && bEintrittsmonatMonat == false) {

			Calendar cVormonat = Calendar.getInstance();
			cVormonat.setTimeInMillis(calErstesZeitmodell.getTimeInMillis());
			cVormonat.add(Calendar.MONTH, -1);

			MonatsabrechnungDto monatsabrechnungVormonatDto = erstelleMonatsAbrechnung(personalIId,
					cVormonat.get(Calendar.YEAR), cVormonat.get(Calendar.MONTH), true, null, theClientDto, false,
					iOptionSortierung, false, bTagesUndwochenmaximumIgnorieren, dNurWennTagesistGroesser);

			Object[][] zeilenVormonat = monatsabrechnungVormonatDto.getData();

			int iKWErster = calErstesZeitmodell.get(Calendar.WEEK_OF_YEAR);

			for (int i = zeilenVormonat.length - 1; i > 0; --i) {
				Object[] zeileVormonat = zeilenVormonat[i];
				int iKWVormonatszeile = (Integer) zeileVormonat[REPORT_MONATSABRECHNUNG_KALENDERWOCHE];
				if (iKWErster == iKWVormonatszeile) {

					BigDecimal bdIstVormonat = (BigDecimal) zeileVormonat[REPORT_MONATSABRECHNUNG_IST];
					if (bdIstVormonat != null) {
						dWochensummeIstOhneSonderzeiten = dWochensummeIstOhneSonderzeiten + bdIstVormonat.doubleValue();
					}

				}

			}

		}

		double dWochensummeSollFuerUestd = 0;
		double dWochensummeFtgSoll = 0;

		ArrayList<ZeileMonatsabrechnungDto> monatsabrechnungZeilen = new ArrayList<ZeileMonatsabrechnungDto>();
		// -------NEU

		// Fuer Wochesumme Uestd50
		cal.set(iJahr.intValue(), iMonat.intValue(), 1, 0, 0, 0);

		for (int i = 1; i < lAnzahlTageImMonat + 1; i++) {
			ArrayList<ArrayList<ZeitdatenDto>> bloecke = monatsDaten[i];
			if (bloecke.size() == 0) {
				bloecke.add(new ArrayList<ZeitdatenDto>());
			}

			// Datum setzen
			cal.set(iJahr.intValue(), iMonat.intValue(), i, 0, 0, 0);
			cal.set(Calendar.MILLISECOND, 0);

			// Sollzeit holen
			java.sql.Time tSollzeit = null;
			double dSollzeitGesamt = 0;
			ZeitmodelltagDto zeitodelltagDto = null;

			try {
				zeitodelltagDto = getZeitmodelltagZuDatum(personalIId, new java.sql.Timestamp(cal.getTimeInMillis()),
						tagesartIId_Feiertag, tagesartIId_Halbtag, false, theClientDto);

				if (zeitodelltagDto != null) {

					// SP4125

					boolean bKeineSollZeitAmOriginalTagWennHalberFeiertag = false;
					if (zeitodelltagDto.getTagesartIId().equals(tagesartIId_Halbtag)) {
						// Wenn Sollzeit am Originaltag nicht vorhanden oder
						// null, dann muss der Mitarbeiter gar nicht anwesend
						// sein
						ZeitmodelltagDto zeitmodelltagDtoOriginaltag = getZeitmodelltagZuDatum(personalIId,
								new Timestamp(cal.getTime().getTime()), tagesartIId_Feiertag, tagesartIId_Halbtag, true,
								theClientDto);

						if (zeitmodelltagDtoOriginaltag == null) {
							bKeineSollZeitAmOriginalTagWennHalberFeiertag = true;
						} else if (zeitmodelltagDtoOriginaltag != null) {

							if (zeitmodelltagDtoOriginaltag.getUSollzeit() == null
									|| zeitmodelltagDtoOriginaltag.getUSollzeit().getTime() == -3600000) {
								bKeineSollZeitAmOriginalTagWennHalberFeiertag = true;
							}
						}
					}

					if (bKeineSollZeitAmOriginalTagWennHalberFeiertag == true) {
						tSollzeit = null;
					} else {
						tSollzeit = zeitodelltagDto.getUSollzeit();
					}

				}
			} catch (Exception ex3) {
				// keine Sollzeit
			}

			// PJ17884
			// Zuerst alle Bereitschaften des Tages holen
			Integer tagesartIId = getTagesartZuDatum(personalIId, new Timestamp(cal.getTimeInMillis()),
					tagesartIId_Feiertag, tagesartIId_Halbtag, tagesartIId_betriebsurlaub, theClientDto);

			if (tagesartIId != null) {
				String sQuery = "select ber FROM FLRBereitschaft ber WHERE ber.t_beginn<'"
						+ Helper.formatTimestampWithSlashes(
								Helper.addiereTageZuTimestamp(new java.sql.Timestamp(cal.getTimeInMillis()), 1))
						+ "' AND ber.flrpersonal.i_id=" + personalIId + " AND ber.t_ende>='"
						+ Helper.formatTimestampWithSlashes(new java.sql.Timestamp(cal.getTimeInMillis())) + "'";

				Session sessionBereitschaft = FLRSessionFactory.getFactory().openSession();

				org.hibernate.Query heutigebereitschaften = sessionBereitschaft.createQuery(sQuery);

				List<?> resultList = heutigebereitschaften.list();

				Iterator<?> resultListIterator = resultList.iterator();

				while (resultListIterator.hasNext()) {

					FLRBereitschaft bereitschaften = (FLRBereitschaft) resultListIterator.next();

					BereitschafttagDto bereitschafttagDto = getBereitschafttagZuDatum(personalIId,
							new java.sql.Timestamp(cal.getTimeInMillis()), tagesartIId_Feiertag, tagesartIId_Halbtag,
							false, bereitschaften.getFlrbereitschaftart().getI_id(), theClientDto);

					Query query = em.createNamedQuery("BereitschafttagfindByBereitschaftartIIdTagesartIId");
					query.setParameter(1, bereitschaften.getFlrbereitschaftart().getI_id());
					query.setParameter(2, bereitschafttagDto.getTagesartIId());
					// @todo getSingleResult oder
					// getResultList
					// ?
					Collection c = query.getResultList();
					Iterator it = c.iterator();
					while (it.hasNext()) {
						Bereitschafttag bereitschafttag = (Bereitschafttag) it.next();

						int z = 0;

						Timestamp tVon = new java.sql.Timestamp(cal.getTimeInMillis());

						if (bereitschaften.getT_beginn().after(tVon)) {
							tVon = new java.sql.Timestamp(bereitschaften.getT_beginn().getTime());
						}

						Timestamp bereitschafttagBeginn = new java.sql.Timestamp(
								cal.getTimeInMillis() + (bereitschafttag.getUBeginn().getTime() + 3600000));

						if (bereitschafttagBeginn.after(tVon)) {
							tVon = bereitschafttagBeginn;
						}

						if (bereitschaften.getT_ende().before(bereitschafttagBeginn)) {
							continue;
						}

						Timestamp tBis = Helper.addiereTageZuTimestamp(new java.sql.Timestamp(cal.getTimeInMillis()),
								1);

						if (bereitschaften.getT_ende().before(tBis)) {
							tBis = new java.sql.Timestamp(bereitschaften.getT_ende().getTime());
						}

						Timestamp bereitschafttagEnde = null;
						if (bereitschafttag.getUEnde() != null) {
							bereitschafttagEnde = new java.sql.Timestamp(
									cal.getTimeInMillis() + bereitschafttag.getUEnde().getTime() + 3600000);
						} else {
							bereitschafttagEnde = Helper
									.addiereTageZuTimestamp(new java.sql.Timestamp(cal.getTimeInMillis()), 1);
						}

						if (bereitschaften.getT_beginn().after(bereitschafttagEnde)) {
							continue;
						}

						if (bereitschafttagEnde.before(tBis)) {
							tBis = bereitschafttagEnde;
						}

						Timestamp tVonFuerReport = new Timestamp(tVon.getTime());
						Timestamp tBisFuerReport = new Timestamp(tBis.getTime());

						MonatsabrechnungBereitschaftDto berDto = new MonatsabrechnungBereitschaftDto();
						berDto.setBereitschaftsart(bereitschaften.getFlrbereitschaftart().getC_bez());

						BetriebskalenderDto dto = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(
								Helper.cutTimestamp(new java.sql.Timestamp(cal.getTimeInMillis())),
								theClientDto.getMandant(), theClientDto);
						if (dto != null) {

							if (dto.getTagesartIId().equals(tagesartIId_Feiertag)
									|| dto.getTagesartIId().equals(tagesartIId_Halbtag)) {
								berDto.setFeiertag(dto.getCBez());
							}
						}

						berDto.setTagesartCNr(kurzeWochentage[cal.get(Calendar.DAY_OF_WEEK)]);

						berDto.setKw(new Integer(cal.get(Calendar.WEEK_OF_YEAR)));
						berDto.setBemerkung(bereitschaften.getC_bemerkung());

						// Nun KOMMT-GEHT Bloecke beruecksichtigen

						boolean bBereitschaftBereitsHinzugefuegt = false;

						for (int j = 0; j < bloecke.size(); j++) {

							ArrayList<ZeitdatenDto> einBlock = (ArrayList<ZeitdatenDto>) bloecke.get(j);
							if (einBlock.size() > 1) {

								// Erste Zeile muss Kommt sein
								ZeitdatenDto kommtDto = einBlock.get(0);

								// Letzt Zeile muss Geht sein
								ZeitdatenDto gehtDto = einBlock.get(einBlock.size() - 1);

								if (tBis.before(kommtDto.getTZeit()) && tVon.after(gehtDto.getTZeit())) {
									continue;
								}

								// 1ter Teil: KOMMT ist VOR dem
								// Bereitschaftsbeginn und GEHT nach dem
								// Bereitschaftsbeginn
								if (kommtDto.getTZeit().before(tVon) && gehtDto.getTZeit().after(tVon)) {

									tVon = new Timestamp(gehtDto.getTZeit().getTime());

									if (bloecke.size() == 1) {
										tVonFuerReport = tVon;
										continue;
									} else {
										if (j == 0) {

											ArrayList<ZeitdatenDto> naechsterBlock = (ArrayList<ZeitdatenDto>) bloecke
													.get(j + 1);
											if (naechsterBlock.size() > 1) {

												// Erste Zeile muss Kommt
												// sein
												ZeitdatenDto kommtDtoNaechstes = naechsterBlock.get(0);

												MonatsabrechnungBereitschaftDto berDtoTeil1 = berDto.clone();
												berDtoTeil1.settVon(tVon);
												berDtoTeil1.settBis(kommtDtoNaechstes.getTZeit());// naechstes
																									// Kommt
												alBereitschaften.add(berDtoTeil1);

												bBereitschaftBereitsHinzugefuegt = true;
											}
										}
									}
								}

								// Komm-Geht Block ist zwischen drin
								if (kommtDto.getTZeit().after(tVon) && gehtDto.getTZeit().before(tBis)) {

									// 2 Neue Zeilen erstellen

									// Wenns der 1. ist ->
									MonatsabrechnungBereitschaftDto berDtoTeil = berDto.clone();
									berDtoTeil.settVon(tVon);
									berDtoTeil.settBis(kommtDto.getTZeit());
									alBereitschaften.add(berDtoTeil);

									bBereitschaftBereitsHinzugefuegt = true;

									// Nun noch bis zum naechsten Kommt oder
									// T_BIS
									if (j == bloecke.size() - 1) {
										// Wenns der letzte ist bis zum T_BIS
										MonatsabrechnungBereitschaftDto berDtoTeil1 = berDto.clone();
										berDtoTeil1.settVon(gehtDto.getTZeit());
										berDtoTeil1.settBis(tBis);
										alBereitschaften.add(berDtoTeil1);
										bBereitschaftBereitsHinzugefuegt = true;

									} else {
										// Wenns nicht der letzte ist, bis zum
										// naechsten Kommt
										ArrayList<ZeitdatenDto> naechsterBlock = (ArrayList<ZeitdatenDto>) bloecke
												.get(j + 1);
										if (naechsterBlock.size() > 1) {

											// Erste Zeile muss Kommt
											// sein
											ZeitdatenDto kommtDtoNaechstes = naechsterBlock.get(0);

											MonatsabrechnungBereitschaftDto berDtoTeil1 = berDto.clone();
											berDtoTeil1.settVon(gehtDto.getTZeit());

											// Ausser das bis_bereitschaft ist <
											// als das Kommt
											if (tBis.before(kommtDtoNaechstes.getTZeit())) {
												berDtoTeil1.settBis(tBis);
											} else {
												berDtoTeil1.settBis(kommtDtoNaechstes.getTZeit());
											}

											alBereitschaften.add(berDtoTeil1);
											bBereitschaftBereitsHinzugefuegt = true;

										}

									}

								}
								// 1ter Teil: KOMMT ist VOR dem
								// Bereitschaftsende und GEHT nach dem
								// Bereitschaftsende
								if (kommtDto.getTZeit().before(tBis) && gehtDto.getTZeit().after(tBis)) {

									tBisFuerReport = kommtDto.getTZeit();

								}
							}
						}

						if (bBereitschaftBereitsHinzugefuegt == false) {

							berDto.settVon(tVonFuerReport);
							berDto.settBis(tBisFuerReport);

							alBereitschaften.add(berDto);
						}

					}

				}
				sessionBereitschaft.close();
			}

			if (bVonBisZeiterfassungOhneKommtGeht == true) {
				bloecke = new ArrayList<ArrayList<ZeitdatenDto>>();
				bloecke.add(new ArrayList<ZeitdatenDto>());
			}

			for (int j = 0; j < bloecke.size(); j++) {

				// EIN KOMMT-GEHT BLOCK
				ZeileMonatsabrechnungDto zeile = new ZeileMonatsabrechnungDto();

				// Bemerkung initialisieren
				zeile.setSBemerkung("");
				// Kalenderwoche setzten (danach wird im Report gruppiert)
				zeile.setIKw(new Integer(cal.get(Calendar.WEEK_OF_YEAR)));
				// Tagesbezeichnung setzen (Mo,Di,Mi) usw
				zeile.setSTag(kurzeWochentage[cal.get(Calendar.DAY_OF_WEEK)]);
				// Jahr setzen
				zeile.setIJahr(new Integer(cal.get(Calendar.YEAR)));
				zeile.setIMonat(new Integer(cal.get(Calendar.MONTH)));
				// Datum setzen
				zeile.setITag(i);
				zeile.setTDatum(new Timestamp(cal.getTimeInMillis()));

				// PJ19734
				if (j == 0) {
					ZeitgutschriftVerschiebenHelper zh = umZeitgutschriftVerschieben(bloecke.get(0), personalIId,
							new Timestamp(cal.getTime().getTime()), zeile, theClientDto);
					bloecke.set(j, zh.block);
					zeile = zh.zmDto;

					BigDecimal bdReisePassiv = BigDecimal.ZERO;
					if (hmPassiveReisezeiten.containsKey(i)) {
						ArrayList<AuftragzeitenDto[]> alDtos = hmPassiveReisezeiten.get(i);

						if (iJahr == 2019 && iMonat == 4 && i == 20) {
							int z = 0;
						}

						for (int x = 0; x < alDtos.size(); x++) {

							AuftragzeitenDto[] azDtos = alDtos.get(x);

							ArrayList<AuftragzeitenDto> auftragzeitenDtosZusaetzlich = new ArrayList<AuftragzeitenDto>();

							for (int y = 0; y < azDtos.length; y++) {

								// PJ21514
								if (hmPassiveReise.containsKey(tagesartIId)) {

									PassivereiseDto prDto = hmPassiveReise.get(tagesartIId);

									AuftragzeitenDto azDto = azDtos[y];

									java.sql.Timestamp tVonZeitbuchung = azDto.getTsBeginn();
									java.sql.Timestamp tBisZeitbuchung = azDto.getTsEnde();

									java.sql.Time tAbAusPassiverReise = prDto.getUAb();
									Calendar tZeit = Calendar.getInstance();
									tZeit.setTimeInMillis(Helper.cutTimestamp(tVonZeitbuchung).getTime());
									Calendar tTemp = Calendar.getInstance();
									tTemp.setTimeInMillis(tAbAusPassiverReise.getTime());
									tZeit.set(Calendar.HOUR_OF_DAY, tTemp.get(Calendar.HOUR_OF_DAY));
									tZeit.set(Calendar.MINUTE, tTemp.get(Calendar.MINUTE));
									tZeit.set(Calendar.SECOND, tTemp.get(Calendar.SECOND));
									tZeit.set(Calendar.MILLISECOND, tTemp.get(Calendar.MILLISECOND));
									java.sql.Timestamp tAbTimestampAusPassiverReise = new java.sql.Timestamp(
											tZeit.getTimeInMillis());

									if (Helper.short2boolean(prDto.getBRestdestages())) {

										if (tVonZeitbuchung.before(tAbTimestampAusPassiverReise)) {
											tVonZeitbuchung = tAbTimestampAusPassiverReise;

										}
										if (tBisZeitbuchung.before(tAbTimestampAusPassiverReise)) {
											tBisZeitbuchung = tAbTimestampAusPassiverReise;

										}

										azDto.setTsBeginn(tVonZeitbuchung);
										azDto.setTsEnde(tBisZeitbuchung);

										BigDecimal dauer = new BigDecimal(Helper.timeInMillis2Double(
												tBisZeitbuchung.getTime() - tVonZeitbuchung.getTime()));

										bdReisePassiv = bdReisePassiv.add(dauer);

									} else {
										java.sql.Time tBisAusPassiverReise = prDto.getUBis();
										tZeit.setTimeInMillis(Helper.cutTimestamp(tVonZeitbuchung).getTime());
										tTemp = Calendar.getInstance();
										tTemp.setTimeInMillis(tBisAusPassiverReise.getTime());
										tZeit.set(Calendar.HOUR_OF_DAY, tTemp.get(Calendar.HOUR_OF_DAY));
										tZeit.set(Calendar.MINUTE, tTemp.get(Calendar.MINUTE));
										tZeit.set(Calendar.SECOND, tTemp.get(Calendar.SECOND));
										tZeit.set(Calendar.MILLISECOND, tTemp.get(Calendar.MILLISECOND));
										java.sql.Timestamp tBisTimestampAusPassiverReise = new java.sql.Timestamp(
												tZeit.getTimeInMillis());

										if (tVonZeitbuchung.before(tBisTimestampAusPassiverReise)
												&& tBisZeitbuchung.after(tAbTimestampAusPassiverReise)) {
											// 2 Bloecke
											BigDecimal dauer = new BigDecimal(
													Helper.timeInMillis2Double(tBisTimestampAusPassiverReise.getTime()
															- tVonZeitbuchung.getTime()));

											azDto.setTsBeginn(tVonZeitbuchung);
											azDto.setTsEnde(tBisTimestampAusPassiverReise);

											bdReisePassiv = bdReisePassiv.add(dauer);

											dauer = new BigDecimal(Helper.timeInMillis2Double(tBisZeitbuchung.getTime()
													- tAbTimestampAusPassiverReise.getTime()));

											AuftragzeitenDto azDtoZweiteBuchung = AuftragzeitenDto.clone(azDto);
											azDtoZweiteBuchung.setTsBeginn(tAbTimestampAusPassiverReise);
											azDtoZweiteBuchung.setTsEnde(tBisZeitbuchung);

											auftragzeitenDtosZusaetzlich.add(azDtoZweiteBuchung);

											bdReisePassiv = bdReisePassiv.add(dauer);

										} else {

											if (tVonZeitbuchung.getTime() >= tBisTimestampAusPassiverReise.getTime()
													&& tBisZeitbuchung.getTime() <= tAbTimestampAusPassiverReise
															.getTime()) {
												// Wenn beide Zeiten ausserhalb der Grenzen, dann auslassen
												azDtos[y] = null;
											} else {

												if (tVonZeitbuchung.before(tBisTimestampAusPassiverReise)
														&& tBisZeitbuchung.after(tBisTimestampAusPassiverReise)) {
													tBisZeitbuchung = tBisTimestampAusPassiverReise;
												}

												if (tVonZeitbuchung.after(tBisTimestampAusPassiverReise)
														&& tVonZeitbuchung.before(tAbTimestampAusPassiverReise)) {
													tVonZeitbuchung = tAbTimestampAusPassiverReise;
												}

												if (tBisZeitbuchung.after(tAbTimestampAusPassiverReise)
														&& tBisZeitbuchung.before(tBisTimestampAusPassiverReise)) {
													tBisZeitbuchung = tBisTimestampAusPassiverReise;
												}

												BigDecimal dauer = new BigDecimal(Helper.timeInMillis2Double(
														tBisZeitbuchung.getTime() - tVonZeitbuchung.getTime()));

												if (dauer.doubleValue() > 0) {
													bdReisePassiv = bdReisePassiv.add(dauer);

													azDto.setTsBeginn(tVonZeitbuchung);
													azDto.setTsEnde(tBisZeitbuchung);

												} else {
													azDtos[y] = null;
												}
											}

										}

										if (tBisZeitbuchung.after(tBisTimestampAusPassiverReise)
												&& tBisZeitbuchung.after(tAbTimestampAusPassiverReise)) {
											tBisZeitbuchung = tBisTimestampAusPassiverReise;

										}

									}

								}
							}

							if (auftragzeitenDtosZusaetzlich != null && auftragzeitenDtosZusaetzlich.size() > 0) {
								AuftragzeitenDto[] azDtosTemp = new AuftragzeitenDto[azDtos.length
										+ auftragzeitenDtosZusaetzlich.size()];

								for (int m = 0; m < azDtos.length; m++) {
									azDtosTemp[m] = azDtos[m];
								}

								for (int m = 0; m < auftragzeitenDtosZusaetzlich.size(); m++) {
									azDtosTemp[azDtos.length + m] = auftragzeitenDtosZusaetzlich.get(m);
								}

								azDtos = azDtosTemp;
								alDtos.set(x, azDtos);
							}

						}
					}
					zeile.setBdReisePassiv(Helper.rundeKaufmaennisch(bdReisePassiv, 2));

				}

				ZeitmodelltagDto zeitmodelltagDto = getZeitmodelltagZuDatum(personalIId,
						new Timestamp(cal.getTime().getTime()), tagesartIId_Feiertag, tagesartIId_Halbtag, false,
						theClientDto);

				if (zeitmodelltagDto != null) {

					if (i == 14) {
						int z = 0;
					}

					// Rundung zugunsten des Unternehmens
					ArrayList<ZeitdatenDto> einBlock_ZurZeitweiligenVerwendung = (ArrayList<ZeitdatenDto>) bloecke
							.get(j);

					// PJ20936 Passive Reisezeiten einbauen

					if (hmPassiveReisezeiten.containsKey(i)) {
						einBlock_ZurZeitweiligenVerwendung = passiveReisezeitenDurchPauseErsetzen(
								einBlock_ZurZeitweiligenVerwendung, hmPassiveReisezeiten.get(i),
								taetigkeitDto_Unter.getIId());
					}

					einBlock_ZurZeitweiligenVerwendung = rundungZugunstenDesUnternehmens(
							einBlock_ZurZeitweiligenVerwendung, zeitmodelltagDto);

					// wg. SP8759
					// Wenn das KOMMT aufgrund der Rundung auf den naechsten Tag faellt, dann muss
					// der Block ausgelassen werden
					if (einBlock_ZurZeitweiligenVerwendung.size() > 0) {
						Calendar cTag = Calendar.getInstance();
						cTag.setTimeInMillis(einBlock_ZurZeitweiligenVerwendung.get(0).getTZeit().getTime());
						if (cTag.get(Calendar.DATE) == (i + 1)) {
							continue;
						}
					}

					// Fruehestes KOMMT und spaetestes GEHT verschieben, wenn
					// gesetzt
					if (bTagesUndwochenmaximumIgnorieren == false) {

						Double dMaximaleTagesanwesenheitszeitAufgrundWochenMaximum = null;
						if (nMaximalesWochenIST != null && nMaximalesWochenIST.doubleValue() > 0) {

							dMaximaleTagesanwesenheitszeitAufgrundWochenMaximum = nMaximalesWochenIST.doubleValue()
									- dWochensummeIstOhneSonderzeiten;
						}

						// SP8199
						zeitmodelltagDto = schichtErkennen(personalIId, theClientDto, taetigkeitIId_Kommt,
								taetigkeitIId_Geht, tagesartIId_Feiertag, tagesartIId_Halbtag, zeitmodelltagDto,
								einBlock_ZurZeitweiligenVerwendung);

						einBlock_ZurZeitweiligenVerwendung = fruehestesKommtUndSpaetestesGehtUndMaximaleTagesanwesenheitVerschieben(
								taetigkeitDto_Unter, taetigkeitDto_Arzt, taetigkeitDto_Behoerde,
								einBlock_ZurZeitweiligenVerwendung, zeitmodelltagDto,
								dMaximaleTagesanwesenheitszeitAufgrundWochenMaximum);
					}

					bloecke.set(j, einBlock_ZurZeitweiligenVerwendung);
				}

				if (zeile.getTDatum().compareTo(dEintrittsdatum) >= 0 && zeile.getTDatum().before(dAustrittsdatum)) {
					int iMinutenabzug = 0;
					ArrayList<?> einBlock = (ArrayList<?>) bloecke.get(j);
					ZeitdatenDto[] zeitdatenEinesTagesDtos = new ZeitdatenDto[einBlock.size()];
					zeitdatenEinesTagesDtos = (ZeitdatenDto[]) einBlock.toArray(zeitdatenEinesTagesDtos);

					if (zeitdatenEinesTagesDtos == null) {
						zeitdatenEinesTagesDtos = new ZeitdatenDto[0];
					}

					String sBemerkung = "";
					double dIst = 0;

					try {
						// Vergleichen, ob Zeitmodell gewechselt wurde
						PersonalzeitmodellDto personalzeitmodellDto = getPersonalFac()
								.personalzeitmodellFindZeitmodellZuDatum(personalIId,
										new Timestamp(cal.getTime().getTime()), theClientDto);
						if (personalzeitmodellDto != null) {
							// Wenn Zeitmodellwechsel, dann auf Ausdruck
							// anzeigen

							ZeitmodellDto zmDto = zeitmodellFindByPrimaryKey(personalzeitmodellDto.getZeitmodellIId(),
									theClientDto);

							bFeiertagAmNaechstenTag = Helper.short2boolean(zmDto.getBFeiertagAmNaechstenTag());

							nMaximalesWochenIST = zmDto.getNMaximalesWochenist();

							schichtIId = zmDto.getSchichtIId();

							iMinutenabzug = zmDto.getIMinutenabzug();

							zeile.setSZeitmodell(zmDto.getBezeichnung());
							zeile.setZeitmodellIId(zmDto.getIId());
							iZeitmodellId = personalzeitmodellDto.getZeitmodellIId();
							if (iZeitmodellId != null) {
								if (cal.get(cal.DATE) > 1) {
									if (!iZeitmodellId.equals(iZeitmodellIdVortag)) {
										sBemerkung = sBemerkung
												+ getTextRespectUISpr("pers.monatsabrechnung.zeitmodellwechsel",
														theClientDto.getMandant(), theClientDto.getLocUi())
												+ " " + personalzeitmodellDto.getZeitmodellDto().getCNr() + ",";
									}
								}
							}
							iZeitmodellIdVortag = personalzeitmodellDto.getZeitmodellIId();
						} else {
							iMinutenabzug = 0;
						}
					} catch (RemoteException ex1) {
						// nothing here
					}

					if (zeitdatenEinesTagesDtos.length > 0) {

						// SP1451
						if (iMinutenabzug > 0) {
							// Bei Kommt und Geht den Minutanbzug jeweils
							// zur
							// Haelfte durchfuhren
							if (bloecke.size() == 1) {

								zeitdatenEinesTagesDtos[0]
										.setTZeit(new Timestamp(zeitdatenEinesTagesDtos[0].getTZeit().getTime()
												+ ((iMinutenabzug / 2) * 1000 * 60)));
								zeitdatenEinesTagesDtos[zeitdatenEinesTagesDtos.length - 1].setTZeit(new Timestamp(
										zeitdatenEinesTagesDtos[zeitdatenEinesTagesDtos.length - 1].getTZeit().getTime()
												- ((iMinutenabzug / 2) * 1000 * 60)));
							} else if (bloecke.size() > 1) {

								if (j == 0) {
									zeitdatenEinesTagesDtos[0]
											.setTZeit(new Timestamp(zeitdatenEinesTagesDtos[0].getTZeit().getTime()
													+ ((iMinutenabzug / 2) * 1000 * 60)));
								}
								if (j == bloecke.size() - 1) {
									zeitdatenEinesTagesDtos[zeitdatenEinesTagesDtos.length - 1].setTZeit(
											new Timestamp(zeitdatenEinesTagesDtos[zeitdatenEinesTagesDtos.length - 1]
													.getTZeit().getTime() - ((iMinutenabzug / 2) * 1000 * 60)));
								}

							}

						}
						if (!zeitdatenEinesTagesDtos[0].getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {
							sBemerkung = getTextRespectUISpr("pers.zeiterfassung.kommmtmussderersteeintragsein",
									theClientDto.getMandant(), theClientDto.getLocUi()) + sBemerkung;
						}

						if (!zeitdatenEinesTagesDtos[zeitdatenEinesTagesDtos.length - 1].getTaetigkeitIId()
								.equals(taetigkeitIId_Geht)) {
							sBemerkung = getTextRespectUISpr("pers.zeiterfassung.gehtmussderletzteeintragsein",
									theClientDto.getMandant(), theClientDto.getLocUi()) + sBemerkung;
						}

						// Ersten und letzten Eintrag des Tages setzen
						java.sql.Time t1 = new java.sql.Time(zeitdatenEinesTagesDtos[0].getTZeit().getTime());
						java.sql.Time t2 = new java.sql.Time(
								zeitdatenEinesTagesDtos[zeitdatenEinesTagesDtos.length - 1].getTZeit().getTime());

						long l1 = zeitdatenEinesTagesDtos[0].getTZeit().getTime();
						long l2 = zeitdatenEinesTagesDtos[zeitdatenEinesTagesDtos.length - 1].getTZeit().getTime();

						long lDiff = (l2 - l1);
						dIst = Helper.timeInMillis2Double(lDiff);

						zeile.setTVon(t1);
						zeile.setTBis(t2);
					}

					// PJ19029

					if (zeitdatenEinesTagesDtos.length > 0) {

						if (schichtIId != null) {

							// PJ21404
							BigDecimal bdDauerFuerExport = BigDecimal.ZERO;

							TreeMap<String, Object[]> tmDatenSubreport = new TreeMap<String, Object[]>();

							SchichtzeitDto[] szDtos = getSchichtFac().schichtzeitFindBySchichtIId(schichtIId);

							SchichtDto schichtDto = getSchichtFac().schichtFindByPrimaryKey(schichtIId);

							String[] fieldNames = new String[] { "Schicht", "Zuschlag", "Dauer" };

							HashMap<Integer, BigDecimal> hmSchichtzeiten = new HashMap<Integer, BigDecimal>();

							for (int k = 0; k < szDtos.length; k++) {
								SchichtzeitDto szDto = szDtos[k];

								SchichtzuschlagDto schichtzuschlagDto = getSchichtFac()
										.schichtzuschlagFindByPrimaryKey(szDto.getSchichtzuschlagIId());
								Object[] oZeile = new Object[3];

								oZeile[0] = schichtDto.getCBez();

								oZeile[1] = schichtzuschlagDto.getCBez();

								java.sql.Timestamp tKommt = zeitdatenEinesTagesDtos[0].getTZeit();
								java.sql.Timestamp tGeht = zeitdatenEinesTagesDtos[zeitdatenEinesTagesDtos.length - 1]
										.getTZeit();

								java.sql.Timestamp tBeginn = new java.sql.Timestamp(
										Helper.cutTimestamp(tKommt).getTime()
												+ (szDto.getuBeginn().getTime() + 3600000));

								java.sql.Timestamp tEnde = null;

								if (i == 27 || i == 28) {
									int z = 0;
								}

								if (szDto.getuEnde() != null) {
									tEnde = new java.sql.Timestamp(Helper.cutTimestamp(tKommt).getTime()
											+ (szDto.getuEnde().getTime() + 3600000));
								} else {
									Calendar cTemp = Calendar.getInstance();
									cTemp.setTime(tKommt);
									cTemp.add(Calendar.DAY_OF_MONTH, 1);

									tEnde = Helper.cutTimestamp(new Timestamp(cTemp.getTimeInMillis()));
								}
								Double dDauer = 0D;
								if ((tKommt.before(tBeginn) && tGeht.before(tBeginn))
										|| (tKommt.after(tEnde) && tGeht.after(tEnde))) {
									// Faellt nicht in Schicht
								} else {
									java.sql.Timestamp tBerechnungsbeginn = tBeginn;

									if (tKommt.after(tBeginn)) {
										tBerechnungsbeginn = tKommt;
									}

									java.sql.Timestamp tBerechnungsEnde = tEnde;

									if (tGeht.before(tEnde)) {
										tBerechnungsEnde = tGeht;
									}

									long l = tBerechnungsEnde.getTime() - tBerechnungsbeginn.getTime();

									if (l > 0) {

										dDauer = new Double((double) l / 3600000);

										// SP3923

										if (Helper.short2boolean(schichtDto.getBPausenabziehen())) {

											ZeitdatenDto[] zeitdatenFuerSchichtzeiten = ZeitdatenDto
													.kopiereArrayUndVerschiebeAnfangsZeitNachSpaeter(
															zeitdatenEinesTagesDtos, tBerechnungsbeginn.getTime());

											zeitdatenFuerSchichtzeiten = ZeitdatenDto
													.kopiereArrayUndVerschiebeEndZeitNachFrueher(
															zeitdatenFuerSchichtzeiten, tBerechnungsEnde.getTime());

											try {
												double pausendauerInSchichtZeit = berechnePaarweiserSondertaetigkeiten(
														zeitdatenFuerSchichtzeiten, taetigkeitDto_Unter.getIId());
												dDauer = dDauer - pausendauerInSchichtZeit;
											} catch (Exception e) {
												//
											}

											// PJ22550
											if (tSollzeit != null
													&& Helper.short2boolean(schichtDto.getBBegrenztAufTagessoll())) {
												double dSoll = Helper.time2Double(tSollzeit);

												if (dDauer > dSoll) {
													dDauer = dSoll;
												}

											}

											if (i == 13 || i == 28) {
												int z = 0;
											}

										}

									}

								}

								hmSchichtzeiten.put(szDto.getIId(), new BigDecimal(dDauer));

								String key = schichtzuschlagDto.getCBez();
								if (tmDatenSubreport.containsKey(key)) {
									Object[] oZeileVorhanden = (Object[]) tmDatenSubreport.get(key);
									Double dauerVorhanden = (Double) oZeileVorhanden[2];

									oZeileVorhanden[2] = dauerVorhanden + dDauer;
									tmDatenSubreport.put(key, oZeileVorhanden);

								} else {

									oZeile[2] = dDauer;

									tmDatenSubreport.put(key, oZeile);
								}

								if (tmDatenSubreportSchichtzulagen.containsKey(key)) {

									Object[] oZeileVorhanden = (Object[]) tmDatenSubreportSchichtzulagen.get(key);
									Double dauerVorhanden = (Double) oZeileVorhanden[2];
									oZeileVorhanden[2] = dauerVorhanden + dDauer;
									oZeileVorhanden[0] = null;
									tmDatenSubreportSchichtzulagen.put(key, oZeileVorhanden);

								} else {

									Object[] oZeileFuerMonatssicht = oZeile.clone();
									oZeileFuerMonatssicht[0] = null;
									tmDatenSubreportSchichtzulagen.put(key, oZeileFuerMonatssicht);
								}

							}
							ArrayList alDatenSubreport = new ArrayList();

							Iterator it = tmDatenSubreport.keySet().iterator();
							while (it.hasNext()) {

								alDatenSubreport.add(tmDatenSubreport.get(it.next()));

							}

							Object[][] dataSub = new Object[alDatenSubreport.size()][fieldNames.length];
							dataSub = (Object[][]) alDatenSubreport.toArray(dataSub);

							zeile.setSubreportSchichtzeiten(new LPDatenSubreport(dataSub, fieldNames));
							zeile.setHMSchichtzeitenFuerExport(hmSchichtzeiten);

						}
					}

					// Ueber jede Zeitbuchung iterieren
					double dSummeTagUNTER = 0;
					double dSummeTagARZT = 0;
					double dSummeTagBEHOERDE = 0;
					double dSummeTagZEITAUSGLEICH = 0;
					double dSummeTagKRANK = 0;
					double dSummeTagKINDKRANK = 0;
					double dSummeTagURLAUB_STUNDEN = 0;
					double dSummeTagSONSTIGE_BEZAHLT = 0;
					double dSummeTagSONSTIGE_BEZAHLT_OHNE_FAKTOR = 0;
					double dSummeTagSONSTIGE_NICHTBEZAHLT = 0;
					double dSummeTagKOMMTGEHT = 0;

					HashMap<Integer, BigDecimal> hmSonstigeTaetigkeiten = new HashMap<Integer, BigDecimal>();

					String sZusatzbezeichnung = "";
					ZeitdatenDto zeitdatenDto_Vorher = null;

					if (bVonBisZeiterfassungOhneKommtGeht == false) {

						for (int m = 0; m < zeitdatenEinesTagesDtos.length; m++) {

							ZeitdatenDto zeitdatenDto_Aktuell = zeitdatenEinesTagesDtos[m];

							// Milliskunden auf 0 setzen
							Timestamp tsTemp = zeitdatenDto_Aktuell.getTZeit();
							Calendar c2 = Calendar.getInstance();
							c2.setTimeInMillis(tsTemp.getTime());
							c2.set(Calendar.MILLISECOND, 0);
							tsTemp = new Timestamp(c2.getTimeInMillis());
							zeitdatenDto_Aktuell.setTZeit(tsTemp);
							// Bei jeder Geraden Zahl mit dem Vorgaenger
							// vergleichen
							if (m % 2 == 0 && m != 0) {
								if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitIId_Kommt)
										&& zeitdatenDto_Vorher.getTaetigkeitIId().equals(taetigkeitIId_Geht)) {
									// Wenn KOMMT - GEHT, dann nicht dazuzaehlen

									Double dBeginn = Helper
											.time2Double(new Time(zeitdatenDto_Vorher.getTZeit().getTime()));
									Double dEnde = Helper
											.time2Double(new Time(zeitdatenDto_Aktuell.getTZeit().getTime()));
									double dSumme = dEnde.doubleValue() - dBeginn.doubleValue();
									dSummeTagKOMMTGEHT = dSummeTagKOMMTGEHT + dSumme;
								} else if (zeitdatenDto_Aktuell.getTaetigkeitIId()
										.equals(zeitdatenDto_Vorher.getTaetigkeitIId())) {

									Double dBeginn = Helper
											.time2Double(new Time(zeitdatenDto_Vorher.getTZeit().getTime()));
									Double dEnde = Helper
											.time2Double(new Time(zeitdatenDto_Aktuell.getTZeit().getTime()));

									if (dBeginn != null && dEnde != null) {
										double dSumme = dEnde.doubleValue() - dBeginn.doubleValue();

										// Wenn Taetigkeit UNTER dann bei UNTER
										// hinzufuegen
										if (zeitdatenDto_Aktuell.getTaetigkeitIId()
												.equals(taetigkeitDto_Unter.getIId())) {
											dSummeTagUNTER = dSummeTagUNTER + dSumme;
										}
										// Wenn Taetigkeit BEHOERDE dann bei
										// BEHOERDE hinzufuegen
										else if (zeitdatenDto_Aktuell.getTaetigkeitIId()
												.equals(taetigkeitDto_Behoerde.getIId())) {
											dSummeTagBEHOERDE = dSummeTagBEHOERDE + dSumme;
										}
										// Wenn Taetigkeit URLAUB dann bei
										// URLAUB
										// hinzufuegen
										else if (zeitdatenDto_Aktuell.getTaetigkeitIId()
												.equals(taetigkeitDto_Urlaub.getIId())) {
											dSummeTagURLAUB_STUNDEN = dSummeTagURLAUB_STUNDEN + dSumme;
										}
										// Wenn Taetigkeit ARZT dann bei ARZT
										// hinzufuegen
										else if (zeitdatenDto_Aktuell.getTaetigkeitIId()
												.equals(taetigkeitDto_Arzt.getIId())) {
											dSummeTagARZT = dSummeTagARZT + dSumme;
										}
										// Wenn Taetigkeit ZA dann bei ZA
										// hinzufuegen
										else if (zeitdatenDto_Aktuell.getTaetigkeitIId()
												.equals(taetigkeitDto_ZA.getIId())) {
											dSummeTagZEITAUSGLEICH = dSummeTagZEITAUSGLEICH + dSumme;
										}
										// Wenn Taetigkeit KRANK dann bei KRANK
										// hinzufuegen
										else if (zeitdatenDto_Aktuell.getTaetigkeitIId()
												.equals(taetigkeitDto_Krank.getIId())) {
											dSummeTagKRANK = dSummeTagKRANK + dSumme;
										}
										// Wenn Taetigkeit KINDKRANK dann bei
										// KINDKRANK
										// hinzufuegen
										else if (zeitdatenDto_Aktuell.getTaetigkeitIId()
												.equals(taetigkeitDto_Kindkrank.getIId())) {
											dSummeTagKINDKRANK = dSummeTagKINDKRANK + dSumme;
										}
										// Wenn KOMMT, dann Mehrfaches KOMMT
										else if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitIId_Kommt)) {
											sBemerkung = "Mehrfaches KOMMT" + sBemerkung;
										}
										// Wenn GEHT, dann Mehrfaches GEHT
										else if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitIId_Geht)) {
											sBemerkung = "Mehrfaches GEHT" + sBemerkung;
										}

										// Ansonsten muss Taetigkeit bei
										// sonstigen
										// bezahlten oder nicht bezahlten
										// Taetigkeiten dabei sein
										else {
											dSumme = Helper.rundeKaufmaennisch(new BigDecimal(dSumme), 2).doubleValue();
											// Bezahlte Taetigkeiten
											for (int k = 0; k < sonstigeTaetigkeiten.length; k++) {
												if (zeitdatenDto_Aktuell.getTaetigkeitIId()
														.equals(sonstigeTaetigkeiten[k].getIId())) {

													if (sonstigeTaetigkeiten[k].getFBezahlt() > 0) {

														dSummeTagSONSTIGE_BEZAHLT_OHNE_FAKTOR += dSumme;
														dSumme = Helper
																.rundeKaufmaennisch(new BigDecimal(dSumme)
																		.multiply(new BigDecimal(sonstigeTaetigkeiten[k]
																				.getFBezahlt().doubleValue() / 100)),
																		2)
																.doubleValue();

														dSummeTagSONSTIGE_BEZAHLT = dSummeTagSONSTIGE_BEZAHLT + dSumme;
													} else {
														dSummeTagSONSTIGE_NICHTBEZAHLT = dSummeTagSONSTIGE_NICHTBEZAHLT
																+ dSumme;
													}

													sZusatzbezeichnung = sZusatzbezeichnung
															+ sonstigeTaetigkeiten[k].getCNr() + " " + dSumme + ",";

													if (hmSonstigeTaetigkeiten
															.containsKey(zeitdatenDto_Aktuell.getTaetigkeitIId())) {
														BigDecimal bdSumme = hmSonstigeTaetigkeiten
																.get(zeitdatenDto_Aktuell.getTaetigkeitIId());
														bdSumme = bdSumme.add(new BigDecimal(dSumme));
														hmSonstigeTaetigkeiten
																.put(zeitdatenDto_Aktuell.getTaetigkeitIId(), bdSumme);

													} else {
														hmSonstigeTaetigkeiten.put(
																zeitdatenDto_Aktuell.getTaetigkeitIId(),
																new BigDecimal(dSumme));
													}

												}
											}

										}
									}
								} else {
									sBemerkung = "Fehler in Buchungen" + sBemerkung;
								}
							}

							zeitdatenDto_Vorher = zeitdatenDto_Aktuell;
						}

					} else {
						// PJ18440

						VonBisErfassungTagesdatenDto vbDto = berechneTagesArbeitszeitVonBisZeiterfassungOhneKommtGeht(
								personalIId, new java.sql.Date(cal.getTime().getTime()), theClientDto);

						dSummeTagUNTER = vbDto.getdUnter();
						dSummeTagARZT = vbDto.getdArzt();
						dSummeTagBEHOERDE = vbDto.getdBehoerde();
						dSummeTagZEITAUSGLEICH = vbDto.getdZeitausgleich();
						dSummeTagKRANK = vbDto.getdKrank();
						dSummeTagKINDKRANK = vbDto.getdKindkrank();
						dSummeTagURLAUB_STUNDEN = vbDto.getdUrlaub();

						dSummeTagSONSTIGE_BEZAHLT = vbDto.getdSontigeBezahlt();
						dSummeTagSONSTIGE_NICHTBEZAHLT = vbDto.getdSonstigeNichtBezahlt();

						sZusatzbezeichnung = vbDto.getSZusatzbezeichnung();

						dIst = vbDto.getdIst() + dSummeTagUNTER + dSummeTagARZT + dSummeTagBEHOERDE
								+ dSummeTagZEITAUSGLEICH + dSummeTagKRANK + dSummeTagKINDKRANK + dSummeTagURLAUB_STUNDEN
								+ dSummeTagSONSTIGE_BEZAHLT;
					}

					// Zulagen in Bemerkung schreiben

					if (hmBelegeMitZulagen.containsKey(i)) {
						HashMap<Integer, Double> hmBelege = hmBelegeMitZulagen.get(i);
						Iterator belege = hmBelege.keySet().iterator();

						ArrayList al = new ArrayList();

						// Zulagen in Bemerkung schreiben
						while (belege.hasNext()) {
							Integer artikelIId = (Integer) belege.next();
							Double dDauer = hmBelege.get(artikelIId);

							String zulagenBezeichnung = null;

							for (int k = 0; k < zulagenDtos.length; k++) {
								ArtikelzulageDto dto = zulagenDtos[k];
								if (zeile.getTDatum().getTime() >= dto.getTGueltigab().getTime()
										&& artikelIId.equals(dto.getArtikelIId())) {

									zulagenBezeichnung = dto.getZulageDto().getCBez();
								}
							}

							if (zulagenBezeichnung != null) {
								Object[] oZeile = new Object[2];
								oZeile[0] = zulagenBezeichnung;
								oZeile[1] = dDauer;
								al.add(oZeile);
							}

						}

						String[] fieldnames = new String[] { "F_ZULAGE", "F_DAUER" };

						Object[][] dataSub = new Object[al.size()][fieldnames.length];
						dataSub = (Object[][]) al.toArray(dataSub);

						zeile.setSubreportZulagen(new LPDatenSubreport(dataSub, fieldnames));
					}

					dIst = dIst - dSummeTagUNTER - dSummeTagARZT - dSummeTagKRANK - dSummeTagKINDKRANK
							- dSummeTagZEITAUSGLEICH - dSummeTagBEHOERDE - dSummeTagURLAUB_STUNDEN
							- dSummeTagSONSTIGE_BEZAHLT_OHNE_FAKTOR - dSummeTagSONSTIGE_NICHTBEZAHLT
							- dSummeTagKOMMTGEHT;

					// PJ 16676
					if (zeitmodelltagDto != null && zeitmodelltagDto.getUErlaubteanwesenheitszeit() != null
							&& zeitmodelltagDto.getUErlaubteanwesenheitszeit().getTime() != -3600000) {
						if (bTagesUndwochenmaximumIgnorieren == false) {
							double dMaxAnwesenheit = Helper
									.time2Double(zeitmodelltagDto.getUErlaubteanwesenheitszeit());
							if (dIst > dMaxAnwesenheit) {
								dIst = dMaxAnwesenheit;
							}
						}
					}

					zeile.setBdIst(Helper.rundeKaufmaennisch(new BigDecimal(dIst), 2));

					zeile.setBdUnter(Helper.rundeKaufmaennisch(new BigDecimal(dSummeTagUNTER), 2));
					zeile.setBdArzt(Helper.rundeKaufmaennisch(new BigDecimal(dSummeTagARZT), 2));
					zeile.setBdBehoerde(Helper.rundeKaufmaennisch(new BigDecimal(dSummeTagBEHOERDE), 2));
					zeile.setBdUrlaubStunden(Helper.rundeKaufmaennisch(new BigDecimal(dSummeTagURLAUB_STUNDEN), 2));
					zeile.setBdUrlaubTage(new BigDecimal(0));
					zeile.setBdZA(Helper.rundeKaufmaennisch(new BigDecimal(dSummeTagZEITAUSGLEICH), 2));
					zeile.setBdKrank(Helper.rundeKaufmaennisch(new BigDecimal(dSummeTagKRANK), 2));
					zeile.setBdKindkrank(Helper.rundeKaufmaennisch(new BigDecimal(dSummeTagKINDKRANK), 2));
					zeile.setBdSonstigeBezahlt(Helper.rundeKaufmaennisch(new BigDecimal(dSummeTagSONSTIGE_BEZAHLT), 2));
					zeile.setBdSonstigeNichtBezahlt(
							Helper.rundeKaufmaennisch(new BigDecimal(dSummeTagSONSTIGE_NICHTBEZAHLT), 2));

					zeile.setHmSonstigeTaetigkeiten(hmSonstigeTaetigkeiten);

					// Nur beim ersten Block rechnen

					// Berechnen der Summen: Arzt, Unterbrechung und
					// Behoerde

					double d_zeitdec = 0;

					// Alle Tageswiesen Spalten nur einmal zaehlen
					if (j == 0) {

						zeile.setBdReise(monatsDatenReisezeiten[i]);

						if (tSollzeit != null) {
							zeile.setBdSoll(new BigDecimal(Helper.time2Double(tSollzeit).doubleValue())); // Sollzeit
																											// zu
							// dem Datum
							d_zeitdec = Helper.time2Double(tSollzeit).doubleValue();
							dSollzeitGesamt = d_zeitdec;
						} else {
							zeile.setBdSoll(new BigDecimal(0));
						}
						// --------- FEIERTAGBERECHNUNG
						// Feiertagsstunden berechnen

						zeile = feiertagBerechnen(personalIId, theClientDto, personalDto, tagesartIId_Halbtag,
								Helper.cutTimestamp(new Timestamp(cal.getTime().getTime())), iZeitmodellId, zeile,
								bFeiertagAmNaechstenTag);

						dSummeMonatFeiertagSoll += zeile.getBdFeiertag().doubleValue();

						// ---------ENDE FEIERTAGBERECHNUNG

						// NEUE BERECHNUNG TAGEWEISE TAETIGKEITEN
						SonderzeitenDto[] sonderzeitenDtos = sonderzeitenFindByPersonalIIdDDatum(personalIId,
								Helper.cutTimestamp(new Timestamp(cal.getTime().getTime())));

						BigDecimal bdZeitDecimal = null;

						for (int m = 0; m < sonderzeitenDtos.length; m++) {
							SonderzeitenDto sonderzeitenDto = sonderzeitenDtos[m];

							if (Helper.short2boolean(sonderzeitenDto.getBTag())
									|| Helper.short2boolean(sonderzeitenDto.getBHalbtag())) {
								bdZeitDecimal = Helper.rundeKaufmaennisch(new BigDecimal(d_zeitdec), 4);
							} else {
								bdZeitDecimal = Helper.rundeKaufmaennisch(
										new BigDecimal(Helper.time2Double(sonderzeitenDto.getUStunden()).doubleValue()),
										4);
							}

							// PJ 15914

							TaetigkeitDto taetigkeitDto = taetigkeitFindByPrimaryKey(sonderzeitenDto.getTaetigkeitIId(),
									theClientDto);
							if (taetigkeitDto.getFBezahlt() > 0) {
								bdZeitDecimal = Helper.rundeKaufmaennisch(bdZeitDecimal
										.multiply(new BigDecimal(taetigkeitDto.getFBezahlt().doubleValue() / 100)), 4);
							}

							// SP9148
							bdZeitDecimal = Helper.rundeKaufmaennisch(bdZeitDecimal, 2);

							// Wenn Taetigkeit URLAUB dann bei URLAUB
							// hinzufuegen
							if (sonderzeitenDto.getTaetigkeitIId().equals(taetigkeitDto_Urlaub.getIId())) {

								zeile.setbUrlaubAutomatik(Helper.short2Boolean(sonderzeitenDto.getBAutomatik()));

								sBemerkung += taetigkeitDto_Urlaub.getBezeichnung();
								if (Helper.short2boolean(sonderzeitenDto.getBTag())) {
									zeile.setBdUrlaubTage(zeile.getBdUrlaubTage().add(new BigDecimal(1)));
									zeile.setBdUrlaubStunden(zeile.getBdUrlaubStunden().add(bdZeitDecimal));
									// 11339: Wenn ein Halber Feiertag ist,
									// dann
									// wird bei den Urlaubsstunden die
									// Sollzeit
									// des
									// Originaltags gutgeschrieben
									if (zeile.isHalberFeiertag()) {
										ZeitmodelltagDto zeitmodelltagDtoOriginaltag = getZeitmodelltagZuDatum(
												personalIId, new Timestamp(cal.getTime().getTime()),
												tagesartIId_Feiertag, tagesartIId_Halbtag, true, theClientDto);

										if (zeitmodelltagDtoOriginaltag != null
												&& zeitmodelltagDtoOriginaltag.getUSollzeit() != null) {

											BigDecimal dbHalbtagsUrlaub = new BigDecimal(
													Helper.time2Double(zeitmodelltagDtoOriginaltag.getUSollzeit())
															.doubleValue());
											dbHalbtagsUrlaub = Helper.rundeKaufmaennisch(dbHalbtagsUrlaub, 2);
											zeile.setBdUrlaubStunden(dbHalbtagsUrlaub);

										}
									}

								} else if (Helper.short2boolean(sonderzeitenDto.getBHalbtag())) {
									zeile.setBdUrlaubTage(zeile.getBdUrlaubTage().add(new BigDecimal(0.5)));
									zeile.setBdUrlaubStunden(zeile.getBdUrlaubStunden()
											.add(bdZeitDecimal.divide(new BigDecimal(2), BigDecimal.ROUND_HALF_EVEN)));

									// 11339: Wenn ein Halber Feiertag ist,
									// dann
									// wird bei den Urlaubsstunden die
									// Haelfte
									// der Sollzeit des
									// Originaltags gutgeschrieben
									if (zeile.isHalberFeiertag()) {
										ZeitmodelltagDto zeitmodelltagDtoOriginaltag = getZeitmodelltagZuDatum(
												personalIId, new Timestamp(cal.getTime().getTime()),
												tagesartIId_Feiertag, tagesartIId_Halbtag, true, theClientDto);

										if (zeitmodelltagDtoOriginaltag != null
												&& zeitmodelltagDtoOriginaltag.getUSollzeit() != null) {

											BigDecimal dbHalbtagsUrlaub = new BigDecimal(
													Helper.time2Double(zeitmodelltagDtoOriginaltag.getUSollzeit())
															.doubleValue() / 2);

											dbHalbtagsUrlaub = Helper.rundeKaufmaennisch(dbHalbtagsUrlaub, 2);
											zeile.setBdUrlaubStunden(dbHalbtagsUrlaub);

										}
									}
								} else {
									zeile.setBdUrlaubStunden(zeile.getBdUrlaubStunden().add(bdZeitDecimal));
								}
							}
							// Wenn Taetigkeit KRANK dann bei KRANK
							// hinzufuegen
							else if (sonderzeitenDto.getTaetigkeitIId().equals(taetigkeitDto_Krank.getIId())) {
								zeile.setBdKrank(zeile.getBdKrank().add(bdZeitDecimal));
								sBemerkung += taetigkeitDto_Krank.getBezeichnung();

							}
							// Wenn Taetigkeit KINDKRANK dann bei KINDKRANK
							// hinzufuegen
							else if (sonderzeitenDto.getTaetigkeitIId().equals(taetigkeitDto_Kindkrank.getIId())) {
								zeile.setBdKindkrank(zeile.getBdKindkrank().add(bdZeitDecimal));
								sBemerkung += taetigkeitDto_Kindkrank.getBezeichnung();

							}
							// Wenn Taetigkeit ZA dann bei ZA hinzufuegen
							else if (sonderzeitenDto.getTaetigkeitIId().equals(taetigkeitDto_ZA.getIId())) {
								zeile.setBdZA(zeile.getBdZA().add(bdZeitDecimal));
								sBemerkung += taetigkeitDto_ZA.getBezeichnung();

							}
							// Wenn Taetigkeit BEHOERDE dann bei BEHOERDE
							// hinzufuegen
							else if (sonderzeitenDto.getTaetigkeitIId().equals(taetigkeitDto_Behoerde.getIId())) {
								zeile.setBdBehoerde(zeile.getBdBehoerde().add(bdZeitDecimal));
								sBemerkung += taetigkeitDto_Behoerde.getBezeichnung();

							}
							// Wenn Taetigkeit ARZT dann bei ARZT
							// hinzufuegen
							else if (sonderzeitenDto.getTaetigkeitIId().equals(taetigkeitDto_Arzt.getIId())) {
								zeile.setBdArzt(zeile.getBdArzt().add(bdZeitDecimal));
								sBemerkung += taetigkeitDto_Arzt.getBezeichnung();

							} else {

								// Sonstige Taetigkeiten
								for (int k = 0; k < sonstigeTaetigkeiten.length; k++) {
									if (sonderzeitenDto.getTaetigkeitIId().equals(sonstigeTaetigkeiten[k].getIId())) {

										if (taetigkeitDto.getFBezahlt() > 0) {
											zeile.setBdSonstigeBezahlt(zeile.getBdSonstigeBezahlt().add(bdZeitDecimal));
										} else {
											zeile.setBdSonstigeNichtBezahlt(
													zeile.getBdSonstigeNichtBezahlt().add(bdZeitDecimal));
										}

										if (hmSonstigeTaetigkeiten.containsKey(sonstigeTaetigkeiten[k].getIId())) {
											BigDecimal bdSumme = hmSonstigeTaetigkeiten
													.get(sonstigeTaetigkeiten[k].getIId());
											bdSumme = bdSumme.add(bdZeitDecimal);
											hmSonstigeTaetigkeiten.put(sonstigeTaetigkeiten[k].getIId(), bdSumme);

										} else {
											hmSonstigeTaetigkeiten.put(sonstigeTaetigkeiten[k].getIId(), bdZeitDecimal);
										}

										sZusatzbezeichnung = sZusatzbezeichnung
												+ sonstigeTaetigkeiten[k].getBezeichnung() + " "
												+ bdZeitDecimal.doubleValue() + ",";
									}
								}

							}
						}

						// NEUE BERECHNUNG TAGEWEISE TAETIGKEITEN ENDE
					}

					zeile.setSZusatzbezeichnung(sZusatzbezeichnung);

					BigDecimal dIstZeit = new BigDecimal(dIst);
					dIstZeit = Helper.rundeKaufmaennisch(dIstZeit, 2);

					// Sollzeit aufteilen auf die einzelnen Tage;

					if (j + 1 != bloecke.size()) {
						if (dIst < dSollzeitGesamt) {
							// auf 2 stellen runden
							// myDouble = Math.round( myDouble * 100. ) /
							// 100.;

							zeile.setBdSoll(Helper.rundeKaufmaennisch(new BigDecimal(dIst), 2));
							dSollzeitGesamt = dSollzeitGesamt - dIst;
						} else {
							zeile.setBdSoll(new BigDecimal(dSollzeitGesamt));
							dSollzeitGesamt = 0;
						}

					} else {
						// Restliche Sollzeit am letzten Tag eintragen
						zeile.setBdSoll(new BigDecimal(dSollzeitGesamt));
						dSollzeitGesamt = 0;
					}

					if (dIstZeit != null) {
						zeile.setBdIst(dIstZeit);
						double differenz = 0;
						if (dIstZeit.doubleValue() != 0) {

							differenz = dIstZeit.doubleValue() - zeile.getBdSoll().doubleValue();
							zeile.setBdDiff(new BigDecimal(differenz)); // Differenz
							// Soll
							// -Ist
						}
						if (dIstZeit.doubleValue() != 0 && zeile.getBdSoll() == null) {
							differenz = dIstZeit.doubleValue() - d_zeitdec;
							zeile.setBdDiff(new BigDecimal(differenz)); // Differenz
							// Soll
							// -Ist
						}
						if (zeile.getBdSoll() != null && dIstZeit.doubleValue() == 0) {
							differenz = dIstZeit.doubleValue() - zeile.getBdSoll().doubleValue();
							zeile.setBdDiff(new BigDecimal(differenz)); // Differenz
							// Soll
							// -Ist
						}

						if (zeile.getBdDiff() == null) {
							zeile.setBdDiff(new BigDecimal(0));
						}
					}

					if (zeile.getSBemerkung() != null) {
						zeile.setSBemerkung(zeile.getSBemerkung() + " " + sBemerkung);
					} else {
						zeile.setSBemerkung(sBemerkung);
					}

					if (tagesartIId != null) {
						zeile.setSTagesart(tagesartFindByPrimaryKey(tagesartIId, theClientDto).getCNr());
					}

					if (kollektivAbrechnungsart != null && kollektivAbrechnungsart
							.equals(PersonalFac.KOLLEKTIV_ABRECHNUNGSART_BETRIEBSVEREINBARUNG_A)) {
						// PJ20486

						if (tagesartIId != null && hmKollektivUestdBVA.containsKey(tagesartIId)) {

							KollektivUestdBVADto kollektivUestdBVADto = hmKollektivUestdBVA.get(tagesartIId);

							// Erster Block mit 100%
							Time tVon = new Time(0, 0, 0);
							Time tBis = kollektivUestdBVADto.getU100Ende();

							BigDecimal bd100Prozent1 = getIstZeitZwischenVonBis(zeitdatenEinesTagesDtos, tVon, tBis,
									true, theClientDto);
							// Erster Block mit 50%
							tVon = kollektivUestdBVADto.getU100Ende();
							tBis = kollektivUestdBVADto.getU50Ende();

							BigDecimal bd50Prozent1 = getIstZeitZwischenVonBis(zeitdatenEinesTagesDtos, tVon, tBis,
									true, theClientDto);

							if (i == 8) {
								int z = 0;
							}

							// Gleitzeit
							tVon = kollektivUestdBVADto.getU50Ende();
							tBis = kollektivUestdBVADto.getU50Beginn();
							BigDecimal bdGleitzeit = getIstZeitZwischenVonBis(zeitdatenEinesTagesDtos, tVon, tBis, true,
									theClientDto);

							BigDecimal bdGleitzeitMitSondertaetigkeiten = getIstZeitZwischenVonBis(
									zeitdatenEinesTagesDtos, tVon, tBis, false, theClientDto);

							BigDecimal bd50ProzentigeAusGleitzeit = BigDecimal.ZERO;

							BigDecimal bdAbWannUestd = new BigDecimal(
									Helper.time2Double(kollektivUestdBVADto.getUGleitzeitBis()));

							if (bdGleitzeitMitSondertaetigkeiten.doubleValue() > bdAbWannUestd.doubleValue()) {
								bd50ProzentigeAusGleitzeit = bdGleitzeitMitSondertaetigkeiten.subtract(bdAbWannUestd);
								bdGleitzeit = bdAbWannUestd;
							}

							// Zweiter Block mit 50%
							tVon = kollektivUestdBVADto.getU50Beginn();
							tBis = kollektivUestdBVADto.getU100Beginn();

							BigDecimal bd50Prozent2 = getIstZeitZwischenVonBis(zeitdatenEinesTagesDtos, tVon, tBis,
									true, theClientDto);

							// Zweiter Block mit 100%

							tVon = kollektivUestdBVADto.getU100Beginn();
							tBis = new Time(23, 59, 59);
							BigDecimal bd100Prozent2 = getIstZeitZwischenVonBis(zeitdatenEinesTagesDtos, tVon, tBis,
									true, theClientDto);

							if (personalDto.getKollektivDto() != null) {
								zeile.setBetriebsvereinbarungADto(
										new BetriebsvereinbarungADto(Helper.rundeKaufmaennisch(bdGleitzeit, 2),
												Helper.rundeKaufmaennisch(bd50ProzentigeAusGleitzeit, 2),
												Helper.rundeKaufmaennisch(bd50Prozent1.add(bd50Prozent2), 2),
												Helper.rundeKaufmaennisch(bd100Prozent1.add(bd100Prozent2), 2),
												personalDto.getKollektivDto().getNFaktoruestd50(),
												personalDto.getKollektivDto().getNFaktoruestd100()));
							} else {
								zeile.setBetriebsvereinbarungADto(
										new BetriebsvereinbarungADto(Helper.rundeKaufmaennisch(bdGleitzeit, 2),
												Helper.rundeKaufmaennisch(bd50ProzentigeAusGleitzeit, 2),
												Helper.rundeKaufmaennisch(bd50Prozent1.add(bd50Prozent2), 2),
												Helper.rundeKaufmaennisch(bd100Prozent1.add(bd100Prozent2), 2)));

							}

						}

						zeile.setBdUestd200(new BigDecimal(0));
						zeile.setBdUestd100(new BigDecimal(0));
						zeile.setBdUestd100Steuerfrei(new BigDecimal(0));
						zeile.setBdUestd50Tageweise(new BigDecimal(0));
						zeile.setBdUestd50TageweiseSteuerfrei(new BigDecimal(0));
						zeile.setBdUestd50(new BigDecimal(0));
						zeile.setBdMehrstunden(new BigDecimal(0));
						// END-PJ20486
					} else {
						// Ueberstundenberechnung
						double dSummeTagUESTD200 = 0;
						double dSummeTagUESTD100 = 0;
						double dSummeTagUESTD100Steuerfrei = 0;
						double dSummeTagUESTD50 = 0;
						double dSummeTagUESTD50Steuerfrei = 0;

						// PJ19563
						if (iBerechnungsbasisUestd == PersonalFac.KOLLEKTIV_BERECHNUNGSBASIS_FESTE_STUNDEN
								|| iBerechnungsbasisUestd == PersonalFac.KOLLEKTIV_BERECHNUNGSBASIS_SOLLZEIT_ZEITMODEL) {

							if (hmKollektivUestd50Tageweise.containsKey(tagesartIId)) {
								ArrayList alZeilen = hmKollektivUestd50Tageweise.get(tagesartIId);
								if (alZeilen.size() > 0) {

									Object[] o = (Object[]) alZeilen.get(0);
									if (iBerechnungsbasisUestd == PersonalFac.KOLLEKTIV_BERECHNUNGSBASIS_FESTE_STUNDEN
											&& zeile.getBdIst() != null && o[0] != null) {

										double dAb = Helper.time2Double(((Time) o[0]));

										if (dAb < zeile.getBdIst().doubleValue()) {
											dSummeTagUESTD50 = zeile.getBdIst().subtract(new BigDecimal(dAb))
													.doubleValue();
										}

									} else if (iBerechnungsbasisUestd == PersonalFac.KOLLEKTIV_BERECHNUNGSBASIS_SOLLZEIT_ZEITMODEL
											&& zeile.getBdIst() != null && zeile.getBdDiff() != null) {
										dSummeTagUESTD50 = zeile.getBdDiff().doubleValue();
									}

								}

							}

						} else {

							if (nNormalstunden != null && zeitdatenEinesTagesDtos.length > 1) {
								// Was ist Heute fuer eine Tagesart?

								boolean bUestdZaehlenErstWennSollzeitErbracht = false;

								double dBlockzeit = getBlockzeitenEinesTages(personalDto, zeitdatenEinesTagesDtos,
										taetigkeitIId_Kommt, taetigkeitIId_Geht);

								if (personalDto.getKollektivDto() != null && Helper
										.short2boolean(personalDto.getKollektivDto().getBUestdabsollstderbracht())) {

									bUestdZaehlenErstWennSollzeitErbracht = true;

									if (zeile.getBdIst().doubleValue() >= zeile.getBdSoll().doubleValue()) {

										// Zeit um Sollzeit verschieben
										// Wenn Ja, dann Zeitbuchungen neu
										// setzen
										long l = zeitdatenEinesTagesDtos[0].getTZeit().getTime()
												+ (long) (zeile.getBdSoll().doubleValue() * 3600000)
												+ (long) (zeile.getBdUnter().doubleValue() * 3600000);
										dBlockzeit = getBlockzeitenEinesTages(personalDto,
												ZeitdatenDto.kopiereArrayUndVerschiebeAnfangsZeitNachSpaeter(
														zeitdatenEinesTagesDtos, l),
												taetigkeitIId_Kommt, taetigkeitIId_Geht);
									}

								}

								// PJ21438
								if (personalDto.getKollektivDto() != null
										&& Helper.short2boolean(
												personalDto.getKollektivDto().getBFeiertagsueberstundenAbSoll())
										&& zeile.getBdIst().doubleValue() > 0) {
									if (tagesartIId.equals(tagesartIId_Feiertag)) {

										Time usoll = getSollzeitZuDatumWennFeiertag(personalIId,
												new Timestamp(cal.getTime().getTime()), theClientDto);
										if (usoll != null) {
											double dFtgSoll = Helper.time2Double(usoll);

											if (zeile.getBdIst().doubleValue() > dFtgSoll) {
												double dDiff = zeile.getBdIst().doubleValue() - dFtgSoll;

												dSummeTagUESTD50Steuerfrei += dDiff;
											}

										}

									}
								}

								// Wenn Tagesart Sonntag und Feiertag, DANN ist
								// den
								// ganzen Tag Blockzeit, d.h. es sind immer
								// Steuerfreie
								// Ueberstunden
								if (tagesartIId.equals(
										tagesartFindByCNr(ZeiterfassungFac.TAGESART_SONNTAG, theClientDto).getIId())
										|| tagesartIId.equals(tagesartIId_Feiertag)) {
									dBlockzeit = 24;
								}

								if (bUestdZaehlenErstWennSollzeitErbracht == false
										|| bUestdZaehlenErstWennSollzeitErbracht == true
												&& zeile.getBdIst().doubleValue() > zeile.getBdSoll().doubleValue()) {

									if ((zeile.getBdFeiertag() != null && zeile.getBdFeiertag().doubleValue() > 0)
											|| cal.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) {
										if (personalDto.getKollektivDto() != null
												&& personalDto.getKollektivDto().getN200prozentigeab() != null) {
											if (zeile.getBdIst().doubleValue() > personalDto.getKollektivDto()
													.getN200prozentigeab().doubleValue()) {

												dSummeTagUESTD200 = zeile.getBdIst()
														.subtract(personalDto.getKollektivDto().getN200prozentigeab())
														.doubleValue();

												dWochensummeUestd200 += dSummeTagUESTD200;

											}
										}
									}

									// Gibt es fuer diese Tagesart einen Eintrag
									// in
									// den
									// Kollektivuestd 100 ?
									if (hmKollektivUestd100.containsKey(tagesartIId)) {
										KollektivuestdDto kollektivuestdDto = (KollektivuestdDto) hmKollektivUestd100
												.get(tagesartIId);

										if (iJahr == 2019 && iMonat == 4 && i == 20) {
											int z = 0;
										}

										ZeitdatenDto[] zeitdatenFuerUestdAbrechnung = ZeitdatenDto
												.kopiereArray(zeitdatenEinesTagesDtos);

										if (bUestdZaehlenErstWennSollzeitErbracht == true) {

											// SP2710

											long lPause = 0;
											if (zeile.getBdSoll().doubleValue() > zeile.getBdUnter().doubleValue()) {

												long lUnter = (long) (zeile.getBdUnter().doubleValue() * 3600000);
												if (zeile.getBdReisePassiv() != null) {
													// SP8290
													long lPassiveReise = (long) (zeile.getBdReisePassiv().doubleValue()
															* 3600000);
													if (lPassiveReise > lUnter) {
														lUnter = 0;
													} else {
														lUnter = lUnter - lPassiveReise;
													}
												}

												lPause = lUnter;
											}

											long l = zeitdatenFuerUestdAbrechnung[0].getTZeit().getTime()
													+ (long) (zeile.getBdSoll().doubleValue() * 3600000) + lPause;

											zeitdatenFuerUestdAbrechnung = ZeitdatenDto
													.kopiereArrayUndVerschiebeAnfangsZeitNachSpaeter(
															zeitdatenFuerUestdAbrechnung, l);

										}

										// --AB setzen

										Calendar cUestdTemp = Calendar.getInstance();
										cUestdTemp.setTimeInMillis(kollektivuestdDto.getUAb().getTime());

										// Wenn Ja, dann Zeitbuchungen neu
										// setzen
										Calendar cUestdAb = Calendar.getInstance();
										cUestdAb.setTimeInMillis(zeitdatenEinesTagesDtos[0].getTZeit().getTime());
										cUestdAb.set(Calendar.HOUR_OF_DAY, cUestdTemp.get(Calendar.HOUR_OF_DAY));
										cUestdAb.set(Calendar.MINUTE, cUestdTemp.get(Calendar.MINUTE));
										cUestdAb.set(Calendar.SECOND, 0);
										cUestdAb.set(Calendar.MILLISECOND, 0);

										zeitdatenFuerUestdAbrechnung = ZeitdatenDto
												.kopiereArrayUndVerschiebeAnfangsZeitNachSpaeter(
														zeitdatenFuerUestdAbrechnung, cUestdAb.getTime().getTime());

										// Ersten und letzten Eintrag des Tages
										// setzen

										long lDifferenz = zeitdatenFuerUestdAbrechnung[zeitdatenEinesTagesDtos.length
												- 1].getTZeit().getTime()
												- zeitdatenFuerUestdAbrechnung[0].getTZeit().getTime();

										Double dIstUestd = (double) lDifferenz / 3600000;

										// Ueber jede Zeitbuchung iterieren
										double dGesamt = dIstUestd;
										zeitdatenDto_Vorher = null;

										for (int m = 0; m < zeitdatenFuerUestdAbrechnung.length; m++) {
											ZeitdatenDto zeitdatenDto_Aktuell = zeitdatenFuerUestdAbrechnung[m];
											// Milliskunden auf 0 setzen
											Timestamp tsTemp = zeitdatenDto_Aktuell.getTZeit();
											Calendar c2 = Calendar.getInstance();
											c2.setTimeInMillis(tsTemp.getTime());
											c2.set(Calendar.MILLISECOND, 0);
											tsTemp = new Timestamp(c2.getTimeInMillis());
											zeitdatenDto_Aktuell.setTZeit(tsTemp);
											// Bei jeder Geraden Zahl mit dem
											// Vorgaenger
											// vergleichen
											if (m % 2 == 0 && m != 0) {
												if (zeitdatenDto_Aktuell.getTaetigkeitIId().equals(taetigkeitIId_Kommt)
														&& zeitdatenDto_Vorher.getTaetigkeitIId()
																.equals(taetigkeitIId_Geht)) {
													// Wenn KOMMT - GEHT, dann
													// nicht
													// dazuzaehlen

													Double dBeginn = Helper.time2Double(
															new Time(zeitdatenDto_Vorher.getTZeit().getTime()));
													Double dEnde = Helper.time2Double(
															new Time(zeitdatenDto_Aktuell.getTZeit().getTime()));
													double dSumme = dEnde.doubleValue() - dBeginn.doubleValue();
													dGesamt += dSumme;
												} else if (zeitdatenDto_Aktuell.getTaetigkeitIId()
														.equals(zeitdatenDto_Vorher.getTaetigkeitIId())) {
													if (Helper.short2boolean(
															kollektivuestdDto.getBUnterignorieren()) == false
															|| (Helper.short2boolean(
																	kollektivuestdDto.getBUnterignorieren()) == true
																	&& !zeitdatenDto_Aktuell.getTaetigkeitIId()
																			.equals(taetigkeitDto_Unter.getIId()))) {
														Double dBeginn = Helper.time2Double(
																new Time(zeitdatenDto_Vorher.getTZeit().getTime()));
														Double dEnde = Helper.time2Double(
																new Time(zeitdatenDto_Aktuell.getTZeit().getTime()));

														if (dBeginn != null && dEnde != null) {
															double dSumme = dEnde.doubleValue() - dBeginn.doubleValue();
															// Wenn Taetigkeit
															// ARZT
															// dann
															// bei
															// ARZT hinzufuegen
															if (zeitdatenDto_Aktuell.getTaetigkeitIId()
																	.equals(taetigkeitDto_Arzt.getIId())) {
																dGesamt += dSumme;
															}
															// Wenn Taetigkeit
															// KRANK
															// dann
															// bei
															// KRANK hinzufuegen
															else if (zeitdatenDto_Aktuell.getTaetigkeitIId()
																	.equals(taetigkeitDto_Krank.getIId())) {
																dGesamt += dSumme;
															}

															// Ansonsten muss
															// Taetigkeit
															// bei
															// sonstigen
															// bezahlten
															// oder
															// nicht
															// bezahlten
															// Taetigkeiten
															// dabei
															// sein
															else {
																dSumme = Helper
																		.rundeKaufmaennisch(new BigDecimal(dSumme), 2)
																		.doubleValue();
																// Bezahlte
																// Taetigkeiten
																boolean bGefunden = false;
																for (int k = 0; k < sonstigeTaetigkeiten.length; k++) {
																	if (zeitdatenDto_Aktuell.getTaetigkeitIId()
																			.equals(sonstigeTaetigkeiten[k].getIId())
																			&& sonstigeTaetigkeiten[k].getFBezahlt()
																					.doubleValue() > 0) {

																		dSumme = Helper.rundeKaufmaennisch(
																				new BigDecimal(dSumme)
																						.multiply(new BigDecimal(
																								sonstigeTaetigkeiten[k]
																										.getFBezahlt()
																										.doubleValue()
																										/ 100)),
																				2).doubleValue();

																		dGesamt += dSumme;
																		bGefunden = true;
																	}
																}

																if (bGefunden == false) {
																	dGesamt -= dSumme;
																}
															}
														}
													}
												}
											}
											zeitdatenDto_Vorher = zeitdatenDto_Aktuell;
										}

										dGesamt -= dSummeTagUESTD200;

										if (dGesamt > 0) {

											if (dBlockzeit > dGesamt) {
												dSummeTagUESTD100Steuerfrei = dGesamt;
												dSummeTagUESTD100 = 0;
											} else {
												dSummeTagUESTD100Steuerfrei = dBlockzeit;
												dSummeTagUESTD100 = dGesamt - dBlockzeit;
											}
											dBlockzeit = dBlockzeit - dGesamt;
										}
										dWochensummeUestd100 += dGesamt;
										// --ENDE AB

										// --BIS setzen
										if (kollektivuestdDto.getUBis() != null) {
											cUestdTemp = Calendar.getInstance();
											cUestdTemp.setTimeInMillis(kollektivuestdDto.getUBis().getTime());

											// Wenn Ja, dann Zeitbuchungen neu
											// setzen
											Calendar cUestdBis = Calendar.getInstance();
											cUestdBis.setTimeInMillis(zeitdatenEinesTagesDtos[0].getTZeit().getTime());
											cUestdBis.set(Calendar.HOUR_OF_DAY, cUestdTemp.get(Calendar.HOUR_OF_DAY));
											cUestdBis.set(Calendar.MINUTE, cUestdTemp.get(Calendar.MINUTE));
											cUestdBis.set(Calendar.SECOND, 0);
											cUestdBis.set(Calendar.MILLISECOND, 0);

											zeitdatenFuerUestdAbrechnung = ZeitdatenDto
													.kopiereArrayUndVerschiebeEndZeitNachFrueher(
															zeitdatenEinesTagesDtos, cUestdBis.getTime().getTime());

											// Ersten und letzten Eintrag des
											// Tages
											// setzen
											lDifferenz = zeitdatenFuerUestdAbrechnung[zeitdatenEinesTagesDtos.length
													- 1].getTZeit().getTime()
													- zeitdatenFuerUestdAbrechnung[0].getTZeit().getTime();

											dIstUestd = (double) lDifferenz / 3600000;
											// Ueber jede Zeitbuchung iterieren
											dGesamt = dIstUestd;
											zeitdatenDto_Vorher = null;

											for (int m = 0; m < zeitdatenFuerUestdAbrechnung.length; m++) {
												ZeitdatenDto zeitdatenDto_Aktuell = zeitdatenFuerUestdAbrechnung[m];
												// Milliskunden auf 0 setzen
												Timestamp tsTemp = zeitdatenDto_Aktuell.getTZeit();
												Calendar c2 = Calendar.getInstance();
												c2.setTimeInMillis(tsTemp.getTime());
												c2.set(Calendar.MILLISECOND, 0);
												tsTemp = new Timestamp(c2.getTimeInMillis());
												zeitdatenDto_Aktuell.setTZeit(tsTemp);
												// Bei jeder Geraden Zahl mit
												// dem
												// Vorgaenger
												// vergleichen
												if (m % 2 == 0 && m != 0) {
													if (zeitdatenDto_Aktuell.getTaetigkeitIId()
															.equals(taetigkeitIId_Kommt)
															&& zeitdatenDto_Vorher.getTaetigkeitIId()
																	.equals(taetigkeitIId_Geht)) {
														// Wenn KOMMT - GEHT,
														// dann
														// nicht
														// dazuzaehlen

														Double dBeginn = Helper.time2Double(
																new Time(zeitdatenDto_Vorher.getTZeit().getTime()));
														Double dEnde = Helper.time2Double(
																new Time(zeitdatenDto_Aktuell.getTZeit().getTime()));
														double dSumme = dEnde.doubleValue() - dBeginn.doubleValue();
														dGesamt += dSumme;
													} else if (zeitdatenDto_Aktuell.getTaetigkeitIId()
															.equals(zeitdatenDto_Vorher.getTaetigkeitIId())) {

														Double dBeginn = Helper.time2Double(
																new Time(zeitdatenDto_Vorher.getTZeit().getTime()));
														Double dEnde = Helper.time2Double(
																new Time(zeitdatenDto_Aktuell.getTZeit().getTime()));

														if (dBeginn != null && dEnde != null) {
															double dSumme = dEnde.doubleValue() - dBeginn.doubleValue();
															// Wenn Taetigkeit
															// ARZT
															// dann
															// bei
															// ARZT hinzufuegen
															if (zeitdatenDto_Aktuell.getTaetigkeitIId()
																	.equals(taetigkeitDto_Arzt.getIId())) {
																dGesamt += dSumme;
															}
															// Wenn Taetigkeit
															// KRANK
															// dann
															// bei KRANK
															// hinzufuegen
															else if (zeitdatenDto_Aktuell.getTaetigkeitIId()
																	.equals(taetigkeitDto_Krank.getIId())) {
																dGesamt += dSumme;
															}

															// Ansonsten muss
															// Taetigkeit
															// bei
															// sonstigen
															// bezahlten
															// oder
															// nicht bezahlten
															// Taetigkeiten
															// dabei sein
															else {
																dSumme = Helper
																		.rundeKaufmaennisch(new BigDecimal(dSumme), 2)
																		.doubleValue();
																// Bezahlte
																// Taetigkeiten
																boolean bGefunden = false;
																for (int k = 0; k < sonstigeTaetigkeiten.length; k++) {
																	if (zeitdatenDto_Aktuell.getTaetigkeitIId()
																			.equals(sonstigeTaetigkeiten[k].getIId())
																			&& sonstigeTaetigkeiten[k].getFBezahlt()
																					.doubleValue() > 0) {

																		dSumme = Helper.rundeKaufmaennisch(
																				new BigDecimal(dSumme)
																						.multiply(new BigDecimal(
																								sonstigeTaetigkeiten[k]
																										.getFBezahlt()
																										.doubleValue()
																										/ 100)),
																				2).doubleValue();

																		dGesamt += dSumme;
																		bGefunden = true;
																	}
																}

																if (bGefunden == false) {
																	dGesamt -= dSumme;
																}

															}
														}
													}
												}
												zeitdatenDto_Vorher = zeitdatenDto_Aktuell;
											}

											dGesamt -= dSummeTagUESTD200;

											if (dGesamt > 0) {
												if (dBlockzeit < 0) {
													dBlockzeit = 0;
												}

												if (dBlockzeit > dGesamt) {
													dSummeTagUESTD100Steuerfrei += dGesamt;
												} else {
													dSummeTagUESTD100Steuerfrei += dBlockzeit;
													dSummeTagUESTD100 += dGesamt - dBlockzeit;
												}
												dBlockzeit = dBlockzeit - dGesamt;
											}
											dWochensummeUestd100 += dGesamt;
										}
										// --ENDE BIS

									}

									// 50% tageweise
									// Gibt es fuer diese Tagesart einen Eintrag
									// in
									// den
									// Kollektivuestd 50 ?
									if (hmKollektivUestd50Tageweise.containsKey(tagesartIId)) {

										ArrayList alVonBis = (ArrayList) hmKollektivUestd50Tageweise.get(tagesartIId);

										for (int alz = 0; alz < alVonBis.size(); alz++) {
											Object[] oZeile = (Object[]) alVonBis.get(alz);
											boolean bPausenIgnorieren = Helper.short2boolean((Short) oZeile[2]);
											Time ab = (Time) oZeile[0];
											Time bis = (Time) oZeile[1];

											// --AB setzen

											Calendar cUestdTemp = Calendar.getInstance();
											cUestdTemp.setTimeInMillis(ab.getTime());

											// Wenn Ja, dann Zeitbuchungen neu
											// setzen
											Calendar cUestdAb = Calendar.getInstance();
											cUestdAb.setTimeInMillis(zeitdatenEinesTagesDtos[0].getTZeit().getTime());
											cUestdAb.set(Calendar.HOUR_OF_DAY, cUestdTemp.get(Calendar.HOUR_OF_DAY));
											cUestdAb.set(Calendar.MINUTE, cUestdTemp.get(Calendar.MINUTE));
											cUestdAb.set(Calendar.SECOND, 0);
											cUestdAb.set(Calendar.MILLISECOND, 0);

											ZeitdatenDto[] zeitdatenFuerUestdAbrechnung = ZeitdatenDto
													.kopiereArray(zeitdatenEinesTagesDtos);

											for (int o = 0; o < zeitdatenFuerUestdAbrechnung.length; o++) {
												ZeitdatenDto zeitdatenDto_Aktuell = zeitdatenFuerUestdAbrechnung[o];
												if (zeitdatenDto_Aktuell.getTZeit()
														.before(new Timestamp(cUestdAb.getTime().getTime()))) {
													zeitdatenDto_Aktuell
															.setTZeit(new Timestamp(cUestdAb.getTime().getTime()));
													zeitdatenFuerUestdAbrechnung[o] = zeitdatenDto_Aktuell;
												}
											}
											// --BIS setzen
											if (bis != null) {
												cUestdTemp.setTimeInMillis(bis.getTime());

												// Wenn Ja, dann Zeitbuchungen
												// neu
												// setzen
												Calendar cUestdBis = Calendar.getInstance();
												cUestdBis.setTimeInMillis(
														zeitdatenFuerUestdAbrechnung[0].getTZeit().getTime());
												cUestdBis.set(Calendar.HOUR_OF_DAY,
														cUestdTemp.get(Calendar.HOUR_OF_DAY));
												cUestdBis.set(Calendar.MINUTE, cUestdTemp.get(Calendar.MINUTE));

												cUestdBis.set(Calendar.SECOND, 0);
												cUestdBis.set(Calendar.MILLISECOND, 0);

												for (int o = 0; o < zeitdatenFuerUestdAbrechnung.length; o++) {
													ZeitdatenDto zeitdatenDto_Aktuell = zeitdatenFuerUestdAbrechnung[o];
													if (zeitdatenDto_Aktuell.getTZeit()
															.after(new Timestamp(cUestdBis.getTime().getTime()))) {
														zeitdatenDto_Aktuell
																.setTZeit(new Timestamp(cUestdBis.getTime().getTime()));
														zeitdatenFuerUestdAbrechnung[o] = zeitdatenDto_Aktuell;
													}
												}
											}
											// Ersten und letzten Eintrag des
											// Tages
											// setzen
											java.sql.Time t1Uesdt = new java.sql.Time(
													zeitdatenFuerUestdAbrechnung[0].getTZeit().getTime());
											java.sql.Time t2Uestd = new java.sql.Time(
													zeitdatenFuerUestdAbrechnung[zeitdatenEinesTagesDtos.length - 1]
															.getTZeit().getTime());

											Double dIstUestd = Helper.time2Double(t2Uestd).doubleValue()
													- Helper.time2Double(t1Uesdt).doubleValue();

											// Ueber jede Zeitbuchung iterieren
											double dGesamt = dIstUestd;
											zeitdatenDto_Vorher = null;

											for (int m = 0; m < zeitdatenFuerUestdAbrechnung.length; m++) {
												ZeitdatenDto zeitdatenDto_Aktuell = zeitdatenFuerUestdAbrechnung[m];
												// Milliskunden auf 0 setzen
												Timestamp tsTemp = zeitdatenDto_Aktuell.getTZeit();
												Calendar c2 = Calendar.getInstance();
												c2.setTimeInMillis(tsTemp.getTime());
												c2.set(c2.MILLISECOND, 0);
												tsTemp = new Timestamp(c2.getTimeInMillis());
												zeitdatenDto_Aktuell.setTZeit(tsTemp);
												// Bei jeder Geraden Zahl mit
												// dem
												// Vorgaenger
												// vergleichen
												if (m % 2 == 0 && m != 0) {
													if (zeitdatenDto_Aktuell.getTaetigkeitIId()
															.equals(taetigkeitIId_Kommt)
															&& zeitdatenDto_Vorher.getTaetigkeitIId()
																	.equals(taetigkeitIId_Geht)) {
														// Wenn KOMMT - GEHT,
														// dann
														// nicht
														// dazuzaehlen

														Double dBeginn = Helper.time2Double(
																new Time(zeitdatenDto_Vorher.getTZeit().getTime()));
														Double dEnde = Helper.time2Double(
																new Time(zeitdatenDto_Aktuell.getTZeit().getTime()));
														double dSumme = dEnde.doubleValue() - dBeginn.doubleValue();
														dGesamt += dSumme;
													} else if (zeitdatenDto_Aktuell.getTaetigkeitIId()
															.equals(zeitdatenDto_Vorher.getTaetigkeitIId())) {

														if (bPausenIgnorieren == false || (bPausenIgnorieren == true
																&& !zeitdatenDto_Aktuell.getTaetigkeitIId()
																		.equals(taetigkeitDto_Unter.getIId()))) {

															Double dBeginn = Helper.time2Double(
																	new Time(zeitdatenDto_Vorher.getTZeit().getTime()));
															Double dEnde = Helper.time2Double(new Time(
																	zeitdatenDto_Aktuell.getTZeit().getTime()));

															if (dBeginn != null && dEnde != null) {
																boolean bBezahlt = false;
																double dSumme = dEnde.doubleValue()
																		- dBeginn.doubleValue();
																// Wenn
																// Taetigkeit
																// ARZT
																// dann
																// bei
																// ARZT
																// hinzufuegen
																if (zeitdatenDto_Aktuell.getTaetigkeitIId()
																		.equals(taetigkeitDto_Arzt.getIId())) {
																	bBezahlt = true;
																}
																// Wenn
																// Taetigkeit
																// KRANK
																// dann
																// bei KRANK
																// hinzufuegen
																else if (zeitdatenDto_Aktuell.getTaetigkeitIId()
																		.equals(taetigkeitDto_Krank.getIId())) {
																	bBezahlt = true;
																}

																// Ansonsten
																// muss
																// Taetigkeit
																// bei
																// sonstigen
																// bezahlten
																// oder
																// nicht
																// bezahlten
																// Taetigkeiten
																// dabei sein
																else {
																	dSumme = Helper.rundeKaufmaennisch(
																			new BigDecimal(dSumme), 2).doubleValue();
																	// Bezahlte
																	// Taetigkeiten
																	for (int k = 0; k < sonstigeTaetigkeiten.length; k++) {
																		if (zeitdatenDto_Aktuell.getTaetigkeitIId()
																				.equals(sonstigeTaetigkeiten[k]
																						.getIId())
																				&& sonstigeTaetigkeiten[k]
																						.getFBezahlt() > 0) {
																			bBezahlt = true;
																		}
																	}

																}

																if (!bBezahlt) {
																	dGesamt -= dSumme;
																}
															}
														}
													}
												}
												zeitdatenDto_Vorher = zeitdatenDto_Aktuell;
											}

											dGesamt -= dSummeTagUESTD200;

											if (dGesamt > 0) {
												if (dBlockzeit < 0) {
													dBlockzeit = 0;
												}

												if (dBlockzeit > dGesamt) {
													dSummeTagUESTD50Steuerfrei += dGesamt;
													dSummeTagUESTD50 += 0;
												} else {
													dSummeTagUESTD50Steuerfrei += dBlockzeit;
													dSummeTagUESTD50 += dGesamt - dBlockzeit;
												}
												dBlockzeit = dBlockzeit - dGesamt;
											}
											dWochensummeUestd50Tageweise += dGesamt;
											// --ENDE 50%Tageweise
											// ------------------------------------------

										}
									}
								}

							}
						}
						zeile.setBdUestd200(new BigDecimal(dSummeTagUESTD200));

						zeile.setBdUestd100(new BigDecimal(dSummeTagUESTD100));
						zeile.setBdUestd100Steuerfrei(new BigDecimal(dSummeTagUESTD100Steuerfrei));

						zeile.setBdUestd50Tageweise(new BigDecimal(dSummeTagUESTD50));
						zeile.setBdUestd50TageweiseSteuerfrei(new BigDecimal(dSummeTagUESTD50Steuerfrei));
						zeile.setBdUestd50(new BigDecimal(0));

						zeile.setBdMehrstunden(new BigDecimal(0));
					}

					// -- ENDE Ueberstundenberechnung

				} else {
					zeile.setBdArzt(new BigDecimal(0));
					zeile.setBdBehoerde(new BigDecimal(0));
					zeile.setBdDiff(new BigDecimal(0));
					zeile.setBdIst(new BigDecimal(0));
					zeile.setBdKrank(new BigDecimal(0));
					zeile.setBdKindkrank(new BigDecimal(0));
					zeile.setBdSoll(new BigDecimal(0));
					zeile.setBdSonstigeBezahlt(new BigDecimal(0));
					zeile.setBdSonstigeNichtBezahlt(new BigDecimal(0));
					zeile.setBdUnter(new BigDecimal(0));
					zeile.setBdUrlaubStunden(new BigDecimal(0));
					zeile.setBdUrlaubTage(new BigDecimal(0));
					zeile.setbUrlaubAutomatik(Boolean.FALSE);
					zeile.setBdZA(new BigDecimal(0));
					zeile.setBdUestd100(new BigDecimal(0));
					zeile.setBdUestd50(new BigDecimal(0));
					zeile.setBdUestd100Steuerfrei(new BigDecimal(0));
					zeile.setBdUestd50Tageweise(new BigDecimal(0));
					zeile.setBdUestd50TageweiseSteuerfrei(new BigDecimal(0));
					zeile.setBdReise(new BigDecimal(0));
					zeile.setBdUestd200(new BigDecimal(0));
					zeile.setBdMehrstunden(new BigDecimal(0));
					zeile.setBdReisePassiv(new BigDecimal(0));
				}

				monatsabrechnungZeilen.add(zeile);

				dWochensummeIst += zeile.getBdIst().doubleValue();

				// PJ18628
				dWochensummeIstOhneSonderzeiten += zeile.getBdIst().doubleValue();
				// Projekt 13205: BezahlteSonmdertaetigkeiten gehoeren dazu
				dWochensummeIst += zeile.getBdSonstigeBezahlt().doubleValue();
				if (zeile.getBdFeiertag() != null) {
					dWochensummeIst += zeile.getBdFeiertag().doubleValue();
				}
				dWochensummeIst += zeile.getBdKrank().doubleValue();
				dWochensummeIst += zeile.getBdBehoerde().doubleValue();
				dWochensummeIst += zeile.getBdUrlaubStunden().doubleValue();
				dWochensummeIst += zeile.getBdArzt().doubleValue();

				if (zeile.getBdSoll() == null) {
					zeile.setBdSoll(new BigDecimal(0));
				}

				dWochensummeFtgSoll += zeile.getBdFeiertag().doubleValue();

				dWochensummeSollFuerUestd += zeile.getBdSoll().add(zeile.getBdFeiertag()).doubleValue();

				// Wenn naechster Tag in anderer Woche, dann Wochesumme
				// ausgeben
				// und bei 0 anfangen

				Calendar cKwNachsterTag = Calendar.getInstance();
				cKwNachsterTag.set(iJahr.intValue(), iMonat.intValue(), i + 1);

				int kwNachsterTag = cKwNachsterTag.get(Calendar.WEEK_OF_YEAR);

				if (zeile.getIKw() != kwNachsterTag || i == lAnzahlTageImMonat) {
					// Hier erfolget die eigentliche 50%
					// Ueberstundenberechnung

					zeile.setBdUestd50(new BigDecimal(0));
					zeile.setBdMehrstunden(new BigDecimal(0));

					System.out
							.println("WochensollFuerUestd fuer KW " + zeile.getIKw() + " " + dWochensummeSollFuerUestd);

					// PJ19638
					if (bWochengesamtsicht == true && i == lAnzahlTageImMonat && zeile.getIKw() == kwNachsterTag) {
						// Wenn die letzte Woche nicht -voll- ist, dann erfolgt
						// keine Wochenweise Ueberstundenberechnung

					} else {

						if (nNormalstunden != null && nNormalstunden.doubleValue() != 0) {

							BigDecimal nFaktorUestd50 = nSollStundenFuerUestd50.divide(nNormalstunden, 4,
									BigDecimal.ROUND_HALF_EVEN);

							BigDecimal nNormalstundenWoche = null;

							if (nFaktorUestd50.doubleValue() != 0) {

								if (bWochengesamtsicht == true && bEintrittsmonatMonat == false && i < 7) {
									// Sollstunden der gesamten Woche berechnen

									Calendar cVormonat = Calendar.getInstance();
									cVormonat.setTimeInMillis(calErstesZeitmodell.getTimeInMillis());
									cVormonat.add(Calendar.MONTH, -1);

									MonatsabrechnungDto monatsabrechnungVormonatDto = erstelleMonatsAbrechnung(
											personalIId, cVormonat.get(Calendar.YEAR), cVormonat.get(Calendar.MONTH),
											true, null, theClientDto, false, iOptionSortierung, false,
											bTagesUndwochenmaximumIgnorieren, dNurWennTagesistGroesser);

									Object[][] zeilenVormonat = monatsabrechnungVormonatDto.getData();

									int iKWErster = calErstesZeitmodell.get(Calendar.WEEK_OF_YEAR);

									for (int k = zeilenVormonat.length - 1; k > 0; --k) {
										Object[] zeileVormonat = zeilenVormonat[k];
										int iKWVormonatszeile = (Integer) zeileVormonat[REPORT_MONATSABRECHNUNG_KALENDERWOCHE];
										if (zeile.getIKw() == iKWVormonatszeile) {

											BigDecimal bdSollVormonat = (BigDecimal) zeileVormonat[REPORT_MONATSABRECHNUNG_SOLL];
											if (bdSollVormonat != null) {
												dWochensummeSollFuerUestd += bdSollVormonat.doubleValue();
											}
											BigDecimal bdSollFtgVormonat = (BigDecimal) zeileVormonat[REPORT_MONATSABRECHNUNG_FEIERTAG];
											if (bdSollFtgVormonat != null) {
												dWochensummeSollFuerUestd += bdSollFtgVormonat.doubleValue();
											}

											BigDecimal bdIst = (BigDecimal) zeileVormonat[REPORT_MONATSABRECHNUNG_IST];
											if (bdIst != null) {
												dWochensummeIst += bdIst.doubleValue();
											}

											BigDecimal bdUest100 = (BigDecimal) zeileVormonat[REPORT_MONATSABRECHNUNG_UESTD100];
											if (bdUest100 != null) {
												dWochensummeUestd100 += bdUest100.doubleValue();
											}

											BigDecimal bdUest100Frei = (BigDecimal) zeileVormonat[REPORT_MONATSABRECHNUNG_UESTD100FREI];
											if (bdUest100Frei != null) {
												dWochensummeUestd100 += bdUest100Frei.doubleValue();
											}

											BigDecimal bdUest200 = (BigDecimal) zeileVormonat[REPORT_MONATSABRECHNUNG_UESTD200];
											if (bdUest200 != null) {
												dWochensummeUestd200 += bdUest200.doubleValue();
											}

											BigDecimal bdUest50Tagesweise = (BigDecimal) zeileVormonat[REPORT_MONATSABRECHNUNG_UESTD50TAGEWEISE];
											if (bdUest50Tagesweise != null) {
												dWochensummeUestd50Tageweise += bdUest50Tagesweise.doubleValue();
											}

											BigDecimal bdUest50TagesweiseFrei = (BigDecimal) zeileVormonat[REPORT_MONATSABRECHNUNG_UESTD50TAGESWEISEFREI];
											if (bdUest50TagesweiseFrei != null) {
												dWochensummeUestd50Tageweise += bdUest50TagesweiseFrei.doubleValue();
											}

										}

									}

									nNormalstundenWoche = new BigDecimal(dWochensummeSollFuerUestd)
											.divide(nFaktorUestd50, 4, BigDecimal.ROUND_HALF_EVEN);

								} else {
									nNormalstundenWoche = new BigDecimal(dWochensummeSollFuerUestd)
											.divide(nFaktorUestd50, 4, BigDecimal.ROUND_HALF_EVEN);
								}

							} else {
								nNormalstundenWoche = new BigDecimal(0);
							}

							BigDecimal nMehrstunden = nNormalstundenWoche
									.subtract(new BigDecimal(dWochensummeSollFuerUestd));

							if (nMehrstunden.doubleValue() < 0) {
								nMehrstunden = new BigDecimal(0);
							}

							double dWochenDiff = dWochensummeIst - dWochensummeSollFuerUestd;

							if (bUestdVerteilen == false) {

								// Berechnungsgrundlage fuer 50%ige Ueberstunden
								BigDecimal bdBerechnungsgrundlageFuer50Prozentige = new BigDecimal(dWochensummeIst)
										.subtract(Helper.rundeKaufmaennisch(new BigDecimal(dWochensummeUestd100), 2))
										.subtract(Helper.rundeKaufmaennisch(new BigDecimal(dWochensummeUestd200), 2));

								bdBerechnungsgrundlageFuer50Prozentige = bdBerechnungsgrundlageFuer50Prozentige
										.subtract(Helper
												.rundeKaufmaennisch(new BigDecimal(dWochensummeUestd50Tageweise), 2));

								bdBerechnungsgrundlageFuer50Prozentige = bdBerechnungsgrundlageFuer50Prozentige
										.subtract(Helper.rundeKaufmaennisch(new BigDecimal(dWochensummeSollFuerUestd),
												2));
								bdBerechnungsgrundlageFuer50Prozentige = Helper
										.rundeKaufmaennisch(bdBerechnungsgrundlageFuer50Prozentige, 2);

								if (bdBerechnungsgrundlageFuer50Prozentige.doubleValue() > nMehrstunden.doubleValue()) {
									zeile.setBdMehrstunden(Helper.rundeKaufmaennisch(nMehrstunden, 2));
									bdBerechnungsgrundlageFuer50Prozentige = bdBerechnungsgrundlageFuer50Prozentige
											.subtract(nMehrstunden);

									if (iBerechnungsbasisUestd == PersonalFac.KOLLEKTIV_BERECHNUNGSBASIS_UHRZEIT) {

										zeile.setBdUestd50(
												Helper.rundeKaufmaennisch(bdBerechnungsgrundlageFuer50Prozentige, 2));
									}
								} else if (bdBerechnungsgrundlageFuer50Prozentige.doubleValue() < 0) {
									zeile.setBdUestd50(new BigDecimal(0));
									zeile.setBdMehrstunden(new BigDecimal(0));
								} else {
									zeile.setBdMehrstunden(
											Helper.rundeKaufmaennisch(bdBerechnungsgrundlageFuer50Prozentige, 2));
								}
							} else {

								double zuVerteilendeUestd = dWochenDiff;

								if (dWochenDiff > 0) {
									if (dWochenDiff > nMehrstunden.doubleValue()) {
										zeile.setBdMehrstunden(nMehrstunden);
										zuVerteilendeUestd = dWochenDiff - nMehrstunden.doubleValue();
									} else {
										zeile.setBdMehrstunden(new BigDecimal(dWochenDiff));
										zuVerteilendeUestd = 0;
									}
								}
								for (int f = 0; f < 4; f++) {
									for (int u = 0; u < monatsabrechnungZeilen.size(); u++) {
										ZeileMonatsabrechnungDto dto = (ZeileMonatsabrechnungDto) monatsabrechnungZeilen
												.get(u);
										if (dto.getIKw().intValue() == zeile.getIKw().intValue()) {

											// Wenn B_UESTDVERTEILEN und diff
											// <0,
											// dann gibt es keine Ueberstunden
											// Mehrstunden bzw. ueberstunden
											if (dWochenDiff <= 0) {
												dto.setBdUestd50(new BigDecimal(0));
												dto.setBdUestd100(new BigDecimal(0));
												dto.setBdUestd100Steuerfrei(new BigDecimal(0));
												dto.setBdUestd50Tageweise(new BigDecimal(0));
												dto.setBdUestd50TageweiseSteuerfrei(new BigDecimal(0));
												dto.setBdMehrstunden(new BigDecimal(0));
											} else {
												// nun verteilen
												if (zuVerteilendeUestd > 0) {

													if (f == 0) {

														if (dto.getBdUestd50Tageweise() != null
																&& dto.getBdUestd50Tageweise().doubleValue() > 0) {

															if (dto.getBdUestd50Tageweise()
																	.doubleValue() > zuVerteilendeUestd) {
																dto.setBdUestd50Tageweise(
																		new BigDecimal(zuVerteilendeUestd));
																zuVerteilendeUestd = 0;
															} else {
																zuVerteilendeUestd -= dto.getBdUestd50Tageweise()
																		.doubleValue();
															}

														}

													}
													if (f == 1) {
														if (dto.getBdUestd100() != null
																&& dto.getBdUestd100().doubleValue() > 0) {

															if (dto.getBdUestd100()
																	.doubleValue() > zuVerteilendeUestd) {
																dto.setBdUestd100(new BigDecimal(zuVerteilendeUestd));
																zuVerteilendeUestd = 0;
															} else {
																zuVerteilendeUestd -= dto.getBdUestd100().doubleValue();
															}

														}

													}
													if (f == 2) {
														if (dto.getBdUestd50TageweiseSteuerfrei() != null && dto
																.getBdUestd50TageweiseSteuerfrei().doubleValue() > 0) {

															if (dto.getBdUestd50TageweiseSteuerfrei()
																	.doubleValue() > zuVerteilendeUestd) {
																dto.setBdUestd50TageweiseSteuerfrei(
																		new BigDecimal(zuVerteilendeUestd));
																zuVerteilendeUestd = 0;
															} else {
																zuVerteilendeUestd -= dto
																		.getBdUestd50TageweiseSteuerfrei()
																		.doubleValue();
															}

														}
													}
													if (f == 3) {
														if (dto.getBdUestd100Steuerfrei() != null
																&& dto.getBdUestd100Steuerfrei().doubleValue() > 0) {

															if (dto.getBdUestd100Steuerfrei()
																	.doubleValue() > zuVerteilendeUestd) {
																dto.setBdUestd100Steuerfrei(
																		new BigDecimal(zuVerteilendeUestd));
																zuVerteilendeUestd = 0;
															} else {
																zuVerteilendeUestd -= dto.getBdUestd100Steuerfrei()
																		.doubleValue();
															}

														}

													}

													// Wenn noch verbeibende,
													// die
													// sind dann Wochenweise
													// 50%ig

													if (f == 3 && zuVerteilendeUestd > 0) {
														zeile.setBdUestd50(new BigDecimal(zuVerteilendeUestd));
													}

												}

											}
											monatsabrechnungZeilen.set(u, dto);
										}
									}
								}
							}
						}
					}

					dWochensummeIst = 0;
					dWochensummeIstOhneSonderzeiten = 0;
					dWochensummeSollFuerUestd = 0;
					dWochensummeUestd50Tageweise = 0;
					dWochensummeUestd100 = 0;
					dWochensummeFtgSoll = 0;
				}
			}

		}

		// Faktor
		BigDecimal faktor50 = new BigDecimal(0.00);
		BigDecimal faktor100 = new BigDecimal(0.00);
		BigDecimal faktormehrstd = new BigDecimal(0.00);
		BigDecimal faktor200 = new BigDecimal(0.00);
		if (personalDto.getKollektivDto() != null) {
			faktor50 = personalDto.getKollektivDto().getNFaktoruestd50();
			faktor100 = personalDto.getKollektivDto().getNFaktoruestd100();
			faktormehrstd = personalDto.getKollektivDto().getNFaktormehrstd();
			faktor200 = personalDto.getKollektivDto().getNFaktoruestd200();
		}

		// Holen des Gleitzeitsaldos des Vormonates
		GleitzeitsaldoDto gleitzeitsaldoDto_Vormonat = getGleitzeitsaldoVormonat(personalIId, iJahr, iMonat,
				d_datum_bis, dEintrittsdatum);

		// Summe der Ausbezahlten Stunden zusammenzaehlen
		BigDecimal bdSummeStundenabrechnungUestdFrei50 = new BigDecimal(0);
		BigDecimal bdSummeStundenabrechnungUestdFrei100 = new BigDecimal(0);
		BigDecimal bdSummeStundenabrechnungUestdPflichtig50 = new BigDecimal(0);
		BigDecimal bdSummeStundenabrechnungUestdPflichtig100 = new BigDecimal(0);
		BigDecimal bdSummeStundenabrechnungUestd200 = new BigDecimal(0);
		BigDecimal bdSummeStundenabrechnungUestdMehrstunden = new BigDecimal(0);
		BigDecimal bdSummeStundenabrechnungUestdNormalstunden = new BigDecimal(0);
		BigDecimal bdSummeStundenabrechnungGutstunden = new BigDecimal(0);
		BigDecimal bdQualifikationspraemie = new BigDecimal(0);

		BigDecimal bdSummeStundenabrechnungUestdNormalstundenVormonat = new BigDecimal(0);

		// In Report uebergeben
		HashMap parameter = new HashMap();

		try {
			StundenabrechnungDto[] stundeabrechnungDtos = getPersonalFac()
					.stundenabrechnungFindByPersonalIIdIJahrIMonat(personalIId, iJahr, iMonat);

			if (iUeberstundenAutomatischAuszahlen == ZeiterfassungFac.UESTAUSZAHLEN_ABRECHNUNGSMONAT) {
				// Zuerst alle automatischen des aktuellen Monats loeschen
				for (int i = 0; i < stundeabrechnungDtos.length; i++) {
					StundenabrechnungDto dto = stundeabrechnungDtos[i];
					if (dto.getCKommentar().equals("AUTOMATISCHE-AUSZAHLUNG")) {
						getPersonalFac().removeStundenabrechnung(dto);
					}
				}
				stundeabrechnungDtos = getPersonalFac().stundenabrechnungFindByPersonalIIdIJahrIMonat(personalIId,
						iJahr, iMonat);

			}

			String[] fieldNamesStundenabrechnung = new String[] { "Datum", "Normalstunden", "Mehrstunden",
					"UestdFrei50", "UestdPflichtig50", "UestdFrei100", "UestdPflichtig100", "Uestd200", "Gutstunden",
					"Qualifikationspraemie", "Qualifikationsfaktor", "Kommentar" };
			ArrayList alDatenSubreportStundenabrechnung = new ArrayList();
			for (int i = 0; i < stundeabrechnungDtos.length; i++) {

				// PJ20997
				Object[] oZeile = new Object[fieldNamesStundenabrechnung.length];
				oZeile[0] = stundeabrechnungDtos[i].getTDatum();
				oZeile[1] = stundeabrechnungDtos[i].getNNormalstunden();
				oZeile[2] = stundeabrechnungDtos[i].getNMehrstunden();
				oZeile[3] = stundeabrechnungDtos[i].getNUestfrei50();
				oZeile[4] = stundeabrechnungDtos[i].getNUestpflichtig50();
				oZeile[5] = stundeabrechnungDtos[i].getNUestfrei100();
				oZeile[6] = stundeabrechnungDtos[i].getNUestpflichtig100();
				oZeile[7] = stundeabrechnungDtos[i].getNUest200();
				oZeile[8] = stundeabrechnungDtos[i].getNGutstunden();
				oZeile[9] = stundeabrechnungDtos[i].getNQualifikationspraemie();
				oZeile[10] = stundeabrechnungDtos[i].getNQualifikationsfaktor();
				oZeile[11] = stundeabrechnungDtos[i].getCKommentar();

				alDatenSubreportStundenabrechnung.add(oZeile);

				Calendar c = Calendar.getInstance();
				c.setTime(stundeabrechnungDtos[i].getTDatum());

				// PJ18647
				for (int k = 0; k < monatsabrechnungZeilen.size(); k++) {
					ZeileMonatsabrechnungDto z = (ZeileMonatsabrechnungDto) monatsabrechnungZeilen.get(k);

					if (z.getITag() == c.get(Calendar.DATE)) {
						z.setBdQualifikationsfaktor(stundeabrechnungDtos[i].getNQualifikationsfaktor());
					}

				}

				// Fuer Uebertrag in Monatsabrechnun

				bdSummeStundenabrechnungUestdNormalstunden = bdSummeStundenabrechnungUestdNormalstunden
						.subtract(stundeabrechnungDtos[i].getNGutstunden());

				bdSummeStundenabrechnungUestdNormalstunden = bdSummeStundenabrechnungUestdNormalstunden
						.add(stundeabrechnungDtos[i].getNNormalstunden());

				if (stundeabrechnungDtos[i].getNQualifikationspraemie() != null) {
					bdQualifikationspraemie = bdQualifikationspraemie
							.add(stundeabrechnungDtos[i].getNQualifikationspraemie());
				}

				// WH: 08-12-09: Die Ueberstunden muessen bei
				// den Ueberstunden und beim Gleitzeitsaldo abgezogen werden.
				bdSummeStundenabrechnungUestdNormalstunden = bdSummeStundenabrechnungUestdNormalstunden
						.add(stundeabrechnungDtos[i].getNMehrstunden().multiply(faktormehrstd))
						.add(stundeabrechnungDtos[i].getNUest200().multiply(faktor200))
						.add(stundeabrechnungDtos[i].getNUestfrei100().multiply(faktor100))
						.add(stundeabrechnungDtos[i].getNUestfrei50().multiply(faktor50))
						.add(stundeabrechnungDtos[i].getNUestpflichtig100().multiply(faktor100))
						.add(stundeabrechnungDtos[i].getNUestpflichtig50().multiply(faktor50));

				// Fuer Uebertrag in Gleitzeitsaldo
				bdSummeStundenabrechnungUestdMehrstunden = bdSummeStundenabrechnungUestdMehrstunden
						.add(stundeabrechnungDtos[i].getNMehrstunden());
				bdSummeStundenabrechnungUestdFrei100 = bdSummeStundenabrechnungUestdFrei100
						.add(stundeabrechnungDtos[i].getNUestfrei100());
				bdSummeStundenabrechnungUestdFrei50 = bdSummeStundenabrechnungUestdFrei50
						.add(stundeabrechnungDtos[i].getNUestfrei50());
				bdSummeStundenabrechnungGutstunden = bdSummeStundenabrechnungGutstunden
						.add(stundeabrechnungDtos[i].getNGutstunden());
				bdSummeStundenabrechnungUestdPflichtig100 = bdSummeStundenabrechnungUestdPflichtig100
						.add(stundeabrechnungDtos[i].getNUestpflichtig100());
				bdSummeStundenabrechnungUestdPflichtig50 = bdSummeStundenabrechnungUestdPflichtig50
						.add(stundeabrechnungDtos[i].getNUestpflichtig50());
				bdSummeStundenabrechnungUestd200 = bdSummeStundenabrechnungUestd200
						.add(stundeabrechnungDtos[i].getNUest200());

			}

			Object[][] dataSub = new Object[alDatenSubreportStundenabrechnung
					.size()][fieldNamesStundenabrechnung.length];
			dataSub = (Object[][]) alDatenSubreportStundenabrechnung.toArray(dataSub);

			parameter.put("P_SUBREPORT_STUNDENABRECHNUNG", new LPDatenSubreport(dataSub, fieldNamesStundenabrechnung));

			// SP9056
			Calendar cVormonat = Calendar.getInstance();
			cVormonat.setTimeInMillis(calErstesZeitmodell.getTimeInMillis());
			cVormonat.add(Calendar.MONTH, -1);

			StundenabrechnungDto[] stundeabrechnungDtosVormonat = getPersonalFac()
					.stundenabrechnungFindByPersonalIIdIJahrIMonat(personalIId, cVormonat.get(Calendar.YEAR),
							cVormonat.get(Calendar.MONTH));
			for (int i = 0; i < stundeabrechnungDtosVormonat.length; i++) {
				// Fuer Uebertrag in Monatsabrechnun

				bdSummeStundenabrechnungUestdNormalstundenVormonat = bdSummeStundenabrechnungUestdNormalstundenVormonat
						.subtract(stundeabrechnungDtosVormonat[i].getNGutstunden());
				bdSummeStundenabrechnungUestdNormalstundenVormonat = bdSummeStundenabrechnungUestdNormalstundenVormonat
						.add(stundeabrechnungDtosVormonat[i].getNMehrstunden().multiply(faktormehrstd))
						.add(stundeabrechnungDtosVormonat[i].getNUest200().multiply(faktor200))
						.add(stundeabrechnungDtosVormonat[i].getNUestfrei100().multiply(faktor100))
						.add(stundeabrechnungDtosVormonat[i].getNUestfrei50().multiply(faktor50))
						.add(stundeabrechnungDtosVormonat[i].getNUestpflichtig100().multiply(faktor100))
						.add(stundeabrechnungDtosVormonat[i].getNUestpflichtig50().multiply(faktor50));
			}

		} catch (RemoteException ex10) {
			throwEJBExceptionLPRespectOld(ex10);
		}

		ArrayList alDatenSubreportMonatsuebergreifend = new ArrayList();

		Iterator it = tmDatenSubreportSchichtzulagen.keySet().iterator();
		while (it.hasNext()) {

			alDatenSubreportMonatsuebergreifend.add(tmDatenSubreportSchichtzulagen.get(it.next()));

		}

		if (alDatenSubreportMonatsuebergreifend.size() > 0) {
			String[] fieldNames = new String[] { "Schicht", "Zuschlag", "Dauer" };
			Object[][] dataSub = new Object[alDatenSubreportMonatsuebergreifend.size()][fieldNames.length];
			dataSub = (Object[][]) alDatenSubreportMonatsuebergreifend.toArray(dataSub);

			parameter.put("P_SUBREPORT_SCHICHTZUSCHLAEGE", new LPDatenSubreport(dataSub, fieldNames));
		}

		parameter.put("P_VON_BIS_ERFASSUNG", new Boolean(bVonBis));
		parameter.put("P_VON_BIS_ERFASSUNG_KOMMT_GEHT", new Boolean(bKommtGeht));

		parameter.put("P_FEIERTAG_AM_NAECHSTEN_TAG", new Boolean(bFeiertagAmNaechstenTag));

		parameter.put("P_AUSBEZAHLTMEHRSTD", Helper.rundeKaufmaennisch(bdSummeStundenabrechnungUestdMehrstunden, 2));

		parameter.put("P_EINTRITTSDATUM", dEintrittsdatum);
		parameter.put("P_AUSTRITTSDATUM", dAustrittsdatumFuerParameter);

		parameter.put("P_STICHTAG_REPORT", tsVon);

		parameter.put("P_AUSBEZAHLTUESTD50", Helper.rundeKaufmaennisch(bdSummeStundenabrechnungUestdPflichtig50, 2));
		parameter.put("P_AUSBEZAHLTUESTD50STF", Helper.rundeKaufmaennisch(bdSummeStundenabrechnungUestdFrei50, 2));
		parameter.put("P_AUSBEZAHLTUESTD100", Helper.rundeKaufmaennisch(bdSummeStundenabrechnungUestdPflichtig100, 2));
		parameter.put("P_AUSBEZAHLTUESTD100STF", Helper.rundeKaufmaennisch(bdSummeStundenabrechnungUestdFrei100, 2));
		parameter.put("P_AUSBEZAHLTNORMALSTD",
				Helper.rundeKaufmaennisch(bdSummeStundenabrechnungUestdNormalstunden, 2));
		parameter.put("P_AUSBEZAHLTUESTD200", Helper.rundeKaufmaennisch(bdSummeStundenabrechnungUestd200, 2));
		parameter.put("P_AUSBEZAHLTGUTSTD", Helper.rundeKaufmaennisch(bdSummeStundenabrechnungGutstunden, 2));
		parameter.put("P_QUALIPRAEMIE", Helper.rundeKaufmaennisch(bdQualifikationspraemie, 2));

		parameter.put("P_GZ_SALDO_MIT_UESDTD_IN_NORMALSTUNDEN_VORMONAT",
				Helper.rundeKaufmaennisch(gleitzeitsaldoDto_Vormonat.getNGzSaldoMitUestdInNormalstunden(), 2));

		// PJ20330
		parameter.put("P_VERBLEIBENDER_PUFFER", Helper.rundeKaufmaennisch(bdUeberstundenPuffer, 2));
		if (iUeberstundenAutomatischAuszahlen > ZeiterfassungFac.UESTAUSZAHLEN_KEINE) {
			if (iUeberstundenAutomatischAuszahlen == ZeiterfassungFac.UESTAUSZAHLEN_FOLGEMONAT) {
				parameter.put("P_UEBERSTUNDEN_MONATLICH_AUSZAHLEN", Boolean.TRUE);
				parameter.put("P_UEBERSTUNDEN_MONATLICH_AUSZAHLEN_ABRECHNUNGSMONAT", Boolean.FALSE);
			} else {
				parameter.put("P_UEBERSTUNDEN_MONATLICH_AUSZAHLEN", Boolean.FALSE);
				parameter.put("P_UEBERSTUNDEN_MONATLICH_AUSZAHLEN_ABRECHNUNGSMONAT", Boolean.TRUE);

			}
		} else {
			parameter.put("P_UEBERSTUNDEN_MONATLICH_AUSZAHLEN", Boolean.FALSE);
			parameter.put("P_UEBERSTUNDEN_MONATLICH_AUSZAHLEN_ABRECHNUNGSMONAT", Boolean.FALSE);
		}

		// Abgerechnete Ueberstunden aus Gleitzeitsaldo-Vormonat abziehen
		gleitzeitsaldoDto_Vormonat.setNSaldouest200(
				gleitzeitsaldoDto_Vormonat.getNSaldouest200().subtract(bdSummeStundenabrechnungUestd200));
		gleitzeitsaldoDto_Vormonat.setNSaldouestpflichtig100(gleitzeitsaldoDto_Vormonat.getNSaldouestpflichtig100()
				.subtract(bdSummeStundenabrechnungUestdPflichtig100));
		gleitzeitsaldoDto_Vormonat.setNSaldouestfrei100(
				gleitzeitsaldoDto_Vormonat.getNSaldouestfrei100().subtract(bdSummeStundenabrechnungUestdFrei100));
		gleitzeitsaldoDto_Vormonat.setNSaldouestpflichtig50(gleitzeitsaldoDto_Vormonat.getNSaldouestpflichtig50()
				.subtract(bdSummeStundenabrechnungUestdPflichtig50));
		gleitzeitsaldoDto_Vormonat.setNSaldouestfrei50(
				gleitzeitsaldoDto_Vormonat.getNSaldouestfrei50().subtract(bdSummeStundenabrechnungUestdFrei50));
		gleitzeitsaldoDto_Vormonat.setNSaldomehrstunden(
				gleitzeitsaldoDto_Vormonat.getNSaldomehrstunden().subtract(bdSummeStundenabrechnungUestdMehrstunden));

		// Berechnung der Gesamtsummen fuer Gleitzeitsaldo

		BigDecimal bdSummeUrlaub = new BigDecimal(0);
		BigDecimal bdSummeArzt = new BigDecimal(0);
		BigDecimal bdSummeBehoerde = new BigDecimal(0);
		BigDecimal bdSummeFeiertag = new BigDecimal(0);
		BigDecimal bdSummeKrank = new BigDecimal(0);
		BigDecimal bdSummeKindkrank = new BigDecimal(0);
		BigDecimal bdSummeSonstigeBezahlt = new BigDecimal(0);
		BigDecimal bdSummeUEST50FREI = new BigDecimal(0);
		BigDecimal bdSummeUEST50PFLICHTIG = new BigDecimal(0);
		BigDecimal bdSummeUEST100FREI = new BigDecimal(0);
		BigDecimal bdSummeUEST100PFLICHTIG = new BigDecimal(0);
		BigDecimal bdSummeMEHRSTUNDEN = new BigDecimal(0);
		BigDecimal bdSummeUEST200 = new BigDecimal(0);

		BigDecimal bdSummeSoll = new BigDecimal(0);
		BigDecimal bdSummeIst = new BigDecimal(0);

		BigDecimal bdSummeReisePassiv = new BigDecimal(0);

		BigDecimal bdSummeBVAGleitzeit = new BigDecimal(0);
		BigDecimal bdSummeBVAUEST50GZ = new BigDecimal(0);
		BigDecimal bdSummeBVAUEST50 = new BigDecimal(0);
		BigDecimal bdSummeBVAUEST100 = new BigDecimal(0);

		BigDecimal bdSummeBVAUEST50GZ_Zuschlag = new BigDecimal(0);
		BigDecimal bdSummeBVAUEST50_Zuschlag = new BigDecimal(0);
		BigDecimal bdSummeBVAUEST100_Zuschlag = new BigDecimal(0);

		for (int i = 0; i < monatsabrechnungZeilen.size(); i++) {
			ZeileMonatsabrechnungDto z = (ZeileMonatsabrechnungDto) monatsabrechnungZeilen.get(i);
			if (z.getBdUrlaubStunden() != null) {
				bdSummeUrlaub = bdSummeUrlaub.add(z.getBdUrlaubStunden());
			}
			if (z.getBdArzt() != null) {
				bdSummeArzt = bdSummeArzt.add(z.getBdArzt());
			}
			if (z.getBdBehoerde() != null) {
				bdSummeBehoerde = bdSummeBehoerde.add(z.getBdBehoerde());
			}
			if (z.getBdFeiertag() != null) {
				bdSummeFeiertag = bdSummeFeiertag.add(z.getBdFeiertag());
			}
			if (z.getBdSonstigeBezahlt() != null) {
				bdSummeSonstigeBezahlt = bdSummeSonstigeBezahlt.add(z.getBdSonstigeBezahlt());
			}
			if (z.getBdKrank() != null) {
				bdSummeKrank = bdSummeKrank.add(z.getBdKrank());
			}
			if (z.getBdKindkrank() != null) {
				bdSummeKindkrank = bdSummeKindkrank.add(z.getBdKindkrank());
			}
			if (z.getBdSoll() != null) {
				bdSummeSoll = bdSummeSoll.add(z.getBdSoll());
			}
			if (z.getBdIst() != null) {
				bdSummeIst = bdSummeIst.add(z.getBdIst());
			}
			if (z.getBdUestd200() != null) {
				bdSummeUEST200 = bdSummeUEST200.add(z.getBdUestd200());
			}
			if (z.getBdUestd100() != null) {
				bdSummeUEST100PFLICHTIG = bdSummeUEST100PFLICHTIG.add(z.getBdUestd100());
			}
			if (z.getBdUestd100Steuerfrei() != null) {
				bdSummeUEST100FREI = bdSummeUEST100FREI.add(z.getBdUestd100Steuerfrei());
			}
			if (z.getBdUestd50() != null) {
				bdSummeUEST50PFLICHTIG = bdSummeUEST50PFLICHTIG.add(z.getBdUestd50());
			}
			if (z.getBdUestd50Tageweise() != null) {
				bdSummeUEST50PFLICHTIG = bdSummeUEST50PFLICHTIG.add(z.getBdUestd50Tageweise());
			}
			if (z.getBdUestd50TageweiseSteuerfrei() != null) {
				bdSummeUEST50FREI = bdSummeUEST50FREI.add(z.getBdUestd50TageweiseSteuerfrei());
			}
			if (z.getBdMehrstunden() != null) {
				bdSummeMEHRSTUNDEN = bdSummeMEHRSTUNDEN.add(z.getBdMehrstunden());
			}

			if (z.getBetriebsvereinbarungADto() != null) {
				bdSummeBVAGleitzeit = bdSummeBVAGleitzeit.add(z.getBetriebsvereinbarungADto().getBdGleitzeit());
				bdSummeBVAUEST50GZ = bdSummeBVAUEST50GZ
						.add(z.getBetriebsvereinbarungADto().getBd50ProzentWennGleitzeitUeberschritten());
				bdSummeBVAUEST50 = bdSummeBVAUEST50.add(z.getBetriebsvereinbarungADto().getBd50Prozent());
				bdSummeBVAUEST100 = bdSummeBVAUEST100.add(z.getBetriebsvereinbarungADto().getBd100Prozent());

				bdSummeBVAUEST50GZ_Zuschlag = bdSummeBVAUEST50GZ_Zuschlag
						.add(z.getBetriebsvereinbarungADto().getBd50ProzentWennGleitzeitUeberschrittenZuschlag());
				bdSummeBVAUEST50_Zuschlag = bdSummeBVAUEST50_Zuschlag
						.add(z.getBetriebsvereinbarungADto().getBd50ProzentZuschlag());
				bdSummeBVAUEST100_Zuschlag = bdSummeBVAUEST100_Zuschlag
						.add(z.getBetriebsvereinbarungADto().getBd100ProzentZuschlag());

			}

			if (z.getBdReisePassiv() != null) {
				bdSummeReisePassiv = bdSummeReisePassiv.add(z.getBdReisePassiv());
			}

		}

		BigDecimal bdZeilensummenIst = bdSummeIst;

		bdSummeBVAGleitzeit = Helper.rundeKaufmaennisch(bdSummeBVAGleitzeit, 2);
		bdSummeBVAUEST50GZ = Helper.rundeKaufmaennisch(bdSummeBVAUEST50GZ, 2);
		bdSummeBVAUEST50 = Helper.rundeKaufmaennisch(bdSummeBVAUEST50, 2);
		bdSummeBVAUEST100 = Helper.rundeKaufmaennisch(bdSummeBVAUEST100, 2);

		bdSummeBVAUEST50GZ_Zuschlag = Helper.rundeKaufmaennisch(bdSummeBVAUEST50GZ_Zuschlag, 2);
		bdSummeBVAUEST50_Zuschlag = Helper.rundeKaufmaennisch(bdSummeBVAUEST50_Zuschlag, 2);
		bdSummeBVAUEST100_Zuschlag = Helper.rundeKaufmaennisch(bdSummeBVAUEST100_Zuschlag, 2);

		// PJ 16194
		if (nSollStundenFIX != null) {
			bdSummeSoll = nSollStundenFIX;
			// 2865
			if (bSollstundenMitrechnen == false) {
				dSummeMonatFeiertagSoll = 0;
			}
			parameter.put("P_SOLLSTUNDEN_FIX", nSollStundenFIX);
		}

		parameter.put("P_SOLLGESAMT", bdSummeSoll);

		bdSummeSoll = bdSummeSoll.add(new BigDecimal(dSummeMonatFeiertagSoll));

		// PJ20225
		parameter.put("P_DRZPAUSCHALE", nDRZPauschale);
		bdSummeSoll = bdSummeSoll.add(nDRZPauschale);

		bdSummeIst = bdSummeIst.add(bdSummeUrlaub);
		bdSummeIst = bdSummeIst.add(bdSummeArzt);
		bdSummeIst = bdSummeIst.add(bdSummeBehoerde);
		bdSummeIst = bdSummeIst.add(bdSummeFeiertag);
		bdSummeIst = bdSummeIst.add(bdSummeKrank);
		bdSummeIst = bdSummeIst.add(bdSummeSonstigeBezahlt);
		bdSummeIst = bdSummeIst.add(bdSummeKindkrank);

		// PJ 16204
		BigDecimal bdSummeIstFuerSaldenabfrage = bdSummeIst;

		bdSummeIst = bdSummeIst.subtract(bdSummeSoll);

		BigDecimal bdSummeSonstigerSondetaetigkeiten = bdSummeUrlaub.add(bdSummeArzt).add(bdSummeBehoerde)
				.add(bdSummeFeiertag).add(bdSummeKrank).add(bdSummeKindkrank).add(bdSummeSonstigeBezahlt);
		parameter.put("P_SUMMEZUSSONDERTAETIGKEITEN", bdSummeSonstigerSondetaetigkeiten);

		// Abgerechnete Ueberstunden

		BigDecimal abAbgerechneteUeberstunden = bdSummeStundenabrechnungUestdPflichtig100.multiply(faktor100);

		abAbgerechneteUeberstunden = abAbgerechneteUeberstunden
				.add(bdSummeStundenabrechnungUestd200.multiply(faktor200));
		abAbgerechneteUeberstunden = abAbgerechneteUeberstunden
				.add(bdSummeStundenabrechnungUestdFrei100.multiply(faktor100));
		abAbgerechneteUeberstunden = abAbgerechneteUeberstunden
				.add(bdSummeStundenabrechnungUestdPflichtig50.multiply(faktor50));
		abAbgerechneteUeberstunden = abAbgerechneteUeberstunden
				.add(bdSummeStundenabrechnungUestdFrei50.multiply(faktor50));
		abAbgerechneteUeberstunden = abAbgerechneteUeberstunden
				.add(bdSummeStundenabrechnungUestdMehrstunden.multiply(faktormehrstd));

		// SP9161
		abAbgerechneteUeberstunden = Helper.rundeKaufmaennisch(abAbgerechneteUeberstunden, 2);

		parameter.put("P_ABGERECHNETEUEBERSTUNDEN", abAbgerechneteUeberstunden);

		// Vormonatsgleitzeitsaldo berechnen
		GleitzeitsaldoDto gleitzeitsaldoDtoVormonat = getGleitzeitsaldoVormonat(personalIId, iJahr, iMonat, d_datum_bis,
				dEintrittsdatum);

		if (iUeberstundenAutomatischAuszahlen == ZeiterfassungFac.UESTAUSZAHLEN_FOLGEMONAT) {
			gleitzeitsaldoDtoVormonat.setNSaldo(gleitzeitsaldoDtoVormonat.getNSaldo().add(abAbgerechneteUeberstunden));
			gleitzeitsaldoDto_Vormonat
					.setNSaldo(gleitzeitsaldoDto_Vormonat.getNSaldo().add(abAbgerechneteUeberstunden));
		}

		parameter.put("P_GLEITZEITSALDOVORMONAT", gleitzeitsaldoDtoVormonat.getNSaldo());

		// SP9056

		BigDecimal gleitzeitsaldovormonatUeberstunden = gleitzeitsaldoDtoVormonat.getNSaldouestfrei100()
				.multiply(faktor100);

		gleitzeitsaldovormonatUeberstunden = gleitzeitsaldovormonatUeberstunden
				.add(gleitzeitsaldoDtoVormonat.getNSaldouest200().multiply(faktor200));
		gleitzeitsaldovormonatUeberstunden = gleitzeitsaldovormonatUeberstunden
				.add(gleitzeitsaldoDtoVormonat.getNSaldouestpflichtig100().multiply(faktor100));
		gleitzeitsaldovormonatUeberstunden = gleitzeitsaldovormonatUeberstunden
				.add(gleitzeitsaldoDtoVormonat.getNSaldouestfrei50().multiply(faktor50));
		gleitzeitsaldovormonatUeberstunden = gleitzeitsaldovormonatUeberstunden
				.add(gleitzeitsaldoDtoVormonat.getNSaldouestpflichtig50().multiply(faktor50));
		gleitzeitsaldovormonatUeberstunden = gleitzeitsaldovormonatUeberstunden
				.add(gleitzeitsaldoDtoVormonat.getNSaldomehrstunden().multiply(faktormehrstd));

		gleitzeitsaldovormonatUeberstunden = Helper.rundeKaufmaennisch(gleitzeitsaldovormonatUeberstunden, 2);

		parameter.put("P_GLEITZEITSALDOVORMONAT_UEBERSTUNDEN", gleitzeitsaldovormonatUeberstunden);

		// PJ20486
		if (kollektivAbrechnungsart != null
				&& kollektivAbrechnungsart.equals(PersonalFac.KOLLEKTIV_ABRECHNUNGSART_BETRIEBSVEREINBARUNG_A)) {

			String[] fieldnames = new String[] { "F_DATUM", "F_GLEITZEIT", "F_UESTD50_GZ", "F_UESTD50_GZ_ZUSCHLAG",
					"F_UESTD50", "F_UESTD50_ZUSCHLAG", "F_UESTD100", "F_UESTD100_ZUSCHLAG", "F_KOMMENTAR", "F_GESPERRT",
					"F_ART" };
			ArrayList zeilenSub = new ArrayList();

			UebertragBVADto uebertragBVAVormonat = getZeiterfassungFac().getUebertragBVAVormonat(personalIId, iJahr,
					iMonat);
			Calendar cMonatsletzter = Calendar.getInstance();
			cMonatsletzter.set(Calendar.DAY_OF_MONTH, 1);
			cMonatsletzter.set(Calendar.YEAR, iJahr);
			cMonatsletzter.set(Calendar.MONTH, iMonat);

			cMonatsletzter.add(Calendar.MONTH, -1);
			cMonatsletzter.set(Calendar.DAY_OF_MONTH, cMonatsletzter.getActualMaximum(Calendar.DAY_OF_MONTH));

			cMonatsletzter.getTime();

			uebertragBVAVormonat.setTDatum(Helper.cutTimestamp(new Timestamp(cMonatsletzter.getTimeInMillis())));

			// Vormonat
			Object[] oZeileVormonat = new Object[fieldnames.length];
			oZeileVormonat[0] = uebertragBVAVormonat.getTDatum();
			oZeileVormonat[1] = uebertragBVAVormonat.getNGleitzeit();
			oZeileVormonat[2] = uebertragBVAVormonat.getNUestd50Gz();
			oZeileVormonat[3] = uebertragBVAVormonat.getNUestd50Gz_Zuschlag();
			oZeileVormonat[4] = uebertragBVAVormonat.getNUestd50();
			oZeileVormonat[5] = uebertragBVAVormonat.getNUestd50_Zuschlag();
			oZeileVormonat[6] = uebertragBVAVormonat.getNUestd100();
			oZeileVormonat[7] = uebertragBVAVormonat.getnUestd100_Zuschlag();

			oZeileVormonat[9] = Helper.short2Boolean(uebertragBVAVormonat.getBGesperrt());
			oZeileVormonat[10] = "SUMME_VORMONAT";

			UebertragBVADto vormonatDto = new UebertragBVADto();
			vormonatDto.setNGleitzeit(uebertragBVAVormonat.getNGleitzeit());
			vormonatDto.setNUestd50(uebertragBVAVormonat.getNUestd50());
			vormonatDto.setNUestd50_Zuschlag(uebertragBVAVormonat.getNUestd50_Zuschlag());
			vormonatDto.setNUestd100(uebertragBVAVormonat.getNUestd100());
			vormonatDto.setNUestd100_Zuschlag(uebertragBVAVormonat.getnUestd100_Zuschlag());
			vormonatDto.setNUestd50Gz(uebertragBVAVormonat.getNUestd50Gz());
			vormonatDto.setNUestd50Gz_Zuschlag(uebertragBVAVormonat.getNUestd50Gz_Zuschlag());

			parameter.put("P_SUMME_VORMONAT_BVA", vormonatDto);

			zeilenSub.add(oZeileVormonat);

			cMonatsletzter.add(Calendar.MONTH, +1);
			cMonatsletzter.set(Calendar.DAY_OF_MONTH, cMonatsletzter.getActualMaximum(Calendar.DAY_OF_MONTH));

			uebertragBVAVormonat.setTDatum(Helper.cutTimestamp(new Timestamp(cMonatsletzter.getTimeInMillis())));

			// Auszahlungen abziehen

			AuszahlungBVADto[] auszahlungen = auszahlungBVAFindByPersonalIIdIJahrIMonat(personalIId, iJahr, iMonat);

			BigDecimal bdSummeAuszahlungenGleitzeit = BigDecimal.ZERO;
			BigDecimal bdSummeAuszahlungenUestd50Gz = BigDecimal.ZERO;
			BigDecimal bdSummeAuszahlungenUestd50Gz_Zuschlag = BigDecimal.ZERO;
			BigDecimal bdSummeAuszahlungenUestd50 = BigDecimal.ZERO;
			BigDecimal bdSummeAuszahlungenUestd50_Zuschlag = BigDecimal.ZERO;
			BigDecimal bdSummeAuszahlungenUestd100 = BigDecimal.ZERO;
			BigDecimal bdSummeAuszahlungenUestd100_Zuschlag = BigDecimal.ZERO;

			for (int i = 0; i < auszahlungen.length; i++) {
				Object[] oZeile = new Object[fieldnames.length];
				oZeile[0] = auszahlungen[i].getTDatum();
				oZeile[1] = auszahlungen[i].getNGleitzeit().negate();
				oZeile[2] = auszahlungen[i].getNUestd50Gz().negate();
				oZeile[3] = auszahlungen[i].getNUestd50Gz_Zuschlag().negate();
				oZeile[4] = auszahlungen[i].getNUestd50().negate();
				oZeile[5] = auszahlungen[i].getNUestd50_Zuschlag().negate();
				oZeile[6] = auszahlungen[i].getNUestd100().negate();
				oZeile[7] = auszahlungen[i].getnUestd100_Zuschlag().negate();
				oZeile[8] = auszahlungen[i].getCKommentar();
				oZeile[10] = "ABRECHNUNG";
				zeilenSub.add(oZeile);

				bdSummeAuszahlungenGleitzeit = bdSummeAuszahlungenGleitzeit.add(auszahlungen[i].getNGleitzeit());
				bdSummeAuszahlungenUestd50Gz = bdSummeAuszahlungenUestd50Gz.add(auszahlungen[i].getNUestd50Gz());
				bdSummeAuszahlungenUestd50Gz_Zuschlag = bdSummeAuszahlungenUestd50Gz_Zuschlag
						.add(auszahlungen[i].getNUestd50Gz_Zuschlag());
				bdSummeAuszahlungenUestd50 = bdSummeAuszahlungenUestd50.add(auszahlungen[i].getNUestd50());
				bdSummeAuszahlungenUestd50_Zuschlag = bdSummeAuszahlungenUestd50_Zuschlag
						.add(auszahlungen[i].getNUestd50_Zuschlag());
				bdSummeAuszahlungenUestd100 = bdSummeAuszahlungenUestd100.add(auszahlungen[i].getNUestd100());
				bdSummeAuszahlungenUestd100_Zuschlag = bdSummeAuszahlungenUestd100_Zuschlag
						.add(auszahlungen[i].getnUestd100_Zuschlag());

				uebertragBVAVormonat
						.setNGleitzeit(uebertragBVAVormonat.getNGleitzeit().subtract(auszahlungen[i].getNGleitzeit()));
				uebertragBVAVormonat
						.setNUestd50Gz(uebertragBVAVormonat.getNUestd50Gz().subtract(auszahlungen[i].getNUestd50Gz()));
				uebertragBVAVormonat.setNUestd50Gz_Zuschlag(uebertragBVAVormonat.getNUestd50Gz_Zuschlag()
						.subtract(auszahlungen[i].getNUestd50Gz_Zuschlag()));
				uebertragBVAVormonat
						.setNUestd50(uebertragBVAVormonat.getNUestd50().subtract(auszahlungen[i].getNUestd50()));
				uebertragBVAVormonat.setNUestd50_Zuschlag(
						uebertragBVAVormonat.getNUestd50_Zuschlag().subtract(auszahlungen[i].getNUestd50_Zuschlag()));
				uebertragBVAVormonat
						.setNUestd100(uebertragBVAVormonat.getNUestd100().subtract(auszahlungen[i].getNUestd100()));
				uebertragBVAVormonat.setNUestd100_Zuschlag(
						uebertragBVAVormonat.getnUestd100_Zuschlag().subtract(auszahlungen[i].getnUestd100_Zuschlag()));

			}

			UebertragBVADto auszahlungenDto = new UebertragBVADto();
			auszahlungenDto.setNGleitzeit(bdSummeAuszahlungenGleitzeit);
			auszahlungenDto.setNUestd50(bdSummeAuszahlungenUestd50);
			auszahlungenDto.setNUestd50_Zuschlag(bdSummeAuszahlungenUestd50_Zuschlag);
			auszahlungenDto.setNUestd100(bdSummeAuszahlungenUestd100);
			auszahlungenDto.setNUestd100_Zuschlag(bdSummeAuszahlungenUestd100_Zuschlag);
			auszahlungenDto.setNUestd50Gz(bdSummeAuszahlungenUestd50Gz);
			auszahlungenDto.setNUestd50Gz_Zuschlag(bdSummeAuszahlungenUestd50Gz_Zuschlag);

			parameter.put("P_SUMME_AUSZAHLUNGEN_BVA", auszahlungenDto);

			// aktuelles Monat addieren

			BigDecimal bdGleizteitDiff = Helper.rundeKaufmaennisch(
					bdSummeBVAGleitzeit.add(bdSummeSonstigerSondetaetigkeiten).subtract(bdSummeSoll), 2);

			Object[] oZeile = new Object[fieldnames.length];
			oZeile[0] = uebertragBVAVormonat.getTDatum();
			oZeile[1] = bdGleizteitDiff;

			parameter.put("P_GLEITZEIT_DIFF_AKTUELLESMONAT", bdGleizteitDiff);

			oZeile[2] = bdSummeBVAUEST50GZ;
			oZeile[3] = Helper.rundeKaufmaennisch(bdSummeBVAUEST50GZ.multiply(faktor50), 2);
			oZeile[4] = bdSummeBVAUEST50;
			oZeile[5] = Helper.rundeKaufmaennisch(bdSummeBVAUEST50.multiply(faktor50), 2);
			oZeile[6] = bdSummeBVAUEST100;
			oZeile[7] = Helper.rundeKaufmaennisch(bdSummeBVAUEST100.multiply(faktor100), 2);

			oZeile[10] = "SUMME_AKTUELLESMONAT";

			zeilenSub.add(oZeile);

			uebertragBVAVormonat.setNGleitzeit(uebertragBVAVormonat.getNGleitzeit().add(bdGleizteitDiff));
			uebertragBVAVormonat.setNUestd50Gz(uebertragBVAVormonat.getNUestd50Gz().add(bdSummeBVAUEST50GZ));
			uebertragBVAVormonat.setNUestd50(uebertragBVAVormonat.getNUestd50().add(bdSummeBVAUEST50));
			uebertragBVAVormonat.setNUestd100(uebertragBVAVormonat.getNUestd100().add(bdSummeBVAUEST100));

			uebertragBVAVormonat.setNUestd100_Zuschlag(Helper.rundeKaufmaennisch(
					uebertragBVAVormonat.getnUestd100_Zuschlag().add(bdSummeBVAUEST100.multiply(faktor100)), 2));
			uebertragBVAVormonat.setNUestd50_Zuschlag(Helper.rundeKaufmaennisch(
					uebertragBVAVormonat.getNUestd50_Zuschlag().add(bdSummeBVAUEST50.multiply(faktor50)), 2));
			uebertragBVAVormonat.setNUestd50Gz_Zuschlag(Helper.rundeKaufmaennisch(
					uebertragBVAVormonat.getNUestd50Gz_Zuschlag().add(bdSummeBVAUEST50GZ.multiply(faktor50)), 2));

			oZeile = new Object[fieldnames.length];
			oZeile[0] = uebertragBVAVormonat.getTDatum();
			oZeile[1] = uebertragBVAVormonat.getNGleitzeit();
			oZeile[2] = uebertragBVAVormonat.getNUestd50Gz();
			oZeile[3] = uebertragBVAVormonat.getNUestd50Gz_Zuschlag();
			oZeile[4] = uebertragBVAVormonat.getNUestd50();
			oZeile[5] = uebertragBVAVormonat.getNUestd50_Zuschlag();
			oZeile[6] = uebertragBVAVormonat.getNUestd100();
			oZeile[7] = uebertragBVAVormonat.getnUestd100_Zuschlag();
			oZeile[10] = "GESAMTSUMME_INKL_VORMONAT";
			zeilenSub.add(oZeile);

			parameter.put("P_UEBERTRAG_BVA", uebertragBVAVormonat);

			parameter.put("P_SUBREPORT_BETRIEBSVEREINBAUNG_A", new LPDatenSubreport(zeilenSub, fieldnames));

			// und zurueckschreiben

			getZeiterfassungFac().schreibeUebertragBVADto(uebertragBVAVormonat, theClientDto);
		}

		// SP5491
		// Ueberstunden des Vormonats als Normalstunden ausweisen
		if (iUeberstundenAutomatischAuszahlen == ZeiterfassungFac.UESTAUSZAHLEN_FOLGEMONAT) {
			BigDecimal saldoUestalsNormalsStunden = gleitzeitsaldoDtoVormonat.getNSaldomehrstunden()
					.multiply(faktormehrstd)
					.add(gleitzeitsaldoDtoVormonat.getNSaldouest200().multiply(faktor200)
							.add(gleitzeitsaldoDtoVormonat.getNSaldouestfrei100().multiply(faktor100)
									.add(gleitzeitsaldoDtoVormonat.getNSaldouestpflichtig100().multiply(faktor100)
											.add(gleitzeitsaldoDtoVormonat.getNSaldouestfrei50().multiply(faktor50)
													.add(gleitzeitsaldoDtoVormonat.getNSaldouestpflichtig50()
															.multiply(faktor50))))));

			// SP9161
			bdSummeStundenabrechnungUestdNormalstunden = Helper
					.rundeKaufmaennisch(bdSummeStundenabrechnungUestdNormalstunden, 2);

			parameter.put("P_UESTD_SALDO_ALS_NORMALSTUNDEN_VORMONAT", saldoUestalsNormalsStunden);
		}

		// SP9161
		bdSummeStundenabrechnungUestdNormalstunden = Helper
				.rundeKaufmaennisch(bdSummeStundenabrechnungUestdNormalstunden, 2);

		parameter.put("P_ABGERECHNETESTUNDEN", bdSummeStundenabrechnungUestdNormalstunden);

		parameter.put("P_ABGERECHNETESTUNDEN_VORMONAT", bdSummeStundenabrechnungUestdNormalstundenVormonat);

		parameter.put("P_ABGERECHNETESTUNDEN_OHNE_UEBERSTUNDEN",
				bdSummeStundenabrechnungUestdNormalstunden.subtract(abAbgerechneteUeberstunden));

		// Ueberstundenpauschale abziehen:
		double fUeberstundenpauschale_abzuziehen = 0;
		// Wenn PlusStunden zwichen 0 und Ueberstundenpauschale, dann ist
		// Ueberstundenpauschale gleich den PlusStunden
		if (bdSummeIst.doubleValue() > 0 && bdSummeIst.doubleValue() <= fUeberstundenpauschale) {
			fUeberstundenpauschale_abzuziehen = bdSummeIst.doubleValue();
		} else if (bdSummeIst.doubleValue() > fUeberstundenpauschale) {
			fUeberstundenpauschale_abzuziehen = fUeberstundenpauschale;
		}
		// Wenn MinusStunden, dann keine Ueberstundenpauschale

		// Stundenausgleich
		BigDecimal bdVorhandeneMehrstunden = bdSummeMEHRSTUNDEN;
		BigDecimal bdVorhandeneUESTD50FREI = bdSummeUEST50FREI;
		BigDecimal bdVorhandeneUESTD50PFLICHTIG = bdSummeUEST50PFLICHTIG;
		BigDecimal bdVorhandeneUESTD100FREI = bdSummeUEST100FREI;
		BigDecimal bdVorhandeneUESTD100PFLICHTIG = bdSummeUEST100PFLICHTIG;
		BigDecimal bdVorhandeneUESTD200 = bdSummeUEST200;

		BigDecimal bdZuverbrauchendeMehrstunden = new BigDecimal(0.00);
		BigDecimal bdZuverbrauchendeUESTD50FREI = new BigDecimal(0.00);
		BigDecimal bdZuverbrauchendeUESTD50PFLICHTIG = new BigDecimal(0.00);
		BigDecimal bdZuverbrauchendeUESTD100FREI = new BigDecimal(0.00);
		BigDecimal bdZuverbrauchendeUESTD100PFLICHTIG = new BigDecimal(0.00);
		BigDecimal bdZuverbrauchendeUESTD200 = new BigDecimal(0.00);

		bdVorhandeneMehrstunden = bdVorhandeneMehrstunden.add(gleitzeitsaldoDto_Vormonat.getNSaldomehrstunden());
		bdVorhandeneUESTD50FREI = bdVorhandeneUESTD50FREI.add(gleitzeitsaldoDto_Vormonat.getNSaldouestfrei50());
		bdVorhandeneUESTD50PFLICHTIG = bdVorhandeneUESTD50PFLICHTIG
				.add(gleitzeitsaldoDto_Vormonat.getNSaldouestpflichtig50());
		bdVorhandeneUESTD100FREI = bdVorhandeneUESTD100FREI.add(gleitzeitsaldoDto_Vormonat.getNSaldouestfrei100());
		bdVorhandeneUESTD100PFLICHTIG = bdVorhandeneUESTD100PFLICHTIG
				.add(gleitzeitsaldoDto_Vormonat.getNSaldouestpflichtig100());
		bdVorhandeneUESTD200 = bdVorhandeneUESTD200.add(gleitzeitsaldoDto_Vormonat.getNSaldouest200());

		// An Report uebergeben
		parameter.put("P_UESTD200VORHANDEN", bdVorhandeneUESTD200);
		parameter.put("P_UESTD100PFLICHTIGVORHANDEN", bdVorhandeneUESTD100PFLICHTIG);
		parameter.put("P_UESTD100FREIVORHANDEN", bdVorhandeneUESTD100FREI);

		// SP2688
		if (bGutstundenZuUest50Addieren) {
			parameter.put("P_UESTD50PFLICHTIGVORHANDEN",
					bdVorhandeneUESTD50PFLICHTIG.add(bdSummeStundenabrechnungGutstunden));
		} else {
			parameter.put("P_UESTD50PFLICHTIGVORHANDEN", bdVorhandeneUESTD50PFLICHTIG);
		}

		parameter.put("P_UESTD50FREIVORHANDEN", bdVorhandeneUESTD50FREI);
		parameter.put("P_MEHRSTUNDENVORHANDEN", bdVorhandeneMehrstunden);

		boolean bStundenWerdenVerbraucht = true;
		if (personalDto.getKollektivDto() != null
				&& Helper.short2boolean(personalDto.getKollektivDto().getBVerbraucheuestd()) == false) {
			bStundenWerdenVerbraucht = false;
		}

		parameter.put("P_FAKTORUESTD50", faktor50);
		parameter.put("P_FAKTORUESTD100", faktor100);
		parameter.put("P_FAKTORUESTD200", faktor200);
		parameter.put("P_FAKTORMEHRSTD", faktormehrstd);

		// SP9056

		BigDecimal bdUestdInNormalstundenNurAktuellesMonat = BigDecimal.ZERO;
		bdUestdInNormalstundenNurAktuellesMonat = bdSummeMEHRSTUNDEN.multiply(faktormehrstd)
				.add(bdSummeUEST50FREI.multiply(faktor50)).add(bdSummeUEST50PFLICHTIG.multiply(faktor50))
				.add(bdSummeUEST100FREI.multiply(faktor100)).add(bdSummeUEST100PFLICHTIG.multiply(faktor100))
				.add(bdSummeUEST200.multiply(faktor200));

		bdUestdInNormalstundenNurAktuellesMonat = Helper.rundeKaufmaennisch(bdUestdInNormalstundenNurAktuellesMonat, 2);

		parameter.put("P_UESTD_IN_NORMALSTUNDEN_NUR_AKTUELLES_MONAT", bdUestdInNormalstundenNurAktuellesMonat);

		if (bStundenWerdenVerbraucht) {

			bdVorhandeneUESTD200 = bdVorhandeneUESTD200.multiply(faktor200);

			bdVorhandeneUESTD100PFLICHTIG = bdVorhandeneUESTD100PFLICHTIG.multiply(faktor100);
			bdVorhandeneUESTD100FREI = bdVorhandeneUESTD100FREI.multiply(faktor100);

			bdVorhandeneUESTD50PFLICHTIG = bdVorhandeneUESTD50PFLICHTIG.multiply(faktor50);
			bdVorhandeneUESTD50FREI = bdVorhandeneUESTD50FREI.multiply(faktor50);

			bdVorhandeneMehrstunden = bdVorhandeneMehrstunden.multiply(faktormehrstd);

			// Nur wenn Gleitzeitsaldo < 0, dann muessen Ueberstunden verbraucht
			// werden
			parameter.put("P_VERBRAUCHTEUESTD", new BigDecimal(0));
			if (personalDto.getKollektivIId() != null) {
				BigDecimal bdZeitsaldoGesamt = bdSummeIst.add(gleitzeitsaldoDto_Vormonat.getNSaldo())
						.subtract(bdSummeStundenabrechnungUestdNormalstunden)
						.subtract(new BigDecimal(fUeberstundenpauschale_abzuziehen)).subtract(nDRZPauschale);

				if (bdZeitsaldoGesamt.doubleValue() < 0) {

					BigDecimal bdZuVerbrauchen = bdZeitsaldoGesamt.abs();

					// CK: 20090123 lt. Kunde werden die Stunden in
					// folgender Reihenfolge verbraucht:
					// zuerst 50P, dann 100P, dann50F und dann 100F
					if (bdZuVerbrauchen.doubleValue() > 0 && bdVorhandeneUESTD50PFLICHTIG.doubleValue() > 0) {
						if (bdVorhandeneUESTD50PFLICHTIG.doubleValue() >= bdZuVerbrauchen.doubleValue()) {
							bdZuverbrauchendeUESTD50PFLICHTIG = bdZuVerbrauchen;
							bdZuVerbrauchen = bdZuVerbrauchen.subtract(bdZuVerbrauchen);
						} else {
							bdZuverbrauchendeUESTD50PFLICHTIG = bdVorhandeneUESTD50PFLICHTIG;
							bdZuVerbrauchen = bdZuVerbrauchen.subtract(bdVorhandeneUESTD50PFLICHTIG);
						}

					}

					if (bdZuVerbrauchen.doubleValue() > 0 && bdZuverbrauchendeUESTD100PFLICHTIG.doubleValue() > 0) {
						if (bdVorhandeneUESTD100PFLICHTIG.doubleValue() >= bdZuVerbrauchen.doubleValue()) {
							bdZuverbrauchendeUESTD100PFLICHTIG = bdZuVerbrauchen;
							bdZuVerbrauchen = bdZuVerbrauchen.subtract(bdZuVerbrauchen);
						} else {
							bdZuverbrauchendeUESTD100PFLICHTIG = bdVorhandeneUESTD100PFLICHTIG;
							bdZuVerbrauchen = bdZuVerbrauchen.subtract(bdVorhandeneUESTD100PFLICHTIG);
						}
					}

					if (bdZuVerbrauchen.doubleValue() > 0 && bdZuverbrauchendeUESTD50FREI.doubleValue() > 0) {
						if (bdVorhandeneUESTD50FREI.doubleValue() >= bdZuVerbrauchen.doubleValue()) {
							bdZuverbrauchendeUESTD50FREI = bdZuVerbrauchen;
							bdZuVerbrauchen = bdZuVerbrauchen.subtract(bdZuVerbrauchen);
						} else {
							bdZuverbrauchendeUESTD50FREI = bdVorhandeneUESTD50FREI;
							bdZuVerbrauchen = bdZuVerbrauchen.subtract(bdVorhandeneUESTD50FREI);
						}

					}
					if (bdZuVerbrauchen.doubleValue() > 0 && bdZuverbrauchendeUESTD100FREI.doubleValue() > 0) {
						if (bdVorhandeneUESTD100FREI.doubleValue() >= bdZuVerbrauchen.doubleValue()) {
							bdZuverbrauchendeUESTD100FREI = bdZuVerbrauchen;
							bdZuVerbrauchen = bdZuVerbrauchen.subtract(bdZuVerbrauchen);
						} else {
							bdZuverbrauchendeUESTD100FREI = bdVorhandeneUESTD100FREI;
							bdZuVerbrauchen = bdZuVerbrauchen.subtract(bdVorhandeneUESTD100FREI);
						}

					}
					if (bdZuVerbrauchen.doubleValue() > 0 && bdVorhandeneUESTD200.doubleValue() > 0) {
						if (bdVorhandeneUESTD200.doubleValue() >= bdZuVerbrauchen.doubleValue()) {
							bdZuverbrauchendeUESTD200 = bdZuVerbrauchen;
							bdZuVerbrauchen = bdZuVerbrauchen.subtract(bdZuVerbrauchen);
						} else {
							bdZuverbrauchendeUESTD200 = bdVorhandeneUESTD200;
							bdZuVerbrauchen = bdZuVerbrauchen.subtract(bdVorhandeneUESTD200);
						}

					}
					// Mehrstunden koennen nur verbraucht werden, wenn Faktor >0
					// sie werden
					// mit
					// dem Gleitzeitsaldo verbraucht

					if (bdZuVerbrauchen.doubleValue() > 0 && bdVorhandeneMehrstunden.doubleValue() > 0) {
						if (bdVorhandeneMehrstunden.doubleValue() >= bdZuVerbrauchen.doubleValue()) {
							bdZuverbrauchendeMehrstunden = bdZuVerbrauchen;
							bdZuVerbrauchen = bdZuVerbrauchen.subtract(bdZuVerbrauchen);
						} else {
							bdZuverbrauchendeMehrstunden = bdVorhandeneMehrstunden;
							bdZuVerbrauchen = bdZuVerbrauchen.subtract(bdVorhandeneMehrstunden);
						}

					}

					BigDecimal bdVerbrauchteUESTD = bdZuverbrauchendeUESTD100PFLICHTIG
							.add(bdZuverbrauchendeUESTD100FREI).add(bdZuverbrauchendeUESTD50PFLICHTIG)
							.add(bdZuverbrauchendeUESTD50FREI).add(bdZuverbrauchendeUESTD200)
							.add(bdZuverbrauchendeMehrstunden);

					parameter.put("P_VERBRAUCHTEUESTD", Helper.rundeKaufmaennisch(bdVerbrauchteUESTD, 2));

					bdSummeIst = bdSummeIst.add(bdVerbrauchteUESTD);

				}

			}

			// Verbrauchte abziehen
			bdVorhandeneUESTD100PFLICHTIG = bdVorhandeneUESTD100PFLICHTIG.subtract(bdZuverbrauchendeUESTD100PFLICHTIG);
			bdVorhandeneUESTD200 = bdVorhandeneUESTD200.subtract(bdZuverbrauchendeUESTD200);
			bdVorhandeneUESTD100FREI = bdVorhandeneUESTD100FREI.subtract(bdZuverbrauchendeUESTD100FREI);
			bdVorhandeneUESTD50PFLICHTIG = bdVorhandeneUESTD50PFLICHTIG.subtract(bdZuverbrauchendeUESTD50PFLICHTIG);
			bdVorhandeneUESTD50FREI = bdVorhandeneUESTD50FREI.subtract(bdZuverbrauchendeUESTD50FREI);
			bdVorhandeneMehrstunden = bdVorhandeneMehrstunden.subtract(bdZuverbrauchendeMehrstunden);

			// Wieder zurueckdividieren

			if (faktor200.doubleValue() != 0) {
				bdVorhandeneUESTD200 = bdVorhandeneUESTD200.divide(faktor200, 4, BigDecimal.ROUND_HALF_EVEN);

			}
			if (faktor100.doubleValue() != 0) {
				bdVorhandeneUESTD100PFLICHTIG = bdVorhandeneUESTD100PFLICHTIG.divide(faktor100, 4,
						BigDecimal.ROUND_HALF_EVEN);
				bdVorhandeneUESTD100FREI = bdVorhandeneUESTD100FREI.divide(faktor100, 4, BigDecimal.ROUND_HALF_EVEN);
			}
			if (faktor50.doubleValue() != 0) {
				bdVorhandeneUESTD50PFLICHTIG = bdVorhandeneUESTD50PFLICHTIG.divide(faktor50, 4,
						BigDecimal.ROUND_HALF_EVEN);
				bdVorhandeneUESTD50FREI = bdVorhandeneUESTD50FREI.divide(faktor50, 4, BigDecimal.ROUND_HALF_EVEN);
			}
			if (faktormehrstd.doubleValue() != 0) {
				bdVorhandeneMehrstunden = bdVorhandeneMehrstunden.divide(faktormehrstd, 4, BigDecimal.ROUND_HALF_EVEN);

			}

		} else {
			parameter.put("P_VERBRAUCHTEUESTD", new BigDecimal(0));
		}

		parameter.put("P_UESTD100PFLICHTIGVERBRAUCHT", bdZuverbrauchendeUESTD100PFLICHTIG);
		parameter.put("P_UESTD200VERBRAUCHT", bdZuverbrauchendeUESTD200);
		parameter.put("P_UESTD100FREIVERBRAUCHT", bdZuverbrauchendeUESTD100FREI);
		parameter.put("P_UESTD50PFLICHTIGVERBRAUCHT", bdZuverbrauchendeUESTD50PFLICHTIG);
		parameter.put("P_UESTD50FREIVERBRAUCHT", bdZuverbrauchendeUESTD50FREI);
		parameter.put("P_MEHRSTUNDENVERBRAUCHT", bdZuverbrauchendeMehrstunden);

		MonatsabrechnungDto monatsabrechnungDto = new MonatsabrechnungDto();

		boolean bSaldenabfrageNurIstAktuellesMonat = false;

		try {
			ParametermandantDto parameterIstZeit = (ParametermandantDto) getParameterFac().getMandantparameter(
					theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
					ParameterFac.PARAMETER_SALDENABFRAGE_NUR_IST_STUNDEN_DES_AKTUELLEN_MONATS);

			bSaldenabfrageNurIstAktuellesMonat = ((Boolean) parameterIstZeit.getCWertAsObject());

		} catch (RemoteException ex5) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex5);
		}

		// SP8203
		parameter.put("P_FAKTOR_PASSIVE_REISEZEIT", iFaktorPassiveReisezeit);
		BigDecimal bdPassiveReiszeitInNormalstunden = BigDecimal.ZERO;
		if (iFaktorPassiveReisezeit > 0) {

			bdPassiveReiszeitInNormalstunden = Helper.getProzentWert(bdSummeReisePassiv,
					new BigDecimal((double) iFaktorPassiveReisezeit), 2);

			bdSummeIst = bdSummeIst.add(bdPassiveReiszeitInNormalstunden);

		}
		parameter.put("P_PASSIVE_REISEZEIT_IN_NORMALSTUNDEN", bdPassiveReiszeitInNormalstunden);

		// PJ18621
		BigDecimal gleizeitsaldoZumAbrechnungszeitpunkt = Helper.rundeKaufmaennisch(gleitzeitsaldoDto_Vormonat
				.getNSaldo().add(bdSummeIst).subtract(bdSummeStundenabrechnungUestdNormalstunden), 2);

		parameter.put("P_GLEITZEITSALDO_ABRECHNUNGSZEITPUNKT", gleizeitsaldoZumAbrechnungszeitpunkt);

		if (bSaldozurueckschreiben == true) {
			GleitzeitsaldoDto dto = null;
			try {
				Query query = em.createNamedQuery("GleitzeitsaldofindByPersonalIIdIJahrIMonat");
				query.setParameter(1, personalIId);
				query.setParameter(2, iJahr);
				query.setParameter(3, iMonat);
				Gleitzeitsaldo gleitzeitsaldo = (Gleitzeitsaldo) query.getSingleResult();
				// if (gleitzeitsaldo==null) {
				// throw new EJBExceptionLP(EJBExceptionLP.
				// FEHLER_BEI_FIND,
				// null);
				// }
				dto = GleitzeitsaldoDtoAssembler.createDto(gleitzeitsaldo);

				if (Helper.short2boolean(dto.getBGesperrt()) == false) {

					if (bdVorhandeneMehrstunden.doubleValue() >= 0) {
						dto.setNSaldomehrstunden(bdVorhandeneMehrstunden);
					} else {
						dto.setNSaldomehrstunden(new BigDecimal(0));
					}

					if (bdVorhandeneUESTD100FREI.doubleValue() >= 0) {

						dto.setNSaldouestfrei100(bdVorhandeneUESTD100FREI);// .
					} else {
						dto.setNSaldouestfrei100(new BigDecimal(0));
					}

					if (bdVorhandeneUESTD200.doubleValue() >= 0) {

						dto.setNSaldouest200(bdVorhandeneUESTD200);// .
					} else {
						dto.setNSaldouest200(new BigDecimal(0));
					}

					if (bdVorhandeneUESTD50FREI.doubleValue() >= 0) {

						dto.setNSaldouestfrei50(bdVorhandeneUESTD50FREI);// .
					} else {
						dto.setNSaldouestfrei50(new BigDecimal(0));
					}

					if (bdVorhandeneUESTD100PFLICHTIG.doubleValue() >= 0) {

						dto.setNSaldouestpflichtig100(bdVorhandeneUESTD100PFLICHTIG);
					} else {
						dto.setNSaldouestpflichtig100(new BigDecimal(0));
					}

					// PJ15624
					// SP2688
					if (bGutstundenZuUest50Addieren) {

						if (bdVorhandeneUESTD50PFLICHTIG.add(bdSummeStundenabrechnungGutstunden).doubleValue() >= 0) {
							dto.setNSaldouestpflichtig50(
									bdVorhandeneUESTD50PFLICHTIG.add(bdSummeStundenabrechnungGutstunden));
						} else {
							dto.setNSaldouestpflichtig50(new BigDecimal(0));
						}

					} else {
						if (bdVorhandeneUESTD50PFLICHTIG.doubleValue() >= 0) {
							dto.setNSaldouestpflichtig50(bdVorhandeneUESTD50PFLICHTIG);
						} else {
							dto.setNSaldouestpflichtig50(new BigDecimal(0));
						}
					}

					// Ueberstundenpauschale und Stundenabrechnung abziehen
					BigDecimal bdSaldo = gleitzeitsaldoDto_Vormonat.getNSaldo()
							.add(bdSummeIst.subtract(new BigDecimal(fUeberstundenpauschale_abzuziehen))
									.subtract(bdSummeStundenabrechnungUestdNormalstunden));

					// PJ19543
					BigDecimal verfalleneUestd = BigDecimal.ZERO;
					if (nMaximaleMehrzeit != null && bdSaldo.doubleValue() > nMaximaleMehrzeit.doubleValue()) {

						BigDecimal bdDiff = bdSaldo.subtract(nMaximaleMehrzeit);
						verfalleneUestd = bdDiff;
						parameter.put("P_VERFALLENE_UEBERSTUNDEN", bdDiff);

						dto = stundenVonGleitzeitsaldoAbziehen(dto, bdDiff);

						bdSaldo = nMaximaleMehrzeit;
					}

					// SP9056

					BigDecimal bdEffektivesIst = bdZeilensummenIst
							.add((BigDecimal) parameter.get("P_SUMMEZUSSONDERTAETIGKEITEN"));
					BigDecimal bdGleitzeitsaldoMonat = bdEffektivesIst
							.subtract((BigDecimal) parameter.get("P_SOLLGESAMT"))
							.subtract(new BigDecimal(dSummeMonatFeiertagSoll))
							.subtract((BigDecimal) parameter.get("P_DRZPAUSCHALE"));

					BigDecimal bdGleitzeitsaldoMitUestdInNormalstunden = bdGleitzeitsaldoMonat
							.subtract(Helper.rundeKaufmaennisch(new BigDecimal(fUeberstundenpauschale_abzuziehen), 2))
							.add(((BigDecimal) parameter.get("P_GZ_SALDO_MIT_UESDTD_IN_NORMALSTUNDEN_VORMONAT"))
									.subtract((BigDecimal) parameter.get("P_GLEITZEITSALDOVORMONAT_UEBERSTUNDEN")))
							.subtract(((BigDecimal) parameter.get("P_ABGERECHNETESTUNDEN"))
									.subtract((BigDecimal) parameter.get("P_ABGERECHNETEUEBERSTUNDEN")))
							.add((BigDecimal) parameter.get("P_VERBRAUCHTEUESTD"))
							.add((BigDecimal) parameter.get("P_PASSIVE_REISEZEIT_IN_NORMALSTUNDEN"));

					bdGleitzeitsaldoMitUestdInNormalstunden = bdGleitzeitsaldoMitUestdInNormalstunden
							.add((BigDecimal) parameter.get("P_UESTD_IN_NORMALSTUNDEN_NUR_AKTUELLES_MONAT"))
							.add((BigDecimal) parameter.get("P_GLEITZEITSALDOVORMONAT_UEBERSTUNDEN"))
							.subtract((BigDecimal) parameter.get("P_ABGERECHNETEUEBERSTUNDEN"))
							.subtract((BigDecimal) parameter.get("P_VERBRAUCHTEUESTD")).subtract(verfalleneUestd);

					dto.setNGzSaldoMitUestdInNormalstunden(bdGleitzeitsaldoMitUestdInNormalstunden);

					dto.setNSaldo(Helper.rundeKaufmaennisch(bdSaldo, 4));
					// P 15964
					if (bSaldenabfrageNurIstAktuellesMonat == false) {
						monatsabrechnungDto.setnSaldo(dto.getNSaldo());
					} else {
						monatsabrechnungDto.setnSaldo(bdSummeIstFuerSaldenabfrage);
					}

					try {
						getPersonalFac().updateGleitzeitsaldo(dto, theClientDto);
					} catch (RemoteException e) {
						throwEJBExceptionLPRespectOld(e);
					}

				}
			} catch (NoResultException e) {

				dto = new GleitzeitsaldoDto();
				dto.setPersonalIId(personalIId);
				dto.setIJahr(iJahr);
				dto.setIMonat(iMonat);

				if (bdVorhandeneMehrstunden.doubleValue() >= 0) {

					dto.setNSaldomehrstunden(bdVorhandeneMehrstunden);
				} else {
					dto.setNSaldomehrstunden(new BigDecimal(0));
				}

				if (bdVorhandeneUESTD200.doubleValue() >= 0) {
					dto.setNSaldouest200(bdVorhandeneUESTD200);
				} else {
					dto.setNSaldouest200(new BigDecimal(0));
				}

				if (bdVorhandeneUESTD100FREI.doubleValue() >= 0) {
					dto.setNSaldouestfrei100(bdVorhandeneUESTD100FREI);
				} else {
					dto.setNSaldouestfrei100(new BigDecimal(0));
				}

				if (bdVorhandeneUESTD50FREI.doubleValue() >= 0) {
					dto.setNSaldouestfrei50(bdVorhandeneUESTD50FREI);
				} else {
					dto.setNSaldouestfrei50(new BigDecimal(0));
				}

				if (bdVorhandeneUESTD100PFLICHTIG.doubleValue() >= 0) {
					dto.setNSaldouestpflichtig100(bdVorhandeneUESTD100PFLICHTIG);
				} else {
					dto.setNSaldouestpflichtig100(new BigDecimal(0));
				}

				// SP2688
				if (bGutstundenZuUest50Addieren) {

					if (bdVorhandeneUESTD50PFLICHTIG.add(bdSummeStundenabrechnungGutstunden).doubleValue() >= 0) {
						dto.setNSaldouestpflichtig50(
								bdVorhandeneUESTD50PFLICHTIG.add(bdSummeStundenabrechnungGutstunden));
					} else {
						dto.setNSaldouestpflichtig50(new BigDecimal(0));
					}

				} else {
					if (bdVorhandeneUESTD50PFLICHTIG.doubleValue() >= 0) {
						dto.setNSaldouestpflichtig50(bdVorhandeneUESTD50PFLICHTIG);
					} else {
						dto.setNSaldouestpflichtig50(new BigDecimal(0));
					}
				}

				BigDecimal bdSaldo = Helper.rundeKaufmaennisch(gleitzeitsaldoDto_Vormonat.getNSaldo().add(bdSummeIst)
						.subtract(bdSummeStundenabrechnungUestdNormalstunden), 4);

				// PJ19543

				BigDecimal verfalleneUestd = BigDecimal.ZERO;

				if (nMaximaleMehrzeit != null && bdSaldo.doubleValue() > nMaximaleMehrzeit.doubleValue()) {

					BigDecimal bdDiff = bdSaldo.subtract(nMaximaleMehrzeit);

					verfalleneUestd = bdDiff;

					parameter.put("P_VERFALLENE_UEBERSTUNDEN", bdDiff);

					bdSaldo = nMaximaleMehrzeit;
				}

				dto.setNSaldo(bdSaldo);

				// SP9056

				BigDecimal bdEffektivesIst = bdZeilensummenIst
						.add((BigDecimal) parameter.get("P_SUMMEZUSSONDERTAETIGKEITEN"));
				BigDecimal bdGleitzeitsaldoMonat = bdEffektivesIst.subtract((BigDecimal) parameter.get("P_SOLLGESAMT"))
						.subtract(new BigDecimal(dSummeMonatFeiertagSoll))
						.subtract((BigDecimal) parameter.get("P_DRZPAUSCHALE"));

				BigDecimal bdGleitzeitsaldoMitUestdInNormalstunden = bdGleitzeitsaldoMonat
						.subtract(Helper.rundeKaufmaennisch(new BigDecimal(fUeberstundenpauschale_abzuziehen), 2))
						.add(((BigDecimal) parameter.get("P_GZ_SALDO_MIT_UESDTD_IN_NORMALSTUNDEN_VORMONAT"))
								.subtract((BigDecimal) parameter.get("P_GLEITZEITSALDOVORMONAT_UEBERSTUNDEN")))
						.subtract(((BigDecimal) parameter.get("P_ABGERECHNETESTUNDEN"))
								.subtract((BigDecimal) parameter.get("P_ABGERECHNETEUEBERSTUNDEN")))
						.add((BigDecimal) parameter.get("P_VERBRAUCHTEUESTD"))
						.add((BigDecimal) parameter.get("P_PASSIVE_REISEZEIT_IN_NORMALSTUNDEN"));

				bdGleitzeitsaldoMitUestdInNormalstunden = bdGleitzeitsaldoMitUestdInNormalstunden
						.add((BigDecimal) parameter.get("P_UESTD_IN_NORMALSTUNDEN_NUR_AKTUELLES_MONAT"))
						.add((BigDecimal) parameter.get("P_GLEITZEITSALDOVORMONAT_UEBERSTUNDEN"))
						.subtract((BigDecimal) parameter.get("P_ABGERECHNETEUEBERSTUNDEN"))
						.subtract((BigDecimal) parameter.get("P_VERBRAUCHTEUESTD")).subtract(verfalleneUestd);
				dto.setNGzSaldoMitUestdInNormalstunden(bdGleitzeitsaldoMitUestdInNormalstunden);

				// P 15964
				if (bSaldenabfrageNurIstAktuellesMonat == false) {
					monatsabrechnungDto.setnSaldo(dto.getNSaldo());
				} else {
					monatsabrechnungDto.setnSaldo(bdSummeIstFuerSaldenabfrage);
				}

				// Ueberstundenpauschale abziehen:
				dto.setNSaldouestpflichtig50(
						dto.getNSaldouestpflichtig50().subtract(new BigDecimal(fUeberstundenpauschale_abzuziehen)));

				try {
					dto = getPersonalFac()
							.gleitzeitsaldoFindByPrimaryKey(getPersonalFac().createGleitzeitsaldo(dto, theClientDto));
				} catch (RemoteException ex9) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex9);
				}
			}

			// Verbleibende Stunden berechnen
			BigDecimal bdUebrigeNormalStunden = dto.getNSaldouestfrei100().multiply(faktor100);
			bdUebrigeNormalStunden = bdUebrigeNormalStunden.add(dto.getNSaldouestpflichtig100().multiply(faktor100));
			bdUebrigeNormalStunden = bdUebrigeNormalStunden.add(dto.getNSaldouestfrei50().multiply(faktor50));
			bdUebrigeNormalStunden = bdUebrigeNormalStunden.add(dto.getNSaldouestpflichtig50().multiply(faktor50));
			bdUebrigeNormalStunden = bdUebrigeNormalStunden.add(dto.getNSaldomehrstunden().multiply(faktormehrstd));

			// Automatische Auszahlung, wenn Flag gesetzt und Ist groesser als
			// Puffer
			if (iUeberstundenAutomatischAuszahlen > ZeiterfassungFac.UESTAUSZAHLEN_KEINE
					&& bdUebrigeNormalStunden.add(bdSummeIst).doubleValue() > bdUeberstundenPuffer.doubleValue()) {
				Calendar cStundenabrechnung = Calendar.getInstance();
				cStundenabrechnung.set(Calendar.YEAR, iJahr);
				cStundenabrechnung.set(Calendar.MONTH, iMonat);

				if (iUeberstundenAutomatischAuszahlen == ZeiterfassungFac.UESTAUSZAHLEN_FOLGEMONAT) {
					cStundenabrechnung.set(Calendar.DAY_OF_MONTH, 1);
					cStundenabrechnung.set(Calendar.MONTH, cStundenabrechnung.get(Calendar.MONTH) + 1);
				} else if (iUeberstundenAutomatischAuszahlen == ZeiterfassungFac.UESTAUSZAHLEN_ABRECHNUNGSMONAT) {
					cStundenabrechnung.set(Calendar.DAY_OF_MONTH,
							cStundenabrechnung.getActualMaximum(Calendar.DAY_OF_MONTH));
				}

				StundenabrechnungDto stundenabrechnungDto = new StundenabrechnungDto();
				stundenabrechnungDto.setPersonalIId(personalIId);
				stundenabrechnungDto
						.setTDatum(Helper.cutTimestamp(new Timestamp(cStundenabrechnung.getTimeInMillis())));

				stundenabrechnungDto.setCKommentar("AUTOMATISCHE-AUSZAHLUNG");
				stundenabrechnungDto.setNGutstunden(new BigDecimal(0));

				stundenabrechnungDto.setNQualifikationspraemie(new BigDecimal(0));

				BigDecimal auszuzahlendeStunden = bdUebrigeNormalStunden
						.add(bdSummeIst.add(gleitzeitsaldoDto_Vormonat.getNSaldo()))
						.subtract(bdSummeStundenabrechnungUestdNormalstunden)
						.subtract(new BigDecimal(fUeberstundenpauschale_abzuziehen)).subtract(bdUeberstundenPuffer);

				parameter.put("P_AUSBEZAHLTE_NORMALSTUNDEN_AUFGRUND_AUSZAHLUNGSAUTOMATIK", auszuzahlendeStunden);

				if (auszuzahlendeStunden.doubleValue() > 0) {

					// 200% Steuerpflichtig vorhanden
					if (auszuzahlendeStunden.doubleValue() > 0) {
						BigDecimal bdVorh = dto.getNSaldouest200().multiply(faktor200);
						if (auszuzahlendeStunden.doubleValue() >= bdVorh.doubleValue()) {
							stundenabrechnungDto.setNUest200(dto.getNSaldouest200());
							auszuzahlendeStunden = auszuzahlendeStunden.subtract(bdVorh);
							dto.setNSaldouest200(BigDecimal.ZERO);
						} else {
							stundenabrechnungDto
									.setNUest200(auszuzahlendeStunden.divide(faktor200, BigDecimal.ROUND_HALF_EVEN));
							auszuzahlendeStunden = new BigDecimal(0);
						}
					} // 100% Steuerpflichtig vorhanden
					if (auszuzahlendeStunden.doubleValue() > 0) {
						BigDecimal bdVorh = dto.getNSaldouestpflichtig100().multiply(faktor100);
						if (auszuzahlendeStunden.doubleValue() >= bdVorh.doubleValue()) {
							stundenabrechnungDto.setNUestpflichtig100(dto.getNSaldouestpflichtig100());
							auszuzahlendeStunden = auszuzahlendeStunden.subtract(bdVorh);
							dto.setNSaldouestpflichtig100(BigDecimal.ZERO);
						} else {
							stundenabrechnungDto.setNUestpflichtig100(
									auszuzahlendeStunden.divide(faktor100, BigDecimal.ROUND_HALF_EVEN));
							auszuzahlendeStunden = new BigDecimal(0);
						}
					}
					// 100% Steuerfrei vorhanden
					if (auszuzahlendeStunden.doubleValue() > 0) {
						BigDecimal bdVorh = dto.getNSaldouestfrei100().multiply(faktor100);
						if (auszuzahlendeStunden.doubleValue() >= bdVorh.doubleValue()) {
							stundenabrechnungDto.setNUestfrei100(dto.getNSaldouestfrei100());
							auszuzahlendeStunden = auszuzahlendeStunden.subtract(bdVorh);
							dto.setNSaldouestfrei100(BigDecimal.ZERO);
						} else {
							stundenabrechnungDto.setNUestfrei100(
									auszuzahlendeStunden.divide(faktor100, BigDecimal.ROUND_HALF_EVEN));
							auszuzahlendeStunden = new BigDecimal(0);
						}
					}
					// 50% Steuerpflichtig vorhanden
					if (auszuzahlendeStunden.doubleValue() > 0) {
						BigDecimal bdVorh = dto.getNSaldouestpflichtig50().multiply(faktor50);
						if (auszuzahlendeStunden.doubleValue() >= bdVorh.doubleValue()) {
							stundenabrechnungDto.setNUestpflichtig50(dto.getNSaldouestpflichtig50());
							auszuzahlendeStunden = auszuzahlendeStunden.subtract(bdVorh);
							dto.setNSaldouestpflichtig50(BigDecimal.ZERO);
						} else {
							stundenabrechnungDto.setNUestpflichtig50(
									auszuzahlendeStunden.divide(faktor50, BigDecimal.ROUND_HALF_EVEN));
							dto.setNSaldouestpflichtig50(dto.getNSaldouestpflichtig50()
									.subtract(stundenabrechnungDto.getNUestpflichtig50()));
							auszuzahlendeStunden = new BigDecimal(0);
						}
					}
					// 50% Steuerfrei vorhanden
					if (auszuzahlendeStunden.doubleValue() > 0) {
						BigDecimal bdVorh = dto.getNSaldouestfrei50().multiply(faktor50);
						if (auszuzahlendeStunden.doubleValue() >= bdVorh.doubleValue()) {
							stundenabrechnungDto.setNUestfrei50(dto.getNSaldouestfrei50());
							auszuzahlendeStunden = auszuzahlendeStunden.subtract(bdVorh);
							dto.setNSaldouestfrei50(BigDecimal.ZERO);
						} else {
							stundenabrechnungDto
									.setNUestfrei50(auszuzahlendeStunden.divide(faktor50, BigDecimal.ROUND_HALF_EVEN));
							auszuzahlendeStunden = new BigDecimal(0);
						}
					}
					// Mehrstunden vorhanden
					if (auszuzahlendeStunden.doubleValue() > 0) {
						BigDecimal bdVorh = dto.getNSaldomehrstunden().multiply(faktormehrstd);
						if (auszuzahlendeStunden.doubleValue() >= bdVorh.doubleValue()) {
							stundenabrechnungDto.setNMehrstunden(dto.getNSaldomehrstunden());
							auszuzahlendeStunden = auszuzahlendeStunden.subtract(bdVorh);
							dto.setNSaldomehrstunden(BigDecimal.ZERO);
						} else {
							stundenabrechnungDto.setNMehrstunden(
									auszuzahlendeStunden.divide(faktormehrstd, BigDecimal.ROUND_HALF_EVEN));
							auszuzahlendeStunden = new BigDecimal(0);
						}
					}

					// SP5491
					if (auszuzahlendeStunden.doubleValue() > 0) {
						stundenabrechnungDto.setNNormalstunden(auszuzahlendeStunden);

					} else {
						stundenabrechnungDto.setNNormalstunden(new BigDecimal(0));
					}

					// Vom Gleitzeitsaldo im gleichen Monat abziehen
					if (iUeberstundenAutomatischAuszahlen == ZeiterfassungFac.UESTAUSZAHLEN_ABRECHNUNGSMONAT) {
						dto.setNSaldo(dto.getNSaldo().subtract(auszuzahlendeStunden));

						try {
							getPersonalFac().updateGleitzeitsaldo(dto, theClientDto);
						} catch (RemoteException ex9) {
							throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex9);
						}
					}

					try {
						StundenabrechnungDto stundenabrechnungDtoTemp = getPersonalFac()
								.stundenabrechnungFindByPersonalIIdDDatum(personalIId,
										Helper.cutTimestamp(new Timestamp(cStundenabrechnung.getTimeInMillis())));

						if (stundenabrechnungDtoTemp != null) {
							stundenabrechnungDto.setIId(stundenabrechnungDtoTemp.getIId());
							getPersonalFac().updateStundenabrechnung(stundenabrechnungDto, theClientDto);
						} else {
							try {
								getPersonalFac().createStundenabrechnung(stundenabrechnungDto, theClientDto);
							} catch (RemoteException ex7) {
								throwEJBExceptionLPRespectOld(ex7);
							}

						}
					}

					catch (RemoteException ex3) {
						throwEJBExceptionLPRespectOld(ex3);
					}

				} else {
					// SP7820
					try {
						StundenabrechnungDto stundenabrechnungDtoTemp = getPersonalFac()
								.stundenabrechnungFindByPersonalIIdDDatum(personalIId,
										Helper.cutTimestamp(new Timestamp(cStundenabrechnung.getTimeInMillis())));
						if (stundenabrechnungDtoTemp != null
								&& "AUTOMATISCHE-AUSZAHLUNG".equals(stundenabrechnungDtoTemp.getCKommentar())) {
							getPersonalFac().removeStundenabrechnung(stundenabrechnungDtoTemp);
						}
					} catch (RemoteException ex3) {
						throwEJBExceptionLPRespectOld(ex3);
					}
				}

			} else {
				if (iUeberstundenAutomatischAuszahlen > ZeiterfassungFac.UESTAUSZAHLEN_KEINE) {
					// SP961 Wenn nicht mehr zutrifft, dann die Zeile loeschen

					Calendar cStundenabrechnung = Calendar.getInstance();
					cStundenabrechnung.set(Calendar.YEAR, iJahr);
					cStundenabrechnung.set(Calendar.MONTH, iMonat);

					if (iUeberstundenAutomatischAuszahlen == ZeiterfassungFac.UESTAUSZAHLEN_FOLGEMONAT) {
						cStundenabrechnung.set(Calendar.DAY_OF_MONTH, 1);
						cStundenabrechnung.set(Calendar.MONTH, cStundenabrechnung.get(Calendar.MONTH) + 1);
					} else if (iUeberstundenAutomatischAuszahlen == ZeiterfassungFac.UESTAUSZAHLEN_ABRECHNUNGSMONAT) {
						cStundenabrechnung.set(Calendar.DAY_OF_MONTH,
								cStundenabrechnung.getActualMaximum(Calendar.DAY_OF_MONTH));
					}
					try {
						StundenabrechnungDto stundenabrechnungDtoTemp = getPersonalFac()
								.stundenabrechnungFindByPersonalIIdDDatum(personalIId,
										Helper.cutTimestamp(new Timestamp(cStundenabrechnung.getTimeInMillis())));
						if (stundenabrechnungDtoTemp != null
								&& "AUTOMATISCHE-AUSZAHLUNG".equals(stundenabrechnungDtoTemp.getCKommentar())) {
							getPersonalFac().removeStundenabrechnung(stundenabrechnungDtoTemp);
						}
					} catch (RemoteException ex3) {
						throwEJBExceptionLPRespectOld(ex3);
					}
				}
			}

		}
		// Erstellung des Reports
		index = -1;
		sAktuellerReport = ZeiterfassungFac.REPORT_MONATSABRECHNUNG;

		parameter.put("P_PERSONAL", personalDto.formatAnrede());
		parameter.put("P_PERSONALNUMMER", personalDto.getCPersonalnr());
		if (personalDto.getKollektivDto() != null) {
			parameter.put("P_KOLLEKTIV", personalDto.getKollektivDto().getCBez());
			parameter.put("P_KOLLEKTIV_ABRECHNUNGSART", personalDto.getKollektivDto().getCAbrechungsart());
		} else {
			// SP6125
			parameter.put("P_KOLLEKTIV_ABRECHNUNGSART", PersonalFac.KOLLEKTIV_ABRECHNUNGSART_STANDARD);
		}

		parameter.put("P_SORTIERUNG",
				getZeiterfassungFac().getParameterSortierungZeitauswertungen(iOptionSortierung, theClientDto));

		parameter.put("P_FEIERTAGSOLL", new BigDecimal(dSummeMonatFeiertagSoll));

		// PJ21325
		BigDecimal bdSaldoAbrechnungsmonatOhneVormonat = bdSummeIstFuerSaldenabfrage.subtract(bdSummeSoll);
		parameter.put("P_GLEITZEITSALDO_NUR_ABRECHNUNGSMONAT", new BigDecimal(dSummeMonatFeiertagSoll));
		monatsabrechnungDto.setGleitzeitsaldoAbrechnungsmonatOhneVormonat(bdSaldoAbrechnungsmonatOhneVormonat);
		boolean bTeilzeit = false;

		try {

			parameter.put("P_PERSONALART", getPersonalFac()
					.personalartFindByPrimaryKey(personalDto.getPersonalartCNr(), theClientDto).getBezeichnung());

			PersonalzeitmodellDto personalzeitmodellDto = getPersonalFac().personalzeitmodellFindZeitmodellZuDatum(
					personalIId, new java.sql.Timestamp(cal.getTime().getTime()), theClientDto);
			if (personalzeitmodellDto != null) {
				parameter.put("P_ZEITMODELL", personalzeitmodellDto.getZeitmodellDto().getCNr());

				parameter.put("P_TEILZEIT",
						Helper.short2Boolean(personalzeitmodellDto.getZeitmodellDto().getBTeilzeit()));

				bTeilzeit = Helper.short2Boolean(personalzeitmodellDto.getZeitmodellDto().getBTeilzeit());

			} else {
				parameter.put("P_ZEITMODELL", "Kein Zeitmodell zugeordnet");
				parameter.put("P_TEILZEIT", new Boolean(false));
			}
		} catch (RemoteException ex11) {
			parameter.put("P_ZEITMODELL", "Kein Zeitmodell zugeordnet");
		}

		try {

			// Resturlaub zum Wechsel des Urlaubsjahres festschreiben
			boolean bUrlaubsabrechnungZumEintrittsdatum = false;

			try {
				ParametermandantDto parameterUrlaubsabrechnung = (ParametermandantDto) getParameterFac()
						.getMandantparameter(theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
								ParameterFac.PARAMETER_URLAUBSABRECHNUNG_ZUM_EINTRITT);

				bUrlaubsabrechnungZumEintrittsdatum = (Boolean) parameterUrlaubsabrechnung.getCWertAsObject();
			} catch (RemoteException e) {
				throwEJBExceptionLPRespectOld(e);
			}

			// Urlaubsberechnung des Vorjahres
			try {
				Calendar c = Calendar.getInstance();

				// set Date auf den letzten Tag des Vorjahres

				if (bUrlaubsabrechnungZumEintrittsdatum) {

					Calendar cEintrittsdatum = Calendar.getInstance();
					cEintrittsdatum.setTimeInMillis(dEintrittsdatum.getTime());

					c.set(c.YEAR, getUrlaubsjahrAnhandAbrechnungszeitpunkt(d_datum_bis,
							bUrlaubsabrechnungZumEintrittsdatum, dEintrittsdatum) - 1);
					c.set(c.MONTH, cEintrittsdatum.get(Calendar.MONTH));
					c.set(c.DATE, cEintrittsdatum.get(Calendar.DAY_OF_MONTH));
					c.set(c.HOUR_OF_DAY, 23);
					c.set(c.MINUTE, 59);
					c.set(c.SECOND, 59);
					c.add(Calendar.DAY_OF_MONTH, -1);
				} else {
					c.set(c.YEAR, iJahr.intValue() - 1);
					c.set(c.MONTH, c.DECEMBER);
					c.set(c.DATE, 31);

					c.set(c.HOUR_OF_DAY, 23);
					c.set(c.MINUTE, 59);
					c.set(c.SECOND, 59);
				}

				java.sql.Date d_vorjahr = new java.sql.Date(c.getTime().getTime());

				if (dEintrittsdatum.before(d_vorjahr)) {

					UrlaubsabrechnungDto urlaubsabrechnungVorjahrDto = berechneUrlaubsAnspruch(personalIId, d_vorjahr,
							theClientDto);

					parameter.put("P_VORJAHRURLAUBSANSPRUCHSTUNDEN",
							urlaubsabrechnungVorjahrDto.getNAktuellerUrlaubsanspruchStunden());

					parameter.put("P_VORJAHRVERFUEGBARERURLAUBSTUNDEN",
							urlaubsabrechnungVorjahrDto.getNVerfuegbarerUrlaubStunden());

					parameter.put("P_VORJAHRURLAUBSANSPRUCHTAGE",
							urlaubsabrechnungVorjahrDto.getNAktuellerUrlaubsanspruchTage());

					parameter.put("P_VORJAHRVERFUEGBARERURLAUBTAGE",
							urlaubsabrechnungVorjahrDto.getNVerfuegbarerUrlaubTage());

				}

			} catch (EJBExceptionLP ex6) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex6);
			}
			java.sql.Date dDatumUrlaubsabrechnung = new java.sql.Date(d_datum_bis.getTime());
			if (dAustrittsdatum.before(d_datum_bis)) {
				dDatumUrlaubsabrechnung = new java.sql.Date(Helper.addiereTageZuDatum(dAustrittsdatum, -1).getTime());
			}

			parameter.put("P_URLAUBSABRECHNUNG_ZUM_EINTRITT", bUrlaubsabrechnungZumEintrittsdatum);

			if (bUrlaubsabrechnungZumEintrittsdatum) {
				Calendar cEintrittsdatum = Calendar.getInstance();
				cEintrittsdatum.setTimeInMillis(dEintrittsdatum.getTime());
				if (iMonat == cEintrittsdatum.get(Calendar.MONTH)) {
					cEintrittsdatum.set(Calendar.YEAR, iJahr);
					cEintrittsdatum.add(Calendar.DAY_OF_MONTH, -1);

					if (cEintrittsdatum.getTime().after(dEintrittsdatum)) {

						berechneUrlaubsAnspruch(personalIId, new java.sql.Date(cEintrittsdatum.getTime().getTime()),
								theClientDto);
					}
				}
			}

			UrlaubsabrechnungDto urlaubsabrechnungDto = berechneUrlaubsAnspruch(personalIId, dDatumUrlaubsabrechnung,
					theClientDto);

			parameter.put("P_STICHTAG_RESTURLAUB_BIS", urlaubsabrechnungDto.getDAktuellerUrlaubsbeginn());

			parameter.put("P_AKTUELLERURLAUBSANSPRUCHSTUNDEN",
					urlaubsabrechnungDto.getNAktuellerUrlaubsanspruchStunden());

			parameter.put("P_AKTUELLERURLAUBSVERBRAUCHTSTUNDEN",
					urlaubsabrechnungDto.getNAktuellerUrlaubVerbrauchtStunden());

			parameter.put("P_ALTERURLAUBSANSPRUCHSTUNDEN", urlaubsabrechnungDto.getNAlterUrlaubsanspruchStunden());

			parameter.put("P_GEPLANTERURLAUBSTUNDEN", urlaubsabrechnungDto.getNGeplanterUrlaubStunden());

			parameter.put("P_VERFUEGBARERURLAUBSTUNDEN", urlaubsabrechnungDto.getNVerfuegbarerUrlaubStunden());

			parameter.put("P_ALIQUOTERURLAUBSTUNDEN", urlaubsabrechnungDto.getNAliquoterAnspruchStunden());

			parameter.put("P_AKTUELLERURLAUBSANSPRUCHTAGE", urlaubsabrechnungDto.getNAktuellerUrlaubsanspruchTage());

			parameter.put("P_AKTUELLERURLAUBSVERBRAUCHTTAGE", urlaubsabrechnungDto.getNAktuellerUrlaubVerbrauchtTage());

			parameter.put("P_ALTERURLAUBSANSPRUCHTAGE", urlaubsabrechnungDto.getNAlterUrlaubsanspruchTage());

			parameter.put("P_GEPLANTERURLAUBTAGE", urlaubsabrechnungDto.getNGeplanterUrlaubTage());

			parameter.put("P_VERFUEGBARERURLAUBTAGE", urlaubsabrechnungDto.getNVerfuegbarerUrlaubTage());

			if (bTeilzeit == false) {
				monatsabrechnungDto.setNVerfuegbarerurlaub(urlaubsabrechnungDto.getNAlterUrlaubsanspruchTage()
						.add(urlaubsabrechnungDto.getNAktuellerUrlaubsanspruchTage())
						.subtract(urlaubsabrechnungDto.getNAktuellerUrlaubVerbrauchtTage()));
				monatsabrechnungDto.setsEinheitVerfuegbarerUrlaub(getTextRespectUISpr("pers.monatsabrechnung.tage",
						theClientDto.getMandant(), theClientDto.getLocUi()));

			} else {
				monatsabrechnungDto.setNVerfuegbarerurlaub(urlaubsabrechnungDto.getNAlterUrlaubsanspruchStunden()
						.add(urlaubsabrechnungDto.getNAktuellerUrlaubsanspruchStunden())
						.subtract(urlaubsabrechnungDto.getNAktuellerUrlaubVerbrauchtStunden()));
				monatsabrechnungDto.setsEinheitVerfuegbarerUrlaub(getTextRespectUISpr("pers.monatsabrechnung.stunden",
						theClientDto.getMandant(), theClientDto.getLocUi()));
			}

			parameter.put("P_ALIQUOTERURLAUBTAGE", urlaubsabrechnungDto.getNAliquoterAnspruchTage());
		} catch (EJBExceptionLP ex6) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex6);
		}

		// Bereitschaften
		String[] fieldnames = new String[] { "F_ART", "F_VON", "F_BIS", "F_BEMERKUNG", "F_KW", "F_TAG", "F_DAUER",
				"F_FEIERTAG" };
		Object[][] zeilenBereitschaften = new Object[alBereitschaften.size()][fieldnames.length];
		for (int i = 0; i < alBereitschaften.size(); i++) {
			zeilenBereitschaften[i][0] = alBereitschaften.get(i).getBereitschaftsart();
			zeilenBereitschaften[i][1] = alBereitschaften.get(i).gettVon();
			zeilenBereitschaften[i][2] = alBereitschaften.get(i).gettBis();
			zeilenBereitschaften[i][3] = alBereitschaften.get(i).getBemerkung();

			zeilenBereitschaften[i][4] = alBereitschaften.get(i).getKw();
			zeilenBereitschaften[i][5] = alBereitschaften.get(i).getTagesartCNr();
			zeilenBereitschaften[i][6] = alBereitschaften.get(i).getdDauer();
			zeilenBereitschaften[i][7] = alBereitschaften.get(i).getFeiertag();
		}

		parameter.put("P_SUBREPORT_BEREITSCHAFTEN", new LPDatenSubreport(zeilenBereitschaften, fieldnames));

		// Ueberstundenpauschale
		parameter.put("P_UEBERSTUNDENPAUSCHALE",
				Helper.rundeKaufmaennisch(new BigDecimal(fUeberstundenpauschale_abzuziehen), 2));

		parameter.put("P_MONAT",
				new DateFormatSymbols(theClientDto.getLocUi()).getMonths()[iMonat.intValue()] + " " + iJahr);

		parameter.put("P_MONATSABRECHNUNG_NUR_AB_TAGESIST", dNurWennTagesistGroesser);

		cal.set(iJahr.intValue(), iMonat.intValue(), 1);

		data = new Object[monatsabrechnungZeilen.size()][REPORT_MONATSABRECHNUNG_ANZAHL_SPALTEN];

		for (int i = 0; i < monatsabrechnungZeilen.size(); i++) {
			ZeileMonatsabrechnungDto z = (ZeileMonatsabrechnungDto) monatsabrechnungZeilen.get(i);
			data[i][REPORT_MONATSABRECHNUNG_ARZT] = z.getBdArzt();
			data[i][REPORT_MONATSABRECHNUNG_BEHOERDE] = z.getBdBehoerde();
			data[i][REPORT_MONATSABRECHNUNG_BEMERKUNG] = z.getSBemerkung();
			data[i][REPORT_MONATSABRECHNUNG_BIS] = z.getTBis();
			data[i][REPORT_MONATSABRECHNUNG_TAGESART] = z.getSTagesart();
			data[i][REPORT_MONATSABRECHNUNG_SUBREPORT_ZULAGEN] = z.getSubreportZulagen();
			data[i][REPORT_MONATSABRECHNUNG_SUBREPORT_SCHICHTZEITEN] = z.getSubreportSchichtzeiten();
			data[i][REPORT_MONATSABRECHNUNG_SCHICHTZEITEN_FUER_EXPORT] = z.getHMSchichtzeitenFuerExport();
			data[i][REPORT_MONATSABRECHNUNG_SONSTIGE_SONDERTAETIGKEITEN_FUER_EXPORT] = z.getHmSonstigeTaetigkeiten();

			Calendar cCal = Calendar.getInstance();
			cCal.setTimeInMillis(z.getTDatum().getTime());
			Integer iTag = cCal.get(Calendar.DATE);
			data[i][REPORT_MONATSABRECHNUNG_TAG] = iTag;

			data[i][REPORT_MONATSABRECHNUNG_DATUM] = z.getTDatum();

			data[i][REPORT_MONATSABRECHNUNG_DIFF] = z.getBdDiff();
			data[i][REPORT_MONATSABRECHNUNG_FEIERTAG] = z.getBdFeiertag();
			data[i][REPORT_MONATSABRECHNUNG_IST] = z.getBdIst();
			data[i][REPORT_MONATSABRECHNUNG_KALENDERWOCHE] = z.getIKw();
			data[i][REPORT_MONATSABRECHNUNG_KRANK] = z.getBdKrank();
			data[i][REPORT_MONATSABRECHNUNG_KINDKRANK] = z.getBdKindkrank();
			data[i][REPORT_MONATSABRECHNUNG_SOLL] = z.getBdSoll();
			data[i][REPORT_MONATSABRECHNUNG_SONSTIGE_BEZAHLTETAETIGKEITEN] = z.getBdSonstigeBezahlt();
			data[i][REPORT_MONATSABRECHNUNG_ZEITMODELL] = z.getSZeitmodell();
			data[i][REPORT_MONATSABRECHNUNG_ZEITMODELL_I_ID] = z.getZeitmodellIId();
			data[i][REPORT_MONATSABRECHNUNG_SONSTIGE_UNBEZAHLTETAETIGKEITEN] = z.getBdSonstigeNichtBezahlt();
			data[i][REPORT_MONATSABRECHNUNG_WOCHENTAG] = z.getSTag();
			data[i][REPORT_MONATSABRECHNUNG_UESTD100] = z.getBdUestd100();
			data[i][REPORT_MONATSABRECHNUNG_UESTD200] = z.getBdUestd200();
			data[i][REPORT_MONATSABRECHNUNG_UESTD100FREI] = z.getBdUestd100Steuerfrei();
			data[i][REPORT_MONATSABRECHNUNG_UESTD50] = z.getBdUestd50();
			data[i][REPORT_MONATSABRECHNUNG_UESTD50TAGEWEISE] = z.getBdUestd50Tageweise();
			data[i][REPORT_MONATSABRECHNUNG_UESTD50TAGESWEISEFREI] = z.getBdUestd50TageweiseSteuerfrei();
			data[i][REPORT_MONATSABRECHNUNG_MEHRZEIT] = z.getBdMehrstunden();
			data[i][REPORT_MONATSABRECHNUNG_UNTER] = z.getBdUnter();
			data[i][REPORT_MONATSABRECHNUNG_URLAUB] = z.getBdUrlaubStunden();
			data[i][REPORT_MONATSABRECHNUNG_URLAUBTAGEWEISE] = z.getBdUrlaubTage();
			data[i][REPORT_MONATSABRECHNUNG_URLAUB_AUTOMATIK] = z.getbUrlaubAutomatik();
			data[i][REPORT_MONATSABRECHNUNG_VON] = z.getTVon();
			data[i][REPORT_MONATSABRECHNUNG_ZEITAUSGLEICH] = z.getBdZA();
			data[i][REPORT_MONATSABRECHNUNG_ZUSATZBEZEICHNUNG] = z.getSZusatzbezeichnung();
			data[i][REPORT_MONATSABRECHNUNG_REISE] = z.getBdReise();
			data[i][REPORT_MONATSABRECHNUNG_REISE_PASSIV] = z.getBdReisePassiv();
			data[i][REPORT_MONATSABRECHNUNG_JAHR] = z.getIJahr();
			data[i][REPORT_MONATSABRECHNUNG_MONAT] = z.getIMonat();
			data[i][REPORT_MONATSABRECHNUNG_QUALIFIKATIONSFAKTOR] = z.getBdQualifikationsfaktor();

			data[i][REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_KOMMT] = z.getBdGutschriftKommt();
			data[i][REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_GEHT] = z.getBdGutschriftGeht();
			if (z.getBetriebsvereinbarungADto() != null) {
				data[i][REPORT_MONATSABRECHNUNG_BV_A_GLEITZEIT] = z.getBetriebsvereinbarungADto().getBdGleitzeit();
				data[i][REPORT_MONATSABRECHNUNG_BV_A_UEST50_UEBER_GLEITZEIT] = z.getBetriebsvereinbarungADto()
						.getBd50ProzentWennGleitzeitUeberschritten();
				data[i][REPORT_MONATSABRECHNUNG_BV_A_UESTD50] = z.getBetriebsvereinbarungADto().getBd50Prozent();
				data[i][REPORT_MONATSABRECHNUNG_BV_A_UESDT100] = z.getBetriebsvereinbarungADto().getBd100Prozent();
				data[i][REPORT_MONATSABRECHNUNG_BV_A_UESDT100_ZUSCHLAG] = z.getBetriebsvereinbarungADto()
						.getBd100ProzentZuschlag();
				data[i][REPORT_MONATSABRECHNUNG_BV_A_UEST50_UEBER_GLEITZEIT_ZUSCHLAG] = z.getBetriebsvereinbarungADto()
						.getBd50ProzentWennGleitzeitUeberschrittenZuschlag();
				data[i][REPORT_MONATSABRECHNUNG_BV_A_UESTD50_ZUSCHLAG] = z.getBetriebsvereinbarungADto()
						.getBd50ProzentZuschlag();

			}

		}

		initJRDS(parameter, ZeiterfassungFac.REPORT_MODUL, ZeiterfassungFac.REPORT_MONATSABRECHNUNG,
				theClientDto.getMandant(), theClientDto.getLocUi(), theClientDto);
		monatsabrechnungDto.setJasperPrint(this.getReportPrint());
		monatsabrechnungDto.setData(data.clone());
		monatsabrechnungDto.setParameter(parameter);
		return monatsabrechnungDto;
	}

	private ZeileMonatsabrechnungDto feiertagBerechnen(Integer personalIId, TheClientDto theClientDto,
			PersonalDto personalDto, Integer tagesartIId_Halbtag, Timestamp tTag, Integer iZeitmodellId,
			ZeileMonatsabrechnungDto zeile, boolean bFeiertagAmNaechstenTag) {

		BetriebskalenderDto dto = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(Helper.cutTimestamp(tTag),
				theClientDto.getMandant(), theClientDto);

		if (bFeiertagAmNaechstenTag == true) {

			if (dto != null && dto.getTagesartIId().equals(tagesartIId_Halbtag)) {
				// Halbtage bleiben am selben Tag
			} else {

				BetriebskalenderDto dtoVortag = getPersonalFac().betriebskalenderFindByMandantCNrDDatum(
						Helper.addiereTageZuTimestamp(Helper.cutTimestamp(tTag), -1), theClientDto.getMandant(),
						theClientDto);
				if (dtoVortag != null && dtoVortag.getTagesartIId().equals(tagesartIId_Halbtag)) {
					dto = null;
				} else {
					dto = dtoVortag;
					// Aufgrund PJ22085 auskommentiert
					// tTag = Helper.addiereTageZuTimestamp(Helper.cutTimestamp(tTag), -1);
				}
			}
		}

		if (dto != null) {

			if (dto.getTagesartIId().equals(tagesartIId_Halbtag)) {
				zeile.setHalberFeiertag(true);
			}

			boolean bHinzurechnenWeilReligionStimmt = false;
			if (personalDto.getReligionIId() == null && dto.getReligionIId() == null) {
				bHinzurechnenWeilReligionStimmt = true;
			} else if (personalDto.getReligionIId() != null && dto.getReligionIId() == null) {
				bHinzurechnenWeilReligionStimmt = true;
			} else if (personalDto.getReligionIId() != null
					&& personalDto.getReligionIId().equals(dto.getReligionIId())) {
				bHinzurechnenWeilReligionStimmt = true;
			}

			double dFtgSoll = 0;
			double dGutschriftFeiertag = 0;
			if (iZeitmodellId != null && bHinzurechnenWeilReligionStimmt) {
				try {
					Query query = em.createNamedQuery("ZeitmodelltagfindByZeitmodellIIdTagesartIId");
					query.setParameter(1, iZeitmodellId);
					query.setParameter(2, dto.getTagesartIId());
					// @todo getSingleResult oder
					// getResultList
					// ?
					Zeitmodelltag zeimodelltag = (Zeitmodelltag) query.getSingleResult();
					dFtgSoll = Helper.time2Double(zeimodelltag.getUSollzeit()).doubleValue();

					if (dFtgSoll == 0 || zeile.isHalberFeiertag()) {
						throw new NoResultException("");
					}
				} catch (NoResultException ex14) {
					// keine Sollzeit fuer Tagesart
					// definiert
					Time usoll = getSollzeitZuDatumWennFeiertag(personalIId, tTag, theClientDto);
					if (usoll != null) {

						if (zeile.isHalberFeiertag()) {
							dFtgSoll = Helper.time2Double(usoll).doubleValue() - dFtgSoll;
							if (dFtgSoll > 0) {

								dGutschriftFeiertag = dFtgSoll;
							}

						} else {
							dFtgSoll = Helper.time2Double(usoll).doubleValue();
							dGutschriftFeiertag = dFtgSoll;
						}
					}
				}

			}

			if (dto.getReligionIId() == null) {

				zeile.setBdFeiertag(new BigDecimal(dGutschriftFeiertag));
				String s = "";
				if (dto.getCBez() != null) {
					s = dto.getCBez();
				} else {
					s = "Unbek. Ftg.";
				}
				zeile.setSBemerkung(zeile.getSBemerkung() + s);
			} else {

				if (dto.getReligionIId().equals(personalDto.getReligionIId())) {

					zeile.setBdFeiertag(new BigDecimal(dGutschriftFeiertag));
					String s = "";
					if (dto.getCBez() != null) {
						s = dto.getCBez();
					} else {
						s = "Unbek. Ftg.";
					}
					zeile.setSBemerkung(zeile.getSBemerkung() + s);

				} else {
					zeile.setBdFeiertag(new BigDecimal(0));
				}

			}

		}
		return zeile;
	}

	private ZeitmodelltagDto schichtErkennen(Integer personalIId, TheClientDto theClientDto,
			Integer taetigkeitIId_Kommt, Integer taetigkeitIId_Geht, Integer tagesartIId_Feiertag,
			Integer tagesartIId_Halbtag, ZeitmodelltagDto zeitmodelltagDto,
			ArrayList<ZeitdatenDto> einBlock_ZurZeitweiligenVerwendung) {

		if (einBlock_ZurZeitweiligenVerwendung.size() > 0) {
			// Bei Schicht gibt es 2 Teile:
			// Fr den Teil des Vortages:
			// z.B.: 21:45 - 00:00
			// Wenn auf das letzte Kommt kein Geht am gleichen Tag folgt, dann gilt fr
			// das
			// frueheste Kommt die Definition des fruehesten Kommts des Folgetags
			// Der Teil des naechsten Tags:
			// z.B.: 00:00 -6:50
			// Wenn das Kommt des Gehts am Vortag ist, dann gilt das fueheste Kommt des
			// aktuellen Tags NICHT

			ZeitdatenDto zTempDto = einBlock_ZurZeitweiligenVerwendung
					.get(einBlock_ZurZeitweiligenVerwendung.size() - 1);

			Calendar tZeit = Calendar.getInstance();
			tZeit.setTimeInMillis(zTempDto.getTZeit().getTime());

			if (tZeit.get(Calendar.DAY_OF_MONTH) == 28) {
				int x = 0;
			}

			if (zTempDto.getTaetigkeitIId() != null && zTempDto.getTaetigkeitIId().equals(taetigkeitIId_Geht)
					&& Helper.short2boolean(zTempDto.getBAutomatikbuchung()) == true) {

				ZeitmodelltagDto zeitmodelltagDtoNaechsterTag = getZeitmodelltagZuDatum(personalIId,
						Helper.cutTimestamp(
								Helper.addiereTageZuTimestamp(einBlock_ZurZeitweiligenVerwendung.get(0).getTZeit(), 1)),
						tagesartIId_Feiertag, tagesartIId_Halbtag, false, theClientDto);
				if (zeitmodelltagDtoNaechsterTag != null) {
					zeitmodelltagDto.setUBeginn(zeitmodelltagDtoNaechsterTag.getUBeginn());
					zeitmodelltagDto.setUEnde(new Time(-3600000));
				}

			}

			zTempDto = einBlock_ZurZeitweiligenVerwendung.get(0);

			if (zTempDto.getTaetigkeitIId() != null && zTempDto.getTaetigkeitIId().equals(taetigkeitIId_Kommt)
					&& Helper.short2boolean(zTempDto.getBAutomatikbuchung()) == true) {
				zeitmodelltagDto.setUBeginn(new Time(-3600000));
			}
		}

		return zeitmodelltagDto;
	}

	private GleitzeitsaldoDto stundenVonGleitzeitsaldoAbziehen(GleitzeitsaldoDto dto, BigDecimal bdDiff) {

		// 200%
		if (bdDiff.doubleValue() > 0) {

			if (bdDiff.doubleValue() >= dto.getNSaldouest200().doubleValue()) {
				bdDiff = bdDiff.subtract(dto.getNSaldouest200());
				dto.setNSaldouest200(BigDecimal.ZERO);
			} else {
				bdDiff = BigDecimal.ZERO;
				dto.setNSaldouest200(dto.getNSaldouest200().subtract(bdDiff));
			}
		}

		if (bdDiff.doubleValue() > 0) {

			if (bdDiff.doubleValue() >= dto.getNSaldouestpflichtig100().doubleValue()) {
				bdDiff = bdDiff.subtract(dto.getNSaldouestpflichtig100());
				dto.setNSaldouestpflichtig100(BigDecimal.ZERO);
			} else {
				bdDiff = BigDecimal.ZERO;
				dto.setNSaldouestpflichtig100(dto.getNSaldouestpflichtig100().subtract(bdDiff));
			}
		}

		if (bdDiff.doubleValue() > 0) {

			if (bdDiff.doubleValue() >= dto.getNSaldouestfrei100().doubleValue()) {
				bdDiff = bdDiff.subtract(dto.getNSaldouestfrei100());
				dto.setNSaldouestfrei100(BigDecimal.ZERO);
			} else {
				bdDiff = BigDecimal.ZERO;
				dto.setNSaldouestfrei100(dto.getNSaldouestfrei100().subtract(bdDiff));
			}
		}

		if (bdDiff.doubleValue() > 0) {

			if (bdDiff.doubleValue() >= dto.getNSaldouestpflichtig50().doubleValue()) {
				bdDiff = bdDiff.subtract(dto.getNSaldouestpflichtig50());
				dto.setNSaldouestpflichtig50(BigDecimal.ZERO);
			} else {
				bdDiff = BigDecimal.ZERO;
				dto.setNSaldouestpflichtig50(dto.getNSaldouestpflichtig50().subtract(bdDiff));
			}
		}

		if (bdDiff.doubleValue() > 0) {

			if (bdDiff.doubleValue() >= dto.getNSaldouestfrei50().doubleValue()) {
				bdDiff = bdDiff.subtract(dto.getNSaldouestfrei50());
				dto.setNSaldouestfrei50(BigDecimal.ZERO);
			} else {
				bdDiff = BigDecimal.ZERO;
				dto.setNSaldouestfrei50(dto.getNSaldouestfrei50().subtract(bdDiff));
			}
		}
		if (bdDiff.doubleValue() > 0) {

			if (bdDiff.doubleValue() >= dto.getNSaldomehrstunden().doubleValue()) {
				bdDiff = bdDiff.subtract(dto.getNSaldomehrstunden());
				dto.setNSaldomehrstunden(BigDecimal.ZERO);
			} else {
				bdDiff = BigDecimal.ZERO;
				dto.setNSaldomehrstunden(dto.getNSaldomehrstunden().subtract(bdDiff));
			}
		}

		return dto;
	}

	private ZeitgutschriftVerschiebenHelper umZeitgutschriftVerschieben(ArrayList<ZeitdatenDto> block,
			Integer personalIId, Timestamp tDatum, ZeileMonatsabrechnungDto zeile, TheClientDto theClientDto) {

		try {
			if (block.size() > 0) {
				Time tGutschriftKommt = null;
				Time tGutschriftGeht = null;

				try {
					Query query = em.createNamedQuery("ZeitgutschriftfindByPersonalIIdTDatum");
					query.setParameter(1, personalIId);
					query.setParameter(2, Helper.cutTimestamp(tDatum));
					Zeitgutschrift zg = (Zeitgutschrift) query.getSingleResult();

					tGutschriftKommt = zg.getUGutschriftKommt();
					tGutschriftGeht = zg.getUGutschriftGeht();

				} catch (NoResultException ex) {
					PersonalzeitmodellDto personalzeitmodellDto = getPersonalFac()
							.personalzeitmodellFindZeitmodellZuDatum(personalIId, tDatum, theClientDto);
					if (personalzeitmodellDto != null && personalzeitmodellDto.getZeitmodellDto() != null) {
						tGutschriftKommt = personalzeitmodellDto.getZeitmodellDto().getUGutschriftKommt();
						tGutschriftGeht = personalzeitmodellDto.getZeitmodellDto().getUGutschriftGeht();
					}
				}

				if (tGutschriftKommt != null && tGutschriftKommt.getTime() > -3600000) {
					// Beim ersten Block das Kommt verschieben

					if (block.size() > 0) {

						Timestamp tKommt = block.get(0).getTZeit();
						// SP5735
						if (!Helper.short2boolean(block.get(0).getBAutomatikbuchung())) {
							tKommt = new Timestamp(tKommt.getTime() - (tGutschriftKommt.getTime() + 3600000));

							block.get(0).setTZeit(tKommt);

							zeile.setBdGutschriftKommt(new BigDecimal(Helper.time2Double(tGutschriftKommt)));
						}
					}

				}

				if (tGutschriftGeht != null && tGutschriftGeht.getTime() > -3600000) {
					// Beim ersten Block das Kommt verschieben

					if (block.size() > 0) {

						ZeitdatenDto zDto_Geht = block.get(block.size() - 1);

						// SP5735
						if (!Helper.short2boolean(zDto_Geht.getBAutomatikbuchung())) {

							Timestamp tGeht = zDto_Geht.getTZeit();

							tGeht = new Timestamp(tGeht.getTime() + (tGutschriftGeht.getTime() + 3600000));

							zDto_Geht.setTZeit(tGeht);

							block.set(block.size() - 1, zDto_Geht);

							zeile.setBdGutschriftGeht(new BigDecimal(Helper.time2Double(tGutschriftGeht)));
						}
					}

				}

			}

		} catch (RemoteException e) {
			throwEJBExceptionLPRespectOld(e);
		}

		ZeitgutschriftVerschiebenHelper zh = new ZeitgutschriftVerschiebenHelper();
		zh.zmDto = zeile;
		zh.block = block;
		return zh;
	}

	private ArrayList<ZeitdatenDto> rundungZugunstenDesUnternehmens(ArrayList<ZeitdatenDto> einBlock,
			ZeitmodelltagDto zeitmodelltagDto) {

		int iRundungBeginn = 0;
		if (zeitmodelltagDto.getIRundungbeginn() != null) {
			iRundungBeginn = zeitmodelltagDto.getIRundungbeginn();
		}

		int iRundungEnde = 0;
		if (zeitmodelltagDto.getIRundungende() != null) {
			iRundungEnde = zeitmodelltagDto.getIRundungende();
		}

		long lRundungBeginn = 60000 * iRundungBeginn;
		long lRundungEnde = 60000 * iRundungEnde;

		if (iRundungBeginn > 0 || iRundungEnde > 0) {

			boolean bRundeSondertaetigkeiten = Helper.short2boolean(zeitmodelltagDto.getBRundesondertaetigkeiten());

			ZeitdatenDto[] zeitdatenEinesTagesDtos = new ZeitdatenDto[einBlock.size()];
			zeitdatenEinesTagesDtos = (ZeitdatenDto[]) einBlock.toArray(zeitdatenEinesTagesDtos);
			for (int z = 0; z < zeitdatenEinesTagesDtos.length; z++) {
				ZeitdatenDto eineZeile = zeitdatenEinesTagesDtos[z];
				// Automatikbuchungen auslassen (z.b. das bei
				// Mitternachtssprung nicht gerundet wird)
				if (Helper.short2boolean(eineZeile.getBAutomatikbuchung()) == false) {

					if (lRundungBeginn != 0) {
						if (z == 0) {
							long lZuviel = eineZeile.getTZeit().getTime() % lRundungBeginn;
							if (lZuviel != 0) {
								lZuviel = lRundungBeginn - lZuviel;
								eineZeile.setTZeit(new Timestamp(eineZeile.getTZeit().getTime() + lZuviel));
							}
						}
					}

					if (z > 0 && z < zeitdatenEinesTagesDtos.length - 1) {
						if (eineZeile.getTaetigkeitIId() != null) {

							if (bRundeSondertaetigkeiten == true) {

								if (z % 2 == 1) {
									if (lRundungEnde != 0) {
										long lZuviel = eineZeile.getTZeit().getTime() % lRundungEnde;
										eineZeile.setTZeit(new Timestamp(eineZeile.getTZeit().getTime() - lZuviel));
									}
								} else if (z % 2 == 0) {
									if (lRundungBeginn != 0) {
										long lZuviel = eineZeile.getTZeit().getTime() % lRundungBeginn;
										if (lZuviel != 0) {
											lZuviel = lRundungBeginn - lZuviel;
											eineZeile.setTZeit(new Timestamp(eineZeile.getTZeit().getTime() + lZuviel));
										}
									}
								}
							}
						}

					}

					if (z == zeitdatenEinesTagesDtos.length - 1) {
						if (lRundungEnde != 0) {
							long lZuviel = eineZeile.getTZeit().getTime() % lRundungEnde;
							eineZeile.setTZeit(new Timestamp(eineZeile.getTZeit().getTime() - lZuviel));
						}
					}
					einBlock.set(z, eineZeile);
				}
			}

		}
		return einBlock;
	}

	private ArrayList<ZeitdatenDto> passiveReisezeitenDurchPauseErsetzen(ArrayList<ZeitdatenDto> einBlock,
			ArrayList<AuftragzeitenDto[]> alAzDtos, Integer taetigkeitIIdUnter) {

		if (einBlock.size() > 1) {

			TreeMap<Timestamp, ZeitdatenDto> tmZeitdaten = new TreeMap<Timestamp, ZeitdatenDto>();

			for (int i = 0; i < einBlock.size(); i++) {

				ZeitdatenDto eineZeile = einBlock.get(i);
				tmZeitdaten.put(eineZeile.getTZeit(), eineZeile);
			}

			for (int i = 0; i < alAzDtos.size(); i++) {
				AuftragzeitenDto[] azDtos = alAzDtos.get(i);
				for (int j = 0; j < azDtos.length; j++) {
					AuftragzeitenDto azDto = azDtos[j];

					// Wenn > Kommt und <= Geht
					if (azDto != null && azDto.getTsBeginn().after(einBlock.get(0).getTZeit())) {
						if (azDto.getTsEnde().getTime() <= einBlock.get(einBlock.size() - 1).getTZeit().getTime()) {

							// 2xUNTER einfuegen
							ZeitdatenDto passiveReisezeit = new ZeitdatenDto();
							passiveReisezeit.setPersonalIId(azDto.getIPersonalMaschinenId());

							if (!tmZeitdaten.containsKey(azDto.getTsBeginn())) {
								passiveReisezeit.setTZeit(azDto.getTsBeginn());
							} else {
								passiveReisezeit.setTZeit(new Timestamp(azDto.getTsBeginn().getTime() + 5));
							}

							passiveReisezeit.setBAutomatikbuchung(Helper.boolean2Short(true));
							passiveReisezeit.setTaetigkeitIId(taetigkeitIIdUnter);

							tmZeitdaten.put(passiveReisezeit.getTZeit(), passiveReisezeit);

							passiveReisezeit = new ZeitdatenDto();
							passiveReisezeit.setPersonalIId(azDto.getIPersonalMaschinenId());
							passiveReisezeit.setBAutomatikbuchung(Helper.boolean2Short(true));
							passiveReisezeit.setTaetigkeitIId(taetigkeitIIdUnter);
							if (!tmZeitdaten.containsKey(azDto.getTsEnde())) {
								passiveReisezeit.setTZeit(azDto.getTsEnde());
							} else {
								passiveReisezeit.setTZeit(new Timestamp(azDto.getTsEnde().getTime() - 5));
							}

							tmZeitdaten.put(passiveReisezeit.getTZeit(), passiveReisezeit);

						}

					}

				}

			}

			// Wieder in ArrayList umwandeln

			return new ArrayList(tmZeitdaten.values());

		} else {
			return einBlock;
		}

	}

	private ArrayList<ZeitdatenDto> fruehestesKommtUndSpaetestesGehtUndMaximaleTagesanwesenheitVerschieben(
			TaetigkeitDto taetigkeitDto_Unter, TaetigkeitDto taetigkeitDto_Arzt, TaetigkeitDto taetigkeitDto_Behoerde,
			ArrayList<ZeitdatenDto> einBlock, ZeitmodelltagDto zeitmodelltagDto,
			Double dMaximaleTagesanwesenheitszeitAufgrundWochenMaximum) {

		java.sql.Time tFruehestesKommt = zeitmodelltagDto.getUBeginn();

		java.sql.Time tSpaetestesGeht = zeitmodelltagDto.getUEnde();

		java.sql.Time tGehtAkzeptiertAb = zeitmodelltagDto.getUEndeAkzeptiertAb();

		java.sql.Time tKommtAkzeptiertBis = zeitmodelltagDto.getUBeginnAkzeptiertBis();

		boolean bVerkehrt = false;

		if (tFruehestesKommt != null && tSpaetestesGeht != null && tFruehestesKommt.after(tSpaetestesGeht)) {
			bVerkehrt = true;
		}

		boolean bFrueh = true;

		ZeitdatenDto[] zeitdatenEinesTagesDtos = new ZeitdatenDto[einBlock.size()];
		zeitdatenEinesTagesDtos = (ZeitdatenDto[]) einBlock.toArray(zeitdatenEinesTagesDtos);

		// PJ16913
		Timestamp tMaxGeht = null;
		if ((zeitmodelltagDto != null && zeitmodelltagDto.getUErlaubteanwesenheitszeit() != null
				&& zeitmodelltagDto.getUErlaubteanwesenheitszeit().getTime() != -3600000)
				|| dMaximaleTagesanwesenheitszeitAufgrundWochenMaximum != null) {
			if (zeitdatenEinesTagesDtos.length > 0) {

				if (tFruehestesKommt != null && tFruehestesKommt.getTime() > -3600000) {
					Calendar tZeit = Calendar.getInstance();
					tZeit.setTimeInMillis(zeitdatenEinesTagesDtos[0].getTZeit().getTime());

					if (tZeit.get(Calendar.DAY_OF_MONTH) == 28) {
						int i = 0;
					}

					Calendar tKommt = Calendar.getInstance();
					tKommt.setTimeInMillis(tFruehestesKommt.getTime());
					tZeit.set(Calendar.HOUR_OF_DAY, tKommt.get(Calendar.HOUR_OF_DAY));
					tZeit.set(Calendar.MINUTE, tKommt.get(Calendar.MINUTE));
					tZeit.set(Calendar.SECOND, 0);
					tZeit.set(Calendar.MILLISECOND, 0);

					// SP7942
					if (Helper.short2boolean(zeitmodelltagDto.getBBeginnVortag())) {
						tZeit.add(Calendar.DATE, -1);

					}

					java.sql.Timestamp tNeueZeitKommt = new java.sql.Timestamp(tZeit.getTimeInMillis());
					if (zeitdatenEinesTagesDtos[0].getTZeit().before(tNeueZeitKommt)) {

						if (tKommtAkzeptiertBis != null && tKommtAkzeptiertBis.getTime() > -3600000) {
							Calendar cKommtAkzeptiertBis = Calendar.getInstance();
							cKommtAkzeptiertBis.setTimeInMillis(tKommtAkzeptiertBis.getTime());
							tZeit.set(Calendar.HOUR_OF_DAY, cKommtAkzeptiertBis.get(Calendar.HOUR_OF_DAY));
							tZeit.set(Calendar.MINUTE, cKommtAkzeptiertBis.get(Calendar.MINUTE));
							tZeit.set(Calendar.SECOND, 0);
							tZeit.set(Calendar.MILLISECOND, 0);
							java.sql.Timestamp tKommtAkzpetiertBis = new java.sql.Timestamp(tZeit.getTimeInMillis());
							if (zeitdatenEinesTagesDtos[0].getTZeit().after(tKommtAkzpetiertBis)) {
								zeitdatenEinesTagesDtos[0].setTZeit(tNeueZeitKommt);
							}
						} else {
							zeitdatenEinesTagesDtos[0].setTZeit(tNeueZeitKommt);
						}
					}
				}

				// PJ18724 Wenn Ein Wochenmaximum definiert kann es sein, muss
				// dies hier beruecksichtigt werden
				double dMaxAnwesenheit = 24;
				if (zeitmodelltagDto.getUErlaubteanwesenheitszeit() != null
						&& zeitmodelltagDto.getUErlaubteanwesenheitszeit().getTime() != -3600000) {
					dMaxAnwesenheit = Helper.time2Double(zeitmodelltagDto.getUErlaubteanwesenheitszeit());
				}

				if (dMaximaleTagesanwesenheitszeitAufgrundWochenMaximum != null) {

					if (dMaximaleTagesanwesenheitszeitAufgrundWochenMaximum.doubleValue() < dMaxAnwesenheit) {
						dMaxAnwesenheit = dMaximaleTagesanwesenheitszeitAufgrundWochenMaximum;
					}

				}

				tMaxGeht = new Timestamp(
						(long) (zeitdatenEinesTagesDtos[0].getTZeit().getTime() + (dMaxAnwesenheit * 3600000)));

				ZeitdatenDto[] zeitdatenDtoFuerVorlaeufigeMaxGehtBerechnung = ZeitdatenDto
						.kopiereArray(zeitdatenEinesTagesDtos);

				// wg. SP3135 auskommentiert
				/*
				 * for (int z = 0; z < zeitdatenDtoFuerVorlaeufigeMaxGehtBerechnung.length; z++)
				 * { ZeitdatenDto eineZeile = zeitdatenDtoFuerVorlaeufigeMaxGehtBerechnung[z];
				 * if (eineZeile.getTZeit().after(tMaxGeht)) { eineZeile.setTZeit(tMaxGeht); } }
				 */

				double dDauerPaarweiseSondertaetigkeiten = 0;
				try {
					dDauerPaarweiseSondertaetigkeiten = berechnePaarweiserSondertaetigkeiten(
							zeitdatenDtoFuerVorlaeufigeMaxGehtBerechnung, taetigkeitDto_Unter.getIId());
					dDauerPaarweiseSondertaetigkeiten += berechnePaarweiserSondertaetigkeiten(
							zeitdatenDtoFuerVorlaeufigeMaxGehtBerechnung, taetigkeitDto_Arzt.getIId());
					dDauerPaarweiseSondertaetigkeiten += berechnePaarweiserSondertaetigkeiten(
							zeitdatenDtoFuerVorlaeufigeMaxGehtBerechnung, taetigkeitDto_Behoerde.getIId());
				} catch (Exception e) {
					//
				}

				tMaxGeht = new Timestamp((long) (tMaxGeht.getTime() + (dDauerPaarweiseSondertaetigkeiten * 3600000)));
			}

		}

		for (int z = 0; z < zeitdatenEinesTagesDtos.length; z++) {
			ZeitdatenDto eineZeile = zeitdatenEinesTagesDtos[z];

			if (!Helper.short2boolean(eineZeile.getBAutomatikbuchung())) {

				Calendar tZeit = Calendar.getInstance();
				tZeit.setTimeInMillis(eineZeile.getTZeit().getTime());

				if (bVerkehrt == false) {

					if (tFruehestesKommt != null && tFruehestesKommt.getTime() > -3600000) {

						Calendar tKommt = Calendar.getInstance();
						tKommt.setTimeInMillis(tFruehestesKommt.getTime());
						tZeit.set(Calendar.HOUR_OF_DAY, tKommt.get(Calendar.HOUR_OF_DAY));
						tZeit.set(Calendar.MINUTE, tKommt.get(Calendar.MINUTE));
						tZeit.set(Calendar.SECOND, 0);
						tZeit.set(Calendar.MILLISECOND, 0);

						// SP7942
						if (Helper.short2boolean(zeitmodelltagDto.getBBeginnVortag())) {
							tZeit.add(Calendar.DATE, -1);

						}

						java.sql.Timestamp tNeueZeitKommt = new java.sql.Timestamp(tZeit.getTimeInMillis());
						if (eineZeile.getTZeit().before(tNeueZeitKommt)) {

							// PJ19944
							if (tKommtAkzeptiertBis != null && tKommtAkzeptiertBis.getTime() > -3600000) {
								Calendar cKommtAkzeptiertBis = Calendar.getInstance();
								cKommtAkzeptiertBis.setTimeInMillis(tKommtAkzeptiertBis.getTime());
								tZeit.set(Calendar.HOUR_OF_DAY, cKommtAkzeptiertBis.get(Calendar.HOUR_OF_DAY));
								tZeit.set(Calendar.MINUTE, cKommtAkzeptiertBis.get(Calendar.MINUTE));
								tZeit.set(Calendar.SECOND, 0);
								tZeit.set(Calendar.MILLISECOND, 0);
								java.sql.Timestamp tKommtAkzpetiertBis = new java.sql.Timestamp(
										tZeit.getTimeInMillis());
								if (eineZeile.getTZeit().after(tKommtAkzpetiertBis)) {
									eineZeile.setTZeit(tNeueZeitKommt);
									zeitdatenEinesTagesDtos[z] = eineZeile;
									einBlock.set(z, eineZeile);
								}
							} else {

								eineZeile.setTZeit(tNeueZeitKommt);
								zeitdatenEinesTagesDtos[z] = eineZeile;
								einBlock.set(z, eineZeile);
							}

						}
					}

					if (tSpaetestesGeht != null && tSpaetestesGeht.getTime() > -3600000) {
						Calendar tGeht = Calendar.getInstance();
						tGeht.setTimeInMillis(tSpaetestesGeht.getTime());
						tZeit.set(Calendar.HOUR_OF_DAY, tGeht.get(Calendar.HOUR_OF_DAY));
						tZeit.set(Calendar.MINUTE, tGeht.get(Calendar.MINUTE));
						tZeit.set(Calendar.SECOND, 0);
						tZeit.set(Calendar.MILLISECOND, 0);
						java.sql.Timestamp tNeueZeitGht = new java.sql.Timestamp(tZeit.getTimeInMillis());

						if (tMaxGeht != null && tNeueZeitGht.after(tMaxGeht)) {
							tNeueZeitGht = tMaxGeht;
						}

						if (eineZeile.getTZeit().after(tNeueZeitGht)) {

							// PJ19694
							if (tGehtAkzeptiertAb != null && tGehtAkzeptiertAb.getTime() > -3600000) {
								Calendar cGethAkzeptierAb = Calendar.getInstance();
								cGethAkzeptierAb.setTimeInMillis(tGehtAkzeptiertAb.getTime());
								tZeit.set(Calendar.HOUR_OF_DAY, cGethAkzeptierAb.get(Calendar.HOUR_OF_DAY));
								tZeit.set(Calendar.MINUTE, cGethAkzeptierAb.get(Calendar.MINUTE));
								tZeit.set(Calendar.SECOND, 0);
								tZeit.set(Calendar.MILLISECOND, 0);
								java.sql.Timestamp tGehtAkzpetiertAb = new java.sql.Timestamp(tZeit.getTimeInMillis());
								if (eineZeile.getTZeit().before(tGehtAkzpetiertAb)) {
									eineZeile.setTZeit(tNeueZeitGht);
									zeitdatenEinesTagesDtos[z] = eineZeile;
									einBlock.set(z, eineZeile);
								}
							} else {
								eineZeile.setTZeit(tNeueZeitGht);
								zeitdatenEinesTagesDtos[z] = eineZeile;
								einBlock.set(z, eineZeile);
							}
						}
					}
				} else {

					// Wenn der erste eintrag nach dem
					// Spaetestem
					// GEHT
					// ist, dann wird alles nach Vorne
					// verschoben
					Calendar tGeht = Calendar.getInstance();
					tGeht.setTimeInMillis(tSpaetestesGeht.getTime());
					tZeit.set(Calendar.HOUR_OF_DAY, tGeht.get(Calendar.HOUR_OF_DAY));
					tZeit.set(Calendar.MINUTE, tGeht.get(Calendar.MINUTE));
					tZeit.set(Calendar.SECOND, 0);
					tZeit.set(Calendar.MILLISECOND, 0);
					java.sql.Timestamp tNeueZeitGht = new java.sql.Timestamp(tZeit.getTimeInMillis());
					if (z == 0 && eineZeile.getTZeit().after(tNeueZeitGht)) {
						bFrueh = false;
					}

					if (bFrueh) {
						if (Helper.short2boolean(zeitmodelltagDto.getBBeginnVortag()) && tFruehestesKommt != null
								&& tFruehestesKommt.getTime() > -3600000) {
							if (eineZeile.getTZeit().after(tNeueZeitGht)) {

								if (tGehtAkzeptiertAb != null && tGehtAkzeptiertAb.getTime() > -3600000) {
									Calendar cGethAkzeptierAb = Calendar.getInstance();
									cGethAkzeptierAb.setTimeInMillis(tGehtAkzeptiertAb.getTime());
									tZeit.set(Calendar.HOUR_OF_DAY, cGethAkzeptierAb.get(Calendar.HOUR_OF_DAY));
									tZeit.set(Calendar.MINUTE, cGethAkzeptierAb.get(Calendar.MINUTE));
									tZeit.set(Calendar.SECOND, 0);
									tZeit.set(Calendar.MILLISECOND, 0);
									java.sql.Timestamp tGehtAkzpetiertAb = new java.sql.Timestamp(
											tZeit.getTimeInMillis());
									if (eineZeile.getTZeit().before(tGehtAkzpetiertAb)) {
										eineZeile.setTZeit(tNeueZeitGht);
										zeitdatenEinesTagesDtos[z] = eineZeile;
										einBlock.set(z, eineZeile);
									}
								} else {

									eineZeile.setTZeit(tNeueZeitGht);
									zeitdatenEinesTagesDtos[z] = eineZeile;
									einBlock.set(z, eineZeile);
								}
							}

						}
					} else {
						if (tFruehestesKommt != null && tFruehestesKommt.getTime() > -3600000) {

							Calendar tKommt = Calendar.getInstance();
							tKommt.setTimeInMillis(tFruehestesKommt.getTime());
							tZeit.set(Calendar.HOUR_OF_DAY, tKommt.get(Calendar.HOUR_OF_DAY));
							tZeit.set(Calendar.MINUTE, tKommt.get(Calendar.MINUTE));
							tZeit.set(Calendar.SECOND, 0);
							tZeit.set(Calendar.MILLISECOND, 0);

							// SP7942
							if (Helper.short2boolean(zeitmodelltagDto.getBBeginnVortag())) {
								tZeit.add(Calendar.DATE, -1);

							}

							java.sql.Timestamp tNeueZeitKommt = new java.sql.Timestamp(tZeit.getTimeInMillis());
							if (eineZeile.getTZeit().before(tNeueZeitKommt)) {

								// PJ19944
								if (tKommtAkzeptiertBis != null && tKommtAkzeptiertBis.getTime() > -3600000) {
									Calendar cKommtAkzeptiertBis = Calendar.getInstance();
									cKommtAkzeptiertBis.setTimeInMillis(tKommtAkzeptiertBis.getTime());
									tZeit.set(Calendar.HOUR_OF_DAY, cKommtAkzeptiertBis.get(Calendar.HOUR_OF_DAY));
									tZeit.set(Calendar.MINUTE, cKommtAkzeptiertBis.get(Calendar.MINUTE));
									tZeit.set(Calendar.SECOND, 0);
									tZeit.set(Calendar.MILLISECOND, 0);
									java.sql.Timestamp tKommtAkzpetiertBis = new java.sql.Timestamp(
											tZeit.getTimeInMillis());
									if (eineZeile.getTZeit().after(tKommtAkzpetiertBis)) {
										eineZeile.setTZeit(tNeueZeitKommt);
										zeitdatenEinesTagesDtos[z] = eineZeile;
										einBlock.set(z, eineZeile);
									}
								} else {
									eineZeile.setTZeit(tNeueZeitKommt);
									zeitdatenEinesTagesDtos[z] = eineZeile;
									einBlock.set(z, eineZeile);
								}

							}
						}

					}
				}
			}
		}

		return einBlock;
	}

	private GleitzeitsaldoDto getGleitzeitsaldoVormonat(Integer personalIId, Integer iJahr, Integer iMonat,
			java.sql.Date d_datum_bis, Date dEintrittsdatum) {
		GleitzeitsaldoDto gleitzeitsaldoDto_Vormonat = new GleitzeitsaldoDto();
		try {

			Calendar tempVormonat = Calendar.getInstance();

			tempVormonat.set(Calendar.YEAR, iJahr.intValue());
			tempVormonat.set(Calendar.MONTH, iMonat.intValue());
			tempVormonat.set(Calendar.DAY_OF_MONTH, 1);

			tempVormonat.set(Calendar.MONTH, tempVormonat.get(Calendar.MONTH) - 1);

			gleitzeitsaldoDto_Vormonat = getPersonalFac().gleitzeitsaldoFindByPersonalIIdIJahrIMonat(personalIId,
					new Integer(tempVormonat.get(Calendar.YEAR)), new Integer(tempVormonat.get(Calendar.MONTH)));
			Calendar temp = Calendar.getInstance();
			temp.setTimeInMillis(d_datum_bis.getTime());
			int akt_jahr = temp.get(Calendar.YEAR);
			int akt_monat = temp.get(Calendar.MONTH);
			temp.setTimeInMillis(dEintrittsdatum.getTime());

			int eintr_jahr = temp.get(Calendar.YEAR);
			int eintr_monat = temp.get(Calendar.MONTH);
			if (akt_jahr == eintr_jahr && akt_monat == eintr_monat) {
				gleitzeitsaldoDto_Vormonat.setNSaldomehrstunden(new BigDecimal(0));
				gleitzeitsaldoDto_Vormonat.setNSaldouestfrei100(new BigDecimal(0));
				gleitzeitsaldoDto_Vormonat.setNSaldouestfrei50(new BigDecimal(0));
				gleitzeitsaldoDto_Vormonat.setNSaldouestpflichtig100(new BigDecimal(0));
				gleitzeitsaldoDto_Vormonat.setNSaldouest200(new BigDecimal(0));
				gleitzeitsaldoDto_Vormonat.setNSaldouestpflichtig50(new BigDecimal(0));
				gleitzeitsaldoDto_Vormonat.setNSaldo(new BigDecimal(0));
				gleitzeitsaldoDto_Vormonat.setNGzSaldoMitUestdInNormalstunden(new BigDecimal(0));
			}
		} catch (Throwable ex8) {
			gleitzeitsaldoDto_Vormonat.setNSaldomehrstunden(new BigDecimal(0));
			gleitzeitsaldoDto_Vormonat.setNSaldouestfrei100(new BigDecimal(0));
			gleitzeitsaldoDto_Vormonat.setNSaldouestfrei50(new BigDecimal(0));
			gleitzeitsaldoDto_Vormonat.setNSaldouestpflichtig100(new BigDecimal(0));
			gleitzeitsaldoDto_Vormonat.setNSaldouest200(new BigDecimal(0));
			gleitzeitsaldoDto_Vormonat.setNSaldouestpflichtig50(new BigDecimal(0));
			gleitzeitsaldoDto_Vormonat.setNSaldo(new BigDecimal(0));
			gleitzeitsaldoDto_Vormonat.setNGzSaldoMitUestdInNormalstunden(new BigDecimal(0));
		}
		return gleitzeitsaldoDto_Vormonat;
	}

	public UebertragBVADto getUebertragBVAVormonat(Integer personalIId, Integer iJahr, Integer iMonat) {
		UebertragBVADto uebertragBVADto_Vormonat = new UebertragBVADto();
		try {

			Calendar tempVormonat = Calendar.getInstance();

			tempVormonat.set(Calendar.DAY_OF_MONTH, 1);
			tempVormonat.set(Calendar.YEAR, iJahr.intValue());
			tempVormonat.set(Calendar.MONTH, iMonat.intValue());

			tempVormonat.add(Calendar.DAY_OF_MONTH, -1);

			tempVormonat.getTime();

			Timestamp tVormonat = Helper.cutTimestamp(new Timestamp(tempVormonat.getTimeInMillis()));

			Query query = em.createNamedQuery("UebertragBVAByPersonalIIdTDatum");

			query.setParameter(1, personalIId);
			query.setParameter(2, tVormonat);

			UebertragBVA uebertragBVA = (UebertragBVA) query.getSingleResult();

			return UebertragBVADtoAssembler.createDto(uebertragBVA);

		} catch (Throwable ex8) {
			uebertragBVADto_Vormonat.setNGleitzeit(BigDecimal.ZERO);
			uebertragBVADto_Vormonat.setBGesperrt(Helper.boolean2Short(false));
			uebertragBVADto_Vormonat.setPersonalIId(personalIId);
			uebertragBVADto_Vormonat.setNUestd50Gz(BigDecimal.ZERO);
			uebertragBVADto_Vormonat.setNUestd50Gz_Zuschlag(BigDecimal.ZERO);
			uebertragBVADto_Vormonat.setNUestd50(BigDecimal.ZERO);
			uebertragBVADto_Vormonat.setNUestd50_Zuschlag(BigDecimal.ZERO);
			uebertragBVADto_Vormonat.setNUestd100(BigDecimal.ZERO);
			uebertragBVADto_Vormonat.setNUestd100_Zuschlag(BigDecimal.ZERO);

		}
		return uebertragBVADto_Vormonat;
	}

	public PersonalDto[] entferneNichtAnwesendePersonen(Integer iJahrVon, Integer iMonatVon, Integer iJahrBis,
			Integer iMonatBis, PersonalDto[] personalDtos, TheClientDto theClientDto) {

		Timestamp tVon = null;
		Timestamp tBis = null;

		if (iJahrVon != null && iMonatVon != null) {
			Calendar c = Calendar.getInstance();
			c.set(Calendar.YEAR, iJahrVon);
			c.set(Calendar.MONTH, iMonatVon);
			c.set(Calendar.DAY_OF_MONTH, 1);
			tVon = new Timestamp(c.getTimeInMillis());
		}
		if (iJahrBis != null && iMonatBis != null) {
			Calendar c = Calendar.getInstance();
			c.set(Calendar.YEAR, iJahrBis);
			c.set(Calendar.MONTH, iMonatBis);
			c.set(Calendar.DAY_OF_MONTH, c.getActualMaximum(Calendar.DAY_OF_MONTH));
			tBis = new Timestamp(c.getTimeInMillis());
		}

		return entferneNichtAnwesendePersonen(tVon, tBis, personalDtos, theClientDto);
	}

	public PersonalDto[] entferneNichtAnwesendePersonen(java.sql.Timestamp tVon, java.sql.Timestamp tBis,
			PersonalDto[] personalDtos, TheClientDto theClientDto) {
		ArrayList<PersonalDto> anwesendePersonen = new ArrayList<PersonalDto>();

		DatumsfilterVonBis df = new DatumsfilterVonBis(tVon, tBis);

		for (int i = 0; i < personalDtos.length; i++) {

			String sQuery = "select zeitdaten FROM FLRZeitdaten zeitdaten WHERE zeitdaten.personal_i_id="
					+ personalDtos[i].getIId();

			if (tVon != null) {
				sQuery += " AND zeitdaten.t_zeit>='" + Helper.formatTimestampWithSlashes(df.getTimestampVon()) + "'";
			}

			if (df.getTimestampBis() != null) {
				sQuery += " AND zeitdaten.t_zeit<'" + Helper.formatTimestampWithSlashes(df.getTimestampBis()) + "'";
			}

			SessionFactory factory = FLRSessionFactory.getFactory();
			Session session = factory.openSession();

			org.hibernate.Query inventurliste = session.createQuery(sQuery);
			inventurliste.setMaxResults(1);

			List<?> resultList = inventurliste.list();

			if (resultList.size() > 0) {
				// anwesend
				anwesendePersonen.add(personalDtos[i]);

			} else {
				// abwesend
			}
			session.close();

		}
		return (PersonalDto[]) anwesendePersonen.toArray(new PersonalDto[anwesendePersonen.size()]);
	}

	@TransactionAttribute(TransactionAttributeType.NEVER)
	public JasperPrintLP printZeitsaldo(Integer personalIId, Integer iJahrVon, Integer iMonatVon, Integer iJahrBis,
			Integer iMonatBis, boolean bisMonatsende, java.sql.Date d_datum_bis, TheClientDto theClientDto,
			Integer iOption, Integer kostenstelleIIdAbteilung, Integer iOptionSortierung, Boolean bPlusVersteckte) {

		try {

			PersonalDto[] personalDtos = null;

			if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON) {

				if (personalIId == null) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN,
							new Exception("personalIId == null"));
				}

				personalDtos = new PersonalDto[1];

				personalDtos[0] = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);

			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_PERSONEN) {
				personalDtos = getPersonalFac().personalFindByMandantCNr(theClientDto.getMandant(), bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_EINE_ABTEILUNG) {
				PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);
				personalDtos = getPersonalFac().personalFindAllPersonenEinerAbteilung(kostenstelleIIdAbteilung,
						theClientDto.getMandant(), bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ARBEITER) {
				personalDtos = getPersonalFac().personalFindAllArbeiterEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
			} else if (iOption.intValue() == ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_ALLE_ANGESTELLTE) {
				personalDtos = getPersonalFac().personalFindAllAngestellteEinesMandanten(theClientDto.getMandant(),
						bPlusVersteckte);
			} else {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER, new Exception("OPTION NICHT VERFUEGBAR"));
			}

			// PJ 17420

			for (int i = personalDtos.length - 1; i > 0; --i) {
				for (int j = 0; j < i; ++j) {
					String vergleich1 = "";
					String vergleich2 = "";

					String kostenstelle1 = "               ";
					String kostenstelle2 = "               ";

					if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_PERSONALNUMMER) {
						vergleich1 += Helper.fitString2LengthAlignRight(personalDtos[j].getCPersonalnr(), 20, '0');
						vergleich2 += Helper.fitString2LengthAlignRight(personalDtos[j + 1].getCPersonalnr(), 20, '0');
					}

					if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_KOSTENSTELLE_NAME_VORNAME
							|| iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_ABTEILUNG_KOSTENSTELLE_NAME_VORNAME) {
						if (personalDtos[j].getKostenstelleIIdStamm() != null) {

							KostenstelleDto kstDto = getSystemFac()
									.kostenstelleFindByPrimaryKey(personalDtos[j].getKostenstelleIIdStamm());
							kostenstelle1 = Helper.fitString2Length(kstDto.getCNr(), 15, ' ');

						}
						if (personalDtos[j + 1].getKostenstelleIIdStamm() != null) {
							KostenstelleDto kstDto = getSystemFac()
									.kostenstelleFindByPrimaryKey(personalDtos[j + 1].getKostenstelleIIdStamm());
							kostenstelle2 = Helper.fitString2Length(kstDto.getCNr(), 15, ' ');

						}

						if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_KOSTENSTELLE_NAME_VORNAME) {
							vergleich1 += kostenstelle1;
							vergleich2 += kostenstelle2;
						}

					}

					if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_ABTEILUNG_NAME_VORNAME
							|| iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_ABTEILUNG_KOSTENSTELLE_NAME_VORNAME) {

						String abteilung1 = "               ";
						String abteilung2 = "               ";

						if (personalDtos[j].getKostenstelleIIdAbteilung() != null) {

							KostenstelleDto kstDto = getSystemFac()
									.kostenstelleFindByPrimaryKey(personalDtos[j].getKostenstelleIIdAbteilung());
							abteilung1 = Helper.fitString2Length(kstDto.getCNr(), 15, ' ');

						} else {
							abteilung1 = "               ";
						}
						if (personalDtos[j + 1].getKostenstelleIIdAbteilung() != null) {
							KostenstelleDto kstDto = getSystemFac()
									.kostenstelleFindByPrimaryKey(personalDtos[j + 1].getKostenstelleIIdAbteilung());
							abteilung2 = Helper.fitString2Length(kstDto.getCNr(), 15, ' ');

						} else {
							abteilung2 = "               ";
						}
						if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_ABTEILUNG_KOSTENSTELLE_NAME_VORNAME) {
							vergleich1 = kostenstelle1 + vergleich1;
							vergleich2 = kostenstelle2 + vergleich2;
						}
						vergleich1 = abteilung1 + vergleich1;
						vergleich2 = abteilung2 + vergleich2;

					}

					PartnerDto p1Dto = getPartnerFac().partnerFindByPrimaryKey(personalDtos[j].getPartnerIId(),
							theClientDto);
					personalDtos[j].setPartnerDto(p1Dto);
					PartnerDto p2Dto = getPartnerFac().partnerFindByPrimaryKey(personalDtos[j + 1].getPartnerIId(),
							theClientDto);
					vergleich1 += Helper.fitString2Length(p1Dto.getCName1nachnamefirmazeile1(), 80, ' ');
					vergleich2 += Helper.fitString2Length(p2Dto.getCName1nachnamefirmazeile1(), 80, ' ');

					if (p1Dto.getCName2vornamefirmazeile2() != null) {
						vergleich1 += p1Dto.getCName2vornamefirmazeile2();
					}
					if (p2Dto.getCName2vornamefirmazeile2() != null) {
						vergleich2 += p2Dto.getCName2vornamefirmazeile2();
					}

					// Als allererstes die Kollektivabrechungsart
					String kollektiv1Abrechnungsart = PersonalFac.KOLLEKTIV_ABRECHNUNGSART_STANDARD;
					if (personalDtos[j].getKollektivIId() != null) {
						KollektivDto k1Dto = getPersonalFac()
								.kollektivFindByPrimaryKey(personalDtos[j].getKollektivIId());
						kollektiv1Abrechnungsart = k1Dto.getCAbrechungsart();
					}
					String kollektiv2Abrechnungsart = PersonalFac.KOLLEKTIV_ABRECHNUNGSART_STANDARD;
					if (personalDtos[j + 1].getKollektivIId() != null) {
						KollektivDto k2Dto = getPersonalFac()
								.kollektivFindByPrimaryKey(personalDtos[j + 1].getKollektivIId());
						kollektiv2Abrechnungsart = k2Dto.getCAbrechungsart();
					}

					vergleich1 = Helper.fitString2Length(kollektiv1Abrechnungsart, 80, ' ') + vergleich1;
					vergleich2 = Helper.fitString2Length(kollektiv2Abrechnungsart, 80, ' ') + vergleich2;

					if (vergleich1.compareTo(vergleich2) > 0) {
						PersonalDto tauschDto = personalDtos[j];
						personalDtos[j] = personalDtos[j + 1];
						personalDtos[j + 1] = tauschDto;
					}

				}
			}

			ArrayList alDaten = new ArrayList();
			for (int i = 0; i < personalDtos.length; i++) {
				Calendar cAktuell = Helper.getCalendarFirstDayOfMonth(iMonatVon, iJahrVon);

				Calendar cEnde;
				if (iMonatBis == null) {
					cEnde = (Calendar) cAktuell.clone();
				} else {
					cEnde = Helper.getCalendarLastDayOfMonth(iMonatBis, iJahrBis);
				}

				while (cAktuell.before(cEnde) || cAktuell.equals(cEnde)) {

					int iJahr = cAktuell.get(Calendar.YEAR);
					int iMonat = cAktuell.get(Calendar.MONTH);

					try {
						MonatsabrechnungDto moaDto = erstelleMonatsAbrechnung(personalDtos[i].getIId(), iJahr, iMonat,
								bisMonatsende, d_datum_bis, theClientDto, false, iOptionSortierung, null);

						HashMap parameter = moaDto.getParameter();

						Object[] zeile = new Object[ZeiterfassungFacBean.REPORT_ZEITSALDO_ANZAHL_ZEILEN];

						BigDecimal bdIstGesamt = new BigDecimal(0);
						BigDecimal bdSollGesamt = new BigDecimal(0);
						BigDecimal bdFtg = new BigDecimal(0);
						BigDecimal bdArzt = new BigDecimal(0);
						BigDecimal bdBehoerde = new BigDecimal(0);
						BigDecimal bdKrank = new BigDecimal(0);
						BigDecimal bdKindKrank = new BigDecimal(0);
						BigDecimal bdUrlaub = new BigDecimal(0);
						BigDecimal bdReise = new BigDecimal(0);
						BigDecimal bdReisePassiv = new BigDecimal(0);
						BigDecimal bdSonstBez = new BigDecimal(0);
						BigDecimal bdSonstNBez = new BigDecimal(0);
						Date dEintrittsdatum = new Date();
						BigDecimal bdUrlaubVorjahr = new BigDecimal(0);

						BigDecimal bdBVAGleitzeit = new BigDecimal(0);
						BigDecimal bdBVAUestd50GZ = new BigDecimal(0);
						BigDecimal bdBVAUestd50 = new BigDecimal(0);
						BigDecimal bdBVAUestd100 = new BigDecimal(0);

						BigDecimal bdBVAUestd50GZ_Zuschlag = new BigDecimal(0);
						BigDecimal bdBVAUestd50_Zuschlag = new BigDecimal(0);
						BigDecimal bdBVAUestd100_Zuschlag = new BigDecimal(0);

						Object[][] datenMoa = moaDto.getData();
						for (int j = 0; j < datenMoa.length; j++) {
							Object[] zeileMoa = datenMoa[j];
							bdIstGesamt = bdIstGesamt
									.add((BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_IST]);
							bdSollGesamt = bdSollGesamt
									.add((BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SOLL]);
							bdFtg = bdFtg
									.add((BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_FEIERTAG]);
							bdArzt = bdArzt
									.add((BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_ARZT]);
							bdBehoerde = bdBehoerde
									.add((BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BEHOERDE]);
							bdKrank = bdKrank
									.add((BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_KRANK]);
							bdKindKrank = bdKindKrank
									.add((BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_KINDKRANK]);
							bdUrlaub = bdUrlaub
									.add((BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_URLAUB]);

							if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_GLEITZEIT] != null) {
								bdBVAGleitzeit = bdBVAGleitzeit.add(
										(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_GLEITZEIT]);
							}
							if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UEST50_UEBER_GLEITZEIT] != null) {
								bdBVAUestd50GZ = bdBVAUestd50GZ.add(
										(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UEST50_UEBER_GLEITZEIT]);
							}
							if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESTD50] != null) {
								bdBVAUestd50 = bdBVAUestd50.add(
										(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESTD50]);
							}
							if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESDT100] != null) {
								bdBVAUestd100 = bdBVAUestd100.add(
										(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESDT100]);
							}

							if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESDT100_ZUSCHLAG] != null) {
								bdBVAUestd100_Zuschlag = bdBVAUestd100_Zuschlag.add(
										(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESDT100_ZUSCHLAG]);
							}
							if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESTD50_ZUSCHLAG] != null) {
								bdBVAUestd50_Zuschlag = bdBVAUestd50_Zuschlag.add(
										(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UESTD50_ZUSCHLAG]);
							}
							if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UEST50_UEBER_GLEITZEIT_ZUSCHLAG] != null) {
								bdBVAUestd50GZ_Zuschlag = bdBVAUestd50GZ_Zuschlag.add(
										(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_BV_A_UEST50_UEBER_GLEITZEIT_ZUSCHLAG]);
							}

							if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_REISE] != null) {
								bdReise = bdReise
										.add((BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_REISE]);
							}

							if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_REISE_PASSIV] != null) {
								bdReisePassiv = bdReisePassiv.add(
										(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_REISE_PASSIV]);
							}

							bdSonstBez = bdSonstBez.add(
									(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SONSTIGE_BEZAHLTETAETIGKEITEN]);
							bdSonstNBez = bdSonstNBez.add(
									(BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SONSTIGE_UNBEZAHLTETAETIGKEITEN]);

						}
						if (parameter.containsKey("P_PERSONAL")) {
							zeile[REPORT_ZEITSALDO_PERSON] = parameter.get("P_PERSONAL");
							zeile[REPORT_ZEITSALDO_PERSONALNUMMER] = personalDtos[i].getCPersonalnr();
						}

						if (personalDtos[i].getKostenstelleIIdStamm() != null) {

							KostenstelleDto kstDto = getSystemFac()
									.kostenstelleFindByPrimaryKey(personalDtos[i].getKostenstelleIIdStamm());
							zeile[REPORT_ZEITSALDO_KOSTENSTELLE] = kstDto.getCNr();

						}
						if (personalDtos[i].getKostenstelleIIdAbteilung() != null) {
							KostenstelleDto kstDto = getSystemFac()
									.kostenstelleFindByPrimaryKey(personalDtos[i].getKostenstelleIIdAbteilung());
							zeile[REPORT_ZEITSALDO_ABTEILUNG] = kstDto.getCNr();

						}

						if (parameter.containsKey("P_EINTRITTSDATUM")) {
							zeile[REPORT_ZEITSALDO_EINTRITTSDATUM] = parameter.get("P_EINTRITTSDATUM");
						}

						zeile[REPORT_ZEITSALDO_IST] = bdIstGesamt;

						BigDecimal nSollstundenFix = (BigDecimal) parameter.get("P_SOLLSTUNDEN_FIX");
						// SP7406
						if (nSollstundenFix != null) {
							bdSollGesamt = nSollstundenFix;
						}

						zeile[REPORT_ZEITSALDO_SOLL] = bdSollGesamt;
						zeile[REPORT_ZEITSALDO_FTGSOLL] = parameter.get("P_FEIERTAGSOLL");
						zeile[REPORT_ZEITSALDO_FTG] = bdFtg;
						zeile[REPORT_ZEITSALDO_ARZT] = bdArzt;
						zeile[REPORT_ZEITSALDO_BEHOERDE] = bdBehoerde;
						zeile[REPORT_ZEITSALDO_KRANK] = bdKrank;
						zeile[REPORT_ZEITSALDO_KIND_KRANK] = bdKindKrank;
						zeile[REPORT_ZEITSALDO_URLAUBSTD] = bdUrlaub;
						zeile[REPORT_ZEITSALDO_REISE] = bdReise;
						zeile[REPORT_ZEITSALDO_REISE_PASSIV] = bdReisePassiv;
						zeile[REPORT_ZEITSALDO_SONSTIGEBEZAHLT] = bdSonstBez;
						zeile[REPORT_ZEITSALDO_SONSTIGENICHTBEZAHLT] = bdSonstNBez;

						zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_GLEITZEIT] = bdBVAGleitzeit;

						zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_GLEITZEIT_DIFF] = Helper
								.rundeKaufmaennisch(bdBVAGleitzeit.subtract(bdSollGesamt), 2);

						if (parameter.containsKey("P_GLEITZEIT_DIFF_AKTUELLESMONAT")) {
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_GLEITZEIT_DIFF_AKTUELLES_MONAT] = parameter
									.get("P_GLEITZEIT_DIFF_AKTUELLESMONAT");
						}

						zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD100] = bdBVAUestd100;
						zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD50] = bdBVAUestd50;
						zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD50_UEBER_GLEITZEIT] = bdBVAUestd50GZ;
						zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD50_ZUSCHLAG] = bdBVAUestd50_Zuschlag;
						zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD50_UEBER_GLEITZEIT_ZUSCHLAG] = bdBVAUestd50GZ_Zuschlag;
						zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD100_ZUSCHLAG] = bdBVAUestd100_Zuschlag;

						if (parameter.containsKey("P_KOLLEKTIV_ABRECHNUNGSART")) {
							zeile[REPORT_ZEITSALDO_KOLLEKTIV_ABRECHNUNGSART] = parameter
									.get("P_KOLLEKTIV_ABRECHNUNGSART");
						}

						if (parameter.containsKey("P_VERFUEGBARERURLAUBTAGE")) {
							zeile[REPORT_ZEITSALDO_URLAUBTAGE_ALIQUOT_ENDEMONAT] = parameter
									.get("P_VERFUEGBARERURLAUBTAGE");
						}
						if (parameter.containsKey("P_VERFUEGBARERURLAUBSTUNDEN")) {
							zeile[REPORT_ZEITSALDO_URLAUBSTUNDEN_ALIQUOT_ENDEMONAT] = parameter
									.get("P_VERFUEGBARERURLAUBSTUNDEN");
						}

						// Urlaubstunden
						if (parameter.containsKey("P_AKTUELLERURLAUBSANSPRUCHSTUNDEN")) {
							zeile[REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUBAKUTELL] = parameter
									.get("P_AKTUELLERURLAUBSANSPRUCHSTUNDEN");
						}
						if (parameter.containsKey("P_AKTUELLERURLAUBSVERBRAUCHTSTUNDEN")) {
							zeile[REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUBAKUTELLVERBRAUCHT] = parameter
									.get("P_AKTUELLERURLAUBSVERBRAUCHTSTUNDEN");
						}
						if (parameter.containsKey("P_ALTERURLAUBSANSPRUCHSTUNDEN")) {
							zeile[REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUBREST] = parameter
									.get("P_ALTERURLAUBSANSPRUCHSTUNDEN");
						}
						if (parameter.containsKey("P_ALTERURLAUBSVERBRAUCHTSTUNDEN")) {
							zeile[REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUBRESTVERBRAUCHT] = parameter
									.get("P_ALTERURLAUBSVERBRAUCHTSTUNDEN");
						}
						if (parameter.containsKey("P_GEPLANTERURLAUBSTUNDEN")) {
							zeile[REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUB_GEPLANT] = parameter
									.get("P_GEPLANTERURLAUBSTUNDEN");
						}
						if (parameter.containsKey("P_VERFUEGBARERURLAUBSTUNDEN")) {
							zeile[REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUB_VERFUGBAR] = parameter
									.get("P_VERFUEGBARERURLAUBSTUNDEN");
						}
						if (parameter.containsKey("P_ALIQUOTERURLAUBSTUNDEN")) {
							zeile[REPORT_ZEITSALDO_URLAUBSTUNDEN_ALIQUOT] = parameter.get("P_ALIQUOTERURLAUBSTUNDEN");
						}
						// Urlaubtage
						if (parameter.containsKey("P_AKTUELLERURLAUBSANSPRUCHTAGE")) {
							zeile[REPORT_ZEITSALDO_URLAUBTAGE_URLAUBAKTUELL] = parameter
									.get("P_AKTUELLERURLAUBSANSPRUCHTAGE");
						}
						// Urlaubtage Vorjahr
						if (parameter.containsKey("P_VORJAHRVERFUEGBARERURLAUBTAGE")) {
							zeile[REPORT_ZEITSALDO_URLAUBTAGE_URLAUBVORJAHR] = parameter
									.get("P_VORJAHRVERFUEGBARERURLAUBTAGE");
						}

						if (parameter.containsKey("P_AKTUELLERURLAUBSVERBRAUCHTTAGE")) {
							zeile[REPORT_ZEITSALDO_URLAUBTAGE_URLAUBAKTUELLVERBRAUCHT] = parameter
									.get("P_AKTUELLERURLAUBSVERBRAUCHTTAGE");
						}
						if (parameter.containsKey("P_ALTERURLAUBSANSPRUCHTAGE")) {
							zeile[REPORT_ZEITSALDO_URLAUBTAGE_URLAUBREST] = parameter.get("P_ALTERURLAUBSANSPRUCHTAGE");
						}
						if (parameter.containsKey("P_ALTERURLAUBSVERBRAUCHTTAGE")) {
							zeile[REPORT_ZEITSALDO_URLAUBTAGE_URLAUBRESTVERBRAUCHT] = parameter
									.get("P_ALTERURLAUBSVERBRAUCHTTAGE");
						}
						if (parameter.containsKey("P_GEPLANTERURLAUBTAGE")) {
							zeile[REPORT_ZEITSALDO_URLAUBTAGE_URLAUB_GEPLANT] = parameter.get("P_GEPLANTERURLAUBTAGE");
						}
						if (parameter.containsKey("P_VERFUEGBARERURLAUBTAGE")) {
							zeile[REPORT_ZEITSALDO_URLAUBTAGE_URLAUB_VERFUGBAR] = parameter
									.get("P_VERFUEGBARERURLAUBTAGE");
						}
						if (parameter.containsKey("P_ALIQUOTERURLAUBTAGE")) {
							zeile[REPORT_ZEITSALDO_URLAUBTAGE_ALIQUOT] = parameter.get("P_ALIQUOTERURLAUBTAGE");
						}

						// UESTD
						if (parameter.containsKey("P_UESTD100PFLICHTIGVORHANDEN")) {
							zeile[REPORT_ZEITSALDO_UESTDSALDO100] = parameter.get("P_UESTD100PFLICHTIGVORHANDEN");
						}
						if (parameter.containsKey("P_UESTD100FREIVORHANDEN")) {
							zeile[REPORT_ZEITSALDO_UESTDSALDO100STF] = parameter.get("P_UESTD100FREIVORHANDEN");
						}

						if (parameter.containsKey("P_UESTD200VORHANDEN")) {
							zeile[REPORT_ZEITSALDO_UESTDSALDO200] = parameter.get("P_UESTD200VORHANDEN");
						}

						if (parameter.containsKey("P_UESTD50PFLICHTIGVORHANDEN")) {
							zeile[REPORT_ZEITSALDO_UESTDSALDO50] = parameter.get("P_UESTD50PFLICHTIGVORHANDEN");
						}
						if (parameter.containsKey("P_UESTD50FREIVORHANDEN")) {
							zeile[REPORT_ZEITSALDO_UESTDSALDO50STF] = parameter.get("P_UESTD50FREIVORHANDEN");
						}
						if (parameter.containsKey("P_MEHRSTUNDENVORHANDEN")) {
							zeile[REPORT_ZEITSALDO_UESTDSALDOMEHRSTD] = parameter.get("P_MEHRSTUNDENVORHANDEN");
						}

						// Ausbezahlt

						if (parameter.containsKey("P_AUSBEZAHLTMEHRSTD")) {
							zeile[REPORT_ZEITSALDO_AUSBEZAHLTMEHRSTD] = parameter.get("P_AUSBEZAHLTMEHRSTD");
						}
						if (parameter.containsKey("P_AUSBEZAHLTUESTD50")) {
							zeile[REPORT_ZEITSALDO_AUSBEZAHLT50] = parameter.get("P_AUSBEZAHLTUESTD50");
						}
						if (parameter.containsKey("P_AUSBEZAHLTUESTD50STF")) {
							zeile[REPORT_ZEITSALDO_AUSBEZAHLT50STF] = parameter.get("P_AUSBEZAHLTUESTD50STF");
						}
						if (parameter.containsKey("P_AUSBEZAHLTUESTD100")) {
							zeile[REPORT_ZEITSALDO_AUSBEZAHLT100] = parameter.get("P_AUSBEZAHLTUESTD100");
						}

						if (parameter.containsKey("P_AUSBEZAHLTUESTD100STF")) {
							zeile[REPORT_ZEITSALDO_AUSBEZAHLT100STF] = parameter.get("P_AUSBEZAHLTUESTD100STF");
						}
						if (parameter.containsKey("P_AUSBEZAHLTNORMALSTD")) {
							zeile[REPORT_ZEITSALDO_AUSBEZAHLTNORMALSTD] = parameter.get("P_AUSBEZAHLTNORMALSTD");
						}
						if (parameter.containsKey("P_AUSBEZAHLTGUTSTD")) {
							zeile[REPORT_ZEITSALDO_AUSBEZAHLTGUTSTD] = parameter.get("P_AUSBEZAHLTGUTSTD");
						}
						if (parameter.containsKey("P_AUSBEZAHLTUESTD200")) {
							zeile[REPORT_ZEITSALDO_AUSBEZAHLT200] = parameter.get("P_AUSBEZAHLTUESTD200");
						}
						if (parameter.containsKey("P_QUALIPRAEMIE")) {
							zeile[REPORT_ZEITSALDO_QUALIPRAEMIE] = parameter.get("P_QUALIPRAEMIE");
						}

						Calendar c = Calendar.getInstance();
						java.sql.Date d_heute = new java.sql.Date(c.getTime().getTime());

						// Hole letztes Eintrittsdatum
						try {

							EintrittaustrittDto eaDto = getPersonalFac().eintrittaustrittFindLetztenEintrittBisDatum(
									personalDtos[i].getIId(), new Timestamp(d_heute.getTime()));

							if (eaDto != null) {
								dEintrittsdatum = eaDto.getTEintritt();
							}

						} catch (RemoteException ex3) {
							throwEJBExceptionLPRespectOld(ex3);
						}

						// Vormonatsgleitzeitsaldo berechnen
						GleitzeitsaldoDto gleitzeitsaldoDto_Vormonat = getGleitzeitsaldoVormonat(
								personalDtos[i].getIId(), iJahr, iMonat, d_heute, dEintrittsdatum);
						zeile[REPORT_ZEITSALDO_GLEITZEITSALDOVORMONAT] = Helper
								.rundeKaufmaennisch(gleitzeitsaldoDto_Vormonat.getNSaldo(), 2);

						// Gleitzeitsaldo des aktuellen Monats holen

						GleitzeitsaldoDto gleitzeitsaldoDto_Aktuell;
						try {
							gleitzeitsaldoDto_Aktuell = getPersonalFac().gleitzeitsaldoFindByPersonalIIdIJahrIMonat(
									personalDtos[i].getIId(), iJahr, iMonat);
							if (gleitzeitsaldoDto_Aktuell != null) {
								zeile[REPORT_ZEITSALDO_GLEITZEITSALDOAKTUELLERMONAT] = gleitzeitsaldoDto_Aktuell
										.getNSaldo();
							}

						} catch (EJBExceptionLP e) {
							// Keinen gefunden;
						}

						zeile[REPORT_ZEITSALDO_MONAT] = new DateFormatSymbols(theClientDto.getLocUi())
								.getMonths()[iMonat] + " " + iJahr;

						// Betriebsvereinbarung

						if (parameter.containsKey("P_SUMME_VORMONAT_BVA")) {

							UebertragBVADto uebertragBVADto = (UebertragBVADto) parameter.get("P_SUMME_VORMONAT_BVA");

							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_GLEITZEIT] = uebertragBVADto
									.getNGleitzeit();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD100] = uebertragBVADto
									.getNUestd100();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD100_ZUSCHLAG] = uebertragBVADto
									.getnUestd100_Zuschlag();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD50] = uebertragBVADto
									.getNUestd50();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD50_ZUSCHLAG] = uebertragBVADto
									.getNUestd50_Zuschlag();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD50_UEBER_GLEITZEIT] = uebertragBVADto
									.getNUestd50Gz();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD50_UEBERGLEITZEIT_ZUSCHLAG] = uebertragBVADto
									.getNUestd50Gz_Zuschlag();
						}

						if (parameter.containsKey("P_UEBERTRAG_BVA")) {

							UebertragBVADto uebertragBVADto = (UebertragBVADto) parameter.get("P_UEBERTRAG_BVA");

							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_GLEITZEIT] = uebertragBVADto
									.getNGleitzeit();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD100] = uebertragBVADto
									.getNUestd100();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD100_ZUSCHLAG] = uebertragBVADto
									.getnUestd100_Zuschlag();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD50] = uebertragBVADto
									.getNUestd50();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD50_ZUSCHLAG] = uebertragBVADto
									.getNUestd50_Zuschlag();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD50_UEBER_GLEITZEIT] = uebertragBVADto
									.getNUestd50Gz();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD50_UEBERGLEITZEIT_ZUSCHLAG] = uebertragBVADto
									.getNUestd50Gz_Zuschlag();

							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_ENTSPRICHT_NORMALSTUNDEN] = uebertragBVADto
									.entsprichtNormalstunden();

						}

						if (parameter.containsKey("P_SUMME_AUSZAHLUNGEN_BVA")) {

							UebertragBVADto auszahlungenBVADto = (UebertragBVADto) parameter
									.get("P_SUMME_AUSZAHLUNGEN_BVA");

							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_GLEITZEIT] = auszahlungenBVADto
									.getNGleitzeit();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD100] = auszahlungenBVADto
									.getNUestd100();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD100_ZUSCHLAG] = auszahlungenBVADto
									.getnUestd100_Zuschlag();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD50] = auszahlungenBVADto
									.getNUestd50();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD50_ZUSCHLAG] = auszahlungenBVADto
									.getNUestd50_Zuschlag();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD50_UEBER_GLEITZEIT] = auszahlungenBVADto
									.getNUestd50Gz();
							zeile[REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD50_UEBERGLEITZEIT_ZUSCHLAG] = auszahlungenBVADto
									.getNUestd50Gz_Zuschlag();
						}

						// Sonderzeiten
						Session session = FLRSessionFactory.getFactory().openSession();

						String sQuery = "SELECT sz FROM FLRSonderzeiten sz WHERE sz.t_datum>='"
								+ Helper.formatDatum(cAktuell.getTime(), theClientDto.getLocUi())
								+ "' AND sz.t_datum<='"
								+ Helper.formatDatum(Helper.getCalendarLastDayOfMonth(iMonat, iJahr).getTime(),
										theClientDto.getLocUi())
								+ "' AND sz.personal_i_id=" + personalDtos[i].getIId()
								+ " ORDER BY sz.flrtaetigkeit.c_nr ASC, sz.t_datum ASC";

						org.hibernate.Query zeiten = session.createQuery(sQuery);

						List<?> resultList = zeiten.list();
						Iterator<?> resultListIterator = resultList.iterator();

						LinkedHashMap<String, ArrayList<FLRSonderzeiten>> lhm = new LinkedHashMap();

						while (resultListIterator.hasNext()) {
							FLRSonderzeiten sz = (FLRSonderzeiten) resultListIterator.next();

							String taetigkeit = sz.getFlrtaetigkeit().getC_nr();

							ArrayList<FLRSonderzeiten> list = null;

							if (lhm.containsKey(taetigkeit)) {
								list = lhm.get(taetigkeit);
							} else {
								list = new ArrayList();
							}

							list.add(sz);

							lhm.put(taetigkeit, list);

						}

						String[] fieldnames = new String[] { "Taetigkeit", "Von", "Bis", "SummeTage", "SummeSollzeit" };
						ArrayList alDataSub = new ArrayList();

						Iterator taetigkeiten = lhm.keySet().iterator();

						while (taetigkeiten.hasNext()) {

							String taetigkeit = (String) taetigkeiten.next();

							ArrayList<FLRSonderzeiten> listeEinerTaetigkeit = lhm.get(taetigkeit);
							java.util.Date dLetzterBeginn = null;

							int iZahlerSeitLetztemBeginn = 0;
							double dSumme = 0;
							BigDecimal bdSummeSoll = BigDecimal.ZERO;

							for (int l = 0; l < listeEinerTaetigkeit.size(); l++) {
								FLRSonderzeiten flrSz = listeEinerTaetigkeit.get(l);

								for (int j = 0; j < datenMoa.length; j++) {
									Object[] zeileMoa = datenMoa[j];

									if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_DATUM]
											.equals(flrSz.getT_datum())) {

										if (zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SOLL] != null) {

											BigDecimal bdSoll = (BigDecimal) zeileMoa[ZeiterfassungFacBean.REPORT_MONATSABRECHNUNG_SOLL];

											if (Helper.short2boolean(flrSz.getB_tag())) {

											} else if (Helper.short2boolean(flrSz.getB_halbtag())) {
												bdSoll = bdSoll.divide(new BigDecimal(2), 2,
														BigDecimal.ROUND_HALF_EVEN);
											} else if (flrSz.getU_stunden() != null) {
												bdSoll = new BigDecimal(Helper.time2Double(
														new java.sql.Time(flrSz.getU_stunden().getTime())));
											}

											bdSummeSoll = bdSummeSoll.add(bdSoll);
										}
									}

								}

								if (dLetzterBeginn == null) {
									dLetzterBeginn = Helper.cutDate(flrSz.getT_datum());

								}

								iZahlerSeitLetztemBeginn++;

								if (Helper.short2boolean(flrSz.getB_tag())) {
									dSumme = dSumme + 1;
								} else if (Helper.short2boolean(flrSz.getB_halbtag())) {
									dSumme = dSumme + 0.5;
								}

								Date dNaechstesErwartetesDatum = Helper
										.cutDate(Helper.addiereTageZuDatum(dLetzterBeginn, iZahlerSeitLetztemBeginn));

								boolean bLetzterEintrag = false;
								if (l == listeEinerTaetigkeit.size() - 1) {
									bLetzterEintrag = true;
								}
								// Beim letztenEintrag
								if (bLetzterEintrag) {

									Object[] oZeileSub = new Object[5];
									oZeileSub[0] = flrSz.getFlrtaetigkeit().getC_nr();

									oZeileSub[1] = dLetzterBeginn;
									oZeileSub[2] = flrSz.getT_datum();
									oZeileSub[3] = new BigDecimal(dSumme);
									oZeileSub[4] = bdSummeSoll;
									alDataSub.add(oZeileSub);

								} else {
									FLRSonderzeiten flrSzNaechster = listeEinerTaetigkeit.get(l + 1);
									if (dNaechstesErwartetesDatum.equals(flrSzNaechster.getT_datum())) {
										// OK
									} else {
										Object[] oZeileSub = new Object[5];
										oZeileSub[0] = flrSz.getFlrtaetigkeit().getC_nr();

										oZeileSub[1] = dLetzterBeginn;
										oZeileSub[2] = flrSz.getT_datum();
										oZeileSub[3] = new BigDecimal(dSumme);
										oZeileSub[4] = bdSummeSoll;
										alDataSub.add(oZeileSub);
										dLetzterBeginn = null;
										iZahlerSeitLetztemBeginn = 0;
										dSumme = 0;
										bdSummeSoll = BigDecimal.ZERO;
									}

								}

							}

						}

						Object[][] dataSub = new Object[alDataSub.size()][fieldnames.length];
						dataSub = (Object[][]) alDataSub.toArray(dataSub);

						zeile[REPORT_ZEITSALDO_SUBREPORT_SONDERZEITEN] = new LPDatenSubreport(dataSub, fieldnames);

						alDaten.add(zeile);

					} catch (EJBExceptionLP ex1) {

						if (ex1.getCode() == EJBExceptionLP.FEHLER_PERSONAL_FEHLER_BEI_EINTRITTSDATUM && iOption
								.intValue() != ZeiterfassungFac.REPORT_SONDERZEITENLISTE_OPTION_SELEKTIERTE_PERSON) {
							// NICHTS - PERSON WIRD AUSGELASSEN
						} else {
							throw new EJBExceptionLP(ex1);
						}

					}

					cAktuell.set(Calendar.DAY_OF_MONTH, 1);
					cAktuell.set(Calendar.MONTH, cAktuell.get(Calendar.MONTH) + 1);

				}
			}
			HashMap<String, Object> parameter = new HashMap<String, Object>();
			parameter.put("P_MONATVON",
					new DateFormatSymbols(theClientDto.getLocUi()).getMonths()[iMonatVon] + " " + iJahrVon);

			if (iMonatBis != null && iJahrBis != null) {
				parameter.put("P_MONATBIS",
						new DateFormatSymbols(theClientDto.getLocUi()).getMonths()[iMonatBis] + " " + iJahrBis);

			}

			parameter.put("P_SORTIERUNG", getParameterSortierungZeitauswertungen(iOptionSortierung, theClientDto));

			// SP9626
			if (kostenstelleIIdAbteilung != null) {
				parameter.put("P_KOSTENSTELLE_ABTEILUNG", getSystemFac()
						.kostenstelleFindByPrimaryKey(kostenstelleIIdAbteilung).formatKostenstellenbezeichnung());
			}

			boolean bUrlaubsabrechnungZumEintrittsdatum = false;

			try {
				ParametermandantDto parameterUrlaubsabrechnung = (ParametermandantDto) getParameterFac()
						.getMandantparameter(theClientDto.getMandant(), ParameterFac.KATEGORIE_PERSONAL,
								ParameterFac.PARAMETER_URLAUBSABRECHNUNG_ZUM_EINTRITT);

				bUrlaubsabrechnungZumEintrittsdatum = (Boolean) parameterUrlaubsabrechnung.getCWertAsObject();
			} catch (RemoteException e) {
				throwEJBExceptionLPRespectOld(e);
			}

			parameter.put("P_URLAUBSABRECHNUNG_ZUM_EINTRITT", bUrlaubsabrechnungZumEintrittsdatum);

			data = new Object[alDaten.size()][32];
			data = (Object[][]) alDaten.toArray(data);

			index = -1;
			sAktuellerReport = ZeiterfassungFac.REPORT_ZEITSALDO;

			initJRDS(parameter, ZeiterfassungFac.REPORT_MODUL, ZeiterfassungFac.REPORT_ZEITSALDO,
					theClientDto.getMandant(), theClientDto.getLocUi(), theClientDto);
			return getReportPrint();

		} catch (

		RemoteException ex) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		}
	}

	public String istBelegGeradeInBearbeitung(String belegartCNr, Integer belegartIId, TheClientDto theClientDto) {
		String s = null;

		Integer taetigkeitIId_Ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();
		// Hole id der Taetigkeit GEHT
		Integer taetigkeitIId_Geht = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_GEHT, theClientDto).getIId();

		String sQueryBelegzeiten = "SELECT z FROM FLRZeitdaten z WHERE z.c_belegartnr='" + belegartCNr
				+ "' AND z.i_belegartid=" + belegartIId;

		sQueryBelegzeiten += " AND z.t_zeit>='"
				+ Helper.formatTimestampWithSlashes(Helper.cutTimestamp(new Timestamp(System.currentTimeMillis())))
				+ "'";

		sQueryBelegzeiten += " AND z.t_zeit<='"
				+ Helper.formatTimestampWithSlashes(new Timestamp(System.currentTimeMillis())) + "'";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query zeiten = session.createQuery(sQueryBelegzeiten);

		List<?> resultList = zeiten.list();

		Iterator<?> resultListAuftraege = resultList.iterator();

		ArrayList<ZeitdatenDtoBelegzeiten[]> alAuftragszeit = new ArrayList<ZeitdatenDtoBelegzeiten[]>();

		HashMap hmPersonalIIds = new HashMap();

		belegdaten: while (resultListAuftraege.hasNext()) {
			FLRZeitdaten auftragszeit = (FLRZeitdaten) resultListAuftraege.next();

			if (!hmPersonalIIds.containsKey(auftragszeit.getPersonal_i_id())) {
				// Pruefen, ob danach noch ein ENDE GEHT oder eine andere
				// Belegbuchung ist
				ZeitdatenDto[] dtos = zeitdatenFindZeitdatenEinesTagesUndEinerPerson(auftragszeit.getPersonal_i_id(),
						new Timestamp(auftragszeit.getT_zeit().getTime()), new Timestamp(System.currentTimeMillis()));

				for (int i = 1; i < dtos.length; i++) {
					ZeitdatenDto dto = dtos[i];

					if (dto.getTaetigkeitIId() != null) {
						if (dto.getTaetigkeitIId().equals(taetigkeitIId_Ende)
								|| dto.getTaetigkeitIId().equals(taetigkeitIId_Geht)) {
							continue belegdaten;
						}

					} else if (dto.getIBelegartid() != null) {
						continue belegdaten;
					}

				}
				hmPersonalIIds.put(auftragszeit.getPersonal_i_id(), "");
			}

		}

		Iterator it = hmPersonalIIds.keySet().iterator();

		byte[] CRLFAscii = { 13, 10 };

		while (it.hasNext()) {
			if (s == null) {
				s = new String(CRLFAscii);
			}
			Integer personalIId = (Integer) it.next();
			PersonalDto personalDto = getPersonalFac().personalFindByPrimaryKey(personalIId, theClientDto);
			s += personalDto.formatAnrede() + new String(CRLFAscii);
		}

		return s;
	}

	public java.sql.Timestamp[] sindIstZeitenVorhandenWennUrlaubGebuchtWird(SonderzeitenDto sonderzeitenDto,
			java.sql.Timestamp tVon, java.sql.Timestamp tBis, TheClientDto theClientDto) {
		if (sonderzeitenDto == null || tVon == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL,
					new Exception("sonderzeitenDto == null || tVon == null"));
		}

		ArrayList auszulassen = new ArrayList();

		tVon = Helper.cutTimestamp(tVon);
		tBis = Helper.cutTimestamp(tBis);

		java.sql.Timestamp d_datum = null;

		Integer iPk = null;

		if (tBis != null) {
			if (tVon.equals(tBis)) {
				d_datum = tVon;
			}
		} else {
			tBis = tVon;
		}

		Calendar cTag = Calendar.getInstance();

		cTag.setTimeInMillis(tVon.getTime());

		while (cTag.getTimeInMillis() <= tBis.getTime()) {
			d_datum = new java.sql.Timestamp(cTag.getTimeInMillis());
			sonderzeitenDto.setTDatum(d_datum);
			try {
				if (istUrlaubstagZuDatumNoetig(sonderzeitenDto.getPersonalIId(), d_datum, theClientDto)) {

					// Naechster Tag fuer suche

					Calendar cTemp = Calendar.getInstance();
					cTemp.setTimeInMillis(cTag.getTimeInMillis());
					cTemp.set(Calendar.DAY_OF_MONTH, cTemp.get(Calendar.DAY_OF_MONTH) + 1);

					// Sind Buchungen vorhanden
					ZeitdatenDto[] dtos = zeitdatenFindZeitdatenEinesTagesUndEinerPerson(
							sonderzeitenDto.getPersonalIId(), d_datum, new java.sql.Timestamp(cTemp.getTimeInMillis()));
					if (dtos != null && dtos.length > 0) {
						auszulassen.add(d_datum);
					}
				}

			} catch (Exception e) {
				// Naechster Tag
			}
			cTag.set(Calendar.DAY_OF_MONTH, cTag.get(Calendar.DAY_OF_MONTH) + 1);
		}

		java.sql.Timestamp[] ta = new java.sql.Timestamp[auszulassen.size()];

		return (java.sql.Timestamp[]) auszulassen.toArray(ta);
	}

	public Integer createSonderzeitenVonBis(SonderzeitenDto sonderzeitenDto, java.sql.Timestamp tVon,
			java.sql.Timestamp tBis, java.sql.Timestamp[] auslassen, TheClientDto theClientDto) throws EJBExceptionLP {
		return createSonderzeitenVonBis(sonderzeitenDto, tVon, tBis, auslassen, false, theClientDto);
	}

	public Integer createSonderzeitenVonBis(SonderzeitenDto sonderzeitenDto, java.sql.Timestamp tVon,
			java.sql.Timestamp tBis, java.sql.Timestamp[] auslassen, boolean bSonderzeitImmerBuchen,
			TheClientDto theClientDto) throws EJBExceptionLP {

		if (sonderzeitenDto == null || tVon == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL,
					new Exception("sonderzeitenDto == null || tVon == null"));
		}

		tVon = Helper.cutTimestamp(tVon);
		tBis = Helper.cutTimestamp(tBis);

		java.sql.Timestamp d_datum = null;

		Integer iPk = null;

		if (tBis != null) {
			if (tVon.equals(tBis)) {
				d_datum = tVon;
			}
		} else {
			tBis = tVon;
		}

		Calendar cTag = Calendar.getInstance();

		cTag.setTimeInMillis(tVon.getTime());

		while (cTag.getTimeInMillis() <= tBis.getTime()) {
			d_datum = new java.sql.Timestamp(cTag.getTimeInMillis());
			sonderzeitenDto.setTDatum(d_datum);
			try {
				if (istUrlaubstagZuDatumNoetig(sonderzeitenDto.getPersonalIId(), d_datum, theClientDto)
						|| bSonderzeitImmerBuchen == true) {
					boolean bAuslassen = false;
					if (auslassen != null) {
						for (int i = 0; i < auslassen.length; i++) {
							if (auslassen[i].equals(d_datum)) {
								bAuslassen = true;
							}
						}
					}
					if (bAuslassen == false) {

						// SP6722
						if (istUrlaubstagZuDatumNoetig(sonderzeitenDto.getPersonalIId(), d_datum, theClientDto) == false
								&& bSonderzeitImmerBuchen == true) {
							sonderzeitenDto.setBTag(Helper.boolean2Short(false));
							sonderzeitenDto.setBHalbtag(Helper.boolean2Short(false));
							sonderzeitenDto.setUStunden(new Time(-3600000));
						}

						iPk = createSonderzeiten(sonderzeitenDto, theClientDto);
					}
				}

			} catch (Exception e) {
				// Naechster Tag
			}
			cTag.set(Calendar.DAY_OF_MONTH, cTag.get(Calendar.DAY_OF_MONTH) + 1);
		}

		return iPk;
	}

	public Integer createSonderzeiten(SonderzeitenDto sonderzeitenDto, TheClientDto theClientDto)
			throws EJBExceptionLP {
		if (sonderzeitenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("sonderzeitenDto == null"));
		}

		if (sonderzeitenDto.getBTag() == null || sonderzeitenDto.getTDatum() == null
				|| sonderzeitenDto.getPersonalIId() == null || sonderzeitenDto.getTaetigkeitIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"sonderzeitenDto.getBTag() == null || sonderzeitenDto.getDDatum() == null || sonderzeitenDto.getPersonalIId() == null || sonderzeitenDto.getTaetigkeitIId() == null"));
		}
		// try {
		Query query = em.createNamedQuery("SonderzeitenfindByPersonalIIdTDatumTaetigkeitIId");
		query.setParameter(1, sonderzeitenDto.getPersonalIId());
		query.setParameter(2, sonderzeitenDto.getTDatum());
		query.setParameter(3, sonderzeitenDto.getTaetigkeitIId());
		// @todo getSingleResult oder getResultList ?
		try {
			Sonderzeiten dopelt = (Sonderzeiten) query.getSingleResult();

			PersonalDto pDto = getPersonalFac().personalFindByPrimaryKey(sonderzeitenDto.getPersonalIId(),
					theClientDto);

			System.out.println("PERS_SONDERZEITEN.UK: pers:" + sonderzeitenDto.getPersonalIId() + " datum: "
					+ sonderzeitenDto.getTDatum().toString() + " taetigkeit: " + sonderzeitenDto.getTaetigkeitIId());
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE,
					new Exception("PERS_SONDERZEITEN.UK PersonalNr.:" + pDto.getCPersonalnr() + " "
							+ pDto.formatAnrede() + " datum: " + sonderzeitenDto.getTDatum().toString()
							+ " taetigkeit: " + sonderzeitenDto.getTaetigkeitIId()));
		} catch (NoResultException e1) {
			// nix
		}

		if (sonderzeitenDto.getBAutomatik() == null) {
			sonderzeitenDto.setBAutomatik(Helper.boolean2Short(false));
		}

		// SP3289
		bringeFehlerWennZeitabschlussvorhanden(sonderzeitenDto.getPersonalIId(), sonderzeitenDto.getTDatum(),
				theClientDto);

		// generieren von primary key
		PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
		Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_SONDERZEITEN);
		sonderzeitenDto.setIId(pk);
		sonderzeitenDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		sonderzeitenDto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));
		try {
			Sonderzeiten sonderzeiten = new Sonderzeiten(sonderzeitenDto.getIId(), sonderzeitenDto.getPersonalIId(),
					sonderzeitenDto.getTDatum(), sonderzeitenDto.getTaetigkeitIId(), sonderzeitenDto.getBTag(),
					sonderzeitenDto.getBHalbtag(), sonderzeitenDto.getPersonalIIdAendern(),
					sonderzeitenDto.getBAutomatik());
			em.persist(sonderzeiten);
			em.flush();

			if (Helper.short2boolean(sonderzeitenDto.getBTag()) == true
					|| Helper.short2boolean(sonderzeitenDto.getBHalbtag()) == true) {
				sonderzeitenDto.setUStunden(null);
			}

			setSonderzeitenFromSonderzeitenDto(sonderzeiten, sonderzeitenDto);
			return sonderzeitenDto.getIId();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}

	}

	public Integer createZeitgutschrift(ZeitgutschriftDto dto, TheClientDto theClientDto) {

		Query query = em.createNamedQuery("ZeitgutschriftfindByPersonalIIdTDatum");
		query.setParameter(1, dto.getPersonalIId());
		query.setParameter(2, dto.getTDatum());

		try {
			Zeitgutschrift dopelt = (Zeitgutschrift) query.getSingleResult();

			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_ZEITGUTSCHRIFT.UK"));
		} catch (NoResultException e1) {
			// nix
		}

		// generieren von primary key
		PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
		Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_ZEITGUTSCHRIFT);
		dto.setIId(pk);

		try {
			Zeitgutschrift sonderzeiten = new Zeitgutschrift(dto.getIId(), dto.getPersonalIId(), dto.getTDatum(),
					dto.getUGutschriftKommt(), dto.getUGutschriftGeht());
			em.persist(sonderzeiten);
			em.flush();

			setZeitgutschriftFromZeitgutschriftDto(sonderzeiten, dto);
			return dto.getIId();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}

	}

	public Integer createUebertragBVA(UebertragBVADto uebertragBVADto, TheClientDto theClientDto) {

		Query query = em.createNamedQuery("UebertragBVAByPersonalIIdTDatum");
		query.setParameter(1, uebertragBVADto.getPersonalIId());
		query.setParameter(2, uebertragBVADto.getTDatum());

		try {
			UebertragBVA dopelt = (UebertragBVA) query.getSingleResult();

			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_UEBERTRAGBVA.UK"));
		} catch (NoResultException e1) {
			// nix
		}

		// generieren von primary key
		PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
		Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_UEBERTRAGBVA);
		uebertragBVADto.setIId(pk);

		uebertragBVADto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		uebertragBVADto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));

		try {
			UebertragBVA uebertrag = new UebertragBVA(uebertragBVADto.getIId(), uebertragBVADto.getPersonalIId(),
					uebertragBVADto.getTDatum(), uebertragBVADto.getPersonalIIdAendern(),
					uebertragBVADto.getNGleitzeit(), uebertragBVADto.getNUestd50Gz(),
					uebertragBVADto.getNUestd50Gz_Zuschlag(), uebertragBVADto.getNUestd50(),
					uebertragBVADto.getNUestd50_Zuschlag(), uebertragBVADto.getNUestd100(),
					uebertragBVADto.getnUestd100_Zuschlag(), uebertragBVADto.getTAendern());
			em.persist(uebertrag);
			em.flush();
			setUebertragBVAFromUebertragBVADto(uebertrag, uebertragBVADto);
			return uebertragBVADto.getIId();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}

	}

	public Integer createAuszahlungBVA(AuszahlungBVADto dto, TheClientDto theClientDto) {

		Query query = em.createNamedQuery("AuszahlungBVAFindByPersonalIIdTDatum");
		query.setParameter(1, dto.getPersonalIId());
		query.setParameter(2, dto.getTDatum());

		try {
			AuszahlungBVA dopelt = (AuszahlungBVA) query.getSingleResult();

			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_AUSZAHLUNG_BVA.UK"));
		} catch (NoResultException e1) {
			// nix
		}

		// generieren von primary key
		PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
		Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_AUSZAHLUNGBVA);
		dto.setIId(pk);

		dto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		dto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));

		try {
			AuszahlungBVA uebertrag = new AuszahlungBVA(dto.getIId(), dto.getPersonalIId(), dto.getTDatum(),
					dto.getPersonalIIdAendern(), dto.getNGleitzeit(), dto.getNUestd50Gz(), dto.getNUestd50Gz_Zuschlag(),
					dto.getNUestd50(), dto.getNUestd50_Zuschlag(), dto.getNUestd100(), dto.getnUestd100_Zuschlag(),
					dto.getTAendern());
			em.persist(uebertrag);
			em.flush();
			setAuszahlungBVAFromAuszahlungBVADto(uebertrag, dto);
			return dto.getIId();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}

	}

	public void removeZeitgutschrift(ZeitgutschriftDto dto) {

		try {
			Zeitgutschrift z = em.find(Zeitgutschrift.class, dto.getIId());
			if (z == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
			}
			em.remove(z);
			em.flush();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, e);
		}
	}

	public void removeUebertragBVA(UebertragBVADto dto) {
		try {
			UebertragBVA z = em.find(UebertragBVA.class, dto.getIId());
			if (z == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
			}
			em.remove(z);
			em.flush();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, e);
		}
	}

	public void removeAuszahlungBVA(AuszahlungBVADto dto) {
		try {
			AuszahlungBVA z = em.find(AuszahlungBVA.class, dto.getIId());
			if (z == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
			}
			em.remove(z);
			em.flush();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, e);
		}
	}

	public void removeSonderzeiten(SonderzeitenDto sonderzeitenDto) throws EJBExceptionLP {
		myLogger.entry();
		if (sonderzeitenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("sonderzeitenDto == null"));
		}
		if (sonderzeitenDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL,
					new Exception("sonderzeitenDto.getIId() == null"));
		}
		try {
			Sonderzeiten sonderzeiten = em.find(Sonderzeiten.class, sonderzeitenDto.getIId());
			if (sonderzeiten == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
			}
			em.remove(sonderzeiten);
			em.flush();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, e);
		}
	}

	public void removeMaschinenzeitdaten(MaschinenzeitdatenDto maschinenzeitdatenDto, TheClientDto theClientDto) {

		try {
			Maschinenzeitdaten maschinenzeitdaten = em.find(Maschinenzeitdaten.class, maschinenzeitdatenDto.getIId());
			if (maschinenzeitdaten == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
			}

			sindEintraegeBereitsVerrechnet(null, maschinenzeitdaten.getIId(), null, null, null);
			getAbrechnungsvorschlagFac().sindEintraegeInAbrechnungsvorschlag(null, maschinenzeitdaten.getIId(), null,
					null, null, theClientDto);

			em.remove(maschinenzeitdaten);
			em.flush();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, e);
		}
	}

	public void updateSonderzeiten(SonderzeitenDto sonderzeitenDto, TheClientDto theClientDto) throws EJBExceptionLP {
		if (sonderzeitenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("sonderzeitenDto == null"));
		}
		if (sonderzeitenDto.getIId() == null || sonderzeitenDto.getPersonalIId() == null
				|| sonderzeitenDto.getTaetigkeitIId() == null || sonderzeitenDto.getBTag() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_DARF_NICHT_NULL_SEIN, new Exception(
					"sonderzeitenDto.getIId() == null || sonderzeitenDto.getPersonalIId() == null || sonderzeitenDto.getTaetigkeitIId() == null || sonderzeitenDto.getBTag() == null"));
		}
		Integer iId = sonderzeitenDto.getIId();
		// try {
		Sonderzeiten sonderzeiten = em.find(Sonderzeiten.class, iId);
		if (sonderzeiten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		// SP3289
		bringeFehlerWennZeitabschlussvorhanden(sonderzeitenDto.getPersonalIId(), sonderzeitenDto.getTDatum(),
				theClientDto);
		try {
			Query query = em.createNamedQuery("SonderzeitenfindByPersonalIIdTDatumTaetigkeitIId");
			query.setParameter(1, sonderzeitenDto.getPersonalIId());
			query.setParameter(2, sonderzeitenDto.getTDatum());
			query.setParameter(3, sonderzeitenDto.getTaetigkeitIId());
			Integer iIdVorhanden = ((Sonderzeiten) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_SONDERZEITEN.UK"));
			}
		} catch (NoResultException ex) {
			// nix
		}
		sonderzeitenDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		sonderzeitenDto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));
		if (Helper.short2boolean(sonderzeitenDto.getBTag()) == true
				|| Helper.short2boolean(sonderzeitenDto.getBHalbtag()) == true) {
			sonderzeitenDto.setUStunden(null);
		}

		setSonderzeitenFromSonderzeitenDto(sonderzeiten, sonderzeitenDto);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);

		// }

	}

	public void updateZeitgutschrift(ZeitgutschriftDto dto, TheClientDto theClientDto) {

		Integer iId = dto.getIId();
		// try {
		Zeitgutschrift z = em.find(Zeitgutschrift.class, iId);
		if (z == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		try {
			Query query = em.createNamedQuery("ZeitgutschriftfindByPersonalIIdTDatum");
			query.setParameter(1, dto.getPersonalIId());
			query.setParameter(2, dto.getTDatum());
			Integer iIdVorhanden = ((Zeitgutschrift) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE,
						new Exception("PERS_ZEITGUTSCHRIFT.UK"));
			}
		} catch (NoResultException ex) {
			// nix
		}

		setZeitgutschriftFromZeitgutschriftDto(z, dto);

	}

	public SonderzeitenDto sonderzeitenFindByPrimaryKey(Integer iId, TheClientDto theClientDto) throws EJBExceptionLP {
		if (iId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}
		// try {
		Sonderzeiten sonderzeiten = em.find(Sonderzeiten.class, iId);
		if (sonderzeiten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		SonderzeitenDto dto = assembleSonderzeitenDto(sonderzeiten);
		dto.setTaetigkeitDto(taetigkeitFindByPrimaryKey(dto.getTaetigkeitIId(), theClientDto));

		return dto;
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	public ZeitgutschriftDto zeitgutschriftFindByPrimaryKey(Integer iId, TheClientDto theClientDto) {

		Zeitgutschrift z = em.find(Zeitgutschrift.class, iId);

		ZeitgutschriftDto dto = assembleZeitgutschriftDto(z);

		return dto;

	}

	public BigDecimal zeitgutschriftEinesDatums(Integer personalIId, Timestamp tDatum, boolean bKommt,
			TheClientDto theClientDto) {

		BigDecimal bdZeitgutschrift = BigDecimal.ZERO;
		try {

			Time tGutschriftKommt = null;
			Time tGutschriftGeht = null;

			try {
				Query query = em.createNamedQuery("ZeitgutschriftfindByPersonalIIdTDatum");
				query.setParameter(1, personalIId);
				query.setParameter(2, Helper.cutTimestamp(tDatum));
				Zeitgutschrift zg = (Zeitgutschrift) query.getSingleResult();

				tGutschriftKommt = zg.getUGutschriftKommt();
				tGutschriftGeht = zg.getUGutschriftGeht();

			} catch (NoResultException ex) {
				PersonalzeitmodellDto personalzeitmodellDto = getPersonalFac()
						.personalzeitmodellFindZeitmodellZuDatum(personalIId, tDatum, theClientDto);
				if (personalzeitmodellDto != null && personalzeitmodellDto.getZeitmodellDto() != null) {
					tGutschriftKommt = personalzeitmodellDto.getZeitmodellDto().getUGutschriftKommt();
					tGutschriftGeht = personalzeitmodellDto.getZeitmodellDto().getUGutschriftGeht();
				}
			}

			if (bKommt) {
				if (tGutschriftKommt != null && tGutschriftKommt.getTime() > -3600000) {
					bdZeitgutschrift = new BigDecimal(Helper.time2Double(tGutschriftKommt));
				}
			} else {
				if (tGutschriftGeht != null && tGutschriftGeht.getTime() > -3600000) {
					bdZeitgutschrift = new BigDecimal(Helper.time2Double(tGutschriftGeht));
				}
			}

		} catch (RemoteException e) {
			throwEJBExceptionLPRespectOld(e);
		}

		return bdZeitgutschrift;

	}

	public SonderzeitenDto[] sonderzeitenFindByPersonalIIdDDatum(Integer personalIId, Timestamp dDatum)
			throws EJBExceptionLP {
		// try {
		Query query = em.createNamedQuery("SonderzeitenfindByPersonalIIdTDatum");
		query.setParameter(1, personalIId);
		query.setParameter(2, Helper.cutTimestamp(dDatum));
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// null);
		// }
		return assembleSonderzeitenDtos(cl);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	public SonderzeitenDto[] sonderzeitenFindByPersonalIIdDDatumBTag(Integer personalIId, Timestamp dDatum, Short bTag)
			throws EJBExceptionLP {
		// try {
		Query query = em.createNamedQuery("SonderzeitenfindByPersonalIIdTDatumBTag");
		query.setParameter(1, personalIId);
		query.setParameter(2, Helper.cutTimestamp(dDatum));
		query.setParameter(3, bTag);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// null);
		// }
		return assembleSonderzeitenDtos(cl);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	private void setSonderzeitenFromSonderzeitenDto(Sonderzeiten sonderzeiten, SonderzeitenDto sonderzeitenDto) {
		sonderzeiten.setPersonalIId(sonderzeitenDto.getPersonalIId());
		sonderzeiten.setTDatum(sonderzeitenDto.getTDatum());
		sonderzeiten.setTaetigkeitIId(sonderzeitenDto.getTaetigkeitIId());
		sonderzeiten.setBTag(sonderzeitenDto.getBTag());
		sonderzeiten.setBHalbtag(sonderzeitenDto.getBHalbtag());
		sonderzeiten.setUStunden(sonderzeitenDto.getUStunden());
		sonderzeiten.setPersonalIIdAendern(sonderzeitenDto.getPersonalIIdAendern());
		sonderzeiten.setTAendern(sonderzeitenDto.getTAendern());
		sonderzeiten.setBAutomatik(sonderzeitenDto.getBAutomatik());
		em.merge(sonderzeiten);
		em.flush();
	}

	private void setZeitgutschriftFromZeitgutschriftDto(Zeitgutschrift z, ZeitgutschriftDto dto) {
		z.setPersonalIId(dto.getPersonalIId());
		z.setTDatum(dto.getTDatum());
		z.setUGutschriftKommt(dto.getUGutschriftKommt());
		z.setUGutschriftGeht(dto.getUGutschriftGeht());

		em.merge(z);
		em.flush();
	}

	private ZeitgutschriftDto assembleZeitgutschriftDto(Zeitgutschrift z) {
		return ZeitgutschriftDtoAssembler.createDto(z);
	}

	private SonderzeitenDto assembleSonderzeitenDto(Sonderzeiten sonderzeiten) {
		return SonderzeitenDtoAssembler.createDto(sonderzeiten);
	}

	private SonderzeitenDto[] assembleSonderzeitenDtos(Collection<?> sonderzeitens) {
		List<SonderzeitenDto> list = new ArrayList<SonderzeitenDto>();
		if (sonderzeitens != null) {
			Iterator<?> iterator = sonderzeitens.iterator();
			while (iterator.hasNext()) {
				Sonderzeiten sonderzeiten = (Sonderzeiten) iterator.next();
				list.add(assembleSonderzeitenDto(sonderzeiten));
			}
		}
		SonderzeitenDto[] returnArray = new SonderzeitenDto[list.size()];
		return (SonderzeitenDto[]) list.toArray(returnArray);
	}

	private void pruefeObZeiltmodelltagPauseSichUeberschneidet(Integer zeitmodelltagIId,
			Integer zeitmodelltagpauseIId) {

		Zeitmodelltagpause zeitmodelltagpauseAktuell = em.find(Zeitmodelltagpause.class, zeitmodelltagpauseIId);

		Query query = em.createNamedQuery("ZeitmodelltagpausefindByZeitmodelltagIId");
		query.setParameter(1, zeitmodelltagIId);
		Collection<?> cl = query.getResultList();
		Iterator it = cl.iterator();

		while (it.hasNext()) {
			Zeitmodelltagpause zmtVorhanden = (Zeitmodelltagpause) it.next();

			if (!zmtVorhanden.getIId().equals(zeitmodelltagpauseIId)) {

				boolean bFehler = false;
				if (zmtVorhanden.getUBeginn().getTime() >= zeitmodelltagpauseAktuell.getUBeginn().getTime()
						&& zmtVorhanden.getUEnde().getTime() <= zeitmodelltagpauseAktuell.getUEnde().getTime()) {
					bFehler = true;
				}

				if (zmtVorhanden.getUBeginn().getTime() >= zeitmodelltagpauseAktuell.getUBeginn().getTime()
						&& zmtVorhanden.getUBeginn().getTime() <= zeitmodelltagpauseAktuell.getUEnde().getTime()) {
					bFehler = true;
				}
				if (zmtVorhanden.getUBeginn().getTime() <= zeitmodelltagpauseAktuell.getUBeginn().getTime()
						&& zmtVorhanden.getUEnde().getTime() >= zeitmodelltagpauseAktuell.getUEnde().getTime()) {
					bFehler = true;
				}
				if (zmtVorhanden.getUBeginn().getTime() <= zeitmodelltagpauseAktuell.getUBeginn().getTime()
						&& zmtVorhanden.getUEnde().getTime() >= zeitmodelltagpauseAktuell.getUEnde().getTime()) {
					bFehler = true;
				}
				if (zeitmodelltagpauseAktuell.getUBeginn().getTime() <= zmtVorhanden.getUEnde().getTime()
						&& zeitmodelltagpauseAktuell.getUEnde().getTime() >= zmtVorhanden.getUEnde().getTime()) {
					bFehler = true;
				}

				if (bFehler == true) {

					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITMODELLTAGPAUSE_UEBERSCHNEIDEN_SICH,
							new Exception("FEHLER_ZEITMODELLTAGPAUSE_UEBERSCHNEIDEN_SICH"));

				}

			}

		}

	}

	public Integer createZeitmodelltagpause(ZeitmodelltagpauseDto zeitmodelltagpauseDto, TheClientDto theClientDto)
			throws EJBExceptionLP {
		if (zeitmodelltagpauseDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitmodelltagpauseDto == null"));
		}
		if (zeitmodelltagpauseDto.getZeitmodelltagIId() == null || zeitmodelltagpauseDto.getUBeginn() == null
				|| zeitmodelltagpauseDto.getUEnde() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"zeitmodelltagpauseDto.getZeitmodelltagIId() == null || zeitmodelltagpauseDto.getUBeginn() == null || zeitmodelltagpauseDto.getUEnde() == null"));
		}

		// generieren von primary key
		PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
		Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_ZEITMODELLTAGPAUSE);
		zeitmodelltagpauseDto.setIId(pk);
		zeitmodelltagpauseDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		zeitmodelltagpauseDto.setTAendern(new Timestamp(System.currentTimeMillis()));
		try {
			Zeitmodelltagpause zeitmodelltagpause = new Zeitmodelltagpause(zeitmodelltagpauseDto.getIId(),
					zeitmodelltagpauseDto.getZeitmodelltagIId(), zeitmodelltagpauseDto.getPersonalIIdAendern(),
					zeitmodelltagpauseDto.getUBeginn(), zeitmodelltagpauseDto.getUEnde());
			em.persist(zeitmodelltagpause);
			em.flush();
			setZeitmodelltagpauseFromZeitmodelltagpauseDto(zeitmodelltagpause, zeitmodelltagpauseDto);

			pruefeObZeiltmodelltagPauseSichUeberschneidet(zeitmodelltagpauseDto.getZeitmodelltagIId(),
					zeitmodelltagpauseDto.getIId());

			return zeitmodelltagpauseDto.getIId();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}

	}

	public void removeZeitmodelltagpause(ZeitmodelltagpauseDto zeitmodelltagpauseDto) throws EJBExceptionLP {
		myLogger.entry();
		if (zeitmodelltagpauseDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitmodelltagpauseDto == null"));
		}
		if (zeitmodelltagpauseDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("zeitmodelltagpauseDto.getIId() == null"));
		}

		// try {
		Zeitmodelltagpause toRemove = em.find(Zeitmodelltagpause.class, zeitmodelltagpauseDto.getIId());
		if (toRemove == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		try {
			em.remove(toRemove);
			em.flush();
		} catch (EntityExistsException er) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, er);
		}
		// }
		// catch (RemoveException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEIM_LOESCHEN,
		// e);
		// }
	}

	public void updateZeitmodelltagpause(ZeitmodelltagpauseDto zeitmodelltagpauseDto, TheClientDto theClientDto)
			throws EJBExceptionLP {
		if (zeitmodelltagpauseDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitmodelltagpauseDto == null"));
		}
		if (zeitmodelltagpauseDto.getIId() == null || zeitmodelltagpauseDto.getZeitmodelltagIId() == null
				|| zeitmodelltagpauseDto.getUBeginn() == null || zeitmodelltagpauseDto.getUEnde() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"zeitmodelltagpauseDto.getIId() == null || zeitmodelltagpauseDto.getZeitmodelltagIId() == null || zeitmodelltagpauseDto.getUBeginn() == null || zeitmodelltagpauseDto.getUEnde() == null"));
		}

		Integer iId = zeitmodelltagpauseDto.getIId();
		// try {
		Zeitmodelltagpause zeitmodelltagpause = em.find(Zeitmodelltagpause.class, iId);
		if (zeitmodelltagpause == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		zeitmodelltagpauseDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		zeitmodelltagpauseDto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));

		setZeitmodelltagpauseFromZeitmodelltagpauseDto(zeitmodelltagpause, zeitmodelltagpauseDto);
		pruefeObZeiltmodelltagPauseSichUeberschneidet(zeitmodelltagpauseDto.getZeitmodelltagIId(),
				zeitmodelltagpauseDto.getIId());

	}

	public ZeitmodelltagpauseDto zeitmodelltagpauseFindByPrimaryKey(Integer iId) throws EJBExceptionLP {
		if (iId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}
		// try {
		Zeitmodelltagpause zeitmodelltagpause = em.find(Zeitmodelltagpause.class, iId);
		if (zeitmodelltagpause == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleZeitmodelltagpauseDto(zeitmodelltagpause);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	private void setZeitmodelltagpauseFromZeitmodelltagpauseDto(Zeitmodelltagpause zeitmodelltagpause,
			ZeitmodelltagpauseDto zeitmodelltagpauseDto) {
		zeitmodelltagpause.setZeitmodelltagIId(zeitmodelltagpauseDto.getZeitmodelltagIId());
		zeitmodelltagpause.setUBeginn(zeitmodelltagpauseDto.getUBeginn());
		zeitmodelltagpause.setUEnde(zeitmodelltagpauseDto.getUEnde());
		zeitmodelltagpause.setPersonalIIdAendern(zeitmodelltagpauseDto.getPersonalIIdAendern());
		zeitmodelltagpause.setTAendern(zeitmodelltagpauseDto.getTAendern());
		em.merge(zeitmodelltagpause);
		em.flush();
	}

	private ZeitmodelltagpauseDto assembleZeitmodelltagpauseDto(Zeitmodelltagpause zeitmodelltagpause) {
		return ZeitmodelltagpauseDtoAssembler.createDto(zeitmodelltagpause);
	}

	private ZeitmodelltagpauseDto[] assembleZeitmodelltagpauseDtos(Collection<?> zeitmodelltagpauses) {
		List<ZeitmodelltagpauseDto> list = new ArrayList<ZeitmodelltagpauseDto>();
		if (zeitmodelltagpauses != null) {
			Iterator<?> iterator = zeitmodelltagpauses.iterator();
			while (iterator.hasNext()) {
				Zeitmodelltagpause zeitmodelltagpause = (Zeitmodelltagpause) iterator.next();
				list.add(assembleZeitmodelltagpauseDto(zeitmodelltagpause));
			}
		}
		ZeitmodelltagpauseDto[] returnArray = new ZeitmodelltagpauseDto[list.size()];
		return (ZeitmodelltagpauseDto[]) list.toArray(returnArray);
	}

	/**
	 * Methode fuer JRDataSource
	 * 
	 * @return boolean
	 * @throws JRException
	 */
	public boolean next() throws JRException {

		index++;
		return (index < data.length);

	}

	public Object getFieldValue(JRField field) throws JRException {
		Object value = null;

		String fieldName = field.getName();

		if (sAktuellerReport.equals(ZeiterfassungFac.REPORT_MONATSABRECHNUNG)) {
			if ("Woche".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_KALENDERWOCHE];
			} else if ("Wochentag".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_WOCHENTAG];
			} else if ("Datum".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_DATUM];
			} else if ("Tag".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_TAG];
			} else if ("Tagesart".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_TAGESART];
			} else if ("Zeitmodell".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_ZEITMODELL];
			} else if ("ZEITMODELL_I_ID".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_ZEITMODELL_I_ID];
			} else if ("Von".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_VON];
			} else if ("Bis".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_BIS];
			} else if ("Unter".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UNTER];
			} else if ("Soll".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_SOLL];
			} else if ("Ist".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_IST];
			} else if ("Diff".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_DIFF];
			} else if ("SubreportZulagen".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_SUBREPORT_ZULAGEN];
			} else if ("SubreportSchichtzeiten".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_SUBREPORT_SCHICHTZEITEN];
			} else if ("Feiertag".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_FEIERTAG];
			} else if ("Urlaub".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_URLAUB];
			} else if ("UrlaubTag".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_URLAUBTAGEWEISE];
			} else if ("UrlaubAutomatik".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_URLAUB_AUTOMATIK];
			} else if ("Krank".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_KRANK];
			} else if ("Kindkrank".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_KINDKRANK];
			} else if ("Arzt".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_ARZT];
			} else if ("Behoerde".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_BEHOERDE];
			} else if ("Zeitausgleich".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_ZEITAUSGLEICH];
			} else if ("Bemerkung".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_BEMERKUNG];
			} else if ("Sonstigebezahlt".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_SONSTIGE_BEZAHLTETAETIGKEITEN];
			} else if ("Sonstigeunbezahlt".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_SONSTIGE_UNBEZAHLTETAETIGKEITEN];
			} else if ("Zusatzbezeichnung".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_ZUSATZBEZEICHNUNG];
			} else if ("Reise".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_REISE];
			} else if ("ReisePassiv".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_REISE_PASSIV];
			} else if ("Uestd100".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UESTD100];
			} else if ("Uestd100Steuerfrei".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UESTD100FREI];
			} else if ("Uestd50".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UESTD50];
			} else if ("Uestd200".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UESTD200];
			} else if ("Uestd50Tageweise".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UESTD50TAGEWEISE];
			} else if ("Uestd50TageweiseSteuerfrei".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UESTD50TAGESWEISEFREI];
			} else if ("Jahr".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_JAHR];
			} else if ("Mehrstunden".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_MEHRZEIT];
			} else if ("Qualifikationsfaktor".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_QUALIFIKATIONSFAKTOR];
			} else if ("ZeitgutschriftKommt".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_KOMMT];
			} else if ("ZeitgutschriftGeht".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_GEHT];
			}

			else if ("BetriebsvereinbarungAGleitzeit".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_BV_A_GLEITZEIT];
			} else if ("BetriebsvereinbarungAUestd50UeberGleitzeit".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_BV_A_UEST50_UEBER_GLEITZEIT];
			} else if ("BetriebsvereinbarungAUestd50".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_BV_A_UESTD50];
			} else if ("BetriebsvereinbarungAUestd100".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_BV_A_UESDT100];
			}

		} else if (sAktuellerReport.equals(ZeiterfassungFac.REPORT_WOCHENABRECHNUNG)
				|| sAktuellerReport.equals(ZeiterfassungFac.REPORT_WOCHENJOURNAL)) {
			if ("Kw".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_KALENDERWOCHE];
			} else if ("Soll".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_SOLL];
			} else if ("Ist".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_IST];
			} else if ("Diff".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_DIFF];
			} else if ("Unter".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UNTER];
			} else if ("Ftg".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_FEIERTAG];
			} else if ("Urlaub".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_URLAUB];
			} else if ("Krank".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_KRANK];
			} else if ("Kindkrank".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_KINDKRANK];
			} else if ("Behoerde".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_BEHOERDE];
			} else if ("Arzt".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_ARZT];
			} else if ("Sonstbez".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_SONSTIGE_BEZAHLTETAETIGKEITEN];
			} else if ("Uestd100".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UESTD100];
			} else if ("Uestd200".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UESTD200];
			} else if ("Uestd100Frei".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UESTD100FREI];
			} else if ("Uestd50Tageweise".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UESTD50TAGEWEISE];
			} else if ("Uestd50TageweiseFrei".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UESTD50TAGESWEISEFREI];
			} else if ("Uestd50".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_UESTD50];
			} else if ("Mehrzeit".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_MEHRZEIT];
			} else if ("SubreportZeitdatenjournal".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_PLATZHALTER_FUER_SUREPORTZEIDATENJOURNAL];
			} else if ("ZeitgutschriftKommt".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_KOMMT];
			} else if ("ZeitgutschriftGeht".equals(fieldName)) {
				value = data[index][REPORT_MONATSABRECHNUNG_ZEITGUTSCHRIFT_GEHT];
			}

		} else if (sAktuellerReport.equals(ZeiterfassungFac.REPORT_ANWESENHEITSLISTE)) {
			if ("Anwesend".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_ANWESEND];
			} else if ("Personalnummer".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_PERSONALNUMMER];
			} else if ("Name".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_NAME];
			} else if ("Vorname".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_VORNAME];
			} else if ("Nachname".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_NACHNAME];
			} else if ("Telefonprivat".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_TEL_PRIVAT];
			} else if ("Taetigkeit".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_TAETIGKEIT];
			} else if ("Zeit".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_ZEIT];
			} else if ("Quelle".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_QUELLE];
			} else if ("Sonderzeit".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_SONDERZEIT];
			} else if ("SonderzeitArt".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_SONDERZEIT_ART];
			} else if ("SonderzeitStunden".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_SONDERZEIT_STUNDEN];
			} else if ("AbwesenheitsartKennung".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_ABWESENHEITSART_KENNUNG];
			} else if ("AbwesenheitsartBezeichnung".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_ABWESENHEITSART_BEZEICHNUNG];
			}

			else if ("TaetigkeitArtikelnummer".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_TAETIGKEIT_ARTIKELNUMMER];
			} else if ("TaetigkeitBezeichnung".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_TAETIGKEIT_BEZEICHNUNG];
			} else if ("KundeKurzbezeichnung".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_KUNDE_KURZBEZEICHNUNG];
			} else if ("PartnerKurzbezeichnung".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_PARTNER_KURZBEZEICHNUNG];
			} else if ("Projektnummer".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_PROJEKTNUMMER];
			} else if ("Projektbezeichnung".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_PROJEKTBEZEICHNUNG];
			} else if ("Losnummer".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_LOSNUMMER];
			} else if ("Auftragsnummer".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_AUFTRAGSNUMMER];
			} else if ("LosAGNummer".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_LOS_AGNUMMER];
			} else if ("LosUAGNummer".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_LOS_UAGNUMMER];
			} else if ("LosMaschineInventarnummer".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_LOS_MASCHINE_INVENTARNUMMER];
			} else if ("LosMaschineBezeichnung".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_LOS_MASCHINE_BEZEICHNUNG];
			} else if ("LosKommentar".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_LOS_KOMMENTAR];
			} else if ("MaschineInventarnummer".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_MASCHINE_INVENTARNUMMER];
			} else if ("MaschineBezeichnung".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_MASCHINE_BEZEICHNUNG];
			} else if ("PERSONAL_I_ID".equals(fieldName)) {
				value = data[index][REPORT_ANWESENHEITSLISTE_PERSONAL_I_ID];
			}

		} else if (sAktuellerReport.equals(ZeiterfassungFac.REPORT_SONDERZEITENLISTE)) {
			if ("Personalnummergruppierung".equals(fieldName)) {
				value = data[index][REPORT_SONDERTAETIGKEITENLISTE_PERSONALNUMMER_GRUPPIERUNG];
			} else if ("Personalnummer".equals(fieldName)) {
				value = data[index][REPORT_SONDERTAETIGKEITENLISTE_PERSONALNUMMER];
			} else if ("Name".equals(fieldName)) {
				value = data[index][REPORT_SONDERTAETIGKEITENLISTE_NAME];
			} else if ("Taetigkeit".equals(fieldName)) {
				value = data[index][REPORT_SONDERTAETIGKEITENLISTE_TAETIGKEIT];
			} else if ("Zeit".equals(fieldName)) {
				value = data[index][REPORT_SONDERTAETIGKEITENLISTE_ZEIT];
			} else if ("Tage".equals(fieldName)) {
				value = data[index][REPORT_SONDERTAETIGKEITENLISTE_TAGE];
			} else if ("Faktorbezahlt".equals(fieldName)) {
				value = data[index][REPORT_SONDERTAETIGKEITENLISTE_FAKTORBEZAHLT];
			} else if ("LfdFehltage".equals(fieldName)) {
				value = data[index][REPORT_SONDERTAETIGKEITENLISTE_LFD_FEHLTAGE];
			} else if ("WarnmeldungInKalendertagen".equals(fieldName)) {
				value = data[index][REPORT_SONDERTAETIGKEITENLISTE_WARNMEDLUNG_IN_KALENDERTAGEN];
			} else if ("SubreportDetails".equals(fieldName)) {
				value = data[index][REPORT_SONDERTAETIGKEITENLISTE_SUBREPORT_DETAILS];
			}
		} else if (sAktuellerReport.equals(ZeiterfassungFac.REPORT_LOHNDATENEXPORT)) {
			if ("Personalnummer".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_PERSONALNUMMER];
			} else if ("Monat".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_MONAT];
			} else if ("Jahr".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_JAHR];
			} else if ("Lohnart".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_LOHNART];
			} else if ("Stunden".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_STUNDEN];
			} else if ("Vorname".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_VORNAME];
			} else if ("Name".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_NACHNAME];
			} else if ("Lohnart_Nr".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_LOHNART_NR];
			} else if ("Lohnstundenart".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_LOHNSTUNDENART];
			} else if ("Zeitmodell".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_ZEITMODELL];
			} else if ("Schichtzeit".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_SCHICHTZEIT];
			} else if ("Taetigkeit".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_TAETIGKEIT];
			} else if ("F_SUBREPORT_VON_BIS".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_SUBREPORT_SONDERZEITEN_VON_BIS];
			} else if ("F_ARRAY_LIST_VON_BIS".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_ARRAYLIST_VON_BIS];
			} else if ("AusfallsprinzipWochen".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_AUSFALLSPRINZIP_WOCHEN];
			} else if ("AusfallsprinzipUestd".equals(fieldName)) {
				value = data[index][ZeiterfassungFac.REPORT_LOHNDATENEXPORT_AUSFALLSPRINZIP_UESTD];
			}
		} else if (sAktuellerReport.equals(ZeiterfassungFac.REPORT_PRODUKTIVITAETSSTATISTIK)) {
			if ("PersonalID".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSONAL_ID];
			} else if ("Auftrag".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG];
			} else if ("Projekt".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT];
			} else if ("ProjektIId".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_I_ID];
			} else if ("ProjektIId_Projektklammer".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_I_ID_PROJEKTKLAMMER];
			} else if ("ProjektBereich".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_BEREICH];
			} else if ("Angebot".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_ANGEBOT];
			} else if ("Projektbezeichnung".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKTBEZEICHNUNG];
			} else if ("Kunde".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE];
			} else if ("KundeBranche".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE_BRANCHE];
			} else if ("KundePartnerklasse".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_KUNDE_PARTNERKLASSE];
			} else if ("Dauer".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_DAUER];
			} else if ("Stklnr".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_STKLNR];
			} else if ("Stklbez".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_STKLBEZ];
			} else if ("Los".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS];
			} else if ("LosFertigungsgruppe".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_FERTIUNGSGRUPPE];
			} else if ("Losklassen".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOSKLASSEN];
			} else if ("Artikel".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_TAETIGKEIT];
			} else if ("Artikelbezeichnung".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_TAETIGKEIT_BEZEICHNUNG];
			}

			else if ("LosAgart".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_AGART];
			} else if ("LosFertig".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_FERTIG];
			} else if ("LosGutstueck".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_GUTSTUECK];
			} else if ("LosRuestenMitrechnen".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_RUESTEN_MITRECHNEN];
			} else if ("LosInarbeit".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_INARBEIT];
			} else if ("LosLosgroesse".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_LOSGROESSE];
			} else if ("LosRuestzeit".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_RUESTZEIT];
			} else if ("LosSchlechtstueck".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_SCHLECHTSTUECK];
			} else if ("LosStueckzeit".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_STUECKZEIT];
			} else if ("LosZeitanteil".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_ZEITANTEIL];
			} else if ("LosGesamtzeit".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_GESAMTZEIT];
			} else if ("LosAgnummer".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_AGNUMMER];
			} else if ("LosUagnummer".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_UAGNUMMER];
			} else if ("Projekt_Projektklammer".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKT_PROJEKTKLAMMER];
			} else if ("Bereich_Projektklammer".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_BEREICH_PROJEKTKLAMMER];
			} else if ("Projektkategorie_Projektklammer".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PROJEKTKATEGORIE_PROJEKTKLAMMER];
			} else if ("Telefonzeit".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_TELEFONZEIT];
			} else if ("PersonName".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_NAME];
			} else if ("PersonPersonalgruppe".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_PERSONALGRUPPE];
			} else if ("PersonIstGesamt".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_IST_GESAMT];
			} else if ("PersonIntern".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_INTERN];
			} else if ("PersonExtern".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_EXTERN];
			} else if ("PersonProzentintern".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_PROZENTINTERN];
			} else if ("PersonProzentextern".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_PROZENTEXTERN];
			} else if ("PersonLeistungswert".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_LEISTUNGSWERT];
			} else if ("PersonSubreportSondertaetigkeiten".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_SUBREPORT_SONDERTAETIGKEITEN];
			} else if ("PersonKostenstelle".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_KOSTENSTELLE];
			} else if ("PersonAbteilung".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_ABTEILUNG];
			} else if ("AuftragKostenstelle".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG_KOSTENSTELLE];
			} else if ("AuftragBestellnummer".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG_BESTELLNUMMER];
			} else if ("AuftragKostenstelleBezeichnung".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_AUFTRAG_KOSTENSTELLE_BEZEICHNUNG];
			} else if ("PersonAbteilung".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_ABTEILUNG];
			} else if ("LosKostenstelle".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_LOS_KOSTENSTELLE];
			}

			else if ("Bemerkung".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_BEMERKUNG];
			} else if ("KommentarIntern".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_KOMMENTAR_INTERN];
			} else if ("KommentarExtern".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_KOMMENTAR_EXTERN];
			} else if ("OffeneZeitenVorhanden".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_OFFENE_ZEITEN_VORHANDEN];
			} else if ("PersonExternVerrechenbar".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_EXTERN_VERRECHENBAR];
			} else if ("PersonExternNichtVerrechenbar".equals(fieldName)) {
				value = data[index][REPORT_PRODUKTIVITAETISSTATISTIK_PERSON_EXTERN_NICHT_VERRECHENBAR];
			}

		} else if (sAktuellerReport.equals(ZeiterfassungFac.REPORT_SONDERTAETIKGEITEN)) {
			if ("Kennung".equals(fieldName)) {
				value = data[index][REPORT_SONDERTAETIGKEITEN_KENNUNG];
			} else if ("Bezeichnung".equals(fieldName)) {
				value = data[index][REPORT_SONDERTAETIGKEITEN_BEZEICHNUNG];
			}
		} else if (sAktuellerReport.equals(ZeiterfassungFac.REPORT_ZEITSALDO)) {
			if ("Arzt".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_ARZT];
			} else if ("Behoerde".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BEHOERDE];
			} else if ("Feiertag".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_FTG];
			} else if ("Feiertagsoll".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_FTGSOLL];
			} else if ("Ist".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_IST];
			} else if ("Krank".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_KRANK];
			} else if ("KindKrank".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_KIND_KRANK];
			} else if ("Person".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_PERSON];
			} else if ("Kostenstelle".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_KOSTENSTELLE];
			} else if ("Abteilung".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_ABTEILUNG];
			} else if ("Eintrittsdatum".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_EINTRITTSDATUM];
			} else if ("Personalnummer".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_PERSONALNUMMER];
			} else if ("Reise".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_REISE];
			} else if ("ReisePassiv".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_REISE_PASSIV];
			} else if ("SubreportSonderzeiten".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_SUBREPORT_SONDERZEITEN];
			} else if ("Soll".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_SOLL];
			} else if ("Sonstigebezahlt".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_SONSTIGEBEZAHLT];
			} else if ("Sonstigenichtbezahlt".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_SONSTIGENICHTBEZAHLT];
			} else if ("Uestdsaldo100".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_UESTDSALDO100];
			} else if ("Uestdsaldo100Steuerfrei".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_UESTDSALDO100STF];
			} else if ("Uestdsaldo200".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_UESTDSALDO200];
			} else if ("Uestdsaldo50".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_UESTDSALDO50];
			} else if ("Ausbezahlt100".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_AUSBEZAHLT100];
			} else if ("Ausbezahlt100Steuerfrei".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_AUSBEZAHLT100STF];
			} else if ("Ausbezahlt50".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_AUSBEZAHLT50];
			} else if ("Ausbezahlt50Steuerfrei".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_AUSBEZAHLT50STF];
			} else if ("AusbezahltGutstunden".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_AUSBEZAHLTGUTSTD];
			} else if ("Qualipraemie".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_QUALIPRAEMIE];
			} else if ("AusbezahltMehrstunden".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_AUSBEZAHLTMEHRSTD];
			} else if ("AusbezahltNormalstunden".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_AUSBEZAHLTNORMALSTD];
			} else if ("Ausbezahlt200".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_AUSBEZAHLT200];
			} else if ("Uestdsaldo50Steuerfrei".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_UESTDSALDO50STF];
			} else if ("UestdsaldoMehrstunden".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_UESTDSALDOMEHRSTD];
			} else if ("Urlaub".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBSTD];
			} else if ("UrlaubStundenAliquot".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBSTUNDEN_ALIQUOT];
			} else if ("UrlaubStundenGeplant".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUB_GEPLANT];
			} else if ("UrlaubStundenAktuell".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUBAKUTELL];
			} else if ("UrlaubStundenAktuellVerbraucht".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUBAKUTELLVERBRAUCHT];
			} else if ("UrlaubStundenRest".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUBREST];
			} else if ("UrlaubStundenRestVerbraucht".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBSTUNDEN_URLAUBRESTVERBRAUCHT];
			} else if ("UrlaubTageAliquot".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBTAGE_ALIQUOT];
			} else if ("UrlaubTageGeplant".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBTAGE_URLAUB_GEPLANT];
			} else if ("UrlaubTageAktuell".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBTAGE_URLAUBAKTUELL];
			} else if ("UrlaubTageVorjahr".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBTAGE_URLAUBVORJAHR];
			} else if ("UrlaubTageAktuellVerbraucht".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBTAGE_URLAUBAKTUELLVERBRAUCHT];
			} else if ("UrlaubTageRest".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBTAGE_URLAUBREST];
			} else if ("UrlaubTageRestVerbraucht".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBTAGE_URLAUBRESTVERBRAUCHT];
			} else if ("GleitzeitsaldoVormonat".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_GLEITZEITSALDOVORMONAT];
			} else if ("GleitzeitsaldoAktuellerMonat".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_GLEITZEITSALDOAKTUELLERMONAT];
			} else if ("MonatJahr".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_MONAT];
			} else if ("BetriebsvereinbarungAGleitzeit".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_GLEITZEIT];
			} else if ("BetriebsvereinbarungAUestd100".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD100];
			} else if ("BetriebsvereinbarungAUestd50".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD50];
			} else if ("BetriebsvereinbarungAUestd50UeberGleitzeit".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD50_UEBER_GLEITZEIT];
			} else if ("BetriebsvereinbarungAUestd50UeberGleitzeitZuschlag".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD50_UEBER_GLEITZEIT_ZUSCHLAG];
			} else if ("BetriebsvereinbarungAUestd50Zuschlag".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD50_ZUSCHLAG];
			} else if ("BetriebsvereinbarungAUestd100Zuschlag".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UESTD100_ZUSCHLAG];
			} else if ("BetriebsvereinbarungAGleitzeitDiff".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_GLEITZEIT_DIFF];
			}

			else if ("KollektivAbrechnungsart".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_KOLLEKTIV_ABRECHNUNGSART];
			}

			else if ("BetriebsvereinbarungAUebertragGleitzeit".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_GLEITZEIT];
			} else if ("BetriebsvereinbarungAUebertragUestd50UeberGleitzeit".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD50_UEBER_GLEITZEIT];
			} else if ("BetriebsvereinbarungAUebertragUestd50UeberGleitzeitZuschlag".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD50_UEBERGLEITZEIT_ZUSCHLAG];
			} else if ("BetriebsvereinbarungAUebertragUestd50".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD50];
			} else if ("BetriebsvereinbarungAUebertragUestd50Zuschlag".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD50_ZUSCHLAG];
			} else if ("BetriebsvereinbarungAUebertragUestd100".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD100];
			} else if ("BetriebsvereinbarungAUebertragUestd100Zuschlag".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_UEBERTRAG_UESTD100_ZUSCHLAG];
			} else if ("BetriebsvereinbarungAEntsprichtNormalstunden".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_ENTSPRICHT_NORMALSTUNDEN];
			} else if ("BetriebsvereinbarungAGleitzeitDiffAktuellesMonat".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_GLEITZEIT_DIFF_AKTUELLES_MONAT];
			} else if ("UrlaubTageAliquotEndeMonat".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBTAGE_ALIQUOT_ENDEMONAT];
			} else if ("UrlaubStundenAliquotEndeMonat".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_URLAUBSTUNDEN_ALIQUOT_ENDEMONAT];
			}

			else if ("BetriebsvereinbarungAAuszahlungGleitzeit".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_GLEITZEIT];
			} else if ("BetriebsvereinbarungAAuszahlungUestd100".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD100];
			} else if ("BetriebsvereinbarungAAuszahlungUestd100Zuschlag".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD100_ZUSCHLAG];
			} else if ("BetriebsvereinbarungAAuszahlungUestd50".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD50];
			} else if ("BetriebsvereinbarungAAuszahlungUestd50Zuschlag".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD50_ZUSCHLAG];
			} else if ("BetriebsvereinbarungAAuszahlungUestd50UeberGleitzeit".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD50_UEBER_GLEITZEIT];
			} else if ("BetriebsvereinbarungAAuszahlungUestd50UeberGleitzeitZuschlag".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_AUSZAHLUNG_UESTD50_UEBERGLEITZEIT_ZUSCHLAG];
			}

			else if ("BetriebsvereinbarungAVormonatGleitzeit".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_GLEITZEIT];
			} else if ("BetriebsvereinbarungAVormonatUestd100".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD100];
			} else if ("BetriebsvereinbarungAVormonatUestd100Zuschlag".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD100_ZUSCHLAG];
			} else if ("BetriebsvereinbarungAVormonatUestd50".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD50];
			} else if ("BetriebsvereinbarungAVormonatUestd50Zuschlag".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD50_ZUSCHLAG];
			} else if ("BetriebsvereinbarungAVormonatUestd50UeberGleitzeit".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD50_UEBER_GLEITZEIT];
			} else if ("BetriebsvereinbarungAVormonatUestd50UeberGleitzeitZuschlag".equals(fieldName)) {
				value = data[index][REPORT_ZEITSALDO_BETRIEBSVEREINBARUNG_A_VORMONAT_UESTD50_UEBERGLEITZEIT_ZUSCHLAG];
			}

		} else if (sAktuellerReport.equals(ZeiterfassungFac.REPORT_WOCHENABSCHLUSS)) {
			if ("Datum".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_DATUM];
			} else if ("Geht".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_GEHT];
			} else if ("Kommt".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_KOMMT];
			} else if ("SubreportBelegzeiten".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_SUBREPORT_BELEGZEITEN];
			} else if ("Soll".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_SOLL];
			} else if ("Ist".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_IST];
			} else if ("Feiertag".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_FEIERTAG];
			} else if ("Arzt".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_ARZT];
			} else if ("Krank".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_KRANK];
			} else if ("KindKrank".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_KINDKRANK];
			} else if ("Behoerde".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_BEHOERDE];
			} else if ("Urlaub".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_URLAUB];
			} else if ("SonstigeBezahlt".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_SONSTIGE_BEZAHLT];
			} else if ("SonstigeUnbezahlt".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_SONSTIGE_UNBEZAHLT];
			} else if ("Fehler".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_FEHLER];
			} else if ("Wochentag".equals(fieldName)) {
				value = data[index][REPORT_WOCHENABSCHLUSS_WOCHENTAG];
			}

		}
		return value;
	}

	public Integer createMaschine(MaschineDto maschineDto, TheClientDto theClientDto) throws EJBExceptionLP {
		if (maschineDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("maschineDto == null"));
		}
		if (maschineDto.getCInventarnummer() == null || maschineDto.getBAutoendebeigeht() == null

				|| maschineDto.getMaschinengruppeIId() == null || maschineDto.getBVersteckt() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"maschineDto.getCInventarnummer() == null || maschineDto.getBAutoendebeigeht() == null || maschineDto.getFVerfuegbarkeitinprozent() == null || maschineDto.getMaschinengruppeIId() == null"));
		}
		try {
			Query query = em.createNamedQuery("MaschinefindByMandantCNrCInventarnummer");
			query.setParameter(1, theClientDto.getMandant());
			query.setParameter(2, maschineDto.getCInventarnummer());
			// @todo getSingleResult oder getResultList ?
			Maschine doppelt = (Maschine) query.getSingleResult();
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_MASCHINE.UK"));
		} catch (NoResultException ex1) {
			// nothing here
		}

		if (maschineDto.getBManuelleBedienung() == null) {
			maschineDto.setBManuelleBedienung(Helper.boolean2Short(false));
		}

		if (maschineDto.getCIdentifikationsnr() != null) {
			try {
				Query query = em.createNamedQuery("MaschinefindByCIdentifikationsnr");
				query.setParameter(1, maschineDto.getCIdentifikationsnr());
				Maschine doppelt = (Maschine) query.getSingleResult();
				throw EJBExcFactory.maschineIdentifikationsnrExistiertBereits(doppelt, theClientDto.getMandant());
			} catch (NoResultException ex1) {
				// nothing here
			}
		}
		try {
			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_MASCHINE);
			maschineDto.setIId(pk);
			maschineDto.setMandantCNr(theClientDto.getMandant());

			Maschine maschine = new Maschine(maschineDto.getIId(), maschineDto.getMandantCNr(),
					maschineDto.getCInventarnummer(), maschineDto.getBAutoendebeigeht(),
					maschineDto.getMaschinengruppeIId(), maschineDto.getBVersteckt(),
					maschineDto.getBManuelleBedienung());
			em.persist(maschine);
			em.flush();
			setMaschineFromMaschineDto(maschine, maschineDto);
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
		return maschineDto.getIId();
	}

	public void removeMaschine(MaschineDto maschineDto) throws EJBExceptionLP {
		myLogger.entry();
		if (maschineDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("maschineDto == null"));
		}
		if (maschineDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("maschineDto.getIId() == null"));
		}

		// try {
		Maschine toRemove = em.find(Maschine.class, maschineDto.getIId());
		if (toRemove == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		try {
			em.remove(toRemove);
			em.flush();
		} catch (EntityExistsException er) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, er);
		}
		// }
		// catch (RemoveException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEIM_LOESCHEN,
		// e);
		// }

	}

	public void updateMaschine(MaschineDto maschineDto) throws EJBExceptionLP {
		if (maschineDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("maschineDto == null"));
		}
		if (maschineDto.getIId() == null || maschineDto.getCInventarnummer() == null
				|| maschineDto.getBAutoendebeigeht() == null || maschineDto.getMaschinengruppeIId() == null
				|| maschineDto.getBVersteckt() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"maschineDto.getIId() == null || maschineDto.getCInventarnummer() == null || maschineDto.getBAutoendebeigeht() == null || maschineDto.getFVerfuegbarkeitinprozent() == null || maschineDto.getMaschinengruppeIId() == null"));
		}
		Integer iId = maschineDto.getIId();

		try {
			Query query = em.createNamedQuery("MaschinefindByMandantCNrCInventarnummer");
			query.setParameter(1, maschineDto.getMandantCNr());
			query.setParameter(2, maschineDto.getCInventarnummer());
			Integer iIdVorhanden = ((Maschine) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_MASCHINE.UK"));
			}

		} catch (NoResultException ex) {
			// NIX
		}

		if (maschineDto.getCIdentifikationsnr() != null) {
			try {
				Query query = em.createNamedQuery("MaschinefindByCIdentifikationsnr");
				query.setParameter(1, maschineDto.getCIdentifikationsnr());
				Integer iIdVorhanden = ((Maschine) query.getSingleResult()).getIId();
				if (iId.equals(iIdVorhanden) == false) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE,
							new Exception("PERS_MASCHINE.C_IDENTIFIKATIONSNR"));
				}

			} catch (NoResultException ex) {

			}

		}

		// try {
		Maschine maschine = em.find(Maschine.class, iId);
		if (maschine == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");

		}
		setMaschineFromMaschineDto(maschine, maschineDto);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);

		// }

	}

	public MaschineDto maschineFindByPrimaryKey(Integer iId) {
		if (iId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}
		// try {
		Maschine maschine = em.find(Maschine.class, iId);
		if (maschine == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleMaschineDto(maschine);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	public MaschinenzeitdatenDto maschinenzeitdatenFindByPrimaryKey(Integer iId) {

		Maschinenzeitdaten maschinenzeitdaten = em.find(Maschinenzeitdaten.class, iId);
		if (maschinenzeitdaten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleMaschinenzeitdatenDto(maschinenzeitdaten);

	}

	public MaschineDto maschineFindByMandantCNrCInventarnummer(String cInventarnummer, TheClientDto theClientDto)
			throws EJBExceptionLP {
		if (cInventarnummer == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("cInventarnummer == null"));
		}
		// try {
		Query query = em.createNamedQuery("MaschinefindByMandantCNrCInventarnummer");
		query.setParameter(1, cInventarnummer);
		query.setParameter(2, theClientDto.getMandant());
		Maschine maschine = (Maschine) query.getSingleResult();
		if (maschine == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleMaschineDto(maschine);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND,
		// e);
		// }
	}

	public MaschineDto[] maschineFindByMandantCNr(String mandantCNr) throws EJBExceptionLP {
		if (mandantCNr == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("mandantCNr == null"));
		}
		// try {
		Query query = em.createNamedQuery("MaschinefindByByMandantCNr");
		query.setParameter(1, mandantCNr);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND,
		// null);
		// }
		return assembleMaschineDtos(cl);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND,
		// e);
		// }
	}

	public MaschineDto maschineFindByCIdentifikationsnr(String cIdentifikationsnr) throws EJBExceptionLP {
		if (cIdentifikationsnr == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("cIdentifikationsnr == null"));
		}
		try {
			Query query = em.createNamedQuery("MaschinefindByCIdentifikationsnr");
			query.setParameter(1, cIdentifikationsnr);
			Maschine maschine = (Maschine) query.getSingleResult();
			return assembleMaschineDto(maschine);
		} catch (NoResultException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, e);
		}
	}

	private void setMaschineFromMaschineDto(Maschine maschine, MaschineDto maschineDto) {
		maschine.setMandantCNr(maschineDto.getMandantCNr());
		maschine.setCInventarnummer(maschineDto.getCInventarnummer());
		maschine.setCIdentifikationsnr(maschineDto.getCIdentifikationsnr());
		maschine.setCBez(maschineDto.getCBez());
		maschine.setBAutoendebeigeht(maschineDto.getBAutoendebeigeht());
		maschine.setTKaufdatum(maschineDto.getTKaufdatum());
		maschine.setMaschinengruppeIId(maschineDto.getMaschinengruppeIId());
		maschine.setBVersteckt(maschineDto.getBVersteckt());

		maschine.setIAbschreibungInMonaten(maschineDto.getIAbschreibungInMonaten());
		maschine.setIPlanstunden(maschineDto.getIPlanstunden());
		maschine.setNAnschaffungskosten(maschineDto.getNAnschaffungskosten());
		maschine.setNEnergiekosten(maschineDto.getNEnergiekosten());
		maschine.setNRaumkosten(maschineDto.getNRaumkosten());
		maschine.setNVerzinsung(maschineDto.getNVerzinsung());
		maschine.setNSonstigekosten(maschineDto.getNSonstigekosten());
		maschine.setArtikelIIdVerrechnen(maschineDto.getArtikelIIdVerrechnen());
		maschine.setBManuelleBedienung(maschineDto.getBManuelleBedienung());
		maschine.setCSeriennummer(maschineDto.getCSeriennummer());

		em.merge(maschine);
		em.flush();
	}

	private MaschineDto assembleMaschineDto(Maschine maschine) {
		return MaschineDtoAssembler.createDto(maschine);
	}

	private MaschinenzeitdatenDto assembleMaschinenzeitdatenDto(Maschinenzeitdaten maschinenzeitdaten) {
		return MaschinenzeitdatenDtoAssembler.createDto(maschinenzeitdaten);
	}

	private MaschineDto[] assembleMaschineDtos(Collection<?> maschines) {
		List<MaschineDto> list = new ArrayList<MaschineDto>();
		if (maschines != null) {
			Iterator<?> iterator = maschines.iterator();
			while (iterator.hasNext()) {
				Maschine maschine = (Maschine) iterator.next();
				list.add(assembleMaschineDto(maschine));
			}
		}
		MaschineDto[] returnArray = new MaschineDto[list.size()];
		return (MaschineDto[]) list.toArray(returnArray);
	}

	public Integer createZeitstift(ZeitstiftDto zeitstiftDto, TheClientDto theClientDto) throws EJBExceptionLP {

		if (zeitstiftDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitstiftDto == null"));
		}
		if (zeitstiftDto.getCNr() == null || zeitstiftDto.getBMehrfachstift() == null
				|| zeitstiftDto.getCTyp() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"zeitstiftDto.getCNr() == null || zeitstiftDto.getBMehrfachstift() == null || zeitstiftDto.getCTyp() == null"));
		}
		if (Helper.short2boolean(zeitstiftDto.getBPersonenzuordnung()) == false) {
			if (Helper.short2boolean(zeitstiftDto.getBMehrfachstift()) == false
					&& zeitstiftDto.getPersonalIId() == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL,
						new Exception("zeitstiftDto.getPersonalIId() == null"));

			}
		} else {
			zeitstiftDto.setPersonalIId(null);
		}
		if (Helper.short2boolean(zeitstiftDto.getBMehrfachstift()) == true) {
			zeitstiftDto.setPersonalIId(null);
		}

		try {
			Query query = em.createNamedQuery("ZeitstiftfindByCNr");
			query.setParameter(1, zeitstiftDto.getCNr());
			Zeitstift doppelt = (Zeitstift) query.getSingleResult();
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_ZEITSTIFT.C_NR"));
		} catch (NoResultException ex1) {
			// nothing here
		}

		try {

			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_ZEITSTIFT);
			zeitstiftDto.setIId(pk);
			zeitstiftDto.setMandantCNr(theClientDto.getMandant());
			Zeitstift zeitstift = new Zeitstift(zeitstiftDto.getIId(), zeitstiftDto.getCNr(),
					zeitstiftDto.getMandantCNr(), zeitstiftDto.getBMehrfachstift(),
					zeitstiftDto.getBPersonenzuordnung(), zeitstiftDto.getCTyp());
			em.persist(zeitstift);
			em.flush();
			setZeitstiftFromZeitstiftDto(zeitstift, zeitstiftDto);
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
		return zeitstiftDto.getIId();
	}

	public void removeZeitstift(ZeitstiftDto zeitstiftDto) throws EJBExceptionLP {

		myLogger.entry();
		if (zeitstiftDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitstiftDto == null"));
		}
		if (zeitstiftDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("zeitstiftDto.getIId() == null"));
		}

		// try {
		Zeitstift toRemove = em.find(Zeitstift.class, zeitstiftDto.getIId());
		if (toRemove == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		try {
			em.remove(toRemove);
			em.flush();
		} catch (EntityExistsException er) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, er);
		}
		// }
		// catch (RemoveException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEIM_LOESCHEN,
		// e);
		// }
	}

	public void updateZeitstift(ZeitstiftDto zeitstiftDto) throws EJBExceptionLP {
		if (zeitstiftDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("zeitstiftDto == null"));
		}
		if (zeitstiftDto.getIId() == null || zeitstiftDto.getCNr() == null || zeitstiftDto.getBMehrfachstift() == null
				|| zeitstiftDto.getCTyp() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"zeitstiftDto.getIId() == null || zeitstiftDto.getCNr() == null || zeitstiftDto.getBMehrfachstift() == null || zeitstiftDto.getCTyp() == null"));
		}

		if (Helper.short2boolean(zeitstiftDto.getBMehrfachstift()) == true) {
			zeitstiftDto.setPersonalIId(null);
		}

		Integer iId = zeitstiftDto.getIId();

		try {
			Query query = em.createNamedQuery("ZeitstiftfindByCNr");
			query.setParameter(1, zeitstiftDto.getCNr());
			Integer iIdVorhanden = ((Zeitstift) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_ZEITSTIFT.CNR"));
			}

		} catch (NoResultException ex) {
			//
		}

		// try {
		Zeitstift zeitstift = em.find(Zeitstift.class, iId);
		if (zeitstift == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");

		}
		setZeitstiftFromZeitstiftDto(zeitstift, zeitstiftDto);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);

		// }

	}

	public ZeitstiftDto zeitstiftFindByPrimaryKey(Integer iId) throws EJBExceptionLP {
		if (iId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}
		// try {
		Zeitstift zeitstift = em.find(Zeitstift.class, iId);
		if (zeitstift == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		return assembleZeitstiftDto(zeitstift);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	public ZeitstiftDto[] zeitstiftFindByPersonalIId(Integer personalIId) throws EJBExceptionLP {
		if (personalIId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("personalIId == null"));
		}
		// try {
		Query query = em.createNamedQuery("ZeitstiftfindByPersonalIId");
		query.setParameter(1, personalIId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND,
		// null);
		// }
		return assembleZeitstiftDtos(cl);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND,
		// e);
		// }
	}

	public ZeitstiftDto[] zeitstiftFindByPersonalIIdCTyp(Integer personalIId, String cTyp) {
		Query query = em.createNamedQuery("ZeitstiftfindByPersonalIIdCTyp");
		query.setParameter(1, personalIId);
		query.setParameter(2, cTyp);
		Collection<?> cl = query.getResultList();
		return assembleZeitstiftDtos(cl);

	}

	public ZeitstiftDto[] zeitstiftFindByMandantCNr(TheClientDto theClientDto) throws EJBExceptionLP {
		// try {
		Query query = em.createNamedQuery("ZeitstiftfindByMandantCNr");
		query.setParameter(1, theClientDto.getMandant());
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND,
		// null);
		// }
		return assembleZeitstiftDtos(cl);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND,
		// e);
		// }
	}

	private void setZeitstiftFromZeitstiftDto(Zeitstift zeitstift, ZeitstiftDto zeitstiftDto) {
		zeitstift.setCNr(zeitstiftDto.getCNr());
		zeitstift.setBMehrfachstift(zeitstiftDto.getBMehrfachstift());
		zeitstift.setBPersonenzuordnung(zeitstiftDto.getBPersonenzuordnung());
		zeitstift.setPersonalIId(zeitstiftDto.getPersonalIId());
		zeitstift.setMandantCNr(zeitstiftDto.getMandantCNr());
		zeitstift.setCTyp(zeitstiftDto.getCTyp());
		em.merge(zeitstift);
		em.flush();
	}

	private ZeitstiftDto assembleZeitstiftDto(Zeitstift zeitstift) {
		return ZeitstiftDtoAssembler.createDto(zeitstift);
	}

	private ZeitstiftDto[] assembleZeitstiftDtos(Collection<?> zeitstifts) {
		List<ZeitstiftDto> list = new ArrayList<ZeitstiftDto>();
		if (zeitstifts != null) {
			Iterator<?> iterator = zeitstifts.iterator();
			while (iterator.hasNext()) {
				Zeitstift zeitstift = (Zeitstift) iterator.next();
				list.add(assembleZeitstiftDto(zeitstift));
			}
		}
		ZeitstiftDto[] returnArray = new ZeitstiftDto[list.size()];
		return (ZeitstiftDto[]) list.toArray(returnArray);
	}

	private ZeitverteilungDto assembleZeitverteilungDto(Zeitverteilung zeitverteilung) {
		return ZeitverteilungDtoAssembler.createDto(zeitverteilung);
	}

	private ZeitverteilungDto[] assembleZeitverteilungDtos(Collection<?> zeitverteilungs) {
		List<ZeitverteilungDto> list = new ArrayList<ZeitverteilungDto>();
		if (zeitverteilungs != null) {
			Iterator<?> iterator = zeitverteilungs.iterator();
			while (iterator.hasNext()) {
				Zeitverteilung zeitverteilung = (Zeitverteilung) iterator.next();
				list.add(assembleZeitverteilungDto(zeitverteilung));
			}
		}
		ZeitverteilungDto[] returnArray = new ZeitverteilungDto[list.size()];
		return (ZeitverteilungDto[]) list.toArray(returnArray);
	}

	public Integer schreibeUebertragBVADto(UebertragBVADto uebertragBVADto, TheClientDto theClientDto) {

		uebertragBVADto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		uebertragBVADto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));

		try {
			Query query = em.createNamedQuery("UebertragBVAByPersonalIIdTDatum");
			query.setParameter(1, uebertragBVADto.getPersonalIId());
			query.setParameter(2, uebertragBVADto.getTDatum());

			UebertragBVA bean = (UebertragBVA) query.getSingleResult();

			if (Helper.short2boolean(bean.getBGesperrt()) == false) {
				uebertragBVADto.setBGesperrt(Helper.boolean2Short(false));
				setUebertragBVAFromUebertragBVADto(bean, uebertragBVADto);
			}

			return uebertragBVADto.getIId();

		} catch (NoResultException ex1) {

			uebertragBVADto.setBGesperrt(Helper.boolean2Short(false));

			return createUebertragBVA(uebertragBVADto, theClientDto);
		}

	}

	public void updateUebertragBVADto(UebertragBVADto dto, TheClientDto theClientDto) {

		Integer iId = dto.getIId();
		// try {
		UebertragBVA z = em.find(UebertragBVA.class, iId);
		if (z == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		try {
			Query query = em.createNamedQuery("UebertragBVAByPersonalIIdTDatum");
			query.setParameter(1, dto.getPersonalIId());
			query.setParameter(2, dto.getTDatum());
			Integer iIdVorhanden = ((UebertragBVA) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_UEBERTRAGBVA.UK"));
			}
		} catch (NoResultException ex) {
			// nix
		}

		dto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		dto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));

		setUebertragBVAFromUebertragBVADto(z, dto);

	}

	public void updateAuszahlungBVADto(AuszahlungBVADto dto, TheClientDto theClientDto) {

		Integer iId = dto.getIId();
		// try {
		AuszahlungBVA z = em.find(AuszahlungBVA.class, iId);
		if (z == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		try {
			Query query = em.createNamedQuery("AuszahlungBVAFindByPersonalIIdTDatum");
			query.setParameter(1, dto.getPersonalIId());
			query.setParameter(2, dto.getTDatum());
			Integer iIdVorhanden = ((AuszahlungBVA) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE,
						new Exception("PERS_AUSZAHLUNG_BVA.UK"));
			}
		} catch (NoResultException ex) {
			// nix
		}

		dto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		dto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));

		setAuszahlungBVAFromAuszahlungBVADto(z, dto);

	}

	public Integer createMaschinenkosten(MaschinenkostenDto maschinenkostenDto) throws EJBExceptionLP {

		try {
			Query query = em.createNamedQuery("MaschinenkostenfindByMaschineIIdTGueltigab");
			query.setParameter(1, maschinenkostenDto.getMaschineIId());
			query.setParameter(2, maschinenkostenDto.getTGueltigab());
			Maschinenkosten doppelt = (Maschinenkosten) query.getSingleResult();
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_MASCHINENKOSTEN.UK"));
		} catch (NoResultException ex1) {
			// nothing here
		}

		try {
			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_MASCHINENKOSTEN);
			maschinenkostenDto.setIId(pk);

			Maschinenkosten maschinenkosten = new Maschinenkosten(maschinenkostenDto.getIId(),
					maschinenkostenDto.getMaschineIId(), maschinenkostenDto.getTGueltigab(),
					maschinenkostenDto.getNStundensatz(), maschinenkostenDto.getNVkstundensatz());
			em.persist(maschinenkosten);
			em.flush();
			setMaschinenkostenFromMaschinenkostenDto(maschinenkosten, maschinenkostenDto);
			return maschinenkostenDto.getIId();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
	}

	public void removeMaschinenkosten(MaschinenkostenDto maschinenkostenDto) throws EJBExceptionLP {
		myLogger.entry();
		if (maschinenkostenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("maschinenkostenDto == null"));
		}
		if (maschinenkostenDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("maschinenkostenDto.getIId() == null"));
		}

		// try {
		Maschinenkosten toRemove = em.find(Maschinenkosten.class, maschinenkostenDto.getIId());
		if (toRemove == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		try {
			em.remove(toRemove);
			em.flush();
		} catch (EntityExistsException er) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, er);
		}
		// }
		// catch (RemoveException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEIM_LOESCHEN,
		// e);
		// }
	}

	public void updateMaschinenkosten(MaschinenkostenDto maschinenkostenDto) throws EJBExceptionLP {
		if (maschinenkostenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("maschinenkostenDto == null"));
		}
		if (maschinenkostenDto.getIId() == null || maschinenkostenDto.getMaschineIId() == null
				|| maschinenkostenDto.getNStundensatz() == null || maschinenkostenDto.getTGueltigab() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"maschinenkostenDto.getIId() == null || maschinenkostenDto.getMaschineIId() == null || maschinenkostenDto.getNStundensatz() == null || maschinenkostenDto.getTGueltigab() == null"));
		}

		Integer iId = maschinenkostenDto.getIId();

		try {
			Query query = em.createNamedQuery("MaschinenkostenfindByMaschineIIdTGueltigab");
			query.setParameter(1, maschinenkostenDto.getMaschineIId());
			query.setParameter(2, maschinenkostenDto.getTGueltigab());
			Integer iIdVorhanden = ((Maschinenkosten) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE,
						new Exception("PERS_MASCHINENKOSTEN.UK"));
			}
		} catch (NoResultException ex) {
			//
		}

		try {
			Maschinenkosten maschinenkosten = em.find(Maschinenkosten.class, iId);
			setMaschinenkostenFromMaschinenkostenDto(maschinenkosten, maschinenkostenDto);
		} catch (Exception e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, e);
		}

	}

	public void maschineStop(Integer maschineIId, Integer lossollarbeitsplanIId, java.sql.Timestamp tStop,
			TheClientDto theClientDto) {

		String sQuery = "select zeitdaten FROM FLRMaschinenzeitdaten zeitdaten WHERE zeitdaten.t_von<'"
				+ Helper.formatTimestampWithSlashes(tStop) + "' AND zeitdaten.maschine_i_id=" + maschineIId
				+ " AND zeitdaten.lossollarbeitsplan_i_id=" + lossollarbeitsplanIId
				+ "  AND zeitdaten.t_bis IS NULL ORDER BY zeitdaten.t_von DESC";

		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Query query = session.createQuery(sQuery);
		query.setMaxResults(1);

		List<?> resultList = query.list();

		Iterator<?> resultListIterator = resultList.iterator();

		if (resultListIterator.hasNext()) {
			FLRMaschinenzeitdaten flrMaschinenzeitdaten = (FLRMaschinenzeitdaten) resultListIterator.next();

			Maschinenzeitdaten maschinenzeitdaten = em.find(Maschinenzeitdaten.class, flrMaschinenzeitdaten.getI_id());
			maschinenzeitdaten.setTBis(tStop);
			em.merge(maschinenzeitdaten);
			em.flush();
		}
	}

	public MaschinenkostenDto maschinenkostenFindByPrimaryKey(Integer iId) throws EJBExceptionLP {
		if (iId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}
		// try {
		Maschinenkosten maschinenkosten = em.find(Maschinenkosten.class, iId);
		if (maschinenkosten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleMaschinenkostenDto(maschinenkosten);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	public MaschinenkostenDto getMaschinenKostenDtoZumZeitpunkt(Integer maschineIId, java.sql.Timestamp tDatum) {
		// try {
		Query query = em.createNamedQuery("MaschinenkostenfindLetzeKostenByMaschineIIdTGueltigab");
		query.setParameter(1, maschineIId);
		query.setParameter(2, tDatum);
		Collection<?> cl = query.getResultList();

		query.setMaxResults(1);

		MaschinenkostenDto[] maschinenkostenDtos = assembleMaschinenkostenDtos(cl);

		if (maschinenkostenDtos != null && maschinenkostenDtos.length > 0) {
			return maschinenkostenDtos[0];
		} else {
			return null;
		}
		// }
		// catch (NoResultException ex) {
		// return new BigDecimal(0);
		// }
	}

	public MaschinenStundensatzDto getMaschinenKostenZumZeitpunkt(Integer maschineIId, java.sql.Timestamp tDatum) {
		return getMaschinenKostenZumZeitpunkt(maschineIId, tDatum, null, null);
	}

	public MaschinenStundensatzDto getMaschinenKostenZumZeitpunkt(Integer maschineIId, java.sql.Timestamp tDatum,
			String belegart, Integer belegartpositionIId) {

		Session session2 = FLRSessionFactory.getFactory().openSession();
		String sQuery = "SELECT count(*) FROM FLRMaschineleistungsfaktor ml WHERE ml.maschine_i_id=" + maschineIId;

		org.hibernate.Query q = session2.createQuery(sQuery);
		q.setMaxResults(1);
		List l = q.list();

		Long lAnzahl = null;

		if (l.size() > 0) {
			lAnzahl = (Long) l.iterator().next();
		}

		BigDecimal bdLeistungsfaktor = BigDecimal.ONE;

		if (lAnzahl != null && lAnzahl > 0) {

			Integer materialIId = null;

			if (belegart != null && belegartpositionIId != null) {

				Integer artikelIId = null;

				if (belegart.equals(LocaleFac.BELEGART_STUECKLISTE)) {
					Stuecklistearbeitsplan stuecklistearbeitsplan = em.find(Stuecklistearbeitsplan.class,
							belegartpositionIId);
					if (stuecklistearbeitsplan != null) {

						if (stuecklistearbeitsplan.getStuecklistepositionIId() != null) {
							Stuecklisteposition stuecklisteposition = em.find(Stuecklisteposition.class,
									stuecklistearbeitsplan.getStuecklistepositionIId());
							artikelIId = stuecklisteposition.getArtikelIId();

						} else {

							Query query = em.createNamedQuery("StuecklistepositionfindByStuecklisteIId");
							query.setParameter(1, stuecklistearbeitsplan.getStuecklisteIId());
							query.setMaxResults(1);
							Iterator<?> iterator = query.getResultList().iterator();
							if (iterator.hasNext()) {
								Stuecklisteposition ersteposition = (Stuecklisteposition) iterator.next();
								artikelIId = ersteposition.getArtikelIId();
							}

						}

					}

				} else if (belegart.equals(LocaleFac.BELEGART_LOS)) {
					Lossollarbeitsplan losarbeitsplan = em.find(Lossollarbeitsplan.class, belegartpositionIId);
					if (losarbeitsplan != null) {

						if (losarbeitsplan.getLossollmaterialIId() != null) {
							Lossollmaterial lossollmaterial = em.find(Lossollmaterial.class,
									losarbeitsplan.getLossollmaterialIId());
							artikelIId = lossollmaterial.getArtikelIId();

						} else {

							Query query = em.createNamedQuery("LossollmaterialfindByLosIIdOrderByISort");
							query.setParameter(1, losarbeitsplan.getLosIId());
							query.setMaxResults(1);
							Iterator<?> iterator = query.getResultList().iterator();
							if (iterator.hasNext()) {
								Lossollmaterial ersteposition = (Lossollmaterial) iterator.next();
								artikelIId = ersteposition.getArtikelIId();
							}

						}

					}
				} else if (belegart.equals(LocaleFac.BELEGART_AGSTUECKLISTE)) {
					Agstklarbeitsplan agstklarbeitsplan = em.find(Agstklarbeitsplan.class, belegartpositionIId);
					if (agstklarbeitsplan != null) {

						Query query = em.createNamedQuery("AgstklpositionfindByAgstklIId");
						query.setParameter(1, agstklarbeitsplan.getAgstklIId());
						query.setMaxResults(1);
						Iterator<?> iterator = query.getResultList().iterator();
						if (iterator.hasNext()) {
							Agstklposition ersteposition = (Agstklposition) iterator.next();
							artikelIId = ersteposition.getArtikelIId();
						} else {
							Query queryMaterial = em.createNamedQuery("AgstklmaterialfindByAgstklIId");
							queryMaterial.setParameter(1, agstklarbeitsplan.getAgstklIId());
							queryMaterial.setMaxResults(1);
							Iterator<?> iteratorMaterial = queryMaterial.getResultList().iterator();
							if (iteratorMaterial.hasNext()) {
								Agstklmaterial ersteposition = (Agstklmaterial) iteratorMaterial.next();
								artikelIId = null;
								materialIId = ersteposition.getMaterialIId();
							}
						}

					}
				}

				if (artikelIId != null) {
					Artikel artikel = em.find(Artikel.class, artikelIId);

					Query query = em.createNamedQuery("StuecklistefindByArtikelIId");
					query.setParameter(1, artikel.getIId());
					if (query.getResultList().size() == 0) {
						materialIId = artikel.getMaterialIId();

					}

				}

				if (materialIId != null) {

					Query query = em.createNamedQuery("MaschineleistungsfaktorfindByMaschineIIdMaterialIIdTGueltigab");
					query.setParameter(1, maschineIId);
					query.setParameter(2, materialIId);
					query.setParameter(3, Helper.cutTimestamp(tDatum));
					query.setMaxResults(1);
					Collection<?> cl = query.getResultList();

					if (cl.size() > 0) {
						Maschineleistungsfaktor ml = (Maschineleistungsfaktor) cl.iterator().next();
						bdLeistungsfaktor = BigDecimal.ONE.add(
								ml.getNFaktorInProzent().divide(new BigDecimal(100), 4, BigDecimal.ROUND_HALF_EVEN));
					}
				}
			}
		}
		// try {
		Query query = em.createNamedQuery("MaschinenkostenfindLetzeKostenByMaschineIIdTGueltigab");
		query.setParameter(1, maschineIId);
		query.setParameter(2, tDatum);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// return new BigDecimal(0);
		// } else {
		MaschinenkostenDto[] maschienkostenDtos = assembleMaschinenkostenDtos(cl);

		if (maschienkostenDtos != null && maschienkostenDtos.length > 0) {
			return new MaschinenStundensatzDto(maschienkostenDtos[0].getNStundensatz().multiply(bdLeistungsfaktor),
					maschienkostenDtos[0].getNVkstundensatz().multiply(bdLeistungsfaktor));
		} else {
			return new MaschinenStundensatzDto(BigDecimal.ZERO, BigDecimal.ZERO);
		}
		// }
		// catch (NoResultException ex) {
		// return new BigDecimal(0);
		// }
	}

	public MaschinenkostenDto maschinenkostenFindByMaschineIIdTGueltigab(Integer maschineIId, Timestamp tGueltigab)
			throws EJBExceptionLP {
		try {
			Query query = em.createNamedQuery("MaschinenkostenfindByMaschineIIdTGueltigab");
			query.setParameter(1, maschineIId);
			query.setParameter(2, tGueltigab);
			return assembleMaschinenkostenDto((Maschinenkosten) query.getSingleResult());
		} catch (Exception e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, e);
		}
	}

	private void setMaschinenkostenFromMaschinenkostenDto(Maschinenkosten maschinenkosten,
			MaschinenkostenDto maschinenkostenDto) {
		maschinenkosten.setMaschineIId(maschinenkostenDto.getMaschineIId());
		maschinenkosten.setTGueltigab(maschinenkostenDto.getTGueltigab());
		maschinenkosten.setNStundensatz(maschinenkostenDto.getNStundensatz());
		maschinenkosten.setNVkstundensatz(maschinenkostenDto.getNVkstundensatz());
		em.merge(maschinenkosten);
		em.flush();
	}

	private void setUebertragBVAFromUebertragBVADto(UebertragBVA uebertragBVA, UebertragBVADto uebertragBVADto) {

		uebertragBVA.setPersonalIId(uebertragBVADto.getPersonalIId());
		uebertragBVA.setTDatum(uebertragBVADto.getTDatum());

		uebertragBVA.setBGesperrt(uebertragBVADto.getBGesperrt());
		uebertragBVA.setPersonalIIdAendern(uebertragBVADto.getPersonalIIdAendern());
		uebertragBVA.setTAendern(uebertragBVADto.getTAendern());

		uebertragBVA.setNGleitzeit(uebertragBVADto.getNGleitzeit());
		uebertragBVA.setNUestd100(uebertragBVADto.getNUestd100());
		uebertragBVA.setNUestd100_Zuschlag(uebertragBVADto.getnUestd100_Zuschlag());
		uebertragBVA.setNUestd50(uebertragBVADto.getNUestd50());
		uebertragBVA.setNUestd50_Zuschlag(uebertragBVADto.getNUestd50_Zuschlag());
		uebertragBVA.setNUestd50Gz(uebertragBVADto.getNUestd50Gz());
		uebertragBVA.setNUestd50Gz_Zuschlag(uebertragBVADto.getNUestd50Gz_Zuschlag());

		em.merge(uebertragBVA);
		em.flush();
	}

	private void setAuszahlungBVAFromAuszahlungBVADto(AuszahlungBVA auszahlungBVA, AuszahlungBVADto auszahlungBVADto) {

		auszahlungBVA.setPersonalIId(auszahlungBVADto.getPersonalIId());
		auszahlungBVA.setTDatum(auszahlungBVADto.getTDatum());

		auszahlungBVA.setCKommentar(auszahlungBVADto.getCKommentar());
		auszahlungBVA.setPersonalIIdAendern(auszahlungBVADto.getPersonalIIdAendern());
		auszahlungBVA.setTAendern(auszahlungBVADto.getTAendern());

		auszahlungBVA.setNGleitzeit(auszahlungBVADto.getNGleitzeit());
		auszahlungBVA.setNUestd100(auszahlungBVADto.getNUestd100());
		auszahlungBVA.setNUestd100_Zuschlag(auszahlungBVADto.getnUestd100_Zuschlag());
		auszahlungBVA.setNUestd50(auszahlungBVADto.getNUestd50());
		auszahlungBVA.setNUestd50_Zuschlag(auszahlungBVADto.getNUestd50_Zuschlag());
		auszahlungBVA.setNUestd50Gz(auszahlungBVADto.getNUestd50Gz());
		auszahlungBVA.setNUestd50Gz_Zuschlag(auszahlungBVADto.getNUestd50Gz_Zuschlag());

		em.merge(auszahlungBVA);
		em.flush();
	}

	private MaschinenkostenDto assembleMaschinenkostenDto(Maschinenkosten maschinenkosten) {
		return MaschinenkostenDtoAssembler.createDto(maschinenkosten);
	}

	private MaschinenkostenDto[] assembleMaschinenkostenDtos(Collection<?> maschinenkostens) {
		List<MaschinenkostenDto> list = new ArrayList<MaschinenkostenDto>();
		if (maschinenkostens != null) {
			Iterator<?> iterator = maschinenkostens.iterator();
			while (iterator.hasNext()) {
				Maschinenkosten maschinenkosten = (Maschinenkosten) iterator.next();
				list.add(assembleMaschinenkostenDto(maschinenkosten));
			}
		}
		MaschinenkostenDto[] returnArray = new MaschinenkostenDto[list.size()];
		return (MaschinenkostenDto[]) list.toArray(returnArray);
	}

	public Integer createMaschinengruppe(MaschinengruppeDto maschinengruppeDto, TheClientDto theClientDto)
			throws EJBExceptionLP {
		Validator.dtoNotNull(maschinengruppeDto, "maschinengruppeDto");
		Validator.notNull(maschinengruppeDto.getCBez(), "cBez");
		Validator.notNull(maschinengruppeDto.getFertigungsgruppeIId(), "fertigungsgruppeIId");

		Maschinengruppe doppelt = MaschinengruppeQuery.findByKbez(em, theClientDto.getMandant(),
				maschinengruppeDto.getCKbez());
		if (doppelt != null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE,
					new Exception("PERS_MASCHINENGRUPPE.C_KBEZ"));
		}

		// try {
		// Query query = em.createNamedQuery("MaschinengruppefindByCBez");
		// query.setParameter(1, maschinengruppeDto.getCBez());
		// Maschinengruppe doppelt = (Maschinengruppe) query.getSingleResult();
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE,
		// new Exception("PERS_MASCHINENGRUPPE.C_BEZ"));
		// } catch (NoResultException ex1) {
		// // nothing here
		// }

		if (maschinengruppeDto.getBAuslastungsanzeige() == null) {
			maschinengruppeDto.setBAuslastungsanzeige(Helper.getShortTrue());
		}

		Integer i = null;
		try {
			Query querynext = em.createNamedQuery(MaschinengruppeQuery.NextISort);
			querynext.setParameter(1, theClientDto.getMandant());
			i = (Integer) querynext.getSingleResult();
		} catch (NoResultException ex) {
			// nothing here
		} catch (NonUniqueResultException ex1) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_NO_UNIQUE_RESULT, ex1);
		}
		if (i == null) {
			i = new Integer(0);
		}
		i = new Integer(i.intValue() + 1);
		maschinengruppeDto.setISort(i);

		maschinengruppeDto.setMandantCNr(theClientDto.getMandant());
		try {
			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_MASCHINENGRUPPE);
			maschinengruppeDto.setIId(pk);

			Maschinengruppe maschinengruppe = new Maschinengruppe(maschinengruppeDto.getIId(),
					maschinengruppeDto.getMandantCNr(), maschinengruppeDto.getCKbez(), maschinengruppeDto.getCBez(),
					maschinengruppeDto.getBAuslastungsanzeige(), maschinengruppeDto.getFertigungsgruppeIId(),
					maschinengruppeDto.getISort());
			em.persist(maschinengruppe);
			em.flush();
			setMaschinengruppeFromMaschinengruppeDto(maschinengruppe, maschinengruppeDto);
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
		return maschinengruppeDto.getIId();
	}

	public void removeMaschinengruppe(MaschinengruppeDto maschinengruppeDto) throws EJBExceptionLP {
		Validator.dtoNotNull(maschinengruppeDto, "maschinengruppeDto");
		Validator.pkFieldNotNull(maschinengruppeDto.getIId(), "getIId()");

		Maschinengruppe toRemove = em.find(Maschinengruppe.class, maschinengruppeDto.getIId());
		if (toRemove == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		try {
			em.remove(toRemove);
			em.flush();
		} catch (EntityExistsException er) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, er);
		}
	}

	public void updateMaschinengruppe(MaschinengruppeDto maschinengruppeDto, TheClientDto theClientDto)
			throws EJBExceptionLP {
		Validator.dtoNotNull(maschinengruppeDto, "maschinengruppeDto");
		Validator.pkFieldNotNull(maschinengruppeDto.getIId(), "getIId()");
		Validator.notNull(maschinengruppeDto.getFertigungsgruppeIId(), "fertigungsgruppeIId()");
		Validator.notNull(maschinengruppeDto.getCBez(), "cbez()");

		Integer iId = maschinengruppeDto.getIId();

		Maschinengruppe maschinengruppe = em.find(Maschinengruppe.class, iId);
		if (maschinengruppe == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		Maschinengruppe mg = MaschinengruppeQuery.findByKbez(em, theClientDto.getMandant(),
				maschinengruppeDto.getCKbez());
		if (mg != null && !mg.getIId().equals(maschinengruppeDto.getIId())) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE,
					new Exception("PERS_MASCHINENGRUPPE.C_KBEZ"));
		}

		setMaschinengruppeFromMaschinengruppeDto(maschinengruppe, maschinengruppeDto);
	}

	public MaschinengruppeDto maschinengruppeFindByPrimaryKey(Integer iId) throws EJBExceptionLP {
		if (iId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}

		// try {
		Maschinengruppe maschinengruppe = em.find(Maschinengruppe.class, iId);
		if (maschinengruppe == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleMaschinengruppeDto(maschinengruppe);
	}

	private void setMaschinengruppeFromMaschinengruppeDto(Maschinengruppe maschinengruppe,
			MaschinengruppeDto maschinengruppeDto) {
		MaschinengruppeDtoAssembler.setEntityFromDto(maschinengruppe, maschinengruppeDto);
		em.merge(maschinengruppe);
		em.flush();
	}

	private MaschinengruppeDto assembleMaschinengruppeDto(Maschinengruppe maschinengruppe) {
		return MaschinengruppeDtoAssembler.createDto(maschinengruppe);
	}

	private MaschinengruppeDto[] assembleMaschinengruppeDtos(Collection<Maschinengruppe> maschinengruppen) {
		return MaschinengruppeDtoAssembler.createDtos(maschinengruppen);
		// List<MaschinengruppeDto> list = new ArrayList<MaschinengruppeDto>();
		// if (maschinengruppes != null) {
		// Iterator<?> iterator = maschinengruppes.iterator();
		// while (iterator.hasNext()) {
		// Maschinengruppe maschinengruppe = (Maschinengruppe) iterator
		// .next();
		// list.add(assembleMaschinengruppeDto(maschinengruppe));
		// }
		// }
		// MaschinengruppeDto[] returnArray = new
		// MaschinengruppeDto[list.size()];
		// return (MaschinengruppeDto[]) list.toArray(returnArray);
	}

	public Integer createReise(ReiseDto reiseDto, TheClientDto theClientDto) throws EJBExceptionLP {

		if (!getMandantFac().darfAnwenderAufZusatzfunktionZugreifen(MandantFac.ZUSATZFUNKTION_REISEZEITEN,
				theClientDto)) {
			return null;
		}

		if (reiseDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("reiseDto == null"));
		}
		if (reiseDto.getPersonalIId() == null || reiseDto.getBBeginn() == null || reiseDto.getTZeit() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"reiseDto.getPersonalIId() == null || reiseDto.getBBeginn() == null || reiseDto.getTZeit() == null"));
		}

		if (Helper.short2Boolean(reiseDto.getBBeginn()) == true) {
			reiseDto.setIKmende(null);
			if (reiseDto.getDiaetenIId() == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL,
						new Exception("reiseDto.getDiaetenIId() == null"));
			}
		} else {
			reiseDto.setPartnerIId(null);
			reiseDto.setAnsprechpartnerIId(null);
			reiseDto.setDiaetenIId(null);
			reiseDto.setCFahrzeug(null);
			reiseDto.setIKmbeginn(null);

			reiseDto.setNSpesen(null);
		}
		try {
			Query query = em.createNamedQuery("ReisefindByPersonalIIdTZeit");
			query.setParameter(1, reiseDto.getPersonalIId());
			query.setParameter(2, reiseDto.getTZeit());
			Reise doppelt = (Reise) query.getSingleResult();
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_REISE.UK"));
		} catch (NoResultException ex1) {
			// nothing here
		}

		try {
			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_REISE);
			reiseDto.setIId(pk);
			reiseDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
			reiseDto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));

			Reise reise = new Reise(reiseDto.getIId(), reiseDto.getPersonalIId(), reiseDto.getTZeit(),
					reiseDto.getBBeginn(), reiseDto.getPersonalIIdAendern());
			em.persist(reise);
			em.flush();
			setReiseFromReiseDto(reise, reiseDto);
			// Mitprotokollieren
			protokolliereReiselog(reiseDto, ZeiterfassungFac.REISELOG_ART_CREATE);

			return pk;
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}

	}

	public BigDecimal getZusaetzlicheReisespesenInMandantenwaehrung(Integer reiseIId) {

		BigDecimal bdSpesen = BigDecimal.ZERO;

		Session session2 = FLRSessionFactory.getFactory().openSession();
		String sQuery = "SELECT sum(r.flreingangsrechnung.n_betrag) FROM FLRReisespesen r WHERE r.reise_i_id="
				+ reiseIId;

		org.hibernate.Query q = session2.createQuery(sQuery);
		q.setMaxResults(1);
		List l = q.list();
		if (l.size() > 0) {
			BigDecimal bd = (BigDecimal) l.iterator().next();
			if (bd != null) {
				return bd;
			}
		}
		return bdSpesen;
	}

	public Integer createReisespesen(ReisespesenDto reisespesenDto, TheClientDto theClientDto) {

		try {
			Query query = em.createNamedQuery("ReisespesenfindByReiseIIdEingangsrechnungIId");
			query.setParameter(1, reisespesenDto.getReiseIId());
			query.setParameter(2, reisespesenDto.getEingangsrechnungIId());
			Reisespesen doppelt = (Reisespesen) query.getSingleResult();
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_REISESPESEN.UK"));
		} catch (NoResultException ex1) {
			// nothing here
		}

		try {
			Query query = em.createNamedQuery("ReisespesenfindByEingangsrechnungIId");
			query.setParameter(1, reisespesenDto.getEingangsrechnungIId());
			Reisespesen doppelt = (Reisespesen) query.getSingleResult();
			ArrayList al = new ArrayList();
			al.add(doppelt.getReiseIId());
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ER_BEREITS_REISEZEIT_ZUGEORDNET, al,
					new Exception("FEHLER_ER_BEREITS_REISEZEIT_ZUGEORDNET"));
		} catch (NoResultException ex1) {
			// nothing here
		}

		try {
			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_REISESPESEN);
			reisespesenDto.setIId(pk);

			Reisespesen reisespesen = new Reisespesen(reisespesenDto.getIId(), reisespesenDto.getReiseIId(),
					reisespesenDto.getEingangsrechnungIId());
			em.persist(reisespesen);
			em.flush();
			setReisespesenFromReiseReisespesenDto(reisespesen, reisespesenDto);

			return pk;
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}

	}

	public void removeReise(ReiseDto reiseDto, TheClientDto theClientDto) throws EJBExceptionLP {
		if (reiseDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("reiseDto == null"));
		}
		if (reiseDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL,
					new Exception("reiseDto.getIId() == null"));
		}

		try {
			Reise reise = em.find(Reise.class, reiseDto.getIId());

			sindEintraegeBereitsVerrechnet(null, null, null, null, reise.getIId());
			getAbrechnungsvorschlagFac().sindEintraegeInAbrechnungsvorschlag(null, null, null, null, reise.getIId(),
					theClientDto);

			if (reise == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
			}
			em.remove(reise);
			em.flush();

			// Mitprotokollieren
			protokolliereReiselog(reiseDto, ZeiterfassungFac.REISELOG_ART_DELETE);

		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, e);
		}

	}

	public void removeReisespesen(ReisespesenDto reisespesenDto, TheClientDto theClientDto) {

		Reisespesen reisespesen = em.find(Reisespesen.class, reisespesenDto.getIId());
		em.remove(reisespesen);
		em.flush();

	}

	public void updateReise(ReiseDto reiseDto, TheClientDto theClientDto) throws EJBExceptionLP {
		if (reiseDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("reiseDto == null"));
		}
		if (reiseDto.getIId() == null || reiseDto.getPersonalIId() == null || reiseDto.getBBeginn() == null
				|| reiseDto.getTZeit() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"reiseDto.getIId() == null || reiseDto.getPersonalIId() == null || reiseDto.getBBeginn() == null || reiseDto.getTZeit() == null"));
		}
		if (reiseDto.getPartnerIId() == null) {
			reiseDto.setAnsprechpartnerIId(null);
		}

		if (Helper.short2Boolean(reiseDto.getBBeginn()) == true) {

			reiseDto.setIKmende(null);
			if (reiseDto.getDiaetenIId() == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL,
						new Exception("reiseDto.getDiaetenIId() == null"));
			}
		} else {
			reiseDto.setPartnerIId(null);
			reiseDto.setAnsprechpartnerIId(null);
			reiseDto.setDiaetenIId(null);
			reiseDto.setCFahrzeug(null);
			reiseDto.setIKmbeginn(null);
			reiseDto.setNSpesen(null);

			// Wenn zusaetzliche Spesen vorhanden, dann kann nicht auf Ende geaendert
			// werden.
			Query query = em.createNamedQuery("ReisespesenfindByReiseIId");
			query.setParameter(1, reiseDto.getIId());
			int i = query.getResultList().size();
			if (i > 0) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZUSAETZLICHE_SPESEN_AUF_ENDE_NICHT_MOEGLICH,
						new Exception("FEHLER_ZUSAETZLICHE_SPESEN_AUF_ENDE_NICHT_MOEGLICH"));
			}

		}
		Integer iId = reiseDto.getIId();

		try {
			Query query = em.createNamedQuery("ReisefindByPersonalIIdTZeit");
			query.setParameter(1, reiseDto.getPersonalIId());
			query.setParameter(2, reiseDto.getTZeit());
			Integer iIdVorhanden = ((Reise) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_REISE.UK"));
			}
		} catch (NoResultException ex) {
			//
		}

		try {
			Reise reise = em.find(Reise.class, iId);

			// PJ20872
			sindEintraegeBereitsVerrechnet(null, null, null, null, reise.getIId());
			Integer abrechnungsvorschlagIIdVorhanden = getAbrechnungsvorschlagFac()
					.sindEintraegeInAbrechnungsvorschlag(null, null, null, null, reise.getIId(), theClientDto);

			reiseDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
			reiseDto.setTAendern(new java.sql.Timestamp(System.currentTimeMillis()));

			setReiseFromReiseDto(reise, reiseDto);

			// Mitprotokollieren
			protokolliereReiselog(reiseDto, ZeiterfassungFac.REISELOG_ART_UPDATE);

			if (abrechnungsvorschlagIIdVorhanden != null) {
				getAbrechnungsvorschlagFac().erstelleAbrechnungsvorschlagReise(null, abrechnungsvorschlagIIdVorhanden,
						theClientDto);
			}

		} catch (Exception e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, e);
		}

	}

	public void updateReisespesen(ReisespesenDto reisespesenDto, TheClientDto theClientDto) {

		Integer iId = reisespesenDto.getIId();

		try {
			Query query = em.createNamedQuery("ReisespesenfindByReiseIIdEingangsrechnungIId");
			query.setParameter(1, reisespesenDto.getReiseIId());
			query.setParameter(2, reisespesenDto.getEingangsrechnungIId());
			Integer iIdVorhanden = ((Reisespesen) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_REISESPESEN.UK"));
			}
		} catch (NoResultException ex) {
			//
		}

		try {
			Query query = em.createNamedQuery("ReisespesenfindByEingangsrechnungIId");
			query.setParameter(1, reisespesenDto.getEingangsrechnungIId());

			Reisespesen rs = (Reisespesen) query.getSingleResult();

			Integer iIdVorhanden = rs.getIId();
			if (iId.equals(iIdVorhanden) == false) {
				ArrayList al = new ArrayList();
				al.add(rs.getReiseIId());
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ER_BEREITS_REISEZEIT_ZUGEORDNET, al,
						new Exception("FEHLER_ER_BEREITS_REISEZEIT_ZUGEORDNET"));

			}
		} catch (NoResultException ex) {
			//
		}

		Reisespesen reisespesen = em.find(Reisespesen.class, iId);
		setReisespesenFromReiseReisespesenDto(reisespesen, reisespesenDto);
	}

	public void updateReiselog(ReiselogDto reiselogDto, TheClientDto theClientDto) throws EJBExceptionLP {

		if (reiselogDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("reiselogDto == null"));
		}
		if (reiselogDto.getIId() == null || reiselogDto.getPersonalIId() == null || reiselogDto.getReiseIId() == null
				|| reiselogDto.getTZeit() == null || reiselogDto.getBBeginn() == null || reiselogDto.getCArt() == null
				|| reiselogDto.getTAendern() == null || reiselogDto.getPersonalIIdAendern() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL, new Exception(
					"reiselogDto.getIId() == null || reiselogDto.getPersonalIId() == null || reiselogDto.getReiseIId() == null || reiselogDto.getTZeit() == null || reiselogDto.getBBeginn() == null || reiselogDto.getCArt() == null || reiselogDto.getTAendern() == null || reiselogDto.getPersonalIIdAendern() == null"));
		}

		Integer iId = reiselogDto.getIId();

		// try {
		Reiselog rl = em.find(Reiselog.class, iId);
		if (rl != null) {
			Integer iIdVorhanden = rl.getIId();

			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_REISELOG.UK"));
			}
		}
		// catch (NoResultException ex) {
		//
		// }

		try {
			Reiselog reiselog = em.find(Reiselog.class, iId);
			setReiselogFromReiselogDto(reiselog, reiselogDto);
		} catch (Exception e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, e);
		}

	}

	public String getParameterSortierungZeitauswertungen(Integer iOptionSortierung, TheClientDto theClientDto) {
		String parameter = "";
		if (iOptionSortierung != null) {
			if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_PERSONALNUMMER) {
				parameter = getTextRespectUISpr("pers.zeitauswertungen.sortierung.personalnummer",
						theClientDto.getMandant(), theClientDto.getLocUi());
			} else if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_ABTEILUNG_NAME_VORNAME) {
				parameter = getTextRespectUISpr("pers.zeitauswertungen.sortierung.abteilungnamevorname",
						theClientDto.getMandant(), theClientDto.getLocUi());
			} else if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_NAME_VORNAME) {
				parameter = getTextRespectUISpr("pers.zeitauswertungen.sortierung.namevorname",
						theClientDto.getMandant(), theClientDto.getLocUi());
			} else if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_KOSTENSTELLE_NAME_VORNAME) {
				parameter = getTextRespectUISpr("pers.zeitauswertungen.sortierung.kostenstellenamevorname",
						theClientDto.getMandant(), theClientDto.getLocUi());
			} else if (iOptionSortierung == ZeiterfassungFacAll.REPORT_MONATSABRECHNUNG_OPTION_SORTIERUNG_ABTEILUNG_KOSTENSTELLE_NAME_VORNAME) {
				parameter = getTextRespectUISpr("pers.zeitauswertungen.sortierung.abteilungkostenstellenamevorname",
						theClientDto.getMandant(), theClientDto.getLocUi());
			}
		}
		return parameter;
	}

	public ReiseDto reiseFindByPrimaryKey(Integer iId, TheClientDto theClientDto) throws EJBExceptionLP {
		if (iId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}
		// try {
		Reise reise = em.find(Reise.class, iId);
		if (reise == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleReiseDto(reise);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	public ReiseDto[] reiseFindByPartnerIId(Integer iPartnerId, TheClientDto theClientDto)
			throws EJBExceptionLP, RemoteException {
		ReiseDto[] reiseDtos = null;
		// try {
		Query query = em.createNamedQuery("ReisefindByPartnerIId");
		query.setParameter(1, iPartnerId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER, null);
		// }
		reiseDtos = assembleReiseDtos(cl);
		// }
		// catch (ObjectNotFoundException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
		// ex);
		// }
		// catch (NoResultException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		// }
		return reiseDtos;
	}

	public ReiseDto[] reiseFindByPartnerIIdOhneExc(Integer iPartnerId, TheClientDto theClientDto)
			throws EJBExceptionLP, RemoteException {
		ReiseDto[] reiseDtos = null;
		// try {
		Query query = em.createNamedQuery("ReisefindByPartnerIId");
		query.setParameter(1, iPartnerId);
		// @todo getSingleResult oder getResultList ?
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// myLogger.warn("partnerIId=" + iPartnerId);
		// return null;
		// }
		reiseDtos = assembleReiseDtos(cl);
		// }
		// catch (ObjectNotFoundException ex) {
		// myLogger.warn("partnerIId=" + iPartnerId, ex);
		// return null;
		// }
		// catch (NoResultException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		// }
		return reiseDtos;
	}

	public ReiselogDto[] reiselogFindByPartnerIId(Integer iPartnerId, TheClientDto theClientDto)
			throws EJBExceptionLP, RemoteException {
		ReiselogDto[] reiselogDtos = null;
		// try {
		Query query = em.createNamedQuery("ReiselogfindByPartnerIId");
		query.setParameter(1, iPartnerId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
		// null);
		// }
		reiselogDtos = assembleReiselogDtos(cl);
		// }
		// catch (ObjectNotFoundException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY,
		// ex);
		// }
		// catch (NoResultException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		// }
		return reiselogDtos;
	}

	public ReiselogDto[] reiselogFindByPartnerIIdOhneExc(Integer iPartnerId, TheClientDto theClientDto)
			throws EJBExceptionLP, RemoteException {
		ReiselogDto[] reiselogDtos = null;
		// try {
		Query query = em.createNamedQuery("ReiselogfindByPartnerIId");
		query.setParameter(1, iPartnerId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// myLogger.warn("partnerIId=" + iPartnerId);
		// return null;
		// }
		reiselogDtos = assembleReiselogDtos(cl);
		// }
		// catch (ObjectNotFoundException ex) {
		// myLogger.warn("partnerIId=" + iPartnerId, ex);
		// return null;
		// }
		// catch (NoResultException ex) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER, ex);
		// }
		return reiselogDtos;
	}

	private void setReiseFromReiseDto(Reise reise, ReiseDto reiseDto) {
		reise.setPersonalIId(reiseDto.getPersonalIId());
		reise.setTZeit(reiseDto.getTZeit());
		reise.setBBeginn(reiseDto.getBBeginn());
		reise.setDiaetenIId(reiseDto.getDiaetenIId());
		reise.setPartnerIId(reiseDto.getPartnerIId());
		reise.setAnsprechpartnerIId(reiseDto.getAnsprechpartnerIId());
		reise.setIKmbeginn(reiseDto.getIKmbeginn());
		reise.setIKmende(reiseDto.getIKmende());
		reise.setNSpesen(reiseDto.getNSpesen());
		reise.setCFahrzeug(reiseDto.getCFahrzeug());
		reise.setCKommentar(reiseDto.getCKommentar());
		reise.setTAendern(reiseDto.getTAendern());
		reise.setPersonalIIdAendern(reiseDto.getPersonalIIdAendern());

		reise.setBelegartCNr(reiseDto.getBelegartCNr());
		reise.setIBelegartid(reiseDto.getIBelegartid());
		reise.setFahrzeugIId(reiseDto.getFahrzeugIId());
		reise.setFVerrechenbar(reiseDto.getFVerrechenbar());
		reise.setPersonalIIdErledigt(reiseDto.getPersonalIIdErledigt());
		reise.setTErledigt(reiseDto.getTErledigt());
		reise.setIMitfahrer(reiseDto.getIMitfahrer());

		em.merge(reise);
		em.flush();
	}

	private void setReisespesenFromReiseReisespesenDto(Reisespesen reisespesen, ReisespesenDto dto) {
		reisespesen.setEingangsrechnungIId(dto.getEingangsrechnungIId());
		reisespesen.setReiseIId(dto.getReiseIId());

		em.merge(reisespesen);
		em.flush();
	}

	private ReiseDto assembleReiseDto(Reise reise) {
		return ReiseDtoAssembler.createDto(reise);
	}

	private ReiseDto[] assembleReiseDtos(Collection<?> reises) {
		List<ReiseDto> list = new ArrayList<ReiseDto>();
		if (reises != null) {
			Iterator<?> iterator = reises.iterator();
			while (iterator.hasNext()) {
				Reise reise = (Reise) iterator.next();
				list.add(assembleReiseDto(reise));
			}
		}
		ReiseDto[] returnArray = new ReiseDto[list.size()];
		return (ReiseDto[]) list.toArray(returnArray);
	}

	private void setReiselogFromReiselogDto(Reiselog reiselog, ReiselogDto reiselogDto) {
		reiselog.setReiseIId(reiselogDto.getReiseIId());
		reiselog.setPersonalIId(reiselogDto.getPersonalIId());
		reiselog.setTZeit(reiselogDto.getTZeit());
		reiselog.setBBeginn(reiselogDto.getBBeginn());
		reiselog.setDiaetenIId(reiselogDto.getDiaetenIId());
		reiselog.setPartnerIId(reiselogDto.getPartnerIId());
		reiselog.setAnsprechpartnerIId(reiselogDto.getAnsprechpartnerIId());
		reiselog.setIKmbeginn(reiselogDto.getIKmbeginn());
		reiselog.setIKmende(reiselogDto.getIKmende());
		reiselog.setNSpesen(reiselogDto.getNSpesen());
		reiselog.setCFahrzeug(reiselogDto.getCFahrzeug());
		reiselog.setCKommentar(reiselogDto.getCKommentar());
		reiselog.setTAendern(reiselogDto.getTAendern());
		reiselog.setPersonalIIdAendern(reiselogDto.getPersonalIIdAendern());
		reiselog.setCArt(reiselogDto.getCArt());
		reiselog.setBelegartCNr(reiselogDto.getBelegartCNr());
		reiselog.setIBelegartid(reiselogDto.getIBelegartid());
		reiselog.setFahrzeugIId(reiselogDto.getFahrzeugIId());
		em.merge(reiselog);
		em.flush();
	}

	private void protokolliereReiselog(ReiseDto reiseDto, String cArt) throws EJBExceptionLP {
		try {

			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_REISELOG);
			reiseDto.setIId(pk);

			Reiselog reiselog = new Reiselog(pk, reiseDto.getIId(), reiseDto.getPersonalIId(), reiseDto.getTZeit(),
					reiseDto.getBBeginn(), reiseDto.getPersonalIIdAendern(), cArt);
			em.persist(reiselog);
			em.flush();

			reiselog.setAnsprechpartnerIId(reiseDto.getAnsprechpartnerIId());
			reiselog.setCFahrzeug(reiseDto.getCFahrzeug());
			reiselog.setCKommentar(reiseDto.getCKommentar());
			reiselog.setIKmbeginn(reiseDto.getIKmbeginn());
			reiselog.setIKmende(reiseDto.getIKmende());
			reiselog.setDiaetenIId(reiseDto.getDiaetenIId());
			reiselog.setNSpesen(reiseDto.getNSpesen());
			reiselog.setPartnerIId(reiseDto.getPartnerIId());
			reiselog.setBelegartCNr(reiseDto.getBelegartCNr());
			reiselog.setIBelegartid(reiseDto.getIBelegartid());
			reiselog.setFahrzeugIId(reiseDto.getFahrzeugIId());

		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}

	}

	private ReiselogDto assembleReiselogDto(Reiselog reiselog) {
		return ReiselogDtoAssembler.createDto(reiselog);
	}

	private ReiselogDto[] assembleReiselogDtos(Collection<?> reiselogs) {
		List<ReiselogDto> list = new ArrayList<ReiselogDto>();
		if (reiselogs != null) {
			Iterator<?> iterator = reiselogs.iterator();
			while (iterator.hasNext()) {
				Reiselog reiselog = (Reiselog) iterator.next();
				list.add(assembleReiselogDto(reiselog));
			}
		}
		ReiselogDto[] returnArray = new ReiselogDto[list.size()];
		return (ReiselogDto[]) list.toArray(returnArray);
	}

	public Integer createTelefonzeiten(TelefonzeitenDto telefonzeitenDto, TheClientDto theClientDto)
			throws EJBExceptionLP {
		if (telefonzeitenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("telefonzeitenDto == null"));
		}
		if (telefonzeitenDto.getPersonalIId() == null || telefonzeitenDto.getTVon() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("telefonzeitenDto.getPersonalIId() == null || telefonzeitenDto.getTVon() == null"));
		}
		try {
			Query query = em.createNamedQuery("TelefonzeitenfindByPersonalIIdTVon");
			query.setParameter(1, telefonzeitenDto.getPersonalIId());
			query.setParameter(2, telefonzeitenDto.getTVon());
			Telefonzeiten doppelt = (Telefonzeiten) query.getSingleResult();
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_TELEFONZEITEN.UK"));
		} catch (NoResultException ex) {

		}

		// SP3289
		bringeFehlerWennZeitabschlussvorhanden(telefonzeitenDto.getPersonalIId(), telefonzeitenDto.getTVon(),
				theClientDto);

		try {
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_TELEFONZEITEN);
			telefonzeitenDto.setIId(pk);

			if (telefonzeitenDto.getPersonalIIdZugewiesener() == null) {
				telefonzeitenDto.setPersonalIIdZugewiesener(telefonzeitenDto.getPersonalIId());
			}

			Telefonzeiten telefonzeiten = new Telefonzeiten(telefonzeitenDto.getIId(),
					telefonzeitenDto.getPersonalIId(), telefonzeitenDto.getTVon(),
					telefonzeitenDto.getPersonalIIdZugewiesener());
			em.persist(telefonzeiten);
			em.flush();
			setTelefonzeitenFromTelefonzeitenDto(telefonzeiten, telefonzeitenDto);

			Integer taetigeitIId_telefon = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_TELEFON, theClientDto)
					.getIId();

			ZeitdatenDto zeitdatenDto = new ZeitdatenDto();
			zeitdatenDto.setTaetigkeitIId(taetigeitIId_telefon);
			zeitdatenDto.setPersonalIId(telefonzeitenDto.getPersonalIId());
			zeitdatenDto.setTZeit(telefonzeitenDto.getTVon());

			try {
				createZeitdaten(zeitdatenDto, false, false, false, false, theClientDto);
			} catch (EJBExceptionLP e) {
				if (e.getCode() == EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE
						|| e.getCode() == EJBExceptionLP.FEHLER_BUCHUNG_BEREITS_VORHANDEN) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITBUCHUNGEN_VORHANDEN,
							new ArrayList<Object>(Arrays.asList(telefonzeitenDto.getTVon())), null);
				}
			}
			if (telefonzeitenDto.getTBis() != null) {
				zeitdatenDto.setTZeit(telefonzeitenDto.getTBis());
				try {
					createZeitdaten(zeitdatenDto, false, false, false, false, theClientDto);
				} catch (EJBExceptionLP e) {
					if (e.getCode() == EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE
							|| e.getCode() == EJBExceptionLP.FEHLER_BUCHUNG_BEREITS_VORHANDEN) {
						throw new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITBUCHUNGEN_VORHANDEN,
								new ArrayList<Object>(Arrays.asList(telefonzeitenDto.getTBis())), e);
					}
				}
			}

			verschiebeBelegzeitenUndEndeNachTelefonEnde(telefonzeitenDto, theClientDto);

			return telefonzeitenDto.getIId();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
	}

	public void removeTelefonzeiten(TelefonzeitenDto telefonzeitenDto, TheClientDto theClientDto)
			throws EJBExceptionLP {
		if (telefonzeitenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("telefonzeitenDto == null"));
		}
		if (telefonzeitenDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_FELD_IN_DTO_IS_NULL,
					new Exception("telefonzeitenDto.getIId() == null"));
		}

		try {
			Telefonzeiten telefonzeiten = em.find(Telefonzeiten.class, telefonzeitenDto.getIId());
			if (telefonzeiten != null) {

				sindEintraegeBereitsVerrechnet(null, null, telefonzeiten.getIId(), null, null);
				getAbrechnungsvorschlagFac().sindEintraegeInAbrechnungsvorschlag(null, null, telefonzeiten.getIId(),
						null, null, theClientDto);

				try {
					Query query = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
					query.setParameter(1, telefonzeiten.getPersonalIId());
					query.setParameter(2, telefonzeiten.getTVon());
					Zeitdaten zeitdatenVon = (Zeitdaten) query.getSingleResult();
					if (zeitdatenVon != null) {
						em.remove(zeitdatenVon);
						em.flush();
					}
				} catch (NoResultException ex) {
					// Dann wurde sie geaendert
				}
				if (telefonzeiten.getTBis() != null) {
					try {
						Query query = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
						query.setParameter(1, telefonzeiten.getPersonalIId());
						query.setParameter(2, telefonzeiten.getTBis());
						Zeitdaten zeitdatenBis = (Zeitdaten) query.getSingleResult();
						if (zeitdatenBis != null) {
							em.remove(zeitdatenBis);
						}
					} catch (NoResultException ex) {
						// Dann wurde sie geaendert
					}
				}

				em.remove(telefonzeiten);
				em.flush();
			}
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, e);
		}
	}

	public void updateTelefonzeiten(TelefonzeitenDto telefonzeitenDto, TheClientDto theClientDto)
			throws EJBExceptionLP {

		if (telefonzeitenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("telefonzeitenDto == null"));
		}
		if (telefonzeitenDto.getIId() == null || telefonzeitenDto.getPersonalIId() == null
				|| telefonzeitenDto.getTVon() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception(
					"telefonzeitenDto.getIId() == null || telefonzeitenDto.getPersonalIId() == null || telefonzeitenDto.getTVon() == null"));
		}

		Integer iId = telefonzeitenDto.getIId();
		// try {
		Telefonzeiten telefonzeiten = em.find(Telefonzeiten.class, iId);
		if (telefonzeiten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		if (telefonzeitenDto.getPersonalIIdZugewiesener() == null) {
			telefonzeitenDto.setPersonalIIdZugewiesener(telefonzeitenDto.getPersonalIId());
		}

		// PJ20872
		sindEintraegeBereitsVerrechnet(null, null, telefonzeiten.getIId(), null, null);
		Integer abrechnungsvorschlagIIdVorhanden = getAbrechnungsvorschlagFac()
				.sindEintraegeInAbrechnungsvorschlag(null, null, telefonzeiten.getIId(), null, null, theClientDto);

		try {
			Query query = em.createNamedQuery("TelefonzeitenfindByPersonalIIdTVon");
			query.setParameter(1, telefonzeitenDto.getPersonalIId());
			query.setParameter(2, telefonzeitenDto.getTVon());
			Integer iIdVorhanden = ((Telefonzeiten) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE,
						new Exception("PERS_TELEFONZEITEN.UK"));
			}
		} catch (NoResultException ex) {

		}

		Integer taetigeitIId_telefon = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_TELEFON, theClientDto).getIId();

		ZeitdatenDto zeitdatenDto = new ZeitdatenDto();
		zeitdatenDto.setTaetigkeitIId(taetigeitIId_telefon);
		zeitdatenDto.setPersonalIId(telefonzeitenDto.getPersonalIId());
		zeitdatenDto.setTZeit(telefonzeitenDto.getTVon());

		try {
			// Von-Zeitdaten in PERS_ZEITDATEN updaten
			Query query = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
			query.setParameter(1, telefonzeiten.getPersonalIId());
			query.setParameter(2, telefonzeiten.getTVon());
			Zeitdaten zeitdaten = (Zeitdaten) query.getSingleResult();
			zeitdaten.setTZeit(telefonzeitenDto.getTVon());
			em.flush();
		} catch (NoResultException ex1) {
			// Dann hat es wer veraendert - neu anlegen
			createZeitdaten(zeitdatenDto, false, false, false, false, theClientDto);
		} catch (EntityExistsException ex) {
			EJBExceptionLP e = new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITBUCHUNGEN_VORHANDEN,
					new Exception("PERS_ZEITDATEN.UK"));
			e.setAlInfoForTheClient(new ArrayList<Object>(Arrays.asList(telefonzeitenDto.getTVon())));
			throw e;
		}

		zeitdatenDto.setTZeit(telefonzeitenDto.getTBis());
		try {
			// Bis-Zeitdaten in PERS_ZEITDATEN updaten
			Query query = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
			query.setParameter(1, telefonzeiten.getPersonalIId());
			query.setParameter(2, telefonzeiten.getTBis());
			Zeitdaten zeitdaten = (Zeitdaten) query.getSingleResult();
			zeitdaten.setTZeit(telefonzeitenDto.getTBis());
			em.flush();
		} catch (NoResultException ex1) {
			// Dann hat es wer veraendert - neu anlegen
			createZeitdaten(zeitdatenDto, false, false, false, false, theClientDto);
		} catch (EntityExistsException ex) {
			EJBExceptionLP e = new EJBExceptionLP(EJBExceptionLP.FEHLER_ZEITBUCHUNGEN_VORHANDEN,
					new Exception("PERS_ZEITDATEN.UK"));
			e.setAlInfoForTheClient(new ArrayList(Arrays.asList(telefonzeitenDto.getTBis())));
			throw e;
		}

		setTelefonzeitenFromTelefonzeitenDto(telefonzeiten, telefonzeitenDto);

		verschiebeBelegzeitenUndEndeNachTelefonEnde(telefonzeitenDto, theClientDto);

		// PJ20872
		if (abrechnungsvorschlagIIdVorhanden != null) {
			getAbrechnungsvorschlagFac().erstelleAbrechnungsvorschlagTelefonzeiten(null,
					abrechnungsvorschlagIIdVorhanden, theClientDto);
		}
	}

	public TelefonzeitenDto telefonzeitenFindByPrimaryKey(Integer iId) throws EJBExceptionLP {
		if (iId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}

		// try {
		Telefonzeiten telefonzeiten = em.find(Telefonzeiten.class, iId);
		if (telefonzeiten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleTelefonzeitenDto(telefonzeiten);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	public TelefonzeitenDto[] telefonzeitenFindByPartnerIId(Integer iPartnerIId) throws EJBExceptionLP {
		if (iPartnerIId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iPartnerIId == null"));
		}
		// try {
		Query query = em.createNamedQuery("TelefonzeitenfindByPartnerIId");
		query.setParameter(1, iPartnerIId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// null);
		// }
		return assembleTelefonzeitenDtos(cl);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	public TelefonzeitenDto[] telefonzeitenFindByPartnerIIdOhneExc(Integer iPartnerIId) throws EJBExceptionLP {
		if (iPartnerIId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iPartnerIId == null"));
		}
		// try {
		Query query = em.createNamedQuery("TelefonzeitenfindByPartnerIId");
		query.setParameter(1, iPartnerIId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// myLogger.warn("partnerIId=" + iPartnerIId);
		// return null;
		// }
		return assembleTelefonzeitenDtos(cl);
		// }
		// catch (ObjectNotFoundException e) {
		// myLogger.warn("partnerIId=" + iPartnerIId, e);
		// return null;
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	private void setTelefonzeitenFromTelefonzeitenDto(Telefonzeiten telefonzeiten, TelefonzeitenDto telefonzeitenDto) {
		telefonzeiten.setPersonalIId(telefonzeitenDto.getPersonalIId());
		telefonzeiten.setPartnerIId(telefonzeitenDto.getPartnerIId());
		telefonzeiten.setAnsprechpartnerIId(telefonzeitenDto.getAnsprechpartnerIId());
		telefonzeiten.setTVon(telefonzeitenDto.getTVon());
		telefonzeiten.setTBis(telefonzeitenDto.getTBis());
		telefonzeiten.setXKommentarext(telefonzeitenDto.getXKommentarext());
		telefonzeiten.setXKommentarint(telefonzeitenDto.getXKommentarint());
		telefonzeiten.setProjektIId(telefonzeitenDto.getProjektIId());

		telefonzeiten.setFVerrechenbar(telefonzeitenDto.getFVerrechenbar());
		telefonzeiten.setPersonalIIdErledigt(telefonzeitenDto.getPersonalIIdErledigt());
		telefonzeiten.setTErledigt(telefonzeitenDto.getTErledigt());
		telefonzeiten.setCTelefonnrGewaehlt(telefonzeitenDto.getCTelefonnrGewaehlt());

		telefonzeiten.setCTitel(telefonzeitenDto.getCTitel());
		telefonzeiten.setTWiedervorlage(telefonzeitenDto.getTWiedervorlage());
		telefonzeiten.setTWiedervorlageErledigt(telefonzeitenDto.getTWiedervorlageErledigt());
		telefonzeiten.setPersonalIIdZugewiesener(telefonzeitenDto.getPersonalIIdZugewiesener());
		telefonzeiten.setKontaktartIId(telefonzeitenDto.getKontaktartIId());

		telefonzeiten.setAuftragIId(telefonzeitenDto.getAuftragIId());
		telefonzeiten.setAngebotIId(telefonzeitenDto.getAngebotIId());
		telefonzeiten.setFDauerUebersteuert(telefonzeitenDto.getFDauerUebersteuert());

		em.merge(telefonzeiten);
		em.flush();
	}

	private TelefonzeitenDto assembleTelefonzeitenDto(Telefonzeiten telefonzeiten) {
		return TelefonzeitenDtoAssembler.createDto(telefonzeiten);
	}

	private TelefonzeitenDto[] assembleTelefonzeitenDtos(Collection<?> telefonzeitens) {
		List<TelefonzeitenDto> list = new ArrayList<TelefonzeitenDto>();
		if (telefonzeitens != null) {
			Iterator<?> iterator = telefonzeitens.iterator();
			while (iterator.hasNext()) {
				Telefonzeiten telefonzeiten = (Telefonzeiten) iterator.next();
				list.add(assembleTelefonzeitenDto(telefonzeiten));
			}
		}
		TelefonzeitenDto[] returnArray = new TelefonzeitenDto[list.size()];
		return (TelefonzeitenDto[]) list.toArray(returnArray);
	}

	public Integer createDiaeten(DiaetenDto diaetenDto) throws EJBExceptionLP {
		if (diaetenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("tagesartDto == null"));
		}
		if (diaetenDto.getCBez() == null || diaetenDto.getLandIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL,
					new Exception("diaetenDto.getCBez() == null || diaetenDto.getLandIId() == null"));
		}
		try {
			Query query = em.createNamedQuery("DiaetenfindByCBez");
			query.setParameter(1, diaetenDto.getCBez());
			Diaeten doppelt = (Diaeten) query.getSingleResult();
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_DIAETEN.C_BEZ"));
		} catch (NoResultException ex) {

		}

		try {
			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_DIAETEN);
			diaetenDto.setIId(pk);

			Diaeten diaeten = new Diaeten(diaetenDto.getIId(), diaetenDto.getCBez(), diaetenDto.getLandIId());
			em.persist(diaeten);
			em.flush();
			setDiaetenFromDiaetenDto(diaeten, diaetenDto);
			return diaetenDto.getIId();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
	}

	public void removeDiaeten(DiaetenDto diaetenDto) throws EJBExceptionLP {
		if (diaetenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("diaetenDto == null"));
		}
		if (diaetenDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}

		// try {
		Diaeten toRemove = em.find(Diaeten.class, diaetenDto.getIId());
		if (toRemove == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		try {
			em.remove(toRemove);
			em.flush();
		} catch (EntityExistsException er) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, er);
		}
		// }
		// catch (RemoveException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEIM_LOESCHEN,
		// e);
		// }

	}

	public void updateDiaeten(DiaetenDto diaetenDto) throws EJBExceptionLP {
		if (diaetenDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("tagesartDto == null"));
		}
		if (diaetenDto.getIId() == null || diaetenDto.getCBez() == null || diaetenDto.getLandIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception(
					"diaetenDto.getIId() == null || diaetenDto.getCBez() == null || diaetenDto.getLandIId() == null"));
		}

		Integer iId = diaetenDto.getIId();
		// try {
		Diaeten diaeten = em.find(Diaeten.class, iId);
		if (diaeten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");

		}

		try {
			Query query = em.createNamedQuery("DiaetenfindByCBez");
			query.setParameter(1, diaetenDto.getCBez());
			Integer iIdVorhanden = ((Diaeten) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_DIAETEN.CBEZ"));
			}
		} catch (NoResultException ex) {

		}

		setDiaetenFromDiaetenDto(diaeten, diaetenDto);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);

		// }
	}

	public DiaetenDto[] diaetenFindByLandIId(Integer landIId) throws EJBExceptionLP {
		if (landIId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("landIId == null"));
		}

		// try {
		Query query = em.createNamedQuery("DiaetenfindByLandIId");
		query.setParameter(1, landIId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// null);
		// }
		return assembleDiaetenDtos(cl);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	public DiaetenDto diaetenFindByPrimaryKey(Integer iId) throws EJBExceptionLP {
		if (iId == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}

		// try {
		Diaeten diaeten = em.find(Diaeten.class, iId);
		if (diaeten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleDiaetenDto(diaeten);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	private void setDiaetenFromDiaetenDto(Diaeten diaeten, DiaetenDto diaetenDto) {
		diaeten.setCBez(diaetenDto.getCBez());
		diaeten.setLandIId(diaetenDto.getLandIId());
		em.merge(diaeten);
		em.flush();
	}

	private DiaetenDto assembleDiaetenDto(Diaeten diaeten) {
		return DiaetenDtoAssembler.createDto(diaeten);
	}

	private DiaetenDto[] assembleDiaetenDtos(Collection<?> diaetens) {
		List<DiaetenDto> list = new ArrayList<DiaetenDto>();
		if (diaetens != null) {
			Iterator<?> iterator = diaetens.iterator();
			while (iterator.hasNext()) {
				Diaeten diaeten = (Diaeten) iterator.next();
				list.add(assembleDiaetenDto(diaeten));
			}
		}
		DiaetenDto[] returnArray = new DiaetenDto[list.size()];
		return (DiaetenDto[]) list.toArray(returnArray);
	}

	public Integer createDiaetentagessatz(DiaetentagessatzDto diaetentagessatzDto) throws EJBExceptionLP {
		if (diaetentagessatzDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("diaetentagessatzDto == null"));
		}
		if (diaetentagessatzDto.getDiaetenIId() == null || diaetentagessatzDto.getBStundenweise() == null
				|| diaetentagessatzDto.getIAbstunden() == null || diaetentagessatzDto.getNMindestsatz() == null
				|| diaetentagessatzDto.getNStundensatz() == null || diaetentagessatzDto.getNTagessatz() == null
				|| diaetentagessatzDto.getTGueltigab() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception(
					"diaetentagessatzDto.getDiaetenIId() == null || diaetentagessatzDto.getBStundenweise() == null || diaetentagessatzDto.getIAbstunden() == null || diaetentagessatzDto.getNMindestsatz() == null || diaetentagessatzDto.getNStundensatz() == null || diaetentagessatzDto.getNTagessatz() == null || diaetentagessatzDto.getTGueltigab() == null"));
		}

		diaetentagessatzDto.setTGueltigab(Helper.cutTimestamp(diaetentagessatzDto.getTGueltigab()));

		diaetentagessatzDto.setNMindestsatz(Helper.rundeKaufmaennisch(diaetentagessatzDto.getNMindestsatz(), 6));
		diaetentagessatzDto.setNStundensatz(Helper.rundeKaufmaennisch(diaetentagessatzDto.getNStundensatz(), 6));
		diaetentagessatzDto.setNTagessatz(Helper.rundeKaufmaennisch(diaetentagessatzDto.getNTagessatz(), 6));

		try {
			Query query = em.createNamedQuery("DiaetentagessatzfindByDiatenIIdTGueltigab");
			query.setParameter(1, diaetentagessatzDto.getDiaetenIId());
			query.setParameter(2, diaetentagessatzDto.getTGueltigab());
			Diaetentagessatz doppelt = (Diaetentagessatz) query.getSingleResult();
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE, new Exception("PERS_DIAETENTAGESSATZ.UK"));
		} catch (NoResultException ex) {

		}
		if (Helper.short2Boolean(diaetentagessatzDto.getBStundenweise()) == false) {
			diaetentagessatzDto.setIAbstunden(0);
		}

		try {
			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_DIAETENTAGESSATZ);
			diaetentagessatzDto.setIId(pk);

			Diaetentagessatz diaetentagessatz = new Diaetentagessatz(diaetentagessatzDto.getIId(),
					diaetentagessatzDto.getDiaetenIId(), diaetentagessatzDto.getTGueltigab(),
					diaetentagessatzDto.getIAbstunden(), diaetentagessatzDto.getBStundenweise(),
					diaetentagessatzDto.getNStundensatz(), diaetentagessatzDto.getNTagessatz(),
					diaetentagessatzDto.getNMindestsatz());
			em.persist(diaetentagessatz);
			em.flush();
			setDiaetentagessatzFromDiaetentagessatzDto(diaetentagessatz, diaetentagessatzDto);
			return diaetentagessatzDto.getIId();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
	}

	public void removeDiaetentagessatz(DiaetentagessatzDto diaetentagessatzDto) throws EJBExceptionLP {
		if (diaetentagessatzDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("diaetentagessatzDto == null"));
		}
		if (diaetentagessatzDto.getIId() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception("iId == null"));
		}

		// try {
		Diaetentagessatz toRemove = em.find(Diaetentagessatz.class, diaetentagessatzDto.getIId());
		if (toRemove == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		try {
			em.remove(toRemove);
			em.flush();
		} catch (EntityExistsException er) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, er);
		}
		// }
		// catch (RemoveException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEIM_LOESCHEN,
		// e);
		// }
	}

	public void updateDiaetentagessatz(DiaetentagessatzDto diaetentagessatzDto) throws EJBExceptionLP {
		if (diaetentagessatzDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DTO_IS_NULL, new Exception("diaetentagessatzDto == null"));
		}
		if (diaetentagessatzDto.getIId() == null || diaetentagessatzDto.getDiaetenIId() == null
				|| diaetentagessatzDto.getBStundenweise() == null || diaetentagessatzDto.getIAbstunden() == null
				|| diaetentagessatzDto.getNMindestsatz() == null || diaetentagessatzDto.getNStundensatz() == null
				|| diaetentagessatzDto.getNTagessatz() == null || diaetentagessatzDto.getTGueltigab() == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_PKFIELD_IS_NULL, new Exception(
					"diaetentagessatzDto.getIId() == null || diaetentagessatzDto.getDiaetenIId() == null || diaetentagessatzDto.getBStundenweise() == null || diaetentagessatzDto.getIAbstunden() == null || diaetentagessatzDto.getNMindestsatz() == null || diaetentagessatzDto.getNStundensatz() == null || diaetentagessatzDto.getNTagessatz() == null || diaetentagessatzDto.getTGueltigab() == null"));
		}
		if (Helper.short2Boolean(diaetentagessatzDto.getBStundenweise()) == false) {
			diaetentagessatzDto.setIAbstunden(0);
		}
		diaetentagessatzDto.setTGueltigab(Helper.cutTimestamp(diaetentagessatzDto.getTGueltigab()));

		diaetentagessatzDto.setNMindestsatz(Helper.rundeKaufmaennisch(diaetentagessatzDto.getNMindestsatz(), 6));
		diaetentagessatzDto.setNStundensatz(Helper.rundeKaufmaennisch(diaetentagessatzDto.getNStundensatz(), 6));
		diaetentagessatzDto.setNTagessatz(Helper.rundeKaufmaennisch(diaetentagessatzDto.getNTagessatz(), 6));

		Integer iId = diaetentagessatzDto.getIId();
		// try {
		Diaetentagessatz diaetentagessatz = em.find(Diaetentagessatz.class, iId);
		if (diaetentagessatz == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");

		}
		try {
			Query query = em.createNamedQuery("DiaetentagessatzfindByDiatenIIdTGueltigab");
			query.setParameter(1, diaetentagessatzDto.getDiaetenIId());
			query.setParameter(2, diaetentagessatzDto.getTGueltigab());
			Integer iIdVorhanden = ((Diaetentagessatz) query.getSingleResult()).getIId();
			if (iId.equals(iIdVorhanden) == false) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_DUPLICATE_UNIQUE,
						new Exception("PERS_DIAETENTAGESSATZ.UK"));
			}

		} catch (NoResultException ex) {

		}

		setDiaetentagessatzFromDiaetentagessatzDto(diaetentagessatz, diaetentagessatzDto);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);

		// }

	}

	public DiaetentagessatzDto diaetentagessatzFindByPrimaryKey(Integer iId) throws EJBExceptionLP {
		// try {
		Diaetentagessatz diaetentagessatz = em.find(Diaetentagessatz.class, iId);
		if (diaetentagessatz == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleDiaetentagessatzDto(diaetentagessatz);
		// }
		// catch (NoResultException e) {
		// throw new EJBExceptionLP(EJBExceptionLP.
		// FEHLER_BEI_FINDBYPRIMARYKEY,
		// e);
		// }
	}

	public DiaetentagessatzDto[] diaetentagessatzFindGueltigenTagessatzZuDatum(Integer diaetenIId, Timestamp tVon) {

		Query query2 = em.createNamedQuery("DiaetentagessatzfindGueltigenTagessatzZuDatum");
		query2.setParameter(1, diaetenIId);
		query2.setParameter(2, tVon);

		return assembleDiaetentagessatzDtos(query2.getResultList());
	}

	private void setDiaetentagessatzFromDiaetentagessatzDto(Diaetentagessatz diaetentagessatz,
			DiaetentagessatzDto diaetentagessatzDto) {
		diaetentagessatz.setDiaetenIId(diaetentagessatzDto.getDiaetenIId());
		diaetentagessatz.setTGueltigab(diaetentagessatzDto.getTGueltigab());
		diaetentagessatz.setIAbstunden(diaetentagessatzDto.getIAbstunden());
		diaetentagessatz.setBStundenweise(diaetentagessatzDto.getBStundenweise());
		diaetentagessatz.setNStundensatz(diaetentagessatzDto.getNStundensatz());
		diaetentagessatz.setNTagessatz(diaetentagessatzDto.getNTagessatz());
		diaetentagessatz.setNMindestsatz(diaetentagessatzDto.getNMindestsatz());
		diaetentagessatz.setCFilenameScript(diaetentagessatzDto.getCFilenameScript());
		em.merge(diaetentagessatz);
		em.flush();
	}

	private DiaetentagessatzDto assembleDiaetentagessatzDto(Diaetentagessatz diaetentagessatz) {
		return DiaetentagessatzDtoAssembler.createDto(diaetentagessatz);
	}

	private DiaetentagessatzDto[] assembleDiaetentagessatzDtos(Collection<?> diaetentagessatzs) {
		List<DiaetentagessatzDto> list = new ArrayList<DiaetentagessatzDto>();
		if (diaetentagessatzs != null) {
			Iterator<?> iterator = diaetentagessatzs.iterator();
			while (iterator.hasNext()) {
				Diaetentagessatz diaetentagessatz = (Diaetentagessatz) iterator.next();
				list.add(assembleDiaetentagessatzDto(diaetentagessatz));
			}
		}
		DiaetentagessatzDto[] returnArray = new DiaetentagessatzDto[list.size()];
		return (DiaetentagessatzDto[]) list.toArray(returnArray);
	}

	public ReiseDto getReiseDtoVorgaenger(Timestamp tZeitpunkt, Integer personalIId) {
		Session session2 = FLRSessionFactory.getFactory().openSession();
		String sQuery = "SELECT r FROM FLRReise r WHERE r.personal_i_id=" + personalIId;
		sQuery += " AND r.t_zeit < '" + Helper.formatTimestampWithSlashes(tZeitpunkt) + "'";
		sQuery += "  ORDER BY r.t_zeit DESC";

		org.hibernate.Query q = session2.createQuery(sQuery);
		q.setMaxResults(1);
		List l = q.list();
		if (l.size() > 0) {
			FLRReise flrReiseVorgaenger = (FLRReise) l.iterator().next();
			return reiseFindByPrimaryKey(flrReiseVorgaenger.getI_id());
		}

		return null;
	}

	public BigDecimal getKmKostenEinerReise(ReiseKomplettDto rkDto, TheClientDto theClientDto) {
		TreeMap tmBeginn = rkDto.getTmReiseBeginn();
		Iterator it = tmBeginn.keySet().iterator();

		BigDecimal kmKosten = new BigDecimal(0);

		while (it.hasNext()) {
			ReiseDto rDto = (ReiseDto) tmBeginn.get(it.next());

			Integer iKm = getEntfernungInKmEinerReise(rDto.getIId());

			if (iKm != null) {

				if (rDto.getCFahrzeug() != null) {
					// KM-Kosten aus Personalgehalt

					Calendar c = Calendar.getInstance();
					c.setTimeInMillis(rDto.getTZeit().getTime());

					try {
						PersonalgehaltDto pgDto = getPersonalFac().personalgehaltFindLetztePersonalgehalt(
								rDto.getPersonalIId(), c.get(Calendar.YEAR), c.get(Calendar.MONTH));

						if (pgDto != null) {
							BigDecimal kmGeld1 = pgDto.getNKmgeld1();
							if (kmGeld1 != null) {

								if (pgDto.getFBiskilometer() != null) {

									if (iKm <= pgDto.getFBiskilometer() || pgDto.getFBiskilometer() == 0) {
										kmKosten = kmKosten.add(kmGeld1.multiply(new BigDecimal(iKm.doubleValue())));
									} else {

										kmKosten = kmKosten
												.add(kmGeld1.multiply(new BigDecimal(pgDto.getFBiskilometer())));
										if (pgDto.getNKmgeld2() != null) {
											Integer km2 = iKm - pgDto.getFBiskilometer().intValue();
											kmKosten = kmKosten.add(pgDto.getNKmgeld2().multiply(new BigDecimal(km2)));
										}
									}

								} else {
									kmKosten = kmKosten.multiply(new BigDecimal(iKm.doubleValue()));
								}

							}
						}
					} catch (RemoteException e) {
						throwEJBExceptionLPRespectOld(e);
					}
				} else if (rkDto.getReiseEnde().getFahrzeugIId() != null) {
					// KM-Kosten aus Fahrzeug

					BigDecimal bdKMKostenFahrzeug = getPersonalFac().getKMKostenInZielwaehrung(
							rkDto.getReiseEnde().getFahrzeugIId(), rDto.getTZeit(),
							theClientDto.getSMandantenwaehrung(), theClientDto);

					if (bdKMKostenFahrzeug != null) {
						kmKosten = bdKMKostenFahrzeug.multiply(new BigDecimal(iKm));
					}

				}

			}

		}
		return kmKosten;
	}

	public void updateReise(ReiseDto reiseDto) throws EJBExceptionLP {
		if (reiseDto != null) {
			Integer iId = reiseDto.getIId();
			try {
				Reise reise = em.find(Reise.class, iId);
				if (reise == null) {
					throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
				}
				setReiseFromReiseDto(reise, reiseDto);
			} catch (Exception e) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_UPDATE, e);
			}
		}
	}

	public void updateReises(ReiseDto[] reiseDtos) throws EJBExceptionLP {
		if (reiseDtos != null) {
			for (int i = 0; i < reiseDtos.length; i++) {
				updateReise(reiseDtos[i]);
			}
		}
	}

	public ReiseDto reiseFindByPrimaryKey(Integer iId) throws EJBExceptionLP {
		Reise reise = em.find(Reise.class, iId);
		Validator.entityFound(reise, iId);
		return assembleReiseDto(reise);
	}

	public ReisespesenDto reisespesenFindByPrimaryKey(Integer iId) {
		Reisespesen reisespesen = em.find(Reisespesen.class, iId);
		return ReisespesenDtoAssembler.createDto(reisespesen);
	}

	public ReiseDto reiseFindByPersonalIIdTZeit(Integer personalIId, Timestamp tZeit) {
		ReiseDto reiseDto = reiseFindByPersonalIIdTZeitOhneExc(personalIId, tZeit);
		if (reiseDto == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, "");
		}

		return reiseDto;
	}

	public ReiseDto reiseFindByPersonalIIdTZeitOhneExc(Integer personalIId, Timestamp tZeit) {
		Query query = em.createNamedQuery("ReisefindByPersonalIIdTZeit");
		query.setParameter(1, personalIId);
		query.setParameter(2, tZeit);
		List<Reise> reisen = query.getResultList();
		return reisen.size() == 0 ? null : assembleReiseDto(reisen.get(0));
	}

	public ReiseDto[] reiseFindByPartnerIId(Integer partnerIIId) throws EJBExceptionLP {
		// try {
		Query query = em.createNamedQuery("ReisefindByPartnerIId");
		query.setParameter(1, partnerIIId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND,null);
		// }
		return assembleReiseDtos(cl);
		// }
		// catch (NoResultException fe) {
		// throw fe;
		// }
		// catch (Exception e) {
		// throw new EJBException(e.getMessage());
		// }
	}

	public ReiseDto[] reiseFindByAnsprechpartnerIId(Integer IansprechpartnerIId) throws EJBExceptionLP {
		// try {
		Query query = em.createNamedQuery("ReisefindByAnsprechpartnerIId");
		query.setParameter(1, IansprechpartnerIId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND,null);
		// }
		return assembleReiseDtos(cl);
		// }
		// catch (NoResultException fe) {
		// throw fe;
		// }
		// catch (Exception e) {
		// throw new EJBException(e.getMessage());
		// }
	}

	public void createReiselog(ReiselogDto reiselogDto) throws EJBExceptionLP {
		if (reiselogDto == null) {
			return;
		}
		try {
			Reiselog reiselog = new Reiselog(reiselogDto.getIId(), reiselogDto.getReiseIId(),
					reiselogDto.getPersonalIId(), reiselogDto.getTZeit(), reiselogDto.getBBeginn(),
					reiselogDto.getPersonalIIdAendern(), reiselogDto.getCArt());
			em.persist(reiselog);
			em.flush();
			setReiselogFromReiselogDto(reiselog, reiselogDto);
		} catch (Exception e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
	}

	public void removeReiselog(Integer iId) throws EJBExceptionLP {
		// try {
		Reiselog toRemove = em.find(Reiselog.class, iId);
		if (toRemove == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		try {
			em.remove(toRemove);
			em.flush();
		} catch (EntityExistsException er) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, er);
		}
		// }
		// catch (Exception e) {
		// throw new EJBException(e.getMessage());
		// }
	}

	public void vertauscheMaschinengruppe(Integer iId1I, Integer iId2I) {

		Maschinengruppe o1 = em.find(Maschinengruppe.class, iId1I);
		if (o1 == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		Maschinengruppe o2 = em.find(Maschinengruppe.class, iId2I);
		if (o2 == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		Integer iSort1 = o1.getISort();
		Integer iSort2 = o2.getISort();

		o2.setISort(new Integer(-1));

		o1.setISort(iSort2);
		o2.setISort(iSort1);

	}

	public void removeReiselog(ReiselogDto reiselogDto) throws EJBExceptionLP {
		if (reiselogDto != null) {
			Integer iId = reiselogDto.getIId();
			removeReiselog(iId);
		}
	}

	public void updateReiselog(ReiselogDto reiselogDto) throws EJBExceptionLP {
		if (reiselogDto != null) {
			Integer iId = reiselogDto.getIId();
			try {
				Reiselog reiselog = em.find(Reiselog.class, iId);
				setReiselogFromReiselogDto(reiselog, reiselogDto);
			} catch (Exception e) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_UPDATE, e);
			}
		}
	}

	public void updateReiselogs(ReiselogDto[] reiselogDtos) throws EJBExceptionLP {
		if (reiselogDtos != null) {
			for (int i = 0; i < reiselogDtos.length; i++) {
				updateReiselog(reiselogDtos[i]);
			}
		}
	}

	public ReiselogDto reiselogFindByPrimaryKey(Integer iId) throws EJBExceptionLP {
		// try {
		Reiselog reiselog = em.find(Reiselog.class, iId);
		if (reiselog == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}
		return assembleReiselogDto(reiselog);
		// }
		// catch (NoResultException fe) {
		// throw fe;
		// }
		// catch (Exception e) {
		// throw new EJBException(e.getMessage());
		// }
	}

	public ReiselogDto[] reiselogFindByPartnerIId(Integer partnerIId) throws EJBExceptionLP {
		// try {
		Query query = em.createNamedQuery("ReiselogfindByPartnerIId");
		query.setParameter(1, partnerIId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND,null);
		// }
		return assembleReiselogDtos(cl);
		// }
		// catch (NoResultException fe) {
		// throw fe;
		// }
		// catch (Exception e) {
		// throw new EJBException(e.getMessage());
		// }
	}

	public ReiselogDto[] reiselogFindByAnsprechpartnerIId(Integer iAnsprechpartnerIId) throws EJBExceptionLP {
		// try {
		Query query = em.createNamedQuery("ReiselogfindByAnsprechpartnerIId");
		query.setParameter(1, iAnsprechpartnerIId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND,null);
		// }
		return assembleReiselogDtos(cl);
		// }
		// catch (NoResultException fe) {
		// throw fe;
		// }
		// catch (Exception e) {
		// throw new EJBException(e.getMessage());
		// }
	}

	private void verschiebeBelegzeitenUndEndeNachTelefonEnde(TelefonzeitenDto telefonzeitenDto,
			TheClientDto theClientDto) {

		if (telefonzeitenDto.getTBis() != null) {
			Integer taetigkeitIId_ende = taetigkeitFindByCNr(ZeiterfassungFac.TAETIGKEIT_ENDE, theClientDto).getIId();

			ZeitdatenDto[] dtos;
			try {
				dtos = getZeiterfassungFac().zeitdatenFindZeitdatenEinesTagesUndEinerPerson(
						telefonzeitenDto.getPersonalIId(), telefonzeitenDto.getTVon(), telefonzeitenDto.getTBis());

				for (int i = 0; i < dtos.length; i++) {

					ZeitdatenDto zeitdatenDto = dtos[i];

					zeitdatenDto.setTZeit(new Timestamp(telefonzeitenDto.getTBis().getTime() + 30));

					// Belegzeit oder ENDE nach Telefonzeit verschieben
					if (zeitdatenDto.getCBelegartnr() != null || (zeitdatenDto.getTaetigkeitIId() != null
							&& zeitdatenDto.getTaetigkeitIId().equals(taetigkeitIId_ende))) {

						boolean bHatPlatz = false;

						while (bHatPlatz == false) {
							try {
								Query query = em.createNamedQuery("ZeitdatenfindByPersonalIIdTZeit");
								query.setParameter(1, zeitdatenDto.getPersonalIId());
								query.setParameter(2, zeitdatenDto.getTZeit());
								Zeitdaten doppelt = (Zeitdaten) query.getSingleResult();
								zeitdatenDto.setTZeit(new Timestamp(zeitdatenDto.getTZeit().getTime() + 30));
							} catch (NoResultException ex) {
								bHatPlatz = true;

								// wg. SP7787
								ZeitdatenDto zDto = zeitdatenFindByPrimaryKey(zeitdatenDto.getIId(), theClientDto);
								zDto.setTZeit(zeitdatenDto.getTZeit());
								updateZeitdaten(zeitdatenDto, theClientDto);

							}
						}

					}

				}

			} catch (RemoteException e) {
				throwEJBExceptionLPRespectOld(e);
			}
		}
	}

	public void updateTelefonzeiten(TelefonzeitenDto telefonzeitenDto) throws EJBExceptionLP {
		if (telefonzeitenDto != null) {
			Integer iId = telefonzeitenDto.getIId();
			try {
				Telefonzeiten telefonzeiten = em.find(Telefonzeiten.class, iId);
				setTelefonzeitenFromTelefonzeitenDto(telefonzeiten, telefonzeitenDto);
			} catch (Exception e) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_UPDATE, e);
			}
		}
	}

	public void updateTelefonzeitens(TelefonzeitenDto[] telefonzeitenDtos) throws EJBExceptionLP {
		if (telefonzeitenDtos != null) {
			for (int i = 0; i < telefonzeitenDtos.length; i++) {
				updateTelefonzeiten(telefonzeitenDtos[i]);
			}
		}
	}

	public void toggleTelefonzeitenWiedervorlageErledigt(Integer telefonzeitenIId, TheClientDto theClientDto) {
		Telefonzeiten telefonzeiten = em.find(Telefonzeiten.class, telefonzeitenIId);

		if (telefonzeiten.getTWiedervorlageErledigt() == null) {
			telefonzeiten.setTWiedervorlageErledigt(new Timestamp(System.currentTimeMillis()));
		} else {
			telefonzeiten.setTWiedervorlageErledigt(null);

		}
	}

	public TelefonzeitenDto telefonzeitenFindByPersonalIIdTVon(Integer personalIId, Timestamp tVon)
			throws EJBExceptionLP {
		try {
			Query query = em.createNamedQuery("TelefonzeitenfindByPersonalIIdTVon");
			query.setParameter(1, personalIId);
			query.setParameter(2, tVon);
			Telefonzeiten telefonzeiten = (Telefonzeiten) query.getSingleResult();
			if (telefonzeiten == null) {
				throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND, "");
			}
			return assembleTelefonzeitenDto(telefonzeiten);
		} catch (NoResultException fe) {
			throw fe;
		}
		// catch (Exception e) {
		// throw new EJBException(e.getMessage());
		// }
	}

	public TelefonzeitenDto[] telefonzeitenFindByAnsprechpartnerIId(Integer iAnsprechpartnerIId) throws EJBExceptionLP {
		// try {
		Query query = em.createNamedQuery("TelefonzeitenfindByAnsprechpartnerIId");
		query.setParameter(1, iAnsprechpartnerIId);
		Collection<?> cl = query.getResultList();
		// if (cl.isEmpty()) {
		// throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FIND,null);
		// }
		return assembleTelefonzeitenDtos(cl);
		// }
		// catch (NoResultException fe) {
		// throw fe;
		// }
		// catch (Exception e) {
		// throw new EJBException(e.getMessage());
		// }
	}

	public Integer createBereitschaft(BereitschaftDto dto) {

		try {
			// generieren von primary key
			PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			Integer pk = pkGen.getNextPrimaryKey(PKConst.PK_BEREITSCHAFT);
			dto.setIId(pk);

			Bereitschaft bean = new Bereitschaft(dto.getIId(), dto.getBereitschaftartIId(), dto.getPersonalIId(),
					dto.getTBeginn(), dto.getTEnde());
			em.persist(bean);
			em.flush();
			setBereitschaftFromIsBereitschaftDto(bean, dto);
			return dto.getIId();
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
	}

	public BereitschaftDto bereitschaftFindByPrimaryKey(Integer iId) {
		Bereitschaft ialle = em.find(Bereitschaft.class, iId);
		return BereitschaftDtoAssembler.createDto(ialle);
	}

	public void updateBereitschaft(BereitschaftDto dto) {
		Bereitschaft ialle = em.find(Bereitschaft.class, dto.getIId());

		setBereitschaftFromIsBereitschaftDto(ialle, dto);
	}

	public void removeBereitschaft(BereitschaftDto dto) {
		Bereitschaft toRemove = em.find(Bereitschaft.class, dto.getIId());
		try {
			em.remove(toRemove);
			em.flush();
		} catch (EntityExistsException er) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_LOESCHEN, er);
		}

	}

	private void setBereitschaftFromIsBereitschaftDto(Bereitschaft bean, BereitschaftDto dto) {
		bean.setBereitschaftartIId(dto.getBereitschaftartIId());
		bean.setPersonalIId(dto.getPersonalIId());
		bean.setTBeginn(dto.getTBeginn());
		bean.setTEnde(dto.getTEnde());
		bean.setCBemerkung(dto.getCBemerkung());
		em.merge(bean);
		em.flush();
	}

	private void vergleicheZeitdatenDtoVorherNachherUndLoggeAenderungen(ZeitdatenDto zeitdatenDto,
			TheClientDto theClientDto) {
		ZeitdatenDto stuecklisteDto_vorher = zeitdatenFindByPrimaryKey(zeitdatenDto.getIId(), theClientDto);

		HvDtoLogger<ZeitdatenDto> zeitdatenLogger = new HvDtoLogger<ZeitdatenDto>(em, zeitdatenDto.getPersonalIId(),
				theClientDto);
		zeitdatenLogger.log(stuecklisteDto_vorher, zeitdatenDto);
	}

	/**
	 * Hole alle Sondertaetigkeiten nach Spr.
	 * 
	 * @param cNrSpracheI String
	 * @throws EJBExceptionLP
	 * @return Map
	 */
	public Map getAllSprSondertaetigkeiten(String cNrSpracheI) {
		return buildSprMap(getAllSondertaetigkeitenRaw(), cNrSpracheI);
	}

	public Map getAllSprSondertaetigkeitenNurBDEBuchbar(String cNrSpracheI) {
		SondertaetigkeitFilter filter = new SondertaetigkeitFilter();
		return buildSprMap(filter.filterNurBdeBebuchbar(getAllSondertaetigkeitenRaw()), cNrSpracheI);
	}

	public Map<Integer, String> getAllSprSondertaetigkeitenOhneVersteckt(String cNrSpracheI) {
		SondertaetigkeitFilter filter = new SondertaetigkeitFilter();
		return buildSprMap(filter.filterOhneVersteckte(getAllSondertaetigkeitenRaw()), cNrSpracheI);
	}

	public Map<Integer, String> getAllSprSondertaetigkeitenNurBDEBuchbarOhneVersteckt(String cNrSpracheI) {
		SondertaetigkeitFilter filter = new SondertaetigkeitFilter();
		return buildSprMap(filter.filterOhneVersteckte(filter.filterNurBdeBebuchbar(getAllSondertaetigkeitenRaw())),
				cNrSpracheI);
	}

	private List<Taetigkeit> getAllSondertaetigkeitenRaw() {
		List<Taetigkeit> bebuchbare = new ArrayList<Taetigkeit>();
		HvTypedQuery<Taetigkeit> query = new HvTypedQuery<Taetigkeit>(em.createNamedQuery("TaetigkeitfindAll"));
		for (Taetigkeit taetigkeit : query.getResultList()) {
			if (!ZeiterfassungFac.TAETIGKEITART_SONDERTAETIGKEIT.equals(taetigkeit.getTaetigkeitartCNr()))
				continue;
			if (Helper.short2boolean(taetigkeit.getBTagbuchbar()))
				continue;

			bebuchbare.add(taetigkeit);
		}

		return bebuchbare;
	}

	private Map<Integer, String> buildSprMap(List<Taetigkeit> entries, String cNrSprache) {
		Map<Integer, String> tmArten = new LinkedHashMap<Integer, String>();
		for (Taetigkeit taetigkeit : entries) {
			String value = taetigkeit.getCNr();
			Taetigkeitspr taetigkeitspr = em.find(Taetigkeitspr.class,
					new TaetigkeitsprPK(taetigkeit.getIId(), cNrSprache));
			if (taetigkeitspr != null && taetigkeitspr.getCBez() != null) {
				value = taetigkeitspr.getCBez();
			}
			tmArten.put(taetigkeit.getIId(), value.trim());
		}
		return tmArten;
	}

	public ArrayList<ReiseKomplettDto> holeReisenKomplett(Integer fahrzeugIId, java.sql.Timestamp tVon,
			java.sql.Timestamp tBis, TheClientDto theClientDto) {
		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Criteria crit = session.createCriteria(FLRReise.class);

		crit.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_B_BEGINN, Helper.boolean2Short(false)));

		if (fahrzeugIId != null) {
			crit.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_FAHRZEUG_I_ID, fahrzeugIId));
		} else {
			crit.add(Restrictions.isNotNull(ZeiterfassungFac.FLR_REISE_FAHRZEUG_I_ID));
		}

		crit.add(Restrictions.ge(ZeiterfassungFac.FLR_REISE_T_ZEIT, tVon));
		crit.add(Restrictions.lt(ZeiterfassungFac.FLR_REISE_T_ZEIT, tBis));

		crit.createAlias("flrfahrzeug", "f").addOrder(Order.asc("f.c_bez"));

		List<?> resultList = crit.list();
		Iterator<?> resultListIterator = resultList.iterator();

		ArrayList<ReiseKomplettDto> alReisen = new ArrayList<ReiseKomplettDto>();

		while (resultListIterator.hasNext()) {
			FLRReise flrReise = (FLRReise) resultListIterator.next();
			ArrayList<ReiseKomplettDto> alReisenTemp = holeReiseKomplettAnhandEndeBuchung(tVon, flrReise, theClientDto);
			alReisen.addAll(alReisenTemp);
		}

		session.close();
		return alReisen;
	}

	public ArrayList<ReiseKomplettDto> holeReisenKomplettFuerAbrechnungsvorschlag(java.sql.Timestamp tBis,
			TheClientDto theClientDto) {
		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Criteria crit = session.createCriteria(FLRReise.class);

		crit.add(Restrictions.isNull("t_erledigt"));

		crit.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_B_BEGINN, Helper.boolean2Short(true)));

		if (tBis != null) {
			crit.add(Restrictions.lt(ZeiterfassungFac.FLR_REISE_T_ZEIT, tBis));
		}
		crit.addOrder(Order.asc(ZeiterfassungFac.FLR_REISE_T_ZEIT));

		List<?> resultList = crit.list();
		Iterator<?> resultListIterator = resultList.iterator();

		ArrayList<ReiseKomplettDto> alReisen = new ArrayList<ReiseKomplettDto>();

		HashMap<Integer, String> hmReiseBereitsGefunden = new HashMap<Integer, String>();

		while (resultListIterator.hasNext()) {
			FLRReise flrReise = (FLRReise) resultListIterator.next();
			// Nun das zugehoerige Ende suchen
			Session session2 = FLRSessionFactory.getFactory().openSession();
			org.hibernate.Criteria critNaechstesEnde = session2.createCriteria(FLRReise.class);
			critNaechstesEnde.add(Restrictions.gt(ZeiterfassungFac.FLR_REISE_T_ZEIT, flrReise.getT_zeit()));
			critNaechstesEnde
					.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_PERSONAL_I_ID, flrReise.getPersonal_i_id()));
			critNaechstesEnde.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_B_BEGINN, Helper.boolean2Short(false)));
			critNaechstesEnde.addOrder(Order.asc(ZeiterfassungFac.FLR_REISE_T_ZEIT));
			critNaechstesEnde.setMaxResults(1);
			List<?> resultListNaechstesEnde = critNaechstesEnde.list();
			Iterator<?> resultListIteratortNaechstesEnde = resultListNaechstesEnde.iterator();
			if (resultListIteratortNaechstesEnde.hasNext()) {
				FLRReise flrReiseEnde = (FLRReise) resultListIteratortNaechstesEnde.next();

				if (!hmReiseBereitsGefunden.containsKey(flrReiseEnde.getI_id())) {
					ArrayList<ReiseKomplettDto> alReisenTemp = holeReiseKomplettAnhandEndeBuchung(null, flrReiseEnde,
							theClientDto);
					alReisen.addAll(alReisenTemp);

					hmReiseBereitsGefunden.put(flrReiseEnde.getI_id(), "");
				}

			}
			session2.close();

		}

		session.close();
		return alReisen;
	}

	public ArrayList<ReiseKomplettDto> holeReisenKomplett(String belegartCNr, Integer belegartIId,
			java.sql.Timestamp tVon, java.sql.Timestamp tBis, TheClientDto theClientDto) {
		Session session = FLRSessionFactory.getFactory().openSession();

		org.hibernate.Criteria crit = session.createCriteria(FLRReise.class);

		crit.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_B_BEGINN, Helper.boolean2Short(true)));

		crit.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_BELEGART_C_NR, belegartCNr));

		crit.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_I_BELEGARTID, belegartIId));

		if (tVon != null) {
			crit.add(Restrictions.ge(ZeiterfassungFac.FLR_REISE_T_ZEIT, tVon));
		}
		if (tBis != null) {
			crit.add(Restrictions.lt(ZeiterfassungFac.FLR_REISE_T_ZEIT, tBis));
		}
		crit.addOrder(Order.asc(ZeiterfassungFac.FLR_REISE_T_ZEIT));

		List<?> resultList = crit.list();
		Iterator<?> resultListIterator = resultList.iterator();

		ArrayList<ReiseKomplettDto> alReisen = new ArrayList<ReiseKomplettDto>();

		HashMap<Integer, String> hmReiseBereitsGefunden = new HashMap<Integer, String>();

		while (resultListIterator.hasNext()) {
			FLRReise flrReise = (FLRReise) resultListIterator.next();
			// Nun das zugehoerige Ende suchen
			Session session2 = FLRSessionFactory.getFactory().openSession();
			org.hibernate.Criteria critNaechstesEnde = session2.createCriteria(FLRReise.class);
			critNaechstesEnde.add(Restrictions.gt(ZeiterfassungFac.FLR_REISE_T_ZEIT, flrReise.getT_zeit()));
			critNaechstesEnde
					.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_PERSONAL_I_ID, flrReise.getPersonal_i_id()));
			critNaechstesEnde.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_B_BEGINN, Helper.boolean2Short(false)));
			critNaechstesEnde.addOrder(Order.asc(ZeiterfassungFac.FLR_REISE_T_ZEIT));
			critNaechstesEnde.setMaxResults(1);
			List<?> resultListNaechstesEnde = critNaechstesEnde.list();
			Iterator<?> resultListIteratortNaechstesEnde = resultListNaechstesEnde.iterator();
			if (resultListIteratortNaechstesEnde.hasNext()) {
				FLRReise flrReiseEnde = (FLRReise) resultListIteratortNaechstesEnde.next();

				if (!hmReiseBereitsGefunden.containsKey(flrReiseEnde.getI_id())) {
					ArrayList<ReiseKomplettDto> alReisenTemp = holeReiseKomplettAnhandEndeBuchung(tVon, flrReiseEnde,
							theClientDto);
					alReisen.addAll(alReisenTemp);

					hmReiseBereitsGefunden.put(flrReiseEnde.getI_id(), "");
				}

			}
			session2.close();

		}

		session.close();
		return alReisen;
	}

	private ArrayList<ReiseKomplettDto> holeReiseKomplettAnhandEndeBuchung(java.sql.Timestamp tVon, FLRReise flrReise,
			TheClientDto theClientDto) {

		ArrayList<ReiseKomplettDto> alReisen = new ArrayList<ReiseKomplettDto>();

		// Das muss ein Ende-eintrag sein

		// Nun den naechsten Ende eintrag der Person suchen
		Session session2 = FLRSessionFactory.getFactory().openSession();
		org.hibernate.Criteria critVorherigesEnde = session2.createCriteria(FLRReise.class);

		critVorherigesEnde.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_B_BEGINN, Helper.boolean2Short(false)));
		critVorherigesEnde.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_PERSONAL_I_ID, flrReise.getPersonal_i_id()));
		critVorherigesEnde.add(Restrictions.lt(ZeiterfassungFac.FLR_REISE_T_ZEIT, flrReise.getT_zeit()));
		critVorherigesEnde.addOrder(Order.desc(ZeiterfassungFac.FLR_REISE_T_ZEIT));
		critVorherigesEnde.setMaxResults(1);
		List<?> resultListVorherigesEnde = critVorherigesEnde.list();

		// Wenns keinen gibt, dann den allerersten suchen
		boolean bEsGibtKeinVorherigesEnde = false;
		if (resultListVorherigesEnde.size() == 0) {
			bEsGibtKeinVorherigesEnde = true;
			critVorherigesEnde = session2.createCriteria(FLRReise.class);

			critVorherigesEnde.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_B_BEGINN, Helper.boolean2Short(true)));
			critVorherigesEnde
					.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_PERSONAL_I_ID, flrReise.getPersonal_i_id()));
			critVorherigesEnde.add(Restrictions.lt(ZeiterfassungFac.FLR_REISE_T_ZEIT, flrReise.getT_zeit()));
			critVorherigesEnde.addOrder(Order.asc(ZeiterfassungFac.FLR_REISE_T_ZEIT));
			critVorherigesEnde.setMaxResults(1);
			resultListVorherigesEnde = critVorherigesEnde.list();

		}

		Iterator<?> resultListIteratorVorherigesEnde = resultListVorherigesEnde.iterator();
		while (resultListIteratorVorherigesEnde.hasNext()) {
			FLRReise flrReiseVorherigesEnde = (FLRReise) resultListIteratorVorherigesEnde.next();
			// Alle Reisezeiten dazwischen sind gesucht

			Session session3 = FLRSessionFactory.getFactory().openSession();
			org.hibernate.Criteria critReiseKomplett = session3.createCriteria(FLRReise.class);

			critReiseKomplett
					.add(Restrictions.eq(ZeiterfassungFac.FLR_REISE_PERSONAL_I_ID, flrReise.getPersonal_i_id()));

			if (bEsGibtKeinVorherigesEnde) {
				critReiseKomplett
						.add(Restrictions.ge(ZeiterfassungFac.FLR_REISE_T_ZEIT, flrReiseVorherigesEnde.getT_zeit()));
			} else {
				critReiseKomplett
						.add(Restrictions.gt(ZeiterfassungFac.FLR_REISE_T_ZEIT, flrReiseVorherigesEnde.getT_zeit()));
			}

			critReiseKomplett.add(Restrictions.le(ZeiterfassungFac.FLR_REISE_T_ZEIT, flrReise.getT_zeit()));
			critReiseKomplett.addOrder(Order.asc(ZeiterfassungFac.FLR_REISE_T_ZEIT));

			List<?> resultListReiseKomplett = critReiseKomplett.list();
			Iterator<?> resultListIteratorReiseKomplett = resultListReiseKomplett.iterator();

			ReiseKomplettDto rkDto = new ReiseKomplettDto();

			while (resultListIteratorReiseKomplett.hasNext()) {
				FLRReise flrReiseKomplett = (FLRReise) resultListIteratorReiseKomplett.next();
				try {
					if (flrReiseKomplett.getB_beginn().equals(Helper.boolean2Short(true))) {

						ReiseDto reiseBeginnDto = getZeiterfassungFac()
								.reiseFindByPrimaryKey(flrReiseKomplett.getI_id(), theClientDto);

						if (tVon != null && reiseBeginnDto.getTZeit().before(tVon)) {
							reiseBeginnDto.setTZeit(tVon);
						}

						rkDto.addBeginn(reiseBeginnDto);
					} else {
						rkDto.setReiseEnde(
								getZeiterfassungFac().reiseFindByPrimaryKey(flrReiseKomplett.getI_id(), theClientDto));
					}
				} catch (RemoteException e) {
					throwEJBExceptionLPRespectOld(e);
				}

			}
			session3.close();
			alReisen.add(rkDto);

		}

		session2.close();

		return alReisen;
	}

	@Override
	public boolean zeitAufLoseVerteilen(Integer personalIId, Timestamp tZeitBis, TheClientDto theClientDto)
			throws RemoteException {
		// TODO Diese Methode gab es in der ZeiterfassungFacAll aber nicht hier.
		return false;
	}

	private class ZeitgutschriftVerschiebenHelper {
		public ArrayList<ZeitdatenDto> block = null;
		public ZeileMonatsabrechnungDto zmDto = null;
	}

	public List<ZeitdatenDto> zeitdatenFindByBelegartnrBelegidOrderedByTZeitAsc(String belegartNr, Integer belegId) {
		List<Zeitdaten> entities = ZeitdatenQuery.listByZeitdatenEinesBelegsOrderedByTZeitAsc(em, belegartNr, belegId);
		ZeitdatenDto[] dtos = assembleZeitdatenDtos(entities);
		return Arrays.asList(dtos);
	}

	public Integer createZeitdatenpruefen(ZeitdatenDto dto, Integer fehlerCode, String fehlerText,
			TheClientDto theClientDto) {
		ZeitdatenpruefenDto pruefDto = new ZeitdatenpruefenDto();
		pruefDto.setArtikelIId(dto.getArtikelIId());
		pruefDto.setBAutomatikbuchung(dto.getBAutomatikbuchung());
		pruefDto.setBTaetigkeitgeaendert(dto.getBTaetigkeitgeaendert());
		pruefDto.setCBelegartnr(dto.getCBelegartnr());
		pruefDto.setCBemerkungzubelegart(dto.getCBemerkungZuBelegart());
		pruefDto.setCWowurdegebucht(dto.getCWowurdegebucht());
		pruefDto.setIBelegartid(dto.getIBelegartid());
		pruefDto.setIBelegartpositionid(dto.getIBelegartpositionid());
		pruefDto.setPersonalIId(dto.getPersonalIId());
		pruefDto.setPersonalIIdAendern(dto.getPersonalIIdAendern());
		pruefDto.setPersonalIIdAnlegen(dto.getPersonalIIdAnlegen());
		pruefDto.setTAendern(dto.getTAendern());
		pruefDto.setTaetigkeitIId(dto.getTaetigkeitIId());
		pruefDto.setTAnlegen(dto.getTAnlegen());
		pruefDto.setTZeit(dto.getTZeit());
		pruefDto.setFehlerCode(fehlerCode);
		pruefDto.setXFehlertext(fehlerText);
		pruefDto.setXKommentar(dto.getXKommentar());
		return createZeitdatenpruefen(pruefDto, theClientDto);
	}

	public Integer createZeitdatenpruefen(ZeitdatenpruefenDto dto, TheClientDto theClientDto) {
		Validator.dtoNotNull(dto, "dto");
		Validator.dtoNotNull(theClientDto, "theClientDto");

		setDefaultsForCreate(dto, theClientDto);

		try {
			verifyIds(dto, theClientDto);

			// // generieren von primary key
			// PKGeneratorObj pkGen = new PKGeneratorObj(); // PKGEN
			// Integer pk =
			// pkGen.getNextPrimaryKey(PKConst.PK_ZEITDATENPRUEFEN);
			// dto.setIId(pk);

			Zeitdatenpruefen entity = new Zeitdatenpruefen();
			setZeitdatenpruefenFromZeitdatenpruefenDto(entity, dto);
			em.persist(entity);
			em.flush();
			return entity.getIId();
		} catch (RemoteException e) {
			throwEJBExceptionLPRespectOld(e);
			return null;
		} catch (EntityExistsException e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		} catch (Exception e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_ANLEGEN, e);
		}
	}

	private void setDefaultsForCreate(ZeitdatenpruefenDto dto, TheClientDto theClientDto) {
		dto.setBTaetigkeitgeaendert(Helper.getShortFalse());
		dto.setTAnlegen(getTimestamp());
		if (dto.getTAendern() == null) {
			dto.setTAendern(dto.getTAnlegen());
		}
		dto.setPersonalIIdAnlegen(theClientDto.getIDPersonal());
		if (dto.getPersonalIIdAendern() == null) {
			dto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		}
		if (dto.getBAutomatikbuchung() == null) {
			dto.setBAutomatikbuchung(Helper.getShortFalse());
		}
	}

	private List<ZeitdatenpruefenAttributDto> verifyIds(ZeitdatenpruefenDto dto, TheClientDto theClientDto)
			throws RemoteException {
		List<ZeitdatenpruefenAttributDto> attributs = new HvList<ZeitdatenpruefenAttributDto>();
		attributs.add(resolvePersonalId(dto, theClientDto));
		attributs.add(resolveArtikel(dto, theClientDto));
		attributs.add(resolveTaetigkeit(dto, theClientDto));
		attributs.addAll(resolveAuftrag(dto, theClientDto));
		attributs.add(resolveProjekt(dto, theClientDto));

		return attributs;
	}

	private ZeitdatenpruefenAttributDto resolvePersonalId(ZeitdatenpruefenDto dto, TheClientDto theClientDto)
			throws RemoteException {
		ZeitdatenpruefenAttributDto attributDto = null;
		Personal pers = em.find(Personal.class, dto.getPersonalIId());
		if (pers == null || !pers.getMandantCNr().equals(theClientDto.getMandant())) {
			PersonalDto persDto = getPersonalFac().personalFindByPartnerIIdMandantCNr(12, theClientDto.getMandant());
			attributDto = new ZeitdatenpruefenAttributDto(Attribut.Personal, dto.getPersonalIId(), persDto.getIId());
			dto.addAttributKommentar(attributDto.toKommentar());
			dto.setPersonalIId(persDto.getIId());
		}

		return attributDto;
	}

	private ZeitdatenpruefenAttributDto resolveArtikel(ZeitdatenpruefenDto dto, TheClientDto theClientDto)
			throws RemoteException {
		ZeitdatenpruefenAttributDto attributDto = null;
		if (dto.getArtikelIId() != null) {
			// Artikel muss im Mandanten vorhanden sein
			Artikel a = em.find(Artikel.class, dto.getArtikelIId());
			if (a != null) {
				ArtikelDto artikelDto = getArtikelFac().artikelFindByCNrOhneExc(a.getCNr(), theClientDto);
				if (artikelDto == null) {
					a = null;
				}
			}

			if (a == null) {
				attributDto = new ZeitdatenpruefenAttributDto(Attribut.Artikel, dto.getArtikelIId(), null);
				dto.addAttributKommentar(attributDto.toKommentar());
				dto.setArtikelIId(null);
			}
		}

		return attributDto;
	}

	private ZeitdatenpruefenAttributDto resolveTaetigkeit(ZeitdatenpruefenDto dto, TheClientDto theClientDto)
			throws RemoteException {
		ZeitdatenpruefenAttributDto attributDto = null;

		if (dto.getTaetigkeitIId() != null) {
			Taetigkeit t = em.find(Taetigkeit.class, dto.getTaetigkeitIId());
			if (t == null) {
				TaetigkeitDto taetigkeitDto = taetigkeitFindByCNrSmallOhneExc(TAETIGKEIT_ENDE);
				attributDto = new ZeitdatenpruefenAttributDto(Attribut.Taetigkeit, dto.getTaetigkeitIId(),
						taetigkeitDto.getIId());
				dto.addAttributKommentar(attributDto.toKommentar());
				dto.setTaetigkeitIId(taetigkeitDto.getIId());
			}
		}

		return attributDto;
	}

	private List<ZeitdatenpruefenAttributDto> resolveAuftrag(ZeitdatenpruefenDto dto, TheClientDto theClientDto)
			throws RemoteException {
		List<ZeitdatenpruefenAttributDto> attributs = new HvList<ZeitdatenpruefenAttributDto>();

		if (LocaleFac.BELEGART_AUFTRAG.equals(dto.getCBelegartnr()) && dto.getIBelegartid() != null) {
			Auftrag a = em.find(Auftrag.class, dto.getIBelegartid());
			if (a == null || !a.getMandantCNr().equals(theClientDto.getMandant())) {
				ZeitdatenpruefenAttributDto attrib = new ZeitdatenpruefenAttributDto(Attribut.Auftrag,
						dto.getIBelegartid(), null);
				attributs.add(attrib);
				dto.addAttributKommentar(attrib.toKommentar());

				TaetigkeitDto taetigkeitDto = taetigkeitFindByCNrSmallOhneExc(TAETIGKEIT_ENDE);
				dto.setTaetigkeitIId(taetigkeitDto.getIId());
				dto.setCBelegartnr(null);
				dto.setIBelegartid(null);
			}

			if (dto.getIBelegartpositionid() != null) {
				Auftragposition p = em.find(Auftragposition.class, dto.getIBelegartpositionid());
				if (p == null) {
					ZeitdatenpruefenAttributDto attrib = new ZeitdatenpruefenAttributDto(Attribut.Auftragposition,
							dto.getIBelegartpositionid(), null);
					attributs.add(attrib);
					dto.addAttributKommentar(attrib.toKommentar());
					dto.setIBelegartpositionid(null);
				}
			}
		}

		return attributs;
	}

	private ZeitdatenpruefenAttributDto resolveProjekt(ZeitdatenpruefenDto dto, TheClientDto theClientDto)
			throws RemoteException {
		ZeitdatenpruefenAttributDto attrib = null;

		if (LocaleFac.BELEGART_PROJEKT.equals(dto.getCBelegartnr()) && dto.getIBelegartid() != null) {
			Projekt p = em.find(Projekt.class, dto.getIBelegartid());
			if (p == null || !p.getMandantCNr().equals(theClientDto.getMandant())) {
				attrib = new ZeitdatenpruefenAttributDto(Attribut.Projekt, dto.getIBelegartid(), null);
				dto.addAttributKommentar(attrib.toKommentar());

				TaetigkeitDto taetigkeitDto = taetigkeitFindByCNrSmallOhneExc(TAETIGKEIT_ENDE);
				dto.setTaetigkeitIId(taetigkeitDto.getIId());
				dto.setCBelegartnr(null);
				dto.setIBelegartid(null);
			}
		}

		return attrib;
	}

	private void setZeitdatenpruefenFromZeitdatenpruefenDto(Zeitdatenpruefen entity, ZeitdatenpruefenDto dto) {
		entity.setArtikelIId(dto.getArtikelIId());
		entity.setBAutomatikbuchung(dto.getBAutomatikbuchung());
		entity.setBTaetigkeitgeaendert(dto.getBTaetigkeitgeaendert());
		entity.setCBelegartnr(dto.getCBelegartnr());
		entity.setCBemerkungzubelegart(dto.getCBemerkungzubelegart());
		if (dto.getCWowurdegebucht() != null) {
			entity.setCWowurdegebucht(
					dto.getCWowurdegebucht().substring(0, Math.min(40, dto.getCWowurdegebucht().length())));
		}
		entity.setFehlerCode(dto.getFehlerCode());
		entity.setIBelegartid(dto.getIBelegartid());
		entity.setIBelegartpositionid(dto.getIBelegartpositionid());
		entity.setPersonalIId(dto.getPersonalIId());
		entity.setPersonalIIdAendern(dto.getPersonalIIdAendern());
		entity.setPersonalIIdAnlegen(dto.getPersonalIIdAnlegen());
		entity.setTAendern(dto.getTAendern());
		entity.setTaetigkeitIId(dto.getTaetigkeitIId());
		entity.setTAnlegen(dto.getTAnlegen());
		entity.setTZeit(dto.getTZeit());
		entity.setXFehlerText(dto.getXFehlertext());
		entity.setXKommentar(dto.getXKommentar());
	}

	@Override
	public ZeitdatenpruefenDto zeitdatenpruefenFindByPrimaryKey(Integer iId, TheClientDto theClientDto)
			throws EJBExceptionLP {
		Validator.pkFieldNotNull(iId, "iId");

		Zeitdatenpruefen zeitdaten = em.find(Zeitdatenpruefen.class, iId);
		if (zeitdaten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, iId.toString());
		}
		ZeitdatenpruefenDto zDto = assembleZeitdatenpruefenDto(zeitdaten);
		return zDto;
	}

	private ZeitdatenpruefenDto assembleZeitdatenpruefenDto(Zeitdatenpruefen zeitdaten) {
		return ZeitdatenpruefenDtoAssembler.createDto(zeitdaten);
	}

	@Override
	public void removeZeitdatenpruefen(ZeitdatenpruefenDto zeitdatenpruefenDto, TheClientDto theClientDto)
			throws EJBExceptionLP {
		Validator.dtoNotNull(zeitdatenpruefenDto, "zeitdatenDto");
		Validator.pkFieldNotNull(zeitdatenpruefenDto.getIId(), "getIId()");

		Zeitdatenpruefen zeitdaten = em.find(Zeitdatenpruefen.class, zeitdatenpruefenDto.getIId());
		if (zeitdaten == null) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEI_FINDBYPRIMARYKEY, "");
		}

		em.remove(zeitdaten);
		em.flush();
	}

	@Override
	public Integer zeitdatenpruefenInZeitdatenUeberleiten(Integer zeitdatenpruefenId, TheClientDto theClientDto) {
		Validator.pkFieldNotNull(zeitdatenpruefenId, "zeitdatenpruefenId");

		Zeitdatenpruefen zdp = em.find(Zeitdatenpruefen.class, zeitdatenpruefenId);
		Validator.entityFound(zdp, zeitdatenpruefenId);
		Integer newId = createZeitdaten(zdp, theClientDto);

		em.remove(zdp);
		em.flush();

		return newId;
	}

	private Integer createZeitdaten(Zeitdatenpruefen zdp, TheClientDto theClientDto) {
		ZeitdatenDto dto = new ZeitdatenDto();
		dto.setArtikelIId(zdp.getArtikelIId());
		dto.setBAutomatikbuchung(zdp.getBAutomatikbuchung());
		dto.setBTaetigkeitgeaendert(zdp.getBTaetigkeitgeaendert());
		dto.setCBelegartnr(zdp.getCBelegartnr());
		dto.setCBemerkungZuBelegart(zdp.getCBemerkungzubelegart());
		dto.setCWowurdegebucht(zdp.getCWowurdegebucht());
		dto.setIBelegartid(zdp.getIBelegartid());
		dto.setIBelegartpositionid(zdp.getIBelegartpositionid());
		dto.setPersonalIId(zdp.getPersonalIId());
		dto.setPersonalIIdAendern(theClientDto.getIDPersonal());
		dto.setPersonalIIdAnlegen(theClientDto.getIDPersonal());
		dto.setTAendern(zdp.getTAendern());
		dto.setTaetigkeitIId(zdp.getTaetigkeitIId());
		dto.setTAnlegen(zdp.getTAnlegen());
		dto.setTZeit(zdp.getTZeit());

		return createZeitdaten(dto, true, true, true, true, theClientDto);
	}

	@Override
	public ZeitdatenpruefenDto updateZeitdatenpruefen(ZeitdatenpruefenDto zdpDto, TheClientDto theClientDto) {
		Validator.dtoNotNull(zdpDto, "zdpDto");
		Validator.pkFieldNotNull(zdpDto.getIId(), "iid");
		try {
			Integer key = zdpDto.getIId();
			Zeitdatenpruefen zdp = em.find(Zeitdatenpruefen.class, key);
			Validator.entityFound(zdp, key);
			zdpDto.setPersonalIIdAendern(theClientDto.getIDPersonal());
			zdpDto.setTAendern(getTimestamp());
			setZeitdatenpruefenFromZeitdatenpruefenDto(zdp, zdpDto);
			em.merge(zdp);
			em.flush();

			return zeitdatenpruefenFindByPrimaryKey(key, theClientDto);
		} catch (Exception e) {
			throw new EJBExceptionLP(EJBExceptionLP.FEHLER_BEIM_UPDATE, e);
		}
	}

	@Override
	public boolean hasZeitdatenpruefen(Integer personalId) {
		Validator.notNull(personalId, "personalId");
		;
		return ZeitdatenpruefenQuery.countByPersonalId(em, personalId) > 0;
	}

	@Override
	public MaschineDto maschineFindByCIdentifikationsnrOhneExc(String cIdentifkationsnr) {
		Maschine entity = MaschineQuery.resultByCIdentifikationsnr(em, cIdentifkationsnr);
		return entity != null ? assembleMaschineDto(entity) : null;
	}

	public MaschineDto maschinefindByCIdentifikationsnrMandantCNrOhneExc(String cIdentifkationsnr, String mandantCNr) {
		Query query = em.createNamedQuery("MaschinefindByCIdentifikationsnrMandantCNr");
		query.setParameter(1, cIdentifkationsnr);
		query.setParameter(2, mandantCNr);
		Collection<?> cl = query.getResultList();

		if (cl.size() == 0) {
			return null;
		} else {
			return assembleMaschineDto((Maschine) cl.iterator().next());
		}

	}

	@Override
	public MaschineDto maschineFindByPrimaryKeyOhneExc(Integer maschineIId) {
		Maschine entity = em.find(Maschine.class, maschineIId);
		return entity != null ? assembleMaschineDto(entity) : null;
	}

	private String collectEmailEmpfaenger(PersonalDto[] personalDtos, ISelect<PersonalDto> selector) {
		if (personalDtos == null)
			return null;

		Collection<PersonalDto> selected = CollectionTools.select(personalDtos, selector);
		if (selected.size() == 0)
			return null;

		// gleicher E-Mailempfaenger soll nur eine E-Mail erhalten
		Set<String> emails = new HashSet<String>();
		for (PersonalDto personalDto : selected) {
			if (personalDto.getCEmail() != null) {
				emails.add(personalDto.getCEmail().trim());
			}
		}

		return StringUtils.join(emails.iterator(), ";");
	}

	private String getEmailGeschaeftsfuehrer(TheClientDto theClientDto) throws RemoteException {
		PersonalDto[] aGeschaeftsfDto = getPersonalFac().personalFindByMandantCNrPersonalfunktionCNr(
				theClientDto.getMandant(), PersonalFac.PERSONALFUNKTION_GESCHAEFTSFUEHRER);
		return collectEmailEmpfaenger(aGeschaeftsfDto, new ISelect<PersonalDto>() {
			@Override
			public boolean select(PersonalDto element) {
				return true;
			}
		});
	}

	private String getEmailAbteilungsleiter(final Integer selectedKostenstelleIId, TheClientDto theClientDto)
			throws RemoteException {
		PersonalDto[] aGeschaeftsfDto = getPersonalFac().personalFindByMandantCNrPersonalfunktionCNr(
				theClientDto.getMandant(), PersonalFac.PERSONALFUNKTION_ABTEILUNGSLEITER);
		return collectEmailEmpfaenger(aGeschaeftsfDto, new ISelect<PersonalDto>() {
			@Override
			public boolean select(PersonalDto element) {
				return element.getKostenstelleIIdAbteilung() != null
						&& element.getKostenstelleIIdAbteilung().equals(selectedKostenstelleIId);
			}
		});
	}

	private String getEmailLohnverrechner(TheClientDto theClientDto) throws RemoteException {
		PersonalDto[] aLohnverrechnungDto = getPersonalFac().personalFindByMandantCNrPersonalfunktionCNr(
				theClientDto.getMandant(), PersonalFac.PERSONALFUNKTION_LOHNVERRECHNUNG);
		return collectEmailEmpfaenger(aLohnverrechnungDto, new ISelect<PersonalDto>() {
			@Override
			public boolean select(PersonalDto element) {
				return true;
			}
		});
	}

	@Override
	public void createSonderzeitenEmail(SonderzeitenAntragEmailDto emailDto, TheClientDto theClientDto)
			throws RemoteException {
		// PJ18441 Mail an Abteilungsleiter bzw. GF
		String cEmpfaenger = null;

		PersonalDto personalDto_Selektiert = getPersonalFac().personalFindByPrimaryKey(emailDto.getPersonalId(),
				theClientDto);
		PersonalDto personalDto_Angemeldet = getPersonalFac().personalFindByPrimaryKey(theClientDto.getIDPersonal(),
				theClientDto);

		if (personalDto_Selektiert.getPersonalfunktionCNr() != null && (personalDto_Selektiert.getPersonalfunktionCNr()
				.equals(PersonalFac.PERSONALFUNKTION_ABTEILUNGSLEITER)
				|| personalDto_Selektiert.getPersonalfunktionCNr()
						.equals(PersonalFac.PERSONALFUNKTION_GESCHAEFTSFUEHRER))) {
			cEmpfaenger = getEmailGeschaeftsfuehrer(theClientDto);
		} else {
			// Mail an Abteilungsleiter, wenn vorhanden
			cEmpfaenger = getEmailAbteilungsleiter(personalDto_Selektiert.getKostenstelleIIdAbteilung(), theClientDto);

			// SP2782 Wenn kein Abteilungsleiter gefunden, dann GF
			if (cEmpfaenger == null) {
				cEmpfaenger = getEmailGeschaeftsfuehrer(theClientDto);
			}
		}

		if (cEmpfaenger != null) {
			VersandauftragDto dto = new VersandauftragDto();
			dto.setCEmpfaenger(cEmpfaenger);

			if (personalDto_Selektiert.getCEmail() != null) {
				dto.setCAbsenderadresse(personalDto_Selektiert.getCEmail());
			} else {
				dto.setCAbsenderadresse(personalDto_Angemeldet.getCEmail());
			}

			String token = null;
			if (emailDto.isUrlaubsantrag()) {
				token = "pers.urlaubsantrag.betreff.urlaub";
			} else if (emailDto.isKrankantrag()) {
				token = "pers.urlaubsantrag.betreff.krank";
			} else {
				token = "pers.urlaubsantrag.betreff.zeitausgleich";
			}
			String sBetreff = getTextRespectUISpr(token, theClientDto.getMandant(), theClientDto.getLocUi(),
					personalDto_Selektiert.getPartnerDto().formatFixName1Name2());
			dto.setCBetreff(sBetreff);

			String text = getTextRespectUISpr("pers.urlaubsantrag.text", theClientDto.getMandant(),
					theClientDto.getLocUi(), Helper.formatDatum(emailDto.getVon(), theClientDto.getLocUi()),
					Helper.formatDatum(emailDto.getBis(), theClientDto.getLocUi()));
			dto.setCText(text);

			// PJ20605 bei Krankantrag auch an Lohnverrechnung
			// schicken
			if (emailDto.isKrankantrag()) {
				String lohnEmail = getEmailLohnverrechner(theClientDto);
				if (lohnEmail != null) {
					dto.setCCcempfaenger(lohnEmail);
				}
			}

			dto = getVersandFac().createVersandauftrag(dto, false, theClientDto);
		} else {
			throw EJBExcFactory.empfaengerSonderzeitenAntragNichtGefunden(personalDto_Selektiert,
					personalDto_Angemeldet);
		}
	}

	private class AnhaengeMonatsabrechnungFilter implements FilenameFilter {

		private String prefix = null;
		private String personalnummer = null;

		public AnhaengeMonatsabrechnungFilter(String prefix, String personalnummer) {
			this.prefix = prefix;
			this.personalnummer = personalnummer;
		}

		public boolean accept(File dir, String name) {
			String lowercaseName = name.toLowerCase();

			String vergleich = personalnummer.toLowerCase();
			if (prefix != null) {
				vergleich = prefix.toLowerCase() + vergleich;
			}
			if (lowercaseName.startsWith(vergleich)) {
				return true;
			} else {
				return false;
			}
		}

	}

}
